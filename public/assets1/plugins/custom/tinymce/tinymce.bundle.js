/**
 * TinyMCE version 8.0.2 (2025-08-14)
 */

(function () {
    'use strict';

    var typeOf$1 = function (x) {
        if (x === null) {
            return 'null';
        }
        if (x === undefined) {
            return 'undefined';
        }
        var t = typeof x;
        if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
            return 'array';
        }
        if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
            return 'string';
        }
        return t;
    };
    var isEquatableType = function (x) {
        return ['undefined', 'boolean', 'number', 'string', 'function', 'xml', 'null'].indexOf(x) !== -1;
    };

    var sort$1 = function (xs, compareFn) {
        var clone = Array.prototype.slice.call(xs);
        return clone.sort(compareFn);
    };

    var contramap = function (eqa, f) {
        return eq$2(function (x, y) { return eqa.eq(f(x), f(y)); });
    };
    var eq$2 = function (f) {
        return ({ eq: f });
    };
    var tripleEq = eq$2(function (x, y) { return x === y; });
    var eqString = tripleEq;
    var eqArray = function (eqa) { return eq$2(function (x, y) {
        if (x.length !== y.length) {
            return false;
        }
        var len = x.length;
        for (var i = 0; i < len; i++) {
            if (!eqa.eq(x[i], y[i])) {
                return false;
            }
        }
        return true;
    }); };
    // TODO: Make an Ord typeclass
    var eqSortedArray = function (eqa, compareFn) {
        return contramap(eqArray(eqa), function (xs) { return sort$1(xs, compareFn); });
    };
    var eqRecord = function (eqa) { return eq$2(function (x, y) {
        var kx = Object.keys(x);
        var ky = Object.keys(y);
        if (!eqSortedArray(eqString).eq(kx, ky)) {
            return false;
        }
        var len = kx.length;
        for (var i = 0; i < len; i++) {
            var q = kx[i];
            if (!eqa.eq(x[q], y[q])) {
                return false;
            }
        }
        return true;
    }); };
    var eqAny = eq$2(function (x, y) {
        if (x === y) {
            return true;
        }
        var tx = typeOf$1(x);
        var ty = typeOf$1(y);
        if (tx !== ty) {
            return false;
        }
        if (isEquatableType(tx)) {
            return x === y;
        }
        else if (tx === 'array') {
            return eqArray(eqAny).eq(x, y);
        }
        else if (tx === 'object') {
            return eqRecord(eqAny).eq(x, y);
        }
        return false;
    });

    /* eslint-disable @typescript-eslint/no-wrapper-object-types */
    const getPrototypeOf$2 = Object.getPrototypeOf;
    const hasProto = (v, constructor, predicate) => {
        var _a;
        if (predicate(v, constructor.prototype)) {
            return true;
        }
        else {
            // String-based fallback time
            return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
        }
    };
    const typeOf = (x) => {
        const t = typeof x;
        if (x === null) {
            return 'null';
        }
        else if (t === 'object' && Array.isArray(x)) {
            return 'array';
        }
        else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {
            return 'string';
        }
        else {
            return t;
        }
    };
    const isType$1 = (type) => (value) => typeOf(value) === type;
    const isSimpleType = (type) => (value) => typeof value === type;
    const eq$1 = (t) => (a) => t === a;
    const is$5 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);
    const isString = isType$1('string');
    const isObject = isType$1('object');
    const isPlainObject = (value) => is$5(value, Object);
    const isArray$1 = isType$1('array');
    const isNull = eq$1(null);
    const isBoolean = isSimpleType('boolean');
    const isUndefined = eq$1(undefined);
    const isNullable = (a) => a === null || a === undefined;
    const isNonNullable = (a) => !isNullable(a);
    const isFunction = isSimpleType('function');
    const isNumber = isSimpleType('number');
    const isArrayOf = (value, pred) => {
        if (isArray$1(value)) {
            for (let i = 0, len = value.length; i < len; ++i) {
                if (!(pred(value[i]))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };

    const noop = () => { };
    /** Compose a unary function with an n-ary function */
    const compose = (fa, fb) => {
        return (...args) => {
            return fa(fb.apply(null, args));
        };
    };
    /** Compose two unary functions. Similar to compose, but avoids using Function.prototype.apply. */
    const compose1 = (fbc, fab) => (a) => fbc(fab(a));
    const constant = (value) => {
        return () => {
            return value;
        };
    };
    const identity = (x) => {
        return x;
    };
    const tripleEquals = (a, b) => {
        return a === b;
    };
    function curry(fn, ...initialArgs) {
        return (...restArgs) => {
            const all = initialArgs.concat(restArgs);
            return fn.apply(null, all);
        };
    }
    const not = (f) => (t) => !f(t);
    const die = (msg) => {
        return () => {
            throw new Error(msg);
        };
    };
    const apply$1 = (f) => {
        return f();
    };
    const call = (f) => {
        f();
    };
    const never = constant(false);
    const always = constant(true);

    /**
     * The `Optional` type represents a value (of any type) that potentially does
     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the
     * value does exist) or a `None` (in which case the value does not exist). This
     * module defines a whole lot of FP-inspired utility functions for dealing with
     * `Optional` objects.
     *
     * Comparison with null or undefined:
     * - We don't get fancy null coalescing operators with `Optional`
     * - We do get fancy helper functions with `Optional`
     * - `Optional` support nesting, and allow for the type to still be nullable (or
     * another `Optional`)
     * - There is no option to turn off strict-optional-checks like there is for
     * strict-null-checks
     */
    class Optional {
        // The internal representation has a `tag` and a `value`, but both are
        // private: able to be console.logged, but not able to be accessed by code
        constructor(tag, value) {
            this.tag = tag;
            this.value = value;
        }
        // --- Identities ---
        /**
         * Creates a new `Optional<T>` that **does** contain a value.
         */
        static some(value) {
            return new Optional(true, value);
        }
        /**
         * Create a new `Optional<T>` that **does not** contain a value. `T` can be
         * any type because we don't actually have a `T`.
         */
        static none() {
            return Optional.singletonNone;
        }
        /**
         * Perform a transform on an `Optional` type. Regardless of whether this
         * `Optional` contains a value or not, `fold` will return a value of type `U`.
         * If this `Optional` does not contain a value, the `U` will be created by
         * calling `onNone`. If this `Optional` does contain a value, the `U` will be
         * created by calling `onSome`.
         *
         * For the FP enthusiasts in the room, this function:
         * 1. Could be used to implement all of the functions below
         * 2. Forms a catamorphism
         */
        fold(onNone, onSome) {
            if (this.tag) {
                return onSome(this.value);
            }
            else {
                return onNone();
            }
        }
        /**
         * Determine if this `Optional` object contains a value.
         */
        isSome() {
            return this.tag;
        }
        /**
         * Determine if this `Optional` object **does not** contain a value.
         */
        isNone() {
            return !this.tag;
        }
        // --- Functor (name stolen from Haskell / maths) ---
        /**
         * Perform a transform on an `Optional` object, **if** there is a value. If
         * you provide a function to turn a T into a U, this is the function you use
         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
         * a value then the output will also contain a value (that value being the
         * output of `mapper(this.value)`), and if this **does not** contain a value
         * then neither will the output.
         */
        map(mapper) {
            if (this.tag) {
                return Optional.some(mapper(this.value));
            }
            else {
                return Optional.none();
            }
        }
        // --- Monad (name stolen from Haskell / maths) ---
        /**
         * Perform a transform on an `Optional` object, **if** there is a value.
         * Unlike `map`, here the transform itself also returns an `Optional`.
         */
        bind(binder) {
            if (this.tag) {
                return binder(this.value);
            }
            else {
                return Optional.none();
            }
        }
        // --- Traversable (name stolen from Haskell / maths) ---
        /**
         * For a given predicate, this function finds out if there **exists** a value
         * inside this `Optional` object that meets the predicate. In practice, this
         * means that for `Optional`s that do not contain a value it returns false (as
         * no predicate-meeting value exists).
         */
        exists(predicate) {
            return this.tag && predicate(this.value);
        }
        /**
         * For a given predicate, this function finds out if **all** the values inside
         * this `Optional` object meet the predicate. In practice, this means that
         * for `Optional`s that do not contain a value it returns true (as all 0
         * objects do meet the predicate).
         */
        forall(predicate) {
            return !this.tag || predicate(this.value);
        }
        filter(predicate) {
            if (!this.tag || predicate(this.value)) {
                return this;
            }
            else {
                return Optional.none();
            }
        }
        // --- Getters ---
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value.
         */
        getOr(replacement) {
            return this.tag ? this.value : replacement;
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value.  Unlike `getOr`, in this method the `replacement` object is also
         * `Optional` - meaning that this method will always return an `Optional`.
         */
        or(replacement) {
            return this.tag ? this : replacement;
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value. Unlike `getOr`, in this method the `replacement` value is
         * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
         * pass a function which (if called) will **return** the `value` you want to
         * use.
         */
        getOrThunk(thunk) {
            return this.tag ? this.value : thunk();
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided Optional object does not contain a
         * value.
         *
         * Unlike `or`, in this method the `replacement` value is "thunked" - that is
         * to say that you don't pass a value to `orThunk`, you pass a function which
         * (if called) will **return** the `value` you want to use.
         *
         * Unlike `getOrThunk`, in this method the `replacement` value is also
         * `Optional`, meaning that this method will always return an `Optional`.
         */
        orThunk(thunk) {
            return this.tag ? this : thunk();
        }
        /**
         * Get the value out of the inside of the `Optional` object, throwing an
         * exception if the provided `Optional` object does not contain a value.
         *
         * WARNING:
         * You should only be using this function if you know that the `Optional`
         * object **is not** empty (otherwise you're throwing exceptions in production
         * code, which is bad).
         *
         * In tests this is more acceptable.
         *
         * Prefer other methods to this, such as `.each`.
         */
        getOrDie(message) {
            if (!this.tag) {
                throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');
            }
            else {
                return this.value;
            }
        }
        // --- Interop with null and undefined ---
        /**
         * Creates an `Optional` value from a nullable (or undefined-able) input.
         * Null, or undefined, is converted to `None`, and anything else is converted
         * to `Some`.
         */
        static from(value) {
            return isNonNullable(value) ? Optional.some(value) : Optional.none();
        }
        /**
         * Converts an `Optional` to a nullable type, by getting the value if it
         * exists, or returning `null` if it does not.
         */
        getOrNull() {
            return this.tag ? this.value : null;
        }
        /**
         * Converts an `Optional` to an undefined-able type, by getting the value if
         * it exists, or returning `undefined` if it does not.
         */
        getOrUndefined() {
            return this.value;
        }
        // --- Utilities ---
        /**
         * If the `Optional` contains a value, perform an action on that value.
         * Unlike the rest of the methods on this type, `.each` has side-effects. If
         * you want to transform an `Optional<T>` **into** something, then this is not
         * the method for you. If you want to use an `Optional<T>` to **do**
         * something, then this is the method for you - provided you're okay with not
         * doing anything in the case where the `Optional` doesn't have a value inside
         * it. If you're not sure whether your use-case fits into transforming
         * **into** something or **doing** something, check whether it has a return
         * value. If it does, you should be performing a transform.
         */
        each(worker) {
            if (this.tag) {
                worker(this.value);
            }
        }
        /**
         * Turn the `Optional` object into an array that contains all of the values
         * stored inside the `Optional`. In practice, this means the output will have
         * either 0 or 1 elements.
         */
        toArray() {
            return this.tag ? [this.value] : [];
        }
        /**
         * Turn the `Optional` object into a string for debugging or printing. Not
         * recommended for production code, but good for debugging. Also note that
         * these days an `Optional` object can be logged to the console directly, and
         * its inner value (if it exists) will be visible.
         */
        toString() {
            return this.tag ? `some(${this.value})` : 'none()';
        }
    }
    // Sneaky optimisation: every instance of Optional.none is identical, so just
    // reuse the same object
    Optional.singletonNone = new Optional(false);

    const nativeSlice = Array.prototype.slice;
    const nativeIndexOf = Array.prototype.indexOf;
    const nativePush = Array.prototype.push;
    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
    const indexOf$1 = (xs, x) => {
        // The rawIndexOf method does not wrap up in an option. This is for performance reasons.
        const r = rawIndexOf(xs, x);
        return r === -1 ? Optional.none() : Optional.some(r);
    };
    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
    const exists = (xs, pred) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return true;
            }
        }
        return false;
    };
    const map$3 = (xs, f) => {
        // pre-allocating array size when it's guaranteed to be known
        // http://jsperf.com/push-allocated-vs-dynamic/22
        const len = xs.length;
        const r = new Array(len);
        for (let i = 0; i < len; i++) {
            const x = xs[i];
            r[i] = f(x, i);
        }
        return r;
    };
    // Unwound implementing other functions in terms of each.
    // The code size is roughly the same, and it should allow for better optimisation.
    // const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {
    const each$e = (xs, f) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            f(x, i);
        }
    };
    const eachr = (xs, f) => {
        for (let i = xs.length - 1; i >= 0; i--) {
            const x = xs[i];
            f(x, i);
        }
    };
    const partition$2 = (xs, pred) => {
        const pass = [];
        const fail = [];
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            const arr = pred(x, i) ? pass : fail;
            arr.push(x);
        }
        return { pass, fail };
    };
    const filter$5 = (xs, pred) => {
        const r = [];
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                r.push(x);
            }
        }
        return r;
    };
    /*
     * Groups an array into contiguous arrays of like elements. Whether an element is like or not depends on f.
     *
     * f is a function that derives a value from an element - e.g. true or false, or a string.
     * Elements are like if this function generates the same value for them (according to ===).
     *
     *
     * Order of the elements is preserved. Arr.flatten() on the result will return the original list, as with Haskell groupBy function.
     *  For a good explanation, see the group function (which is a special case of groupBy)
     *  http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#v:group
     */
    const groupBy = (xs, f) => {
        if (xs.length === 0) {
            return [];
        }
        else {
            let wasType = f(xs[0]); // initial case for matching
            const r = [];
            let group = [];
            for (let i = 0, len = xs.length; i < len; i++) {
                const x = xs[i];
                const type = f(x);
                if (type !== wasType) {
                    r.push(group);
                    group = [];
                }
                wasType = type;
                group.push(x);
            }
            if (group.length !== 0) {
                r.push(group);
            }
            return r;
        }
    };
    const foldr = (xs, f, acc) => {
        eachr(xs, (x, i) => {
            acc = f(acc, x, i);
        });
        return acc;
    };
    const foldl = (xs, f, acc) => {
        each$e(xs, (x, i) => {
            acc = f(acc, x, i);
        });
        return acc;
    };
    const findUntil$1 = (xs, pred, until) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return Optional.some(x);
            }
            else if (until(x, i)) {
                break;
            }
        }
        return Optional.none();
    };
    const find$2 = (xs, pred) => {
        return findUntil$1(xs, pred, never);
    };
    const findIndex$2 = (xs, pred) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return Optional.some(i);
            }
        }
        return Optional.none();
    };
    const findLastIndex = (arr, pred) => {
        for (let i = arr.length - 1; i >= 0; i--) {
            if (pred(arr[i], i)) {
                return Optional.some(i);
            }
        }
        return Optional.none();
    };
    const flatten = (xs) => {
        // Note, this is possible because push supports multiple arguments:
        // http://jsperf.com/concat-push/6
        // Note that in the past, concat() would silently work (very slowly) for array-like objects.
        // With this change it will throw an error.
        const r = [];
        for (let i = 0, len = xs.length; i < len; ++i) {
            // Ensure that each value is an array itself
            if (!isArray$1(xs[i])) {
                throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
            }
            nativePush.apply(r, xs[i]);
        }
        return r;
    };
    const bind$3 = (xs, f) => flatten(map$3(xs, f));
    const forall = (xs, pred) => {
        for (let i = 0, len = xs.length; i < len; ++i) {
            const x = xs[i];
            if (pred(x, i) !== true) {
                return false;
            }
        }
        return true;
    };
    const reverse = (xs) => {
        const r = nativeSlice.call(xs, 0);
        r.reverse();
        return r;
    };
    const difference = (a1, a2) => filter$5(a1, (x) => !contains$2(a2, x));
    const mapToObject = (xs, f) => {
        const r = {};
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            r[String(x)] = f(x, i);
        }
        return r;
    };
    const sort = (xs, comparator) => {
        const copy = nativeSlice.call(xs, 0);
        copy.sort(comparator);
        return copy;
    };
    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    const head = (xs) => get$b(xs, 0);
    const last$2 = (xs) => get$b(xs, xs.length - 1);
    const from = isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);
    const findMap = (arr, f) => {
        for (let i = 0; i < arr.length; i++) {
            const r = f(arr[i], i);
            if (r.isSome()) {
                return r;
            }
        }
        return Optional.none();
    };
    const unique$1 = (xs, comparator) => {
        const r = [];
        const isDuplicated = isFunction(comparator) ?
            (x) => exists(r, (i) => comparator(i, x)) :
            (x) => contains$2(r, x);
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (!isDuplicated(x)) {
                r.push(x);
            }
        }
        return r;
    };

    // There are many variations of Object iteration that are faster than the 'for-in' style:
    // http://jsperf.com/object-keys-iteration/107
    //
    // Use the native keys if it is available (IE9+), otherwise fall back to manually filtering
    const keys = Object.keys;
    const hasOwnProperty$1 = Object.hasOwnProperty;
    const each$d = (obj, f) => {
        const props = keys(obj);
        for (let k = 0, len = props.length; k < len; k++) {
            const i = props[k];
            const x = obj[i];
            f(x, i);
        }
    };
    const map$2 = (obj, f) => {
        return tupleMap(obj, (x, i) => ({
            k: i,
            v: f(x, i)
        }));
    };
    const tupleMap = (obj, f) => {
        const r = {};
        each$d(obj, (x, i) => {
            const tuple = f(x, i);
            r[tuple.k] = tuple.v;
        });
        return r;
    };
    const objAcc = (r) => (x, i) => {
        r[i] = x;
    };
    const internalFilter = (obj, pred, onTrue, onFalse) => {
        each$d(obj, (x, i) => {
            (pred(x, i) ? onTrue : onFalse)(x, i);
        });
    };
    const bifilter = (obj, pred) => {
        const t = {};
        const f = {};
        internalFilter(obj, pred, objAcc(t), objAcc(f));
        return { t, f };
    };
    const filter$4 = (obj, pred) => {
        const t = {};
        internalFilter(obj, pred, objAcc(t), noop);
        return t;
    };
    const mapToArray = (obj, f) => {
        const r = [];
        each$d(obj, (value, name) => {
            r.push(f(value, name));
        });
        return r;
    };
    const values = (obj) => {
        return mapToArray(obj, identity);
    };
    const get$a = (obj, key) => {
        return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);
    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;
    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);

    /*
     * Generates a church encoded ADT (https://en.wikipedia.org/wiki/Church_encoding)
     * For syntax and use, look at the test code.
     */
    const generate$2 = (cases) => {
        // validation
        if (!isArray$1(cases)) {
            throw new Error('cases must be an array');
        }
        if (cases.length === 0) {
            throw new Error('there must be at least one case');
        }
        const constructors = [];
        // adt is mutated to add the individual cases
        const adt = {};
        each$e(cases, (acase, count) => {
            const keys$1 = keys(acase);
            // validation
            if (keys$1.length !== 1) {
                throw new Error('one and only one name per case');
            }
            const key = keys$1[0];
            const value = acase[key];
            // validation
            if (adt[key] !== undefined) {
                throw new Error('duplicate key detected:' + key);
            }
            else if (key === 'cata') {
                throw new Error('cannot have a case named cata (sorry)');
            }
            else if (!isArray$1(value)) {
                // this implicitly checks if acase is an object
                throw new Error('case arguments must be an array');
            }
            constructors.push(key);
            //
            // constructor for key
            //
            adt[key] = (...args) => {
                const argLength = args.length;
                // validation
                if (argLength !== value.length) {
                    throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
                }
                const match = (branches) => {
                    const branchKeys = keys(branches);
                    if (constructors.length !== branchKeys.length) {
                        throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
                    }
                    const allReqd = forall(constructors, (reqKey) => {
                        return contains$2(branchKeys, reqKey);
                    });
                    if (!allReqd) {
                        throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
                    }
                    return branches[key].apply(null, args);
                };
                //
                // the fold function for key
                //
                return {
                    fold: (...foldArgs) => {
                        // runtime validation
                        if (foldArgs.length !== cases.length) {
                            throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);
                        }
                        const target = foldArgs[count];
                        return target.apply(null, args);
                    },
                    match,
                    // NOTE: Only for debugging.
                    log: (label) => {
                        // eslint-disable-next-line no-console
                        console.log(label, {
                            constructors,
                            constructor: key,
                            params: args
                        });
                    }
                };
            };
        });
        return adt;
    };
    const Adt = {
        generate: generate$2
    };

    const Cell = (initial) => {
        let value = initial;
        const get = () => {
            return value;
        };
        const set = (v) => {
            value = v;
        };
        return {
            get,
            set
        };
    };

    /**
     * Creates a new `Result<T, E>` that **does** contain a value.
     */
    const value$2 = (value) => {
        const applyHelper = (fn) => fn(value);
        const constHelper = constant(value);
        const outputHelper = () => output;
        const output = {
            // Debug info
            tag: true,
            inner: value,
            // Actual Result methods
            fold: (_onError, onValue) => onValue(value),
            isValue: always,
            isError: never,
            map: (mapper) => Result.value(mapper(value)),
            mapError: outputHelper,
            bind: applyHelper,
            exists: applyHelper,
            forall: applyHelper,
            getOr: constHelper,
            or: outputHelper,
            getOrThunk: constHelper,
            orThunk: outputHelper,
            getOrDie: constHelper,
            each: (fn) => {
                // Can't write the function inline because we don't want to return something by mistake
                fn(value);
            },
            toOptional: () => Optional.some(value),
        };
        return output;
    };
    /**
     * Creates a new `Result<T, E>` that **does not** contain a value, and therefore
     * contains an error.
     */
    const error = (error) => {
        const outputHelper = () => output;
        const output = {
            // Debug info
            tag: false,
            inner: error,
            // Actual Result methods
            fold: (onError, _onValue) => onError(error),
            isValue: never,
            isError: always,
            map: outputHelper,
            mapError: (mapper) => Result.error(mapper(error)),
            bind: outputHelper,
            exists: never,
            forall: always,
            getOr: identity,
            or: identity,
            getOrThunk: apply$1,
            orThunk: apply$1,
            getOrDie: die(String(error)),
            each: noop,
            toOptional: Optional.none,
        };
        return output;
    };
    /**
     * Creates a new `Result<T, E>` from an `Optional<T>` and an `E`. If the
     * `Optional` contains a value, so will the outputted `Result`. If it does not,
     * the outputted `Result` will contain an error (and that error will be the
     * error passed in).
     */
    const fromOption = (optional, err) => optional.fold(() => error(err), value$2);
    const Result = {
        value: value$2,
        error,
        fromOption
    };

    // Use window object as the global if it's available since CSP will block script evals
    // eslint-disable-next-line @typescript-eslint/no-implied-eval
    const Global = typeof window !== 'undefined' ? window : Function('return this;')();

    /* eslint-disable no-bitwise */
    const uuidV4Bytes = () => {
        const bytes = window.crypto.getRandomValues(new Uint8Array(16));
        // https://tools.ietf.org/html/rfc4122#section-4.1.3
        // This will first bit mask away the most significant 4 bits (version octet)
        // then mask in the v4 number we only care about v4 random version at this point so (byte & 0b00001111 | 0b01000000)
        bytes[6] = bytes[6] & 15 | 64;
        // https://tools.ietf.org/html/rfc4122#section-4.1.1
        // This will first bit mask away the highest two bits then masks in the highest bit so (byte & 0b00111111 | 0b10000000)
        // So it will set the Msb0=1 & Msb1=0 described by the "The variant specified in this document." row in the table
        bytes[8] = bytes[8] & 63 | 128;
        return bytes;
    };
    const uuidV4String = () => {
        const uuid = uuidV4Bytes();
        const getHexRange = (startIndex, endIndex) => {
            let buff = '';
            for (let i = startIndex; i <= endIndex; ++i) {
                const hexByte = uuid[i].toString(16).padStart(2, '0');
                buff += hexByte;
            }
            return buff;
        };
        // RFC 4122 UUID format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
        return `${getHexRange(0, 3)}-${getHexRange(4, 5)}-${getHexRange(6, 7)}-${getHexRange(8, 9)}-${getHexRange(10, 15)}`;
    };

    /**
     * Adds two numbers, and wrap to a range.
     * If the result overflows to the right, snap to the left.
     * If the result overflows to the left, snap to the right.
     */
    // ASSUMPTION: Max will always be larger than min
    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);
    // the division is meant to get a number between 0 and 1 for more information check this discussion: https://stackoverflow.com/questions/58285941/how-to-replace-math-random-with-crypto-getrandomvalues-and-keep-same-result
    const random = () => window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;

    /**
     * Generate a unique identifier.
     *
     * The unique portion of the identifier only contains an underscore
     * and digits, so that it may safely be used within HTML attributes.
     *
     * The chance of generating a non-unique identifier has been minimized
     * by combining the current time, a random number and a one-up counter.
     *
     * generate :: String -> String
     */
    let unique = 0;
    const generate$1 = (prefix) => {
        const date = new Date();
        const time = date.getTime();
        const random$1 = Math.floor(random() * 1000000000);
        unique++;
        return prefix + '_' + random$1 + unique + String(time);
    };
    /**
     * Generate a uuidv4 string
     * In accordance with RFC 4122 (https://datatracker.ietf.org/doc/html/rfc4122)
     */
    const uuidV4 = () => {
        if (window.isSecureContext) {
            return window.crypto.randomUUID();
        }
        else {
            return uuidV4String();
        }
    };

    const shallow$1 = (old, nu) => {
        return nu;
    };
    const deep$1 = (old, nu) => {
        const bothObjects = isPlainObject(old) && isPlainObject(nu);
        return bothObjects ? deepMerge(old, nu) : nu;
    };
    const baseMerge = (merger) => {
        return (...objects) => {
            if (objects.length === 0) {
                throw new Error(`Can't merge zero objects`);
            }
            const ret = {};
            for (let j = 0; j < objects.length; j++) {
                const curObject = objects[j];
                for (const key in curObject) {
                    if (has$2(curObject, key)) {
                        ret[key] = merger(ret[key], curObject[key]);
                    }
                }
            }
            return ret;
        };
    };
    const deepMerge = baseMerge(deep$1);
    const merge$1 = baseMerge(shallow$1);

    /**
     * **Is** the value stored inside this Optional object equal to `rhs`?
     */
    const is$4 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));
    /**
     * Are these two Optional objects equal? Equality here means either they're both
     * `Some` (and the values are equal under the comparator) or they're both `None`.
     */
    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
    const cat = (arr) => {
        const r = [];
        const push = (x) => {
            r.push(x);
        };
        for (let i = 0; i < arr.length; i++) {
            arr[i].each(push);
        }
        return r;
    };
    /*
    Notes on the lift functions:
    - We used to have a generic liftN, but we were concerned about its type-safety, and the below variants were faster in microbenchmarks.
    - The getOrDie calls are partial functions, but are checked beforehand. This is faster and more convenient (but less safe) than folds.
    - && is used instead of a loop for simplicity and performance.
    */
    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
    // This can help with type inference, by specifying the type param on the none case, so the caller doesn't have to.
    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();

    /** path :: ([String], JsObj?) -> JsObj */
    const path = (parts, scope) => {
        let o = scope !== undefined && scope !== null ? scope : Global;
        for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {
            o = o[parts[i]];
        }
        return o;
    };
    /** resolve :: (String, JsObj?) -> JsObj */
    const resolve$3 = (p, scope) => {
        const parts = p.split('.');
        return path(parts, scope);
    };

    Adt.generate([
        { bothErrors: ['error1', 'error2'] },
        { firstError: ['error1', 'value2'] },
        { secondError: ['value1', 'error2'] },
        { bothValues: ['value1', 'value2'] }
    ]);
    /** partition :: [Result a] -> { errors: [String], values: [a] } */
    const partition$1 = (results) => {
        const errors = [];
        const values = [];
        each$e(results, (result) => {
            result.fold((err) => {
                errors.push(err);
            }, (value) => {
                values.push(value);
            });
        });
        return { errors, values };
    };

    const singleton = (doRevoke) => {
        const subject = Cell(Optional.none());
        const revoke = () => subject.get().each(doRevoke);
        const clear = () => {
            revoke();
            subject.set(Optional.none());
        };
        const isSet = () => subject.get().isSome();
        const get = () => subject.get();
        const set = (s) => {
            revoke();
            subject.set(Optional.some(s));
        };
        return {
            clear,
            isSet,
            get,
            set
        };
    };
    const repeatable = (delay) => {
        const intervalId = Cell(Optional.none());
        const revoke = () => intervalId.get().each((id) => clearInterval(id));
        const clear = () => {
            revoke();
            intervalId.set(Optional.none());
        };
        const isSet = () => intervalId.get().isSome();
        const get = () => intervalId.get();
        const set = (functionToRepeat) => {
            revoke();
            intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));
        };
        return {
            clear,
            isSet,
            get,
            set,
        };
    };
    const value$1 = () => {
        const subject = singleton(noop);
        const on = (f) => subject.get().each(f);
        return {
            ...subject,
            on
        };
    };

    const removeFromStart = (str, numChars) => {
        return str.substring(numChars);
    };

    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    const removeLeading = (str, prefix) => {
        return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    const contains$1 = (str, substr, start = 0, end) => {
        const idx = str.indexOf(substr, start);
        if (idx !== -1) {
            return isUndefined(end) ? true : idx + substr.length <= end;
        }
        else {
            return false;
        }
    };
    /** Does 'str' start with 'prefix'?
     *  Note: all strings start with the empty string.
     *        More formally, for all strings x, startsWith(x, "").
     *        This is so that for all strings x and y, startsWith(y + x, y)
     */
    const startsWith = (str, prefix) => {
        return checkRange(str, prefix, 0);
    };
    /** Does 'str' end with 'suffix'?
     *  Note: all strings end with the empty string.
     *        More formally, for all strings x, endsWith(x, "").
     *        This is so that for all strings x and y, endsWith(x + y, y)
     */
    const endsWith = (str, suffix) => {
        return checkRange(str, suffix, str.length - suffix.length);
    };
    const blank = (r) => (s) => s.replace(r, '');
    /** removes all leading and trailing spaces */
    const trim$4 = blank(/^\s+|\s+$/g);
    const lTrim = blank(/^\s+/g);
    const rTrim = blank(/\s+$/g);
    const isNotEmpty = (s) => s.length > 0;
    const isEmpty$5 = (s) => !isNotEmpty(s);
    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);
    const toInt = (value, radix = 10) => {
        const num = parseInt(value, radix);
        return isNaN(num) ? Optional.none() : Optional.some(num);
    };

    // Run a function fn after rate ms. If another invocation occurs
    // during the time it is waiting, ignore it completely.
    const first$1 = (fn, rate) => {
        let timer = null;
        const cancel = () => {
            if (!isNull(timer)) {
                clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = (...args) => {
            if (isNull(timer)) {
                timer = setTimeout(() => {
                    timer = null;
                    fn.apply(null, args);
                }, rate);
            }
        };
        return {
            cancel,
            throttle
        };
    };
    // Run a function fn after rate ms. If another invocation occurs
    // during the time it is waiting, reschedule the function again
    // with the new arguments.
    const last$1 = (fn, rate) => {
        let timer = null;
        const cancel = () => {
            if (!isNull(timer)) {
                clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = (...args) => {
            cancel();
            timer = setTimeout(() => {
                timer = null;
                fn.apply(null, args);
            }, rate);
        };
        return {
            cancel,
            throttle
        };
    };

    const cached = (f) => {
        let called = false;
        let r;
        return (...args) => {
            if (!called) {
                called = true;
                r = f.apply(null, args);
            }
            return r;
        };
    };

    const zeroWidth = '\uFEFF';
    const nbsp = '\u00A0';
    const ellipsis = '\u2026';
    const isZwsp$2 = (char) => char === zeroWidth;
    const removeZwsp = (s) => s.replace(/\uFEFF/g, '');

    const stringArray = (a) => {
        const all = {};
        each$e(a, (key) => {
            all[key] = {};
        });
        return keys(all);
    };

    const isArrayLike = (o) => o.length !== undefined;
    const isArray = Array.isArray;
    const toArray$1 = (obj) => {
        if (!isArray(obj)) {
            const array = [];
            for (let i = 0, l = obj.length; i < l; i++) {
                array[i] = obj[i];
            }
            return array;
        }
        else {
            return obj;
        }
    };
    const each$c = (o, cb, s) => {
        if (!o) {
            return false;
        }
        s = s || o;
        if (isArrayLike(o)) {
            // Indexed arrays, needed for Safari
            for (let n = 0, l = o.length; n < l; n++) {
                if (cb.call(s, o[n], n, o) === false) {
                    return false;
                }
            }
        }
        else {
            // Hashtables
            for (const n in o) {
                if (has$2(o, n)) {
                    if (cb.call(s, o[n], n, o) === false) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    const map$1 = (array, callback) => {
        const out = [];
        each$c(array, (item, index) => {
            out.push(callback(item, index, array));
        });
        return out;
    };
    const filter$3 = (a, f) => {
        const o = [];
        each$c(a, (v, index) => {
            if (!f || f(v, index, a)) {
                o.push(v);
            }
        });
        return o;
    };
    const indexOf = (a, v) => {
        if (a) {
            for (let i = 0, l = a.length; i < l; i++) {
                if (a[i] === v) {
                    return i;
                }
            }
        }
        return -1;
    };
    const reduce = (collection, iteratee, accumulator, thisArg) => {
        let acc = isUndefined(accumulator) ? collection[0] : accumulator;
        for (let i = 0; i < collection.length; i++) {
            acc = iteratee.call(thisArg, acc, collection[i], i);
        }
        return acc;
    };
    const findIndex$1 = (array, predicate, thisArg) => {
        for (let i = 0, l = array.length; i < l; i++) {
            if (predicate.call(thisArg, array[i], i, array)) {
                return i;
            }
        }
        return -1;
    };
    const last = (collection) => collection[collection.length - 1];

    const DeviceType = (os, browser, userAgent, mediaMatch) => {
        const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
        const isiPhone = os.isiOS() && !isiPad;
        const isMobile = os.isiOS() || os.isAndroid();
        const isTouch = isMobile || mediaMatch('(pointer:coarse)');
        const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
        const isPhone = isiPhone || isMobile && !isTablet;
        const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
        const isDesktop = !isPhone && !isTablet && !iOSwebview;
        return {
            isiPad: constant(isiPad),
            isiPhone: constant(isiPhone),
            isTablet: constant(isTablet),
            isPhone: constant(isPhone),
            isTouch: constant(isTouch),
            isAndroid: os.isAndroid,
            isiOS: os.isiOS,
            isWebView: constant(iOSwebview),
            isDesktop: constant(isDesktop)
        };
    };

    const firstMatch = (regexes, s) => {
        for (let i = 0; i < regexes.length; i++) {
            const x = regexes[i];
            if (x.test(s)) {
                return x;
            }
        }
        return undefined;
    };
    const find$1 = (regexes, agent) => {
        const r = firstMatch(regexes, agent);
        if (!r) {
            return { major: 0, minor: 0 };
        }
        const group = (i) => {
            return Number(agent.replace(r, '$' + i));
        };
        return nu$3(group(1), group(2));
    };
    const detect$4 = (versionRegexes, agent) => {
        const cleanedAgent = String(agent).toLowerCase();
        if (versionRegexes.length === 0) {
            return unknown$2();
        }
        return find$1(versionRegexes, cleanedAgent);
    };
    const unknown$2 = () => {
        return nu$3(0, 0);
    };
    const nu$3 = (major, minor) => {
        return { major, minor };
    };
    const Version = {
        nu: nu$3,
        detect: detect$4,
        unknown: unknown$2
    };

    const detectBrowser$1 = (browsers, userAgentData) => {
        return findMap(userAgentData.brands, (uaBrand) => {
            const lcBrand = uaBrand.brand.toLowerCase();
            return find$2(browsers, (browser) => { var _a; return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase()); })
                .map((info) => ({
                current: info.name,
                version: Version.nu(parseInt(uaBrand.version, 10), 0)
            }));
        });
    };

    const detect$3 = (candidates, userAgent) => {
        const agent = String(userAgent).toLowerCase();
        return find$2(candidates, (candidate) => {
            return candidate.search(agent);
        });
    };
    // They (browser and os) are the same at the moment, but they might
    // not stay that way.
    const detectBrowser = (browsers, userAgent) => {
        return detect$3(browsers, userAgent).map((browser) => {
            const version = Version.detect(browser.versionRegexes, userAgent);
            return {
                current: browser.name,
                version
            };
        });
    };
    const detectOs = (oses, userAgent) => {
        return detect$3(oses, userAgent).map((os) => {
            const version = Version.detect(os.versionRegexes, userAgent);
            return {
                current: os.name,
                version
            };
        });
    };

    const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    const checkContains = (target) => {
        return (uastring) => {
            return contains$1(uastring, target);
        };
    };
    const browsers = [
        // This is legacy Edge
        {
            name: 'Edge',
            versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
            search: (uastring) => {
                return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');
            }
        },
        // This is Google Chrome and Chromium Edge
        {
            name: 'Chromium',
            brand: 'Chromium',
            versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, normalVersionRegex],
            search: (uastring) => {
                return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');
            }
        },
        {
            name: 'IE',
            versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
            search: (uastring) => {
                return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');
            }
        },
        // INVESTIGATE: Is this still the Opera user agent?
        {
            name: 'Opera',
            versionRegexes: [normalVersionRegex, /.*?opera\/([0-9]+)\.([0-9]+).*/],
            search: checkContains('opera')
        },
        {
            name: 'Firefox',
            versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
            search: checkContains('firefox')
        },
        {
            name: 'Safari',
            versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],
            search: (uastring) => {
                return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');
            }
        }
    ];
    const oses = [
        {
            name: 'Windows',
            search: checkContains('win'),
            versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
            name: 'iOS',
            search: (uastring) => {
                return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');
            },
            versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
        },
        {
            name: 'Android',
            search: checkContains('android'),
            versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
            name: 'macOS',
            search: checkContains('mac os x'),
            versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
        },
        {
            name: 'Linux',
            search: checkContains('linux'),
            versionRegexes: []
        },
        { name: 'Solaris',
            search: checkContains('sunos'),
            versionRegexes: []
        },
        {
            name: 'FreeBSD',
            search: checkContains('freebsd'),
            versionRegexes: []
        },
        {
            name: 'ChromeOS',
            search: checkContains('cros'),
            versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
        }
    ];
    const PlatformInfo = {
        browsers: constant(browsers),
        oses: constant(oses)
    };

    const edge = 'Edge';
    const chromium = 'Chromium';
    const ie = 'IE';
    const opera = 'Opera';
    const firefox = 'Firefox';
    const safari = 'Safari';
    const unknown$1 = () => {
        return nu$2({
            current: undefined,
            version: Version.unknown()
        });
    };
    const nu$2 = (info) => {
        const current = info.current;
        const version = info.version;
        const isBrowser = (name) => () => current === name;
        return {
            current,
            version,
            isEdge: isBrowser(edge),
            isChromium: isBrowser(chromium),
            // NOTE: isIe just looks too weird
            isIE: isBrowser(ie),
            isOpera: isBrowser(opera),
            isFirefox: isBrowser(firefox),
            isSafari: isBrowser(safari)
        };
    };
    const Browser = {
        unknown: unknown$1,
        nu: nu$2,
        edge: constant(edge),
        chromium: constant(chromium),
        ie: constant(ie),
        opera: constant(opera),
        firefox: constant(firefox),
        safari: constant(safari)
    };

    const windows = 'Windows';
    const ios = 'iOS';
    const android = 'Android';
    const linux = 'Linux';
    const macos = 'macOS';
    const solaris = 'Solaris';
    const freebsd = 'FreeBSD';
    const chromeos = 'ChromeOS';
    // Though there is a bit of dupe with this and Browser, trying to
    // reuse code makes it much harder to follow and change.
    const unknown = () => {
        return nu$1({
            current: undefined,
            version: Version.unknown()
        });
    };
    const nu$1 = (info) => {
        const current = info.current;
        const version = info.version;
        const isOS = (name) => () => current === name;
        return {
            current,
            version,
            isWindows: isOS(windows),
            // TODO: Fix capitalisation
            isiOS: isOS(ios),
            isAndroid: isOS(android),
            isMacOS: isOS(macos),
            isLinux: isOS(linux),
            isSolaris: isOS(solaris),
            isFreeBSD: isOS(freebsd),
            isChromeOS: isOS(chromeos)
        };
    };
    const OperatingSystem = {
        unknown,
        nu: nu$1,
        windows: constant(windows),
        ios: constant(ios),
        android: constant(android),
        linux: constant(linux),
        macos: constant(macos),
        solaris: constant(solaris),
        freebsd: constant(freebsd),
        chromeos: constant(chromeos)
    };

    const detect$2 = (userAgent, userAgentDataOpt, mediaMatch) => {
        const browsers = PlatformInfo.browsers();
        const oses = PlatformInfo.oses();
        const browser = userAgentDataOpt.bind((userAgentData) => detectBrowser$1(browsers, userAgentData))
            .orThunk(() => detectBrowser(browsers, userAgent))
            .fold(Browser.unknown, Browser.nu);
        const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
        const deviceType = DeviceType(os, browser, userAgent, mediaMatch);
        return {
            browser,
            os,
            deviceType
        };
    };
    const PlatformDetection = {
        detect: detect$2
    };

    const mediaMatch = (query) => window.matchMedia(query).matches;
    // IMPORTANT: Must be in a thunk, otherwise rollup thinks calling this immediately
    // causes side effects and won't tree shake this away
    // Note: navigator.userAgentData is not part of the native typescript types yet
    let platform$4 = cached(() => PlatformDetection.detect(window.navigator.userAgent, Optional.from((window.navigator.userAgentData)), mediaMatch));
    const detect$1 = () => platform$4();

    const unsafe = (name, scope) => {
        return resolve$3(name, scope);
    };
    const getOrDie = (name, scope) => {
        const actual = unsafe(name, scope);
        if (actual === undefined || actual === null) {
            throw new Error(name + ' not available on this browser');
        }
        return actual;
    };

    const getPrototypeOf$1 = Object.getPrototypeOf;
    /*
     * IE9 and above
     *
     * MDN no use on this one, but here's the link anyway:
     * https://developer.mozilla.org/en/docs/Web/API/HTMLElement
     */
    const sandHTMLElement = (scope) => {
        return getOrDie('HTMLElement', scope);
    };
    const isPrototypeOf = (x) => {
        // use Resolve to get the window object for x and just return undefined if it can't find it.
        // undefined scope later triggers using the global window.
        const scope = resolve$3('ownerDocument.defaultView', x);
        // TINY-7374: We can't rely on looking at the owner window HTMLElement as the element may have
        // been constructed in a different window and then appended to the current window document.
        return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf$1(x).constructor.name));
    };

    /**
     * This class contains various environment constants like browser versions etc.
     * Normally you don't want to sniff specific browser versions but sometimes you have
     * to when it's impossible to feature detect. So use this with care.
     *
     * @class tinymce.Env
     * @static
     */
    const userAgent = window.navigator.userAgent;
    const platform$3 = detect$1();
    const browser$3 = platform$3.browser;
    const os$1 = platform$3.os;
    const deviceType = platform$3.deviceType;
    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;
    const Env = {
        /**
         * Transparent image data url.
         *
         * @property transparentSrc
         * @type Boolean
         * @final
         */
        transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
        /**
         * Returns the IE document mode. For non IE browsers, this will fake IE 10 document mode.
         *
         * @property documentMode
         * @type Number
         */
        documentMode: browser$3.isIE() ? (document.documentMode || 7) : 10,
        cacheSuffix: null,
        container: null,
        /**
         * Constant if CSP mode is possible or not. Meaning we can't use script urls for the iframe.
         */
        canHaveCSP: !browser$3.isIE(),
        windowsPhone,
        /**
         * @include ../../../../../tools/docs/tinymce.Env.js
         */
        browser: {
            current: browser$3.current,
            version: browser$3.version,
            isChromium: browser$3.isChromium,
            isEdge: browser$3.isEdge,
            isFirefox: browser$3.isFirefox,
            isIE: browser$3.isIE,
            isOpera: browser$3.isOpera,
            isSafari: browser$3.isSafari
        },
        os: {
            current: os$1.current,
            version: os$1.version,
            isAndroid: os$1.isAndroid,
            isChromeOS: os$1.isChromeOS,
            isFreeBSD: os$1.isFreeBSD,
            isiOS: os$1.isiOS,
            isLinux: os$1.isLinux,
            isMacOS: os$1.isMacOS,
            isSolaris: os$1.isSolaris,
            isWindows: os$1.isWindows
        },
        deviceType: {
            isDesktop: deviceType.isDesktop,
            isiPad: deviceType.isiPad,
            isiPhone: deviceType.isiPhone,
            isPhone: deviceType.isPhone,
            isTablet: deviceType.isTablet,
            isTouch: deviceType.isTouch,
            isWebView: deviceType.isWebView
        }
    };

    /**
     * This class contains various utility functions. These are also exposed
     * directly on the tinymce namespace.
     *
     * @class tinymce.util.Tools
     */
    /**
     * Removes whitespace from the beginning and end of a string.
     *
     * @method trim
     * @param {String} s String to remove whitespace from.
     * @return {String} New string with removed whitespace.
     */
    const whiteSpaceRegExp$1 = /^\s*|\s*$/g;
    const trim$3 = (str) => {
        return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');
    };
    /**
     * Checks if a object is of a specific type for example an array.
     *
     * @method is
     * @param {Object} obj Object to check type of.
     * @param {String} type Optional type to check for.
     * @return {Boolean} true/false if the object is of the specified type.
     */
    const is$3 = (obj, type) => {
        if (!type) {
            return obj !== undefined;
        }
        if (type === 'array' && isArray(obj)) {
            return true;
        }
        return typeof obj === type;
    };
    /**
     * Makes a name/object map out of an array with names.
     *
     * @method makeMap
     * @param {Array/String} items Items to make map out of.
     * @param {String} delim Optional delimiter to split string by.
     * @param {Object} map Optional map to add items to.
     * @return {Object} Name/value map of items.
     */
    const makeMap$4 = (items, delim, map = {}) => {
        const resolvedItems = isString(items) ? items.split(delim || ',') : (items || []);
        let i = resolvedItems.length;
        while (i--) {
            map[resolvedItems[i]] = {};
        }
        return map;
    };
    /**
     * JavaScript does not protect hasOwnProperty method, so it is possible to overwrite it. This is
     * an object independent version.
     * Checks if the input object "<code>obj</code>" has the property "<code>prop</code>".
     *
     * @method hasOwnProperty
     * @param {Object} obj Object to check if the property exists.
     * @param {String} prop Name of a property on the object.
     * @returns {Boolean} true if the object has the specified property.
     */
    const hasOwnProperty = has$2;
    const extend$3 = (obj, ...exts) => {
        for (let i = 0; i < exts.length; i++) {
            const ext = exts[i];
            for (const name in ext) {
                if (has$2(ext, name)) {
                    const value = ext[name];
                    if (value !== undefined) {
                        obj[name] = value;
                    }
                }
            }
        }
        return obj;
    };
    /**
     * Executed the specified function for each item in a object tree.
     *
     * @method walk
     * @param {Object} o Object tree to walk though.
     * @param {Function} f Function to call for each item.
     * @param {String} n Optional name of collection inside the objects to walk for example childNodes.
     * @param {String} s Optional scope to execute the function in.
     */
    const walk$4 = function (o, f, n, s) {
        s = s || this;
        if (o) {
            if (n) {
                o = o[n];
            }
            each$c(o, (o, i) => {
                if (f.call(s, o, i, n) === false) {
                    return false;
                }
                else {
                    walk$4(o, f, n, s);
                    return true;
                }
            });
        }
    };
    /**
     * Resolves a string and returns the object from a specific structure.
     *
     * @method resolve
     * @param {String} n Path to resolve for example a.b.c.d.
     * @param {Object} o Optional object to search though, defaults to window.
     * @return {Object} Last object in path or null if it couldn't be resolved.
     * @example
     * // Resolve a path into an object reference
     * const obj = tinymce.resolve('a.b.c.d');
     */
    const resolve$2 = (n, o = window) => {
        const path = n.split('.');
        for (let i = 0, l = path.length; i < l; i++) {
            o = o[path[i]];
            if (!o) {
                break;
            }
        }
        return o;
    };
    /**
     * Splits a string but removes the whitespace before and after each value.
     *
     * @method explode
     * @param {String} s String to split.
     * @param {String} d Delimiter to split by.
     * @example
     * // Split a string into an array with a,b,c
     * const arr = tinymce.explode('a, b,   c');
     */
    const explode$3 = (s, d) => {
        if (isArray$1(s)) {
            return s;
        }
        else if (s === '') {
            return [];
        }
        else {
            return map$1(s.split(d || ','), trim$3);
        }
    };
    const _addCacheSuffix = (url) => {
        const cacheSuffix = Env.cacheSuffix;
        if (cacheSuffix) {
            url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;
        }
        return url;
    };
    const Tools = {
        trim: trim$3,
        /**
         * Returns true/false if the object is an array or not.
         *
         * @method isArray
         * @param {Object} obj Object to check.
         * @return {Boolean} true/false state if the object is an array or not.
         */
        isArray: isArray,
        is: is$3,
        /**
         * Converts the specified object into a real JavaScript array.
         *
         * @method toArray
         * @param {Object} obj Object to convert into array.
         * @return {Array} Array object based in input.
         */
        toArray: toArray$1,
        makeMap: makeMap$4,
        /**
         * Performs an iteration of all items in a collection such as an object or array. This method will execute the
         * callback function for each item in the collection, if the callback returns false the iteration will terminate.
         * The callback has the following format: `cb(value, key_or_index)`.
         *
         * @method each
         * @param {Object} o Collection to iterate.
         * @param {Function} cb Callback function to execute for each item.
         * @param {Object} s Optional scope to execute the callback in.
         * @example
         * // Iterate an array
         * tinymce.each([ 1,2,3 ], (v, i) => {
         *   console.debug("Value: " + v + ", Index: " + i);
         * });
         *
         * // Iterate an object
         * tinymce.each({ a: 1, b: 2, c: 3 }, (v, k) => {
         *   console.debug("Value: " + v + ", Key: " + k);
         * });
         */
        each: each$c,
        /**
         * Creates a new array by the return value of each iteration function call. This enables you to convert
         * one array list into another.
         *
         * @method map
         * @param {Array} array Array of items to iterate.
         * @param {Function} callback Function to call for each item. It's return value will be the new value.
         * @return {Array} Array with new values based on function return values.
         */
        map: map$1,
        /**
         * Filters out items from the input array by calling the specified function for each item.
         * If the function returns false the item will be excluded if it returns true it will be included.
         *
         * @method grep
         * @param {Array} a Array of items to loop though.
         * @param {Function} f Function to call for each item. Include/exclude depends on it's return value.
         * @return {Array} New array with values imported and filtered based in input.
         * @example
         * // Filter out some items, this will return an array with 4 and 5
         * const items = tinymce.grep([ 1,2,3,4,5 ], (v) => v > 3);
         */
        grep: filter$3,
        /**
         * Returns an index of the item or -1 if item is not present in the array.
         *
         * @method inArray
         * @param {any} item Item to search for.
         * @param {Array} arr Array to search in.
         * @return {Number} index of the item or -1 if item was not found.
         */
        inArray: indexOf,
        hasOwn: hasOwnProperty,
        extend: extend$3,
        walk: walk$4,
        resolve: resolve$2,
        explode: explode$3,
        _addCacheSuffix
    };

    const fromHtml$1 = (html, scope) => {
        const doc = scope || document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        if (!div.hasChildNodes() || div.childNodes.length > 1) {
            const message = 'HTML does not have a single root node';
            // eslint-disable-next-line no-console
            console.error(message, html);
            throw new Error(message);
        }
        return fromDom$2(div.childNodes[0]);
    };
    const fromTag = (tag, scope) => {
        const doc = scope || document;
        const node = doc.createElement(tag);
        return fromDom$2(node);
    };
    const fromText = (text, scope) => {
        const doc = scope || document;
        const node = doc.createTextNode(text);
        return fromDom$2(node);
    };
    const fromDom$2 = (node) => {
        // TODO: Consider removing this check, but left atm for safety
        if (node === null || node === undefined) {
            throw new Error('Node cannot be null or undefined');
        }
        return {
            dom: node
        };
    };
    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);
    // tslint:disable-next-line:variable-name
    const SugarElement = {
        fromHtml: fromHtml$1,
        fromTag,
        fromText,
        fromDom: fromDom$2,
        fromPoint: fromPoint$2
    };

    // NOTE: Mutates the range.
    const setStart = (rng, situ) => {
        situ.fold((e) => {
            rng.setStartBefore(e.dom);
        }, (e, o) => {
            rng.setStart(e.dom, o);
        }, (e) => {
            rng.setStartAfter(e.dom);
        });
    };
    const setFinish = (rng, situ) => {
        situ.fold((e) => {
            rng.setEndBefore(e.dom);
        }, (e, o) => {
            rng.setEnd(e.dom, o);
        }, (e) => {
            rng.setEndAfter(e.dom);
        });
    };
    const relativeToNative = (win, startSitu, finishSitu) => {
        const range = win.document.createRange();
        setStart(range, startSitu);
        setFinish(range, finishSitu);
        return range;
    };
    const exactToNative = (win, start, soffset, finish, foffset) => {
        const rng = win.document.createRange();
        rng.setStart(start.dom, soffset);
        rng.setEnd(finish.dom, foffset);
        return rng;
    };

    const adt$3 = Adt.generate([
        { ltr: ['start', 'soffset', 'finish', 'foffset'] },
        { rtl: ['start', 'soffset', 'finish', 'foffset'] }
    ]);
    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);
    const getRanges$1 = (win, selection) => selection.match({
        domRange: (rng) => {
            return {
                ltr: constant(rng),
                rtl: Optional.none
            };
        },
        relative: (startSitu, finishSitu) => {
            return {
                ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
                rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))
            };
        },
        exact: (start, soffset, finish, foffset) => {
            return {
                ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),
                rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))
            };
        }
    });
    const doDiagnose = (win, ranges) => {
        // If we cannot create a ranged selection from start > finish, it could be RTL
        const rng = ranges.ltr();
        if (rng.collapsed) {
            // Let's check if it's RTL ... if it is, then reversing the direction will not be collapsed
            const reversed = ranges.rtl().filter((rev) => rev.collapsed === false);
            return reversed.map((rev) => 
            // We need to use "reversed" here, because the original only has one point (collapsed)
            adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));
        }
        else {
            return fromRange(win, adt$3.ltr, rng);
        }
    };
    const diagnose = (win, selection) => {
        const ranges = getRanges$1(win, selection);
        return doDiagnose(win, ranges);
    };
    adt$3.ltr;
    adt$3.rtl;

    const COMMENT = 8;
    const DOCUMENT = 9;
    const DOCUMENT_FRAGMENT = 11;
    const ELEMENT = 1;
    const TEXT = 3;

    const is$2 = (element, selector) => {
        const dom = element.dom;
        if (dom.nodeType !== ELEMENT) {
            return false;
        }
        else {
            const elem = dom;
            if (elem.matches !== undefined) {
                return elem.matches(selector);
            }
            else if (elem.msMatchesSelector !== undefined) {
                return elem.msMatchesSelector(selector);
            }
            else if (elem.webkitMatchesSelector !== undefined) {
                return elem.webkitMatchesSelector(selector);
            }
            else if (elem.mozMatchesSelector !== undefined) {
                // cast to any as mozMatchesSelector doesn't exist in TS DOM lib
                return elem.mozMatchesSelector(selector);
            }
            else {
                throw new Error('Browser lacks native selectors');
            } // unfortunately we can't throw this on startup :(
        }
    };
    const bypassSelector = (dom) => 
    // Only elements, documents and shadow roots support querySelector
    // shadow root element type is DOCUMENT_FRAGMENT
    dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT ||
        // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/
        dom.childElementCount === 0;
    const all = (selector, scope) => {
        const base = scope === undefined ? document : scope.dom;
        return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    const one = (selector, scope) => {
        const base = scope === undefined ? document : scope.dom;
        return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };

    const eq = (e1, e2) => e1.dom === e2.dom;
    // Returns: true if node e1 contains e2, otherwise false.
    // (returns false if e1===e2: A node does not contain itself).
    const contains = (e1, e2) => {
        const d1 = e1.dom;
        const d2 = e2.dom;
        return d1 === d2 ? false : d1.contains(d2);
    };
    const is$1 = is$2;

    /**
     * Applies f repeatedly until it completes (by returning Optional.none()).
     *
     * Normally would just use recursion, but JavaScript lacks tail call optimisation.
     *
     * This is what recursion looks like when manually unravelled :)
     */
    const toArray = (target, f) => {
        const r = [];
        const recurse = (e) => {
            r.push(e);
            return f(e);
        };
        let cur = f(target);
        do {
            cur = cur.bind(recurse);
        } while (cur.isSome());
        return r;
    };

    const name = (element) => {
        const r = element.dom.nodeName;
        return r.toLowerCase();
    };
    const type$1 = (element) => element.dom.nodeType;
    const isType = (t) => (element) => type$1(element) === t;
    const isComment$1 = (element) => type$1(element) === COMMENT || name(element) === '#comment';
    const isHTMLElement$1 = (element) => isElement$8(element) && isPrototypeOf(element.dom);
    const isElement$8 = isType(ELEMENT);
    const isText$c = isType(TEXT);
    const isDocument$2 = isType(DOCUMENT);
    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);
    const isTag = (tag) => (e) => isElement$8(e) && name(e) === tag;

    /**
     * The document associated with the current element
     * NOTE: this will throw if the owner is null.
     */
    const owner$1 = (element) => SugarElement.fromDom(element.dom.ownerDocument);
    /**
     * If the element is a document, return it. Otherwise, return its ownerDocument.
     * @param dos
     */
    const documentOrOwner = (dos) => isDocument$2(dos) ? dos : owner$1(dos);
    const documentElement = (element) => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
    /**
     * The window element associated with the element
     * NOTE: this will throw if the defaultView is null.
     */
    const defaultView = (element) => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
    const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    const parentElement = (element) => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
    const parents$1 = (element, isRoot) => {
        const stop = isFunction(isRoot) ? isRoot : never;
        // This is used a *lot* so it needs to be performant, not recursive
        let dom = element.dom;
        const ret = [];
        while (dom.parentNode !== null && dom.parentNode !== undefined) {
            const rawParent = dom.parentNode;
            const p = SugarElement.fromDom(rawParent);
            ret.push(p);
            if (stop(p) === true) {
                break;
            }
            else {
                dom = rawParent;
            }
        }
        return ret;
    };
    const siblings = (element) => {
        // TODO: Refactor out children so we can just not add self instead of filtering afterwards
        const filterSelf = (elements) => filter$5(elements, (x) => !eq(element, x));
        return parent(element).map(children$1).map(filterSelf).getOr([]);
    };
    const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
    const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
    // This one needs to be reversed, so they're still in DOM order
    const prevSiblings = (element) => reverse(toArray(element, prevSibling));
    const nextSiblings = (element) => toArray(element, nextSibling);
    const children$1 = (element) => map$3(element.dom.childNodes, SugarElement.fromDom);
    const child$1 = (element, index) => {
        const cs = element.dom.childNodes;
        return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    const firstChild = (element) => child$1(element, 0);
    const lastChild = (element) => child$1(element, element.dom.childNodes.length - 1);
    const childNodesCount = (element) => element.dom.childNodes.length;

    const getHead = (doc) => {
        /*
         * IE9 and above per
         * https://developer.mozilla.org/en-US/docs/Web/API/Document/head
         */
        const b = doc.dom.head;
        if (b === null || b === undefined) {
            throw new Error('Head is not available yet');
        }
        return SugarElement.fromDom(b);
    };

    /**
     * Is the element a ShadowRoot?
     *
     * Note: this is insufficient to test if any element is a shadow root, but it is sufficient to differentiate between
     * a Document and a ShadowRoot.
     */
    const isShadowRoot = (dos) => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);
    const getRootNode = (e) => SugarElement.fromDom(e.dom.getRootNode());
    /** Where style tags need to go. ShadowRoot or document head */
    const getStyleContainer = (dos) => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));
    /** Where content needs to go. ShadowRoot or document body */
    const getContentContainer = (dos) => 
    // Can't use SugarBody.body without causing a circular module reference (since SugarBody.inBody uses SugarShadowDom)
    isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
    /** If this element is in a ShadowRoot, return it. */
    const getShadowRoot = (e) => {
        const r = getRootNode(e);
        return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    /** Return the host of a ShadowRoot.
     *
     * This function will throw if Shadow DOM is unsupported in the browser, or if the host is null.
     * If you actually have a ShadowRoot, this shouldn't happen.
     */
    const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
    /**
     * When Events bubble up through a ShadowRoot, the browser changes the target to be the shadow host.
     * This function gets the "original" event target if possible.
     * This only works if the shadow tree is open - if the shadow tree is closed, event.target is returned.
     * See: https://developers.google.com/web/fundamentals/web-components/shadowdom#events
     */
    const getOriginalEventTarget = (event) => {
        if (isNonNullable(event.target)) {
            const el = SugarElement.fromDom(event.target);
            if (isElement$8(el) && isOpenShadowHost(el)) {
                // When target element is inside Shadow DOM we need to take first element from composedPath
                // otherwise we'll get Shadow Root parent, not actual target element.
                if (event.composed && event.composedPath) {
                    const composedPath = event.composedPath();
                    if (composedPath) {
                        return head(composedPath);
                    }
                }
            }
        }
        return Optional.from(event.target);
    };
    /** Return true if the element is a host of an open shadow root.
     *  Return false if the element is a host of a closed shadow root, or if the element is not a host.
     */
    const isOpenShadowHost = (element) => isNonNullable(element.dom.shadowRoot);

    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({
        target,
        x,
        y,
        stop,
        prevent,
        kill,
        raw
    });
    /** Wraps an Event in an EventArgs structure.
     * The returned EventArgs structure has its target set to the "original" target if possible.
     * See SugarShadowDom.getOriginalEventTarget
     */
    const fromRawEvent = (rawEvent) => {
        const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
        const stop = () => rawEvent.stopPropagation();
        const prevent = () => rawEvent.preventDefault();
        const kill = compose(prevent, stop); // more of a sequence than a compose, but same effect
        // FIX: Don't just expose the raw event. Need to identify what needs standardisation.
        return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    const handle$1 = (filter, handler) => (rawEvent) => {
        if (filter(rawEvent)) {
            handler(fromRawEvent(rawEvent));
        }
    };
    const binder = (element, event, filter, handler, useCapture) => {
        const wrapped = handle$1(filter, handler);
        // IE9 minimum
        element.dom.addEventListener(event, wrapped, useCapture);
        return {
            unbind: curry(unbind, element, event, wrapped, useCapture)
        };
    };
    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);
    const unbind = (element, event, handler, useCapture) => {
        // IE9 minimum
        element.dom.removeEventListener(event, handler, useCapture);
    };

    const filter$2 = always; // no filter on plain DomEvents
    const bind$1 = (element, event, handler) => bind$2(element, event, filter$2, handler);

    const getDocument = () => SugarElement.fromDom(document);

    const focus$1 = (element, preventScroll = false) => element.dom.focus({ preventScroll });
    const hasFocus$1 = (element) => {
        const root = getRootNode(element).dom;
        return element.dom === root.activeElement;
    };
    // Note: assuming that activeElement will always be a HTMLElement (maybe we should add a runtime check?)
    const active = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
    /**
     * Return the descendant element that has focus.
     * Use instead of SelectorFind.descendant(container, ':focus')
     *  because the :focus selector relies on keyboard focus.
     */
    const search = (element) => active(getRootNode(element))
        .filter((e) => element.dom.contains(e.dom));

    const before$4 = (marker, element) => {
        const parent$1 = parent(marker);
        parent$1.each((v) => {
            v.dom.insertBefore(element.dom, marker.dom);
        });
    };
    const after$4 = (marker, element) => {
        const sibling = nextSibling(marker);
        sibling.fold(() => {
            const parent$1 = parent(marker);
            parent$1.each((v) => {
                append$1(v, element);
            });
        }, (v) => {
            before$4(v, element);
        });
    };
    const prepend = (parent, element) => {
        const firstChild$1 = firstChild(parent);
        firstChild$1.fold(() => {
            append$1(parent, element);
        }, (v) => {
            parent.dom.insertBefore(element.dom, v.dom);
        });
    };
    const append$1 = (parent, element) => {
        parent.dom.appendChild(element.dom);
    };
    const wrap$2 = (element, wrapper) => {
        before$4(element, wrapper);
        append$1(wrapper, element);
    };

    const before$3 = (marker, elements) => {
        each$e(elements, (x) => {
            before$4(marker, x);
        });
    };
    const after$3 = (marker, elements) => {
        each$e(elements, (x, i) => {
            const e = i === 0 ? marker : elements[i - 1];
            after$4(e, x);
        });
    };
    const append = (parent, elements) => {
        each$e(elements, (x) => {
            append$1(parent, x);
        });
    };

    const rawSet = (dom, key, value) => {
        /*
         * JQuery coerced everything to a string, and silently did nothing on text node/null/undefined.
         *
         * We fail on those invalid cases, only allowing numbers and booleans.
         */
        if (isString(value) || isBoolean(value) || isNumber(value)) {
            dom.setAttribute(key, value + '');
        }
        else {
            // eslint-disable-next-line no-console
            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
            throw new Error('Attribute value was not simple');
        }
    };
    const set$4 = (element, key, value) => {
        rawSet(element.dom, key, value);
    };
    const setAll$1 = (element, attrs) => {
        const dom = element.dom;
        each$d(attrs, (v, k) => {
            rawSet(dom, k, v);
        });
    };
    const get$9 = (element, key) => {
        const v = element.dom.getAttribute(key);
        // undefined is the more appropriate value for JS, and this matches JQuery
        return v === null ? undefined : v;
    };
    const getOpt = (element, key) => Optional.from(get$9(element, key));
    const has$1 = (element, key) => {
        const dom = element.dom;
        // return false for non-element nodes, no point in throwing an error
        return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
    };
    const remove$9 = (element, key) => {
        element.dom.removeAttribute(key);
    };
    const hasNone = (element) => {
        const attrs = element.dom.attributes;
        return attrs === undefined || attrs === null || attrs.length === 0;
    };
    const clone$4 = (element) => foldl(element.dom.attributes, (acc, attr) => {
        acc[attr.name] = attr.value;
        return acc;
    }, {});

    const empty = (element) => {
        // shortcut "empty node" trick. Requires IE 9.
        element.dom.textContent = '';
        // If the contents was a single empty text node, the above doesn't remove it. But, it's still faster in general
        // than removing every child node manually.
        // The following is (probably) safe for performance as 99.9% of the time the trick works and
        // Traverse.children will return an empty array.
        each$e(children$1(element), (rogue) => {
            remove$8(rogue);
        });
    };
    const remove$8 = (element) => {
        const dom = element.dom;
        if (dom.parentNode !== null) {
            dom.parentNode.removeChild(dom);
        }
    };
    const unwrap = (wrapper) => {
        const children = children$1(wrapper);
        if (children.length > 0) {
            after$3(wrapper, children);
        }
        remove$8(wrapper);
    };

    const clone$3 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
    /** Shallow clone - just the tag, no children */
    const shallow = (original) => clone$3(original, false);
    /** Deep clone - everything copied including children */
    const deep = (original) => clone$3(original, true);
    /** Shallow clone, with a new tag */
    const shallowAs = (original, tag) => {
        const nu = SugarElement.fromTag(tag);
        const attributes = clone$4(original);
        setAll$1(nu, attributes);
        return nu;
    };
    /** Change the tag name, but keep all children */
    const mutate = (original, tag) => {
        const nu = shallowAs(original, tag);
        after$4(original, nu);
        const children = children$1(original);
        append(nu, children);
        remove$8(original);
        return nu;
    };

    const fromHtml = (html, scope) => {
        const doc = scope || document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        return children$1(SugarElement.fromDom(div));
    };
    const fromDom$1 = (nodes) => map$3(nodes, SugarElement.fromDom);

    const get$8 = (element) => element.dom.innerHTML;
    const set$3 = (element, content) => {
        const owner = owner$1(element);
        const docDom = owner.dom;
        // FireFox has *terrible* performance when using innerHTML = x
        const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
        const contentElements = fromHtml(content, docDom);
        append(fragment, contentElements);
        empty(element);
        append$1(element, fragment);
    };
    const getOuter = (element) => {
        const container = SugarElement.fromTag('div');
        const clone = SugarElement.fromDom(element.dom.cloneNode(true));
        append$1(container, clone);
        return get$8(container);
    };

    // some elements, such as mathml, don't have style attributes
    // others, such as angular elements, have style attributes that aren't a CSSStyleDeclaration
    const isSupported = (dom) => dom.style !== undefined && isFunction(dom.style.getPropertyValue);

    // Node.contains() is very, very, very good performance
    // http://jsperf.com/closest-vs-contains/5
    const inBody = (element) => {
        // Technically this is only required on IE, where contains() returns false for text nodes.
        // But it's cheap enough to run everywhere and Sugar doesn't have platform detection (yet).
        const dom = isText$c(element) ? element.dom.parentNode : element.dom;
        // use ownerDocument.body to ensure this works inside iframes.
        // Normally contains is bad because an element "contains" itself, but here we want that.
        if (dom === undefined || dom === null || dom.ownerDocument === null) {
            return false;
        }
        const doc = dom.ownerDocument;
        return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));
    };

    const internalSet = (dom, property, value) => {
        // This is going to hurt. Apologies.
        // JQuery coerces numbers to pixels for certain property names, and other times lets numbers through.
        // we're going to be explicit; strings only.
        if (!isString(value)) {
            // eslint-disable-next-line no-console
            console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
            throw new Error('CSS value must be a string: ' + value);
        }
        // removed: support for dom().style[property] where prop is camel case instead of normal property name
        if (isSupported(dom)) {
            dom.style.setProperty(property, value);
        }
    };
    const internalRemove = (dom, property) => {
        /*
         * IE9 and above - MDN doesn't have details, but here's a couple of random internet claims
         *
         * http://help.dottoro.com/ljopsjck.php
         * http://stackoverflow.com/a/7901886/7546
         */
        if (isSupported(dom)) {
            dom.style.removeProperty(property);
        }
    };
    const set$2 = (element, property, value) => {
        const dom = element.dom;
        internalSet(dom, property, value);
    };
    const setAll = (element, css) => {
        const dom = element.dom;
        each$d(css, (v, k) => {
            internalSet(dom, k, v);
        });
    };
    /*
     * NOTE: For certain properties, this returns the "used value" which is subtly different to the "computed value" (despite calling getComputedStyle).
     * Blame CSS 2.0.
     *
     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     */
    const get$7 = (element, property) => {
        const dom = element.dom;
        /*
         * IE9 and above per
         * https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle
         *
         * Not in numerosity, because it doesn't memoize and looking this up dynamically in performance critical code would be horrendous.
         *
         * JQuery has some magic here for IE popups, but we don't really need that.
         * It also uses element.ownerDocument.defaultView to handle iframes but that hasn't been required since FF 3.6.
         */
        const styles = window.getComputedStyle(dom);
        const r = styles.getPropertyValue(property);
        // jquery-ism: If r is an empty string, check that the element is not in a document. If it isn't, return the raw value.
        // Turns out we do this a lot.
        return (r === '' && !inBody(element)) ? getUnsafeProperty(dom, property) : r;
    };
    // removed: support for dom().style[property] where prop is camel case instead of normal property name
    // empty string is what the browsers (IE11 and Chrome) return when the propertyValue doesn't exists.
    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';
    /*
     * Gets the raw value from the style attribute. Useful for retrieving "used values" from the DOM:
     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     *
     * Returns NONE if the property isn't set, or the value is an empty string.
     */
    const getRaw$1 = (element, property) => {
        const dom = element.dom;
        const raw = getUnsafeProperty(dom, property);
        return Optional.from(raw).filter((r) => r.length > 0);
    };
    const getAllRaw = (element) => {
        const css = {};
        const dom = element.dom;
        if (isSupported(dom)) {
            for (let i = 0; i < dom.style.length; i++) {
                const ruleName = dom.style.item(i);
                css[ruleName] = dom.style[ruleName];
            }
        }
        return css;
    };
    const remove$7 = (element, property) => {
        const dom = element.dom;
        internalRemove(dom, property);
        if (is$4(getOpt(element, 'style').map(trim$4), '')) {
            // No more styles left, remove the style attribute as well
            remove$9(element, 'style');
        }
    };
    /* NOTE: This function is here for the side effect it triggers.
    The value itself is not used.
    Be sure to not use the return value, and that it is not removed by a minifier.
     */
    const reflow = (e) => e.dom.offsetWidth;

    const Dimension = (name, getOffset) => {
        const set = (element, h) => {
            if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
                throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
            }
            const dom = element.dom;
            if (isSupported(dom)) {
                dom.style[name] = h + 'px';
            }
        };
        /*
         * jQuery supports querying width and height on the document and window objects.
         *
         * TBIO doesn't do this, so the code is removed to save space, but left here just in case.
         */
        /*
        var getDocumentWidth = (element) => {
          var dom = element.dom;
          if (Node.isDocument(element)) {
            var body = dom.body;
            var doc = dom.documentElement;
            return Math.max(
              body.scrollHeight,
              doc.scrollHeight,
              body.offsetHeight,
              doc.offsetHeight,
              doc.clientHeight
            );
          }
        };
      
        var getWindowWidth = (element) => {
          var dom = element.dom;
          if (dom.window === dom) {
            // There is no offsetHeight on a window, so use the clientHeight of the document
            return dom.document.documentElement.clientHeight;
          }
        };
      */
        const get = (element) => {
            const r = getOffset(element);
            // zero or null means non-standard or disconnected, fall back to CSS
            if (r <= 0 || r === null) {
                const css = get$7(element, name);
                // ugh this feels dirty, but it saves cycles
                return parseFloat(css) || 0;
            }
            return r;
        };
        // in jQuery, getOuter replicates (or uses) box-sizing: border-box calculations
        // although these calculations only seem relevant for quirks mode, and edge cases TBIO doesn't rely on
        const getOuter = get;
        const aggregate = (element, properties) => foldl(properties, (acc, property) => {
            const val = get$7(element, property);
            const value = val === undefined ? 0 : parseInt(val, 10);
            return isNaN(value) ? acc : acc + value;
        }, 0);
        const max = (element, value, properties) => {
            const cumulativeInclusions = aggregate(element, properties);
            // if max-height is 100px and your cumulativeInclusions is 150px, there is no way max-height can be 100px, so we return 0.
            const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
            return absoluteMax;
        };
        return {
            set,
            get,
            getOuter,
            aggregate,
            max
        };
    };

    const api$1 = Dimension('height', (element) => {
        // getBoundingClientRect gives better results than offsetHeight for tables with captions on Firefox
        const dom = element.dom;
        return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    const get$6 = (element) => api$1.get(element);

    const r = (left, top) => {
        const translate = (x, y) => r(left + x, top + y);
        return {
            left,
            top,
            translate
        };
    };
    // tslint:disable-next-line:variable-name
    const SugarPosition = r;

    const boxPosition = (dom) => {
        const box = dom.getBoundingClientRect();
        return SugarPosition(box.left, box.top);
    };
    // Avoids falsy false fallthrough
    const firstDefinedOrZero = (a, b) => {
        if (a !== undefined) {
            return a;
        }
        else {
            return b !== undefined ? b : 0;
        }
    };
    const absolute = (element) => {
        const doc = element.dom.ownerDocument;
        const body = doc.body;
        const win = doc.defaultView;
        const html = doc.documentElement;
        if (body === element.dom) {
            return SugarPosition(body.offsetLeft, body.offsetTop);
        }
        const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
        const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
        const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
        const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
        return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    const viewport = (element) => {
        const dom = element.dom;
        const doc = dom.ownerDocument;
        const body = doc.body;
        if (body === dom) {
            return SugarPosition(body.offsetLeft, body.offsetTop);
        }
        if (!inBody(element)) {
            return SugarPosition(0, 0);
        }
        return boxPosition(dom);
    };

    // get scroll position (x,y) relative to document _doc (or global if not supplied)
    const get$5 = (_DOC) => {
        const doc = _DOC !== undefined ? _DOC.dom : document;
        // ASSUMPTION: This is for cross-browser support, body works for Safari & EDGE, and when we have an iframe body scroller
        const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
        const y = doc.body.scrollTop || doc.documentElement.scrollTop;
        return SugarPosition(x, y);
    };
    // Scroll content to (x,y) relative to document _doc (or global if not supplied)
    const to = (x, y, _DOC) => {
        const doc = _DOC !== undefined ? _DOC.dom : document;
        const win = doc.defaultView;
        if (win) {
            win.scrollTo(x, y);
        }
    };
    // TBIO-4472 Safari 10 - Scrolling typeahead with keyboard scrolls page
    const intoView = (element, alignToTop) => {
        const isSafari = detect$1().browser.isSafari();
        // this method isn't in TypeScript
        if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {
            element.dom.scrollIntoViewIfNeeded(false); // false=align to nearest edge
        }
        else {
            element.dom.scrollIntoView(alignToTop); // true=to top, false=to bottom
        }
    };

    const NodeValue = (is, name) => {
        const get = (element) => {
            if (!is(element)) {
                throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
            }
            return getOption(element).getOr('');
        };
        const getOption = (element) => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
        const set = (element, value) => {
            if (!is(element)) {
                throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
            }
            element.dom.nodeValue = value;
        };
        return {
            get,
            getOption,
            set
        };
    };

    const fromElements = (elements, scope) => {
        const doc = scope || document;
        const fragment = doc.createDocumentFragment();
        each$e(elements, (element) => {
            fragment.appendChild(element.dom);
        });
        return SugarElement.fromDom(fragment);
    };

    const api = NodeValue(isText$c, 'text');
    const get$4 = (element) => api.get(element);
    const getOption = (element) => api.getOption(element);
    const set$1 = (element, value) => api.set(element, value);

    // Methods for handling attributes that contain a list of values <div foo="alpha beta theta">
    const read$4 = (element, attr) => {
        const value = get$9(element, attr);
        return value === undefined || value === '' ? [] : value.split(' ');
    };
    const add$4 = (element, attr, id) => {
        const old = read$4(element, attr);
        const nu = old.concat([id]);
        set$4(element, attr, nu.join(' '));
        return true;
    };
    const remove$6 = (element, attr, id) => {
        const nu = filter$5(read$4(element, attr), (v) => v !== id);
        if (nu.length > 0) {
            set$4(element, attr, nu.join(' '));
        }
        else {
            remove$9(element, attr);
        }
        return false;
    };

    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {
        if (is(scope, a)) {
            return Optional.some(scope);
        }
        else if (isFunction(isRoot) && isRoot(scope)) {
            return Optional.none();
        }
        else {
            return ancestor(scope, a, isRoot);
        }
    };

    const ancestor$5 = (scope, predicate, isRoot) => {
        let element = scope.dom;
        const stop = isFunction(isRoot) ? isRoot : never;
        while (element.parentNode) {
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            if (predicate(el)) {
                return Optional.some(el);
            }
            else if (stop(el)) {
                break;
            }
        }
        return Optional.none();
    };
    const closest$4 = (scope, predicate, isRoot) => {
        // This is required to avoid ClosestOrAncestor passing the predicate to itself
        const is = (s, test) => test(s);
        return ClosestOrAncestor(is, ancestor$5, scope, predicate, isRoot);
    };
    const sibling$1 = (scope, predicate) => {
        const element = scope.dom;
        if (!element.parentNode) {
            return Optional.none();
        }
        return child(SugarElement.fromDom(element.parentNode), (x) => !eq(scope, x) && predicate(x));
    };
    const child = (scope, predicate) => {
        const pred = (node) => predicate(SugarElement.fromDom(node));
        const result = find$2(scope.dom.childNodes, pred);
        return result.map(SugarElement.fromDom);
    };
    const descendant$2 = (scope, predicate) => {
        const descend = (node) => {
            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < node.childNodes.length; i++) {
                const child = SugarElement.fromDom(node.childNodes[i]);
                if (predicate(child)) {
                    return Optional.some(child);
                }
                const res = descend(node.childNodes[i]);
                if (res.isSome()) {
                    return res;
                }
            }
            return Optional.none();
        };
        return descend(scope.dom);
    };

    const ancestor$4 = (scope, selector, isRoot) => ancestor$5(scope, (e) => is$2(e, selector), isRoot);
    const descendant$1 = (scope, selector) => one(selector, scope);
    // Returns Some(closest ancestor element (sugared)) matching 'selector' up to isRoot, or None() otherwise
    const closest$3 = (scope, selector, isRoot) => {
        const is = (element, selector) => is$2(element, selector);
        return ClosestOrAncestor(is, ancestor$4, scope, selector, isRoot);
    };

    // IE11 Can return undefined for a classList on elements such as math, so we make sure it's not undefined before attempting to use it.
    const supports = (element) => element.dom.classList !== undefined;
    const get$3 = (element) => read$4(element, 'class');
    const add$3 = (element, clazz) => add$4(element, 'class', clazz);
    const remove$5 = (element, clazz) => remove$6(element, 'class', clazz);
    const toggle$2 = (element, clazz) => {
        if (contains$2(get$3(element), clazz)) {
            return remove$5(element, clazz);
        }
        else {
            return add$3(element, clazz);
        }
    };

    /*
     * ClassList is IE10 minimum:
     * https://developer.mozilla.org/en-US/docs/Web/API/Element.classList
     *
     * Note that IE doesn't support the second argument to toggle (at all).
     * If it did, the toggler could be better.
     */
    const add$2 = (element, clazz) => {
        if (supports(element)) {
            element.dom.classList.add(clazz);
        }
        else {
            add$3(element, clazz);
        }
    };
    const cleanClass = (element) => {
        const classList = supports(element) ? element.dom.classList : get$3(element);
        // classList is a "live list", so this is up to date already
        if (classList.length === 0) {
            // No more classes left, remove the class attribute as well
            remove$9(element, 'class');
        }
    };
    const remove$4 = (element, clazz) => {
        if (supports(element)) {
            const classList = element.dom.classList;
            classList.remove(clazz);
        }
        else {
            remove$5(element, clazz);
        }
        cleanClass(element);
    };
    const toggle$1 = (element, clazz) => {
        const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);
        cleanClass(element);
        return result;
    };
    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);

    /*
     * ClassList is IE10 minimum:
     * https://developer.mozilla.org/en-US/docs/Web/API/Element.classList
     */
    const add$1 = (element, classes) => {
        each$e(classes, (x) => {
            add$2(element, x);
        });
    };
    const remove$3 = (element, classes) => {
        each$e(classes, (x) => {
            remove$4(element, x);
        });
    };

    const closest$2 = (target) => closest$3(target, '[contenteditable]');
    const isEditable$2 = (element, assumeEditable = false) => {
        if (inBody(element)) {
            return element.dom.isContentEditable;
        }
        else {
            // Find the closest contenteditable element and check if it's editable
            return closest$2(element).fold(constant(assumeEditable), (editable) => getRaw(editable) === 'true');
        }
    };
    const getRaw = (element) => element.dom.contentEditable;
    const set = (element, editable) => {
        element.dom.contentEditable = editable ? 'true' : 'false';
    };

    const ancestors$1 = (scope, predicate, isRoot) => filter$5(parents$1(scope, isRoot), predicate);
    const children = (scope, predicate) => filter$5(children$1(scope), predicate);
    const descendants$1 = (scope, predicate) => {
        let result = [];
        // Recurse.toArray() might help here
        each$e(children$1(scope), (x) => {
            if (predicate(x)) {
                result = result.concat([x]);
            }
            result = result.concat(descendants$1(x, predicate));
        });
        return result;
    };

    // For all of the following:
    //
    // jQuery does siblings of firstChild. IE9+ supports scope.dom.children (similar to Traverse.children but elements only).
    // Traverse should also do this (but probably not by default).
    //
    const ancestors = (scope, selector, isRoot) => 
    // It may surprise you to learn this is exactly what JQuery does
    // TODO: Avoid all this wrapping and unwrapping
    ancestors$1(scope, (e) => is$2(e, selector), isRoot);
    const descendants = (scope, selector) => all(selector, scope);

    const ancestor$3 = (scope, predicate, isRoot) => ancestor$5(scope, predicate, isRoot).isSome();
    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();
    const descendant = (scope, predicate) => descendant$2(scope, predicate).isSome();

    const ancestor$2 = (element, target) => ancestor$3(element, curry(eq, target));

    const ancestor$1 = (scope, selector, isRoot) => ancestor$4(scope, selector, isRoot).isSome();

    const ensureIsRoot = (isRoot) => isFunction(isRoot) ? isRoot : never;
    const ancestor = (scope, transform, isRoot) => {
        let element = scope.dom;
        const stop = ensureIsRoot(isRoot);
        while (element.parentNode) {
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            const transformed = transform(el);
            if (transformed.isSome()) {
                return transformed;
            }
            else if (stop(el)) {
                break;
            }
        }
        return Optional.none();
    };
    const closest$1 = (scope, transform, isRoot) => {
        const current = transform(scope);
        const stop = ensureIsRoot(isRoot);
        return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));
    };

    const isTextNodeWithCursorPosition = (el) => getOption(el).filter((text) => 
    // For the purposes of finding cursor positions only allow text nodes with content,
    // but trim removes &nbsp; and that's allowed
    text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();
    const isContentEditableFalse$b = (elem) => isHTMLElement$1(elem) && (get$9(elem, 'contenteditable') === 'false');
    const elementsWithCursorPosition = ['img', 'br'];
    const isCursorPosition = (elem) => {
        const hasCursorPosition = isTextNodeWithCursorPosition(elem);
        return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$b(elem);
    };

    const first = (element) => descendant$2(element, isCursorPosition);

    const create$c = (start, soffset, finish, foffset) => ({
        start,
        soffset,
        finish,
        foffset
    });
    // tslint:disable-next-line:variable-name
    const SimRange = {
        create: create$c
    };

    const adt$2 = Adt.generate([
        { before: ['element'] },
        { on: ['element', 'offset'] },
        { after: ['element'] }
    ]);
    // Probably don't need this given that we now have "match"
    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
    const getStart$2 = (situ) => situ.fold(identity, identity, identity);
    const before$2 = adt$2.before;
    const on = adt$2.on;
    const after$2 = adt$2.after;
    // tslint:disable-next-line:variable-name
    const Situ = {
        before: before$2,
        on,
        after: after$2,
        cata,
        getStart: getStart$2
    };

    // Consider adding a type for "element"
    const adt$1 = Adt.generate([
        { domRange: ['rng'] },
        { relative: ['startSitu', 'finishSitu'] },
        { exact: ['start', 'soffset', 'finish', 'foffset'] }
    ]);
    const exactFromRange = (simRange) => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
    const getStart$1 = (selection) => selection.match({
        domRange: (rng) => SugarElement.fromDom(rng.startContainer),
        relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
        exact: (start, _soffset, _finish, _foffset) => start
    });
    const domRange = adt$1.domRange;
    const relative = adt$1.relative;
    const exact = adt$1.exact;
    const getWin = (selection) => {
        const start = getStart$1(selection);
        return defaultView(start);
    };
    // This is out of place but it's API so I can't remove it
    const range = SimRange.create;
    // tslint:disable-next-line:variable-name
    const SimSelection = {
        domRange,
        relative,
        exact,
        exactFromRange,
        getWin,
        range
    };

    const caretPositionFromPoint = (doc, x, y) => {
        var _a;
        return Optional.from((_a = doc.caretPositionFromPoint) === null || _a === void 0 ? void 0 : _a.call(doc, x, y))
            .bind((pos) => {
            // It turns out that Firefox can return null for pos.offsetNode
            if (pos.offsetNode === null) {
                return Optional.none();
            }
            const r = doc.createRange();
            r.setStart(pos.offsetNode, pos.offset);
            r.collapse();
            return Optional.some(r);
        });
    };
    const caretRangeFromPoint = (doc, x, y) => { var _a; return Optional.from((_a = doc.caretRangeFromPoint) === null || _a === void 0 ? void 0 : _a.call(doc, x, y)); };
    const availableSearch = (doc, x, y) => {
        if (doc.caretPositionFromPoint) {
            return caretPositionFromPoint(doc, x, y); // defined standard, firefox only
        }
        else if (doc.caretRangeFromPoint) {
            return caretRangeFromPoint(doc, x, y); // webkit/blink implementation
        }
        else {
            return Optional.none(); // unsupported browser
        }
    };
    const fromPoint$1 = (win, x, y) => {
        const doc = win.document;
        return availableSearch(doc, x, y).map((rng) => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
    };

    const beforeSpecial = (element, offset) => {
        // From memory, we don't want to use <br> directly on Firefox because it locks the keyboard input.
        // It turns out that <img> directly on IE locks the keyboard as well.
        // If the offset is 0, use before. If the offset is 1, use after.
        // TBIO-3889: Firefox Situ.on <input> results in a child of the <input>; Situ.before <input> results in platform inconsistencies
        const name$1 = name(element);
        if ('input' === name$1) {
            return Situ.after(element);
        }
        else if (!contains$2(['br', 'img'], name$1)) {
            return Situ.on(element, offset);
        }
        else {
            return offset === 0 ? Situ.before(element) : Situ.after(element);
        }
    };
    const preprocessRelative = (startSitu, finishSitu) => {
        const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
        const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
        return SimSelection.relative(start, finish);
    };
    const preprocessExact = (start, soffset, finish, foffset) => {
        const startSitu = beforeSpecial(start, soffset);
        const finishSitu = beforeSpecial(finish, foffset);
        return SimSelection.relative(startSitu, finishSitu);
    };
    const preprocess = (selection) => selection.match({
        domRange: (rng) => {
            const start = SugarElement.fromDom(rng.startContainer);
            const finish = SugarElement.fromDom(rng.endContainer);
            return preprocessExact(start, rng.startOffset, finish, rng.endOffset);
        },
        relative: preprocessRelative,
        exact: preprocessExact
    });

    const toNative = (selection) => {
        const win = SimSelection.getWin(selection).dom;
        const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);
        const filtered = preprocess(selection);
        return diagnose(win, filtered).match({
            ltr: getDomRange,
            rtl: getDomRange
        });
    };
    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);

    const get$2 = (_win) => {
        const win = _win === undefined ? window : _win;
        if (detect$1().browser.isFirefox()) {
            // TINY-7984: Firefox 91 is returning incorrect values for visualViewport.pageTop, so disable it for now
            return Optional.none();
        }
        else {
            return Optional.from(win.visualViewport);
        }
    };
    const bounds = (x, y, width, height) => ({
        x,
        y,
        width,
        height,
        right: x + width,
        bottom: y + height
    });
    const getBounds = (_win) => {
        const win = _win === undefined ? window : _win;
        const doc = win.document;
        const scroll = get$5(SugarElement.fromDom(doc));
        return get$2(win).fold(() => {
            const html = win.document.documentElement;
            // Don't use window.innerWidth/innerHeight here, as we don't want to include scrollbars
            // since the right/bottom position is based on the edge of the scrollbar not the window
            const width = html.clientWidth;
            const height = html.clientHeight;
            return bounds(scroll.left, scroll.top, width, height);
        }, (visualViewport) => 
        // iOS doesn't update the pageTop/pageLeft when element.scrollIntoView() is called, so we need to fallback to the
        // scroll position which will always be less than the page top/left values when page top/left are accurate/correct.
        bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));
    };

    /**
     * TreeWalker class enables you to walk the DOM in a linear manner.
     *
     * @class tinymce.dom.TreeWalker
     * @example
     * const walker = new tinymce.dom.TreeWalker(startNode);
     *
     * do {
     *   console.log(walker.current());
     * } while (walker.next());
     */
    class DomTreeWalker {
        constructor(startNode, rootNode) {
            this.node = startNode;
            this.rootNode = rootNode;
            // This is a bit hacky but needed to ensure the 'this' variable
            // always references the instance and not the caller scope
            this.current = this.current.bind(this);
            this.next = this.next.bind(this);
            this.prev = this.prev.bind(this);
            this.prev2 = this.prev2.bind(this);
        }
        /**
         * Returns the current node.
         *
         * @method current
         * @return {Node/undefined} Current node where the walker is, or undefined if the walker has reached the end.
         */
        current() {
            return this.node;
        }
        /**
         * Walks to the next node in tree.
         *
         * @method next
         * @return {Node/undefined} Current node where the walker is after moving to the next node, or undefined if the walker has reached the end.
         */
        next(shallow) {
            this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);
            return this.node;
        }
        /**
         * Walks to the previous node in tree.
         *
         * @method prev
         * @return {Node/undefined} Current node where the walker is after moving to the previous node, or undefined if the walker has reached the end.
         */
        prev(shallow) {
            this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);
            return this.node;
        }
        prev2(shallow) {
            this.node = this.findPreviousNode(this.node, shallow);
            return this.node;
        }
        findSibling(node, startName, siblingName, shallow) {
            if (node) {
                // Walk into nodes if it has a start
                if (!shallow && node[startName]) {
                    return node[startName];
                }
                // Return the sibling if it has one
                if (node !== this.rootNode) {
                    let sibling = node[siblingName];
                    if (sibling) {
                        return sibling;
                    }
                    // Walk up the parents to look for siblings
                    for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {
                        sibling = parent[siblingName];
                        if (sibling) {
                            return sibling;
                        }
                    }
                }
            }
            return undefined;
        }
        findPreviousNode(node, shallow) {
            if (node) {
                const sibling = node.previousSibling;
                if (this.rootNode && sibling === this.rootNode) {
                    return;
                }
                if (sibling) {
                    if (!shallow) {
                        // Walk down to the most distant child
                        for (let child = sibling.lastChild; child; child = child.lastChild) {
                            if (!child.lastChild) {
                                return child;
                            }
                        }
                    }
                    return sibling;
                }
                const parent = node.parentNode;
                if (parent && parent !== this.rootNode) {
                    return parent;
                }
            }
            return undefined;
        }
    }

    const whiteSpaceRegExp = /^[ \t\r\n]*$/;
    const isWhitespaceText = (text) => whiteSpaceRegExp.test(text);
    const isZwsp$1 = (text) => {
        for (const c of text) {
            if (!isZwsp$2(c)) {
                return false;
            }
        }
        return true;
    };
    // Don't compare other unicode spaces here, as we're only concerned about whitespace the browser would collapse
    const isCollapsibleWhitespace$1 = (c) => ' \f\t\v'.indexOf(c) !== -1;
    const isNewLineChar = (c) => c === '\n' || c === '\r';
    const isNewline = (text, idx) => (idx < text.length && idx >= 0) ? isNewLineChar(text[idx]) : false;
    // Converts duplicate whitespace to alternating space/nbsps and tabs to spaces
    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {
        // Replace tabs with a variable amount of spaces
        // Note: We don't use an actual tab character here, as it only works when in a "whitespace: pre" element,
        // which will cause other issues, such as trying to type the content will also be treated as being in a pre.
        const tabSpace = repeat(' ', tabSpaces);
        const normalizedText = text.replace(/\t/g, tabSpace);
        const result = foldl(normalizedText, (acc, c) => {
            // Are we dealing with a char other than some collapsible whitespace or nbsp? if so then just use it as is
            if (isCollapsibleWhitespace$1(c) || c === nbsp) {
                // If the previous char is a space, we are at the start or end, or if the next char is a new line char, then we need
                // to convert the space to a nbsp
                if (acc.pcIsSpace || (acc.str === '' && isStartOfContent) || (acc.str.length === normalizedText.length - 1 && isEndOfContent) || isNewline(normalizedText, acc.str.length + 1)) {
                    return { pcIsSpace: false, str: acc.str + nbsp };
                }
                else {
                    return { pcIsSpace: true, str: acc.str + ' ' };
                }
            }
            else {
                // Treat newlines as being a space, since we'll need to convert any leading spaces to nsbps
                return { pcIsSpace: isNewLineChar(c), str: acc.str + c };
            }
        }, { pcIsSpace: false, str: '' });
        return result.str;
    };

    const isNodeType = (type) => {
        return (node) => {
            return !!node && node.nodeType === type;
        };
    };
    // Firefox can allow you to get a selection on a restricted node, such as file/number inputs. These nodes
    // won't implement the Object prototype, so Object.getPrototypeOf() will return null or something similar.
    const isRestrictedNode = (node) => !!node && !Object.getPrototypeOf(node);
    const isElement$7 = isNodeType(1);
    const isHTMLElement = (node) => isElement$7(node) && isHTMLElement$1(SugarElement.fromDom(node));
    const isSVGElement = (node) => isElement$7(node) && node.namespaceURI === 'http://www.w3.org/2000/svg';
    const matchNodeName$1 = (name) => {
        const lowerCasedName = name.toLowerCase();
        return (node) => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;
    };
    const matchNodeNames$1 = (names) => {
        const lowerCasedNames = names.map((s) => s.toLowerCase());
        return (node) => {
            if (node && node.nodeName) {
                const nodeName = node.nodeName.toLowerCase();
                return contains$2(lowerCasedNames, nodeName);
            }
            return false;
        };
    };
    const matchStyleValues = (name, values) => {
        const items = values.toLowerCase().split(' ');
        return (node) => {
            if (isElement$7(node)) {
                const win = node.ownerDocument.defaultView;
                if (win) {
                    for (let i = 0; i < items.length; i++) {
                        const computed = win.getComputedStyle(node, null);
                        const cssValue = computed ? computed.getPropertyValue(name) : null;
                        if (cssValue === items[i]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
    };
    const hasAttribute = (attrName) => {
        return (node) => {
            return isElement$7(node) && node.hasAttribute(attrName);
        };
    };
    const isBogus$1 = (node) => isElement$7(node) && node.hasAttribute('data-mce-bogus');
    const isBogusAll = (node) => isElement$7(node) && node.getAttribute('data-mce-bogus') === 'all';
    const isTable$2 = (node) => isElement$7(node) && node.tagName === 'TABLE';
    const hasContentEditableState = (value) => {
        return (node) => {
            if (isHTMLElement(node)) {
                if (node.contentEditable === value) {
                    return true;
                }
                if (node.getAttribute('data-mce-contenteditable') === value) {
                    return true;
                }
            }
            return false;
        };
    };
    const isTextareaOrInput = matchNodeNames$1(['textarea', 'input']);
    const isText$b = isNodeType(3);
    const isCData = isNodeType(4);
    const isPi = isNodeType(7);
    const isComment = isNodeType(8);
    const isDocument$1 = isNodeType(9);
    const isDocumentFragment = isNodeType(11);
    const isBr$7 = matchNodeName$1('br');
    const isImg = matchNodeName$1('img');
    const isAnchor = matchNodeName$1('a');
    const isContentEditableTrue$3 = hasContentEditableState('true');
    const isContentEditableFalse$a = hasContentEditableState('false');
    const isEditingHost = (node) => isHTMLElement(node) && node.isContentEditable && isNonNullable(node.parentElement) && !node.parentElement.isContentEditable;
    const isTableCell$3 = matchNodeNames$1(['td', 'th']);
    const isTableCellOrCaption = matchNodeNames$1(['td', 'th', 'caption']);
    const isTemplate = matchNodeName$1('template');
    const isMedia$2 = matchNodeNames$1(['video', 'audio', 'object', 'embed']);
    const isListItem$3 = matchNodeName$1('li');
    const isDetails = matchNodeName$1('details');
    const isSummary$1 = matchNodeName$1('summary');

    const defaultOptionValues = {
        skipBogus: true,
        includeZwsp: false,
        checkRootAsContent: false,
    };
    const hasWhitespacePreserveParent = (node, rootNode, schema) => {
        const rootElement = SugarElement.fromDom(rootNode);
        const startNode = SugarElement.fromDom(node);
        const whitespaceElements = schema.getWhitespaceElements();
        const predicate = (node) => has$2(whitespaceElements, name(node));
        return ancestor$3(startNode, predicate, curry(eq, rootElement));
    };
    const isNamedAnchor = (node) => {
        return isElement$7(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));
    };
    const isNonEmptyElement$1 = (node, schema) => {
        return isElement$7(node) && has$2(schema.getNonEmptyElements(), node.nodeName);
    };
    const isBookmark = hasAttribute('data-mce-bookmark');
    const hasNonEditableParent = (node) => parentElement(SugarElement.fromDom(node)).exists((parent) => !isEditable$2(parent));
    const isWhitespace$1 = (node, rootNode, schema) => isWhitespaceText(node.data)
        && !hasWhitespacePreserveParent(node, rootNode, schema);
    const isText$a = (node, rootNode, schema, options) => isText$b(node)
        && !isWhitespace$1(node, rootNode, schema)
        && (!options.includeZwsp || !isZwsp$1(node.data));
    const isContentNode = (schema, node, rootNode, options) => {
        return isFunction(options.isContent) && options.isContent(node)
            || isNonEmptyElement$1(node, schema)
            || isBookmark(node)
            || isNamedAnchor(node)
            || isText$a(node, rootNode, schema, options)
            || isContentEditableFalse$a(node)
            || isContentEditableTrue$3(node) && hasNonEditableParent(node);
    };
    const isEmptyNode = (schema, targetNode, opts) => {
        const options = { ...defaultOptionValues, ...opts };
        if (options.checkRootAsContent) {
            if (isContentNode(schema, targetNode, targetNode, options)) {
                return false;
            }
        }
        let node = targetNode.firstChild;
        let brCount = 0;
        if (!node) {
            return true;
        }
        const walker = new DomTreeWalker(node, targetNode);
        do {
            if (options.skipBogus && isElement$7(node)) {
                const bogusValue = node.getAttribute('data-mce-bogus');
                if (bogusValue) {
                    node = walker.next(bogusValue === 'all');
                    continue;
                }
            }
            if (isComment(node)) {
                node = walker.next(true);
                continue;
            }
            if (isBr$7(node)) {
                brCount++;
                node = walker.next();
                continue;
            }
            if (isContentNode(schema, node, targetNode, options)) {
                return false;
            }
            node = walker.next();
        } while (node);
        return brCount <= 1;
    };
    const isEmpty$4 = (schema, elm, options) => {
        return isEmptyNode(schema, elm.dom, { checkRootAsContent: true, ...options });
    };
    const isContent$1 = (schema, node, options) => {
        return isContentNode(schema, node, node, { includeZwsp: defaultOptionValues.includeZwsp, ...options });
    };

    const nodeNameToNamespaceType = (name) => {
        const lowerCaseName = name.toLowerCase();
        if (lowerCaseName === 'svg') {
            return 'svg';
        }
        else if (lowerCaseName === 'math') {
            return 'math';
        }
        else {
            return 'html';
        }
    };
    const isNonHtmlElementRootName = (name) => nodeNameToNamespaceType(name) !== 'html';
    const isNonHtmlElementRoot = (node) => isNonHtmlElementRootName(node.nodeName);
    const toScopeType = (node) => nodeNameToNamespaceType(node.nodeName);
    const namespaceElements = ['svg', 'math'];
    const createNamespaceTracker = () => {
        const currentScope = value$1();
        const current = () => currentScope.get().map(toScopeType).getOr('html');
        const track = (node) => {
            if (isNonHtmlElementRoot(node)) {
                currentScope.set(node);
            }
            else if (currentScope.get().exists((scopeNode) => !scopeNode.contains(node))) {
                currentScope.clear();
            }
            return current();
        };
        const reset = () => {
            currentScope.clear();
        };
        return {
            track,
            current,
            reset
        };
    };

    const transparentBlockAttr = 'data-mce-block';
    // Returns the lowercase element names form a SchemaMap by excluding anyone that has uppercase letters.
    // This method is to avoid having to specify all possible valid characters other than lowercase a-z such as '-' or ':' etc.
    const elementNames = (map) => filter$5(keys(map), (key) => !/[A-Z]/.test(key));
    const makeSelectorFromSchemaMap = (map) => map$3(elementNames(map), (name) => {
        // Exclude namespace elements from processing
        const escapedName = CSS.escape(name);
        return `${escapedName}:` + map$3(namespaceElements, (ns) => `not(${ns} ${escapedName})`).join(':');
    }).join(',');
    const updateTransparent = (blocksSelector, transparent) => {
        if (isNonNullable(transparent.querySelector(blocksSelector))) {
            transparent.setAttribute(transparentBlockAttr, 'true');
            if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {
                transparent.removeAttribute('data-mce-selected');
            }
            return true;
        }
        else {
            transparent.removeAttribute(transparentBlockAttr);
            return false;
        }
    };
    const updateBlockStateOnChildren = (schema, scope) => {
        const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());
        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
        return filter$5(scope.querySelectorAll(transparentSelector), (transparent) => updateTransparent(blocksSelector, transparent));
    };
    const trimEdge = (schema, el, leftSide) => {
        var _a;
        const childPropertyName = leftSide ? 'lastChild' : 'firstChild';
        for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {
            if (isEmptyNode(schema, child, { checkRootAsContent: true })) {
                (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);
                return;
            }
        }
    };
    const split$2 = (schema, parentElm, splitElm) => {
        const range = document.createRange();
        const parentNode = parentElm.parentNode;
        if (parentNode) {
            range.setStartBefore(parentElm);
            range.setEndBefore(splitElm);
            const beforeFragment = range.extractContents();
            trimEdge(schema, beforeFragment, true);
            range.setStartAfter(splitElm);
            range.setEndAfter(parentElm);
            const afterFragment = range.extractContents();
            trimEdge(schema, afterFragment, false);
            if (!isEmptyNode(schema, beforeFragment, { checkRootAsContent: true })) {
                parentNode.insertBefore(beforeFragment, parentElm);
            }
            if (!isEmptyNode(schema, splitElm, { checkRootAsContent: true })) {
                parentNode.insertBefore(splitElm, parentElm);
            }
            if (!isEmptyNode(schema, afterFragment, { checkRootAsContent: true })) {
                parentNode.insertBefore(afterFragment, parentElm);
            }
            parentNode.removeChild(parentElm);
        }
    };
    // This will find invalid blocks wrapped in anchors and split them out so for example
    // <h1><a href="#"><h2>x</h2></a></h1> will find that h2 is invalid inside the H1 and split that out.
    // This is a simplistic apporach so it's likely not covering all the cases but it's a start.
    const splitInvalidChildren = (schema, scope, transparentBlocks) => {
        const blocksElements = schema.getBlockElements();
        const rootNode = SugarElement.fromDom(scope);
        const isBlock = (el) => name(el) in blocksElements;
        const isRoot = (el) => eq(el, rootNode);
        each$e(fromDom$1(transparentBlocks), (transparentBlock) => {
            ancestor$5(transparentBlock, isBlock, isRoot).each((parentBlock) => {
                const invalidChildren = children(transparentBlock, (el) => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));
                if (invalidChildren.length > 0) {
                    const stateScope = parentElement(parentBlock);
                    each$e(invalidChildren, (child) => {
                        ancestor$5(child, isBlock, isRoot).each((parentBlock) => {
                            split$2(schema, parentBlock.dom, child.dom);
                        });
                    });
                    stateScope.each((scope) => updateBlockStateOnChildren(schema, scope.dom));
                }
            });
        });
    };
    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {
        each$e([...transparentBlocks, ...(isTransparentBlock(schema, scope) ? [scope] : [])], (block) => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), (elm) => {
            if (isTransparentInline(schema, elm.dom)) {
                unwrap(elm);
            }
        }));
    };
    const updateChildren = (schema, scope) => {
        const transparentBlocks = updateBlockStateOnChildren(schema, scope);
        splitInvalidChildren(schema, scope, transparentBlocks);
        unwrapInvalidChildren(schema, scope, transparentBlocks);
    };
    const updateElement = (schema, target) => {
        if (isTransparentElement(schema, target)) {
            const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
            updateTransparent(blocksSelector, target);
        }
    };
    const updateCaret = (schema, root, caretParent) => {
        const isRoot = (el) => eq(el, SugarElement.fromDom(root));
        const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);
        // Check the element just above below the root so in if caretParent is I in this
        // case <body><p><b><i>|</i></b></p></body> it would use the P as the scope
        get$b(parents, parents.length - 2).filter(isElement$8).fold(() => updateChildren(schema, root), (scope) => updateChildren(schema, scope.dom));
    };
    const hasBlockAttr = (el) => el.hasAttribute(transparentBlockAttr);
    const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);
    const isTransparentElement = (schema, node) => isElement$7(node) && isTransparentElementName(schema, node.nodeName);
    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);
    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);
    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));

    const browser$2 = detect$1().browser;
    const firstElement = (nodes) => find$2(nodes, isElement$8);
    // Firefox has a bug where caption height is not included correctly in offset calculations of tables
    // this tries to compensate for that by detecting if that offsets are incorrect and then remove the height
    const getTableCaptionDeltaY = (elm) => {
        if (browser$2.isFirefox() && name(elm) === 'table') {
            return firstElement(children$1(elm)).filter((elm) => {
                return name(elm) === 'caption';
            }).bind((caption) => {
                return firstElement(nextSiblings(caption)).map((body) => {
                    const bodyTop = body.dom.offsetTop;
                    const captionTop = caption.dom.offsetTop;
                    const captionHeight = caption.dom.offsetHeight;
                    return bodyTop <= captionTop ? -captionHeight : 0;
                });
            }).getOr(0);
        }
        else {
            return 0;
        }
    };
    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);
    const getPos = (body, elm, rootElm) => {
        let x = 0, y = 0;
        const doc = body.ownerDocument;
        rootElm = rootElm ? rootElm : body;
        if (elm) {
            // Use getBoundingClientRect if it exists since it's faster than looping offset nodes
            // Fallback to offsetParent calculations if the body isn't static better since it stops at the body root
            if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {
                const pos = elm.getBoundingClientRect();
                // Add scroll offsets from documentElement or body since IE with the wrong box model will use d.body and so do WebKit
                // Also remove the body/documentelement clientTop/clientLeft on IE 6, 7 since they offset the position
                x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;
                y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;
                return { x, y };
            }
            let offsetParent = elm;
            while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
                const castOffsetParent = offsetParent;
                x += castOffsetParent.offsetLeft || 0;
                y += castOffsetParent.offsetTop || 0;
                offsetParent = castOffsetParent.offsetParent;
            }
            offsetParent = elm.parentNode;
            while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
                x -= offsetParent.scrollLeft || 0;
                y -= offsetParent.scrollTop || 0;
                offsetParent = offsetParent.parentNode;
            }
            y += getTableCaptionDeltaY(SugarElement.fromDom(elm));
        }
        return { x, y };
    };

    const getCrossOrigin$1 = (url, settings) => {
        const crossOriginFn = settings.crossOrigin;
        if (settings.contentCssCors) {
            return 'anonymous';
        }
        else if (isFunction(crossOriginFn)) {
            return crossOriginFn(url);
        }
        else {
            return undefined;
        }
    };
    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {
        let idCount = 0;
        const loadedStates = {};
        const edos = SugarElement.fromDom(documentOrShadowRoot);
        const doc = documentOrOwner(edos);
        const _setReferrerPolicy = (referrerPolicy) => {
            settings.referrerPolicy = referrerPolicy;
        };
        const _setContentCssCors = (contentCssCors) => {
            settings.contentCssCors = contentCssCors;
        };
        const _setCrossOrigin = (crossOrigin) => {
            settings.crossOrigin = crossOrigin;
        };
        const addStyle = (element) => {
            append$1(getStyleContainer(edos), element);
        };
        const removeStyle = (id) => {
            const styleContainer = getStyleContainer(edos);
            descendant$1(styleContainer, '#' + id).each(remove$8);
        };
        const getOrCreateState = (url) => get$a(loadedStates, url).getOrThunk(() => ({
            id: 'mce-u' + (idCount++),
            passed: [],
            failed: [],
            count: 0
        }));
        /**
         * Loads the specified CSS file and returns a Promise that will resolve when the stylesheet is loaded successfully or reject if it failed to load.
         *
         * @method load
         * @param {String} url Url to be loaded.
         * @return {Promise} A Promise that will resolve or reject when the stylesheet is loaded.
         */
        const load = (url) => new Promise((success, failure) => {
            let link;
            const urlWithSuffix = Tools._addCacheSuffix(url);
            const state = getOrCreateState(urlWithSuffix);
            loadedStates[urlWithSuffix] = state;
            state.count++;
            const resolve = (callbacks, status) => {
                each$e(callbacks, call);
                state.status = status;
                state.passed = [];
                state.failed = [];
                if (link) {
                    link.onload = null;
                    link.onerror = null;
                    link = null;
                }
            };
            const passed = () => resolve(state.passed, 2);
            const failed = () => resolve(state.failed, 3);
            if (success) {
                state.passed.push(success);
            }
            if (failure) {
                state.failed.push(failure);
            }
            // Is loading wait for it to pass
            if (state.status === 1) {
                return;
            }
            // Has finished loading and was success
            if (state.status === 2) {
                passed();
                return;
            }
            // Has finished loading and was a failure
            if (state.status === 3) {
                failed();
                return;
            }
            // Start loading
            state.status = 1;
            const linkElem = SugarElement.fromTag('link', doc.dom);
            setAll$1(linkElem, {
                rel: 'stylesheet',
                type: 'text/css',
                id: state.id
            });
            const crossorigin = getCrossOrigin$1(url, settings);
            if (crossorigin !== undefined) {
                set$4(linkElem, 'crossOrigin', crossorigin);
            }
            if (settings.referrerPolicy) {
                // Note: Don't use link.referrerPolicy = ... here as it doesn't work on Safari
                set$4(linkElem, 'referrerpolicy', settings.referrerPolicy);
            }
            link = linkElem.dom;
            link.onload = passed;
            link.onerror = failed;
            addStyle(linkElem);
            set$4(linkElem, 'href', urlWithSuffix);
        });
        /**
         * Loads the specified css string in as a style element with an unique key.
         *
         * @method loadRawCss
         * @param {String} key Unique key for the style element.
         * @param {String} css Css style content to add.
         */
        const loadRawCss = (key, css) => {
            const state = getOrCreateState(key);
            loadedStates[key] = state;
            state.count++;
            // Start loading
            const styleElem = SugarElement.fromTag('style', doc.dom);
            setAll$1(styleElem, {
                'rel': 'stylesheet',
                'type': 'text/css',
                'id': state.id,
                'data-mce-key': key
            });
            styleElem.dom.innerHTML = css;
            addStyle(styleElem);
        };
        /**
         * Loads the specified CSS files and returns a Promise that is resolved when all stylesheets are loaded or rejected if any failed to load.
         *
         * @method loadAll
         * @param {Array} urls URLs to be loaded.
         * @return {Promise} A Promise that will resolve or reject when all stylesheets are loaded.
         */
        const loadAll = (urls) => {
            const loadedUrls = Promise.allSettled(map$3(urls, (url) => load(url).then(constant(url))));
            return loadedUrls.then((results) => {
                const parts = partition$2(results, (r) => r.status === 'fulfilled');
                if (parts.fail.length > 0) {
                    return Promise.reject(map$3(parts.fail, (result) => result.reason));
                }
                else {
                    return map$3(parts.pass, (result) => result.value);
                }
            });
        };
        /**
         * Unloads the specified CSS file if no resources currently depend on it.
         *
         * @method unload
         * @param {String} url URL to unload or remove.
         */
        const unload = (url) => {
            const urlWithSuffix = Tools._addCacheSuffix(url);
            get$a(loadedStates, urlWithSuffix).each((state) => {
                const count = --state.count;
                if (count === 0) {
                    delete loadedStates[urlWithSuffix];
                    removeStyle(state.id);
                }
            });
        };
        /**
         * Unloads the specified CSS style element by key.
         *
         * @method unloadRawCss
         * @param {String} key Key of CSS style resource to unload.
         */
        const unloadRawCss = (key) => {
            get$a(loadedStates, key).each((state) => {
                const count = --state.count;
                if (count === 0) {
                    delete loadedStates[key];
                    removeStyle(state.id);
                }
            });
        };
        /**
         * Unloads each specified CSS file if no resources currently depend on it.
         *
         * @method unloadAll
         * @param {Array} urls URLs to unload or remove.
         */
        const unloadAll = (urls) => {
            each$e(urls, (url) => {
                unload(url);
            });
        };
        return {
            load,
            loadRawCss,
            loadAll,
            unload,
            unloadRawCss,
            unloadAll,
            _setReferrerPolicy,
            _setContentCssCors,
            _setCrossOrigin
        };
    };

    /**
     * This function is exported for testing purposes only - please use StyleSheetLoader.instance in production code.
     */
    const create$b = () => {
        const map = new WeakMap();
        const forElement = (referenceElement, settings) => {
            const root = getRootNode(referenceElement);
            const rootDom = root.dom;
            return Optional.from(map.get(rootDom)).getOrThunk(() => {
                const sl = StyleSheetLoader(rootDom, settings);
                map.set(rootDom, sl);
                return sl;
            });
        };
        return {
            forElement
        };
    };
    const instance = create$b();

    const isSpan = (node) => node.nodeName.toLowerCase() === 'span';
    const isInlineContent = (node, schema) => isNonNullable(node) && (isContent$1(schema, node) || schema.isInline(node.nodeName.toLowerCase()));
    const surroundedByInlineContent = (node, root, schema) => {
        const prev = new DomTreeWalker(node, root).prev(false);
        const next = new DomTreeWalker(node, root).next(false);
        // Check if the next/previous is either inline content or the start/end (eg is undefined)
        const prevIsInline = isUndefined(prev) || isInlineContent(prev, schema);
        const nextIsInline = isUndefined(next) || isInlineContent(next, schema);
        return prevIsInline && nextIsInline;
    };
    const isBookmarkNode$2 = (node) => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';
    // Keep text nodes with only spaces if surrounded by spans.
    // eg. "<p><span>a</span> <span>b</span></p>" should keep space between a and b
    const isKeepTextNode = (node, root, schema) => isText$b(node) && node.data.length > 0 && surroundedByInlineContent(node, root, schema);
    // Keep elements as long as they have any children
    const isKeepElement = (node) => isElement$7(node) ? node.childNodes.length > 0 : false;
    const isDocument = (node) => isDocumentFragment(node) || isDocument$1(node);
    // W3C valid browsers tend to leave empty nodes to the left/right side of the contents - this makes sense
    // but we don't want that in our code since it serves no purpose for the end user
    // For example splitting this html at the bold element:
    //   <p>text 1<span><b>CHOP</b></span>text 2</p>
    // would produce:
    //   <p>text 1<span></span></p><b>CHOP</b><p><span></span>text 2</p>
    // this function will then trim off empty edges and produce:
    //   <p>text 1</p><b>CHOP</b><p>text 2</p>
    const trimNode = (dom, node, schema, root) => {
        var _a;
        const rootNode = root || node;
        if (isElement$7(node) && isBookmarkNode$2(node)) {
            return node;
        }
        const children = node.childNodes;
        for (let i = children.length - 1; i >= 0; i--) {
            trimNode(dom, children[i], schema, rootNode);
        }
        // If the only child is a bookmark then move it up
        if (isElement$7(node)) {
            const currentChildren = node.childNodes;
            if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {
                (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);
            }
        }
        // Remove any empty nodes
        if (!isDocument(node) && !isContent$1(schema, node) && !isKeepElement(node) && !isKeepTextNode(node, rootNode, schema)) {
            dom.remove(node);
        }
        return node;
    };

    /**
     * Entity encoder class.
     *
     * @class tinymce.html.Entities
     * @static
     * @version 3.4
     */
    const makeMap$3 = Tools.makeMap;
    const attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    const textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    const rawCharsRegExp = /[<>&\"\']/g;
    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
    const asciiMap = {
        128: '\u20AC', 130: '\u201A', 131: '\u0192', 132: '\u201E', 133: '\u2026', 134: '\u2020',
        135: '\u2021', 136: '\u02C6', 137: '\u2030', 138: '\u0160', 139: '\u2039', 140: '\u0152',
        142: '\u017D', 145: '\u2018', 146: '\u2019', 147: '\u201C', 148: '\u201D', 149: '\u2022',
        150: '\u2013', 151: '\u2014', 152: '\u02DC', 153: '\u2122', 154: '\u0161', 155: '\u203A',
        156: '\u0153', 158: '\u017E', 159: '\u0178'
    };
    // Raw entities
    const baseEntities = {
        '\"': '&quot;', // Needs to be escaped since the YUI compressor would otherwise break the code
        '\'': '&#39;',
        '<': '&lt;',
        '>': '&gt;',
        '&': '&amp;',
        '\u0060': '&#96;'
    };
    // Reverse lookup table for raw entities
    const reverseEntities = {
        '&lt;': '<',
        '&gt;': '>',
        '&amp;': '&',
        '&quot;': '"',
        '&apos;': `'`
    };
    // Decodes text by using the browser
    const nativeDecode = (text) => {
        const elm = SugarElement.fromTag('div').dom;
        elm.innerHTML = text;
        return elm.textContent || elm.innerText || text;
    };
    // Build a two way lookup table for the entities
    const buildEntitiesLookup = (items, radix) => {
        const lookup = {};
        if (items) {
            const itemList = items.split(',');
            radix = radix || 10;
            // Build entities lookup table
            for (let i = 0; i < itemList.length; i += 2) {
                const chr = String.fromCharCode(parseInt(itemList[i], radix));
                // Only add non base entities
                if (!baseEntities[chr]) {
                    const entity = '&' + itemList[i + 1] + ';';
                    lookup[chr] = entity;
                    lookup[entity] = chr;
                }
            }
            return lookup;
        }
        else {
            return undefined;
        }
    };
    // Unpack entities lookup where the numbers are in radix 32 to reduce the size
    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +
        '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +
        '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +
        '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +
        '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +
        '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +
        '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +
        '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +
        '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +
        '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +
        'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +
        'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +
        't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +
        'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +
        'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +
        '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +
        '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +
        '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +
        '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +
        '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +
        'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +
        'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +
        'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +
        '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +
        '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
    /**
     * Encodes the specified string using raw entities. This means only the required XML base entities will be encoded.
     *
     * @method encodeRaw
     * @param {String} text Text to encode.
     * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
     * @return {String} Entity encoded text.
     */
    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
        return baseEntities[chr] || chr;
    });
    /**
     * Encoded the specified text with both the attributes and text entities. This function will produce larger text contents
     * since it doesn't know if the context is within an attribute or text node. This was added for compatibility
     * and is exposed as the `DOMUtils.encode` function.
     *
     * @method encodeAllRaw
     * @param {String} text Text to encode.
     * @return {String} Entity encoded text.
     */
    const encodeAllRaw = (text) => ('' + text).replace(rawCharsRegExp, (chr) => {
        return baseEntities[chr] || chr;
    });
    /**
     * Encodes the specified string using numeric entities. The core entities will be
     * encoded as named ones but all non lower ascii characters will be encoded into numeric entities.
     *
     * @method encodeNumeric
     * @param {String} text Text to encode.
     * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
     * @return {String} Entity encoded text.
     */
    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
        // Multi byte sequence convert it to a single entity
        if (chr.length > 1) {
            return '&#' + (((chr.charCodeAt(0) - 0xD800) * 0x400) + (chr.charCodeAt(1) - 0xDC00) + 0x10000) + ';';
        }
        return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
    });
    /**
     * Encodes the specified string using named entities. The core entities will be encoded
     * as named ones but all non lower ascii characters will be encoded into named entities.
     *
     * @method encodeNamed
     * @param {String} text Text to encode.
     * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
     * @param {Object} entities Optional parameter with entities to use.
     * @return {String} Entity encoded text.
     */
    const encodeNamed = (text, attr, entities) => {
        const resolveEntities = entities || namedEntities;
        return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
            return baseEntities[chr] || resolveEntities[chr] || chr;
        });
    };
    /**
     * Returns an encode function based on the name(s) and it's optional entities.
     *
     * @method getEncodeFunc
     * @param {String} name Comma separated list of encoders for example named,numeric.
     * @param {String} entities Optional parameter with entities to use instead of the built in set.
     * @return {Function} Encode function to be used.
     */
    const getEncodeFunc = (name, entities) => {
        const entitiesMap = buildEntitiesLookup(entities) || namedEntities;
        const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
            if (baseEntities[chr] !== undefined) {
                return baseEntities[chr];
            }
            if (entitiesMap[chr] !== undefined) {
                return entitiesMap[chr];
            }
            // Convert multi-byte sequences to a single entity.
            if (chr.length > 1) {
                return '&#' + (((chr.charCodeAt(0) - 0xD800) * 0x400) + (chr.charCodeAt(1) - 0xDC00) + 0x10000) + ';';
            }
            return '&#' + chr.charCodeAt(0) + ';';
        });
        const encodeCustomNamed = (text, attr) => {
            return encodeNamed(text, attr, entitiesMap);
        };
        // Replace + with , to be compatible with previous TinyMCE versions
        const nameMap = makeMap$3(name.replace(/\+/g, ','));
        // Named and numeric encoder
        if (nameMap.named && nameMap.numeric) {
            return encodeNamedAndNumeric;
        }
        // Named encoder
        if (nameMap.named) {
            // Custom names
            if (entities) {
                return encodeCustomNamed;
            }
            return encodeNamed;
        }
        // Numeric
        if (nameMap.numeric) {
            return encodeNumeric;
        }
        // Raw encoder
        return encodeRaw;
    };
    /**
     * Decodes the specified string, this will replace entities with raw UTF characters.
     *
     * @method decode
     * @param {String} text Text to entity decode.
     * @return {String} Entity decoded string.
     */
    const decode = (text) => text.replace(entityRegExp, (all, numeric) => {
        if (numeric) {
            if (numeric.charAt(0).toLowerCase() === 'x') {
                numeric = parseInt(numeric.substr(1), 16);
            }
            else {
                numeric = parseInt(numeric, 10);
            }
            // Support upper UTF
            if (numeric > 0xFFFF) {
                numeric -= 0x10000;
                // eslint-disable-next-line no-bitwise
                return String.fromCharCode(0xD800 + (numeric >> 10), 0xDC00 + (numeric & 0x3FF));
            }
            return asciiMap[numeric] || String.fromCharCode(numeric);
        }
        return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
    });
    const Entities = {
        encodeRaw,
        encodeAllRaw,
        encodeNumeric,
        encodeNamed,
        getEncodeFunc,
        decode
    };

    const split$1 = (items, delim) => {
        items = Tools.trim(items);
        return items ? items.split(delim || ' ') : [];
    };
    // Converts a wildcard expression string to a regexp for example *a will become /.*a/.
    const patternToRegExp = (str) => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');
    const isRegExp$1 = (obj) => isObject(obj) && obj.source && Object.prototype.toString.call(obj) === '[object RegExp]';
    const deepCloneElementRule = (obj) => {
        const helper = (value) => {
            if (isArray$1(value)) {
                return map$3(value, helper);
            }
            else if (isRegExp$1(value)) {
                return new RegExp(value.source, value.flags);
            }
            else if (isObject(value)) {
                return map$2(value, helper);
            }
            else {
                return value;
            }
        };
        return helper(obj);
    };

    const parseCustomElementsRules = (value) => {
        const customElementRegExp = /^(~)?(.+)$/;
        return bind$3(split$1(value, ','), (rule) => {
            const matches = customElementRegExp.exec(rule);
            if (matches) {
                const inline = matches[1] === '~';
                const cloneName = inline ? 'span' : 'div';
                const name = matches[2];
                return [{ cloneName, name }];
            }
            else {
                return [];
            }
        });
    };

    const getGlobalAttributeSet = (type) => {
        return Object.freeze([
            // Present on all schema types
            'id',
            'accesskey',
            'class',
            'dir',
            'lang',
            'style',
            'tabindex',
            'title',
            'role',
            // html5 and html5-strict extra attributes
            ...(type !== 'html4' ? ['contenteditable', 'contextmenu', 'draggable', 'dropzone', 'hidden', 'spellcheck', 'translate', 'itemprop', 'itemscope', 'itemtype'] : []),
            // html4 and html5 extra attributes
            ...(type !== 'html5-strict' ? ['xml:lang'] : [])
        ]);
    };

    // Missing elements in `phrasing` compared to HTML5 spec at 2024-01-30 (timestamped since spec is constantly evolving)
    //  area - required to be inside a map element so we should not add it to all elements.
    //  link - required to be in the body so we should not add it to all elements.
    //  math - currently not supported.
    //  meta - Only allowed if the `itemprop` attribute is set so very special.
    //  slot - We only want these to be accepted in registered custom components.
    // Extra element in `phrasing`: command keygen
    //
    // Missing elements in `flow` compared to HTML5 spec at 2034-01-30 (timestamped since the spec is constantly evolving)
    //  search - Can be both in a block and inline position but is not a transparent element. So not supported at this time.
    const getElementSetsAsStrings = (type) => {
        let blockContent;
        let phrasingContent;
        // Block content elements
        blockContent =
            'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';
        // Phrasing content elements from the HTML5 spec (inline)
        phrasingContent =
            'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' +
                'label map noscript object q s samp script select small span strong sub sup ' +
                'textarea u var #text #comment';
        // Add HTML5 items to globalAttributes, blockContent, phrasingContent
        if (type !== 'html4') {
            const transparentContent = 'a ins del canvas map';
            blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;
            phrasingContent += ' audio canvas command data datalist mark meter output picture ' +
                'progress template time wbr video ruby bdi keygen svg';
        }
        // Add HTML4 elements unless it's html5-strict
        if (type !== 'html5-strict') {
            const html4PhrasingContent = 'acronym applet basefont big font strike tt';
            phrasingContent = [phrasingContent, html4PhrasingContent].join(' ');
            const html4BlockContent = 'center dir isindex noframes';
            blockContent = [blockContent, html4BlockContent].join(' ');
        }
        // Flow content elements from the HTML5 spec (block+inline)
        const flowContent = [blockContent, phrasingContent].join(' ');
        return { blockContent, phrasingContent, flowContent };
    };
    const getElementSets = (type) => {
        const { blockContent, phrasingContent, flowContent } = getElementSetsAsStrings(type);
        const toArr = (value) => {
            return Object.freeze(value.split(' '));
        };
        return Object.freeze({
            blockContent: toArr(blockContent),
            phrasingContent: toArr(phrasingContent),
            flowContent: toArr(flowContent)
        });
    };

    const cachedSets = {
        'html4': cached(() => getElementSets('html4')),
        'html5': cached(() => getElementSets('html5')),
        'html5-strict': cached(() => getElementSets('html5-strict'))
    };
    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
    const getElementsPreset = (type, name) => {
        const { blockContent, phrasingContent, flowContent } = cachedSets[type]();
        if (name === 'blocks') {
            return Optional.some(blockContent);
        }
        else if (name === 'phrasing') {
            return Optional.some(phrasingContent);
        }
        else if (name === 'flow') {
            return Optional.some(flowContent);
        }
        else {
            return Optional.none();
        }
    };

    const makeSchema = (type) => {
        const globalAttributes = getGlobalAttributeSet(type);
        const { phrasingContent, flowContent } = getElementSetsAsStrings(type);
        const schema = {};
        const addElement = (name, attributes, children) => {
            schema[name] = {
                attributes: mapToObject(attributes, constant({})),
                attributesOrder: attributes,
                children: mapToObject(children, constant({}))
            };
        };
        const add = (name, attributes = '', children = '') => {
            const childNames = split$1(children);
            const names = split$1(name);
            let ni = names.length;
            const allAttributes = [...globalAttributes, ...split$1(attributes)];
            while (ni--) {
                addElement(names[ni], allAttributes.slice(), childNames);
            }
        };
        const addAttrs = (name, attributes) => {
            const names = split$1(name);
            const attrs = split$1(attributes);
            let ni = names.length;
            while (ni--) {
                const schemaItem = schema[names[ni]];
                for (let i = 0, l = attrs.length; i < l; i++) {
                    schemaItem.attributes[attrs[i]] = {};
                    schemaItem.attributesOrder.push(attrs[i]);
                }
            }
        };
        if (type !== 'html5-strict') {
            const html4PhrasingContent = 'acronym applet basefont big font strike tt';
            each$e(split$1(html4PhrasingContent), (name) => {
                add(name, '', phrasingContent);
            });
            const html4BlockContent = 'center dir isindex noframes';
            each$e(split$1(html4BlockContent), (name) => {
                add(name, '', flowContent);
            });
        }
        // HTML4 base schema TODO: Move HTML5 specific attributes to HTML5 specific if statement
        // Schema items <element name>, <specific attributes>, <children ..>
        add('html', 'manifest', 'head body');
        add('head', '', 'base command link meta noscript script style title');
        add('title hr noscript br');
        add('base', 'href target');
        add('link', 'href rel media hreflang type sizes hreflang');
        add('meta', 'name http-equiv content charset');
        add('style', 'media type scoped');
        add('script', 'src async defer type charset');
        add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' +
            'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' +
            'onpopstate onresize onscroll onstorage onunload', flowContent);
        add('dd div', '', flowContent);
        add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);
        add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);
        add('blockquote', 'cite', flowContent);
        add('ol', 'reversed start type', 'li');
        add('ul', '', 'li');
        add('li', 'value', flowContent);
        add('dl', '', 'dt dd');
        add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);
        add('q', 'cite', phrasingContent);
        add('ins del', 'cite datetime', flowContent);
        add('img', 'src sizes srcset alt usemap ismap width height');
        add('iframe', 'src name width height', flowContent);
        add('embed', 'src type width height');
        add('object', 'data type typemustmatch name usemap form width height', [flowContent, 'param'].join(' '));
        add('param', 'name value');
        add('map', 'name', [flowContent, 'area'].join(' '));
        add('area', 'alt coords shape href target rel media hreflang type');
        add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));
        add('colgroup', 'span', 'col');
        add('col', 'span');
        add('tbody thead tfoot', '', 'tr');
        add('tr', '', 'td th');
        add('td', 'colspan rowspan headers', flowContent);
        add('th', 'colspan rowspan headers scope abbr', flowContent);
        add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);
        add('fieldset', 'disabled form name', [flowContent, 'legend'].join(' '));
        add('label', 'form for', phrasingContent);
        add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' +
            'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');
        add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);
        add('select', 'disabled form multiple name required size', 'option optgroup');
        add('optgroup', 'disabled label', 'option');
        add('option', 'disabled label selected value');
        add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');
        add('menu', 'type label', [flowContent, 'li'].join(' '));
        add('noscript', '', flowContent);
        // Extend with HTML5 elements
        if (type !== 'html4') {
            add('wbr');
            add('ruby', '', [phrasingContent, 'rt rp'].join(' '));
            add('figcaption', '', flowContent);
            add('mark rt rp bdi', '', phrasingContent);
            add('summary', '', [phrasingContent, 'h1 h2 h3 h4 h5 h6'].join(' '));
            add('canvas', 'width height', flowContent);
            add('data', 'value', phrasingContent);
            add('video', 'src crossorigin poster preload autoplay mediagroup loop ' +
                'muted controls width height buffered', [flowContent, 'track source'].join(' '));
            add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' +
                'buffered volume', [flowContent, 'track source'].join(' '));
            add('picture', '', 'img source');
            add('source', 'src srcset type media sizes');
            add('track', 'kind src srclang label default');
            add('datalist', '', [phrasingContent, 'option'].join(' '));
            add('article section nav aside main header footer', '', flowContent);
            add('hgroup', '', 'h1 h2 h3 h4 h5 h6');
            add('figure', '', [flowContent, 'figcaption'].join(' '));
            add('time', 'datetime', phrasingContent);
            add('dialog', 'open', flowContent);
            add('command', 'type label icon disabled checked radiogroup command');
            add('output', 'for form name', phrasingContent);
            add('progress', 'value max', phrasingContent);
            add('meter', 'value min max low high optimum', phrasingContent);
            add('details', 'open', [flowContent, 'summary'].join(' '));
            add('keygen', 'autofocus challenge disabled form keytype name');
            // SVGs only support a subset of the global attributes
            addElement('svg', 'id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform'.split(' '), []);
        }
        // Extend with HTML4 attributes unless it's html5-strict
        if (type !== 'html5-strict') {
            addAttrs('script', 'language xml:space');
            addAttrs('style', 'xml:space');
            addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');
            addAttrs('embed', 'align name hspace vspace');
            addAttrs('param', 'valuetype type');
            addAttrs('a', 'charset name rev shape coords');
            addAttrs('br', 'clear');
            addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');
            addAttrs('img', 'name longdesc align border hspace vspace');
            addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');
            addAttrs('font basefont', 'size color face');
            addAttrs('input', 'usemap align');
            addAttrs('select');
            addAttrs('textarea');
            addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');
            addAttrs('ul', 'type compact');
            addAttrs('li', 'type');
            addAttrs('ol dl menu dir', 'compact');
            addAttrs('pre', 'width xml:space');
            addAttrs('hr', 'align noshade size width');
            addAttrs('isindex', 'prompt');
            addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');
            addAttrs('col', 'width align char charoff valign');
            addAttrs('colgroup', 'width align char charoff valign');
            addAttrs('thead', 'align char charoff valign');
            addAttrs('tr', 'align char charoff valign bgcolor');
            addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');
            addAttrs('form', 'accept');
            addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');
            addAttrs('tfoot', 'align char charoff valign');
            addAttrs('tbody', 'align char charoff valign');
            addAttrs('area', 'nohref');
            addAttrs('body', 'background bgcolor text link vlink alink');
        }
        // Extend with HTML5 attributes unless it's html4
        if (type !== 'html4') {
            addAttrs('input button select textarea', 'autofocus');
            addAttrs('input textarea', 'placeholder');
            addAttrs('a', 'download');
            addAttrs('link script img', 'crossorigin');
            addAttrs('img', 'loading');
            addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading referrerpolicy'); // Excluded: srcdoc
        }
        // Special: iframe, ruby, video, audio, label
        if (type !== 'html4') {
            // Video/audio elements cannot have nested children
            each$e([schema.video, schema.audio], (item) => {
                delete item.children.audio;
                delete item.children.video;
            });
        }
        // Delete children of the same name from it's parent
        // For example: form can't have a child of the name form
        each$e(split$1('a form meter progress dfn'), (name) => {
            if (schema[name]) {
                delete schema[name].children[name];
            }
        });
        // Delete header, footer, sectioning and heading content descendants
        /* each('dt th address', function(name) {
         delete schema[name].children[name];
         });*/
        // Caption can't have tables
        delete schema.caption.children.table;
        // Delete scripts by default due to possible XSS
        delete schema.script;
        // TODO: LI:s can only have value if parent is OL
        return schema;
    };

    const prefixToOperation = (prefix) => prefix === '-' ? 'remove' : 'add';
    const parseValidChild = (name) => {
        // see: https://html.spec.whatwg.org/#valid-custom-element-name
        const validChildRegExp = /^(@?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)$/;
        return Optional.from(validChildRegExp.exec(name)).map((matches) => ({
            preset: matches[1] === '@',
            name: matches[2]
        }));
    };
    const parseValidChildrenRules = (value) => {
        // see: https://html.spec.whatwg.org/#valid-custom-element-name
        const childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/; // from w3c's custom grammar (above)
        return bind$3(split$1(value, ','), (rule) => {
            const matches = childRuleRegExp.exec(rule);
            if (matches) {
                const prefix = matches[1];
                const operation = prefix ? prefixToOperation(prefix) : 'replace';
                const name = matches[2];
                const validChildren = bind$3(split$1(matches[3], '|'), (validChild) => parseValidChild(validChild).toArray());
                return [{ operation, name, validChildren }];
            }
            else {
                return [];
            }
        });
    };

    const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {
        const attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/;
        const hasPatternsRegExp = /[*?+]/;
        const { attributes, attributesOrder } = targetElement;
        return each$e(split$1(attrData, '|'), (rule) => {
            const matches = attrRuleRegExp.exec(rule);
            if (matches) {
                const attr = {};
                const attrType = matches[1];
                const attrName = matches[2].replace(/[\\:]:/g, ':');
                const attrPrefix = matches[3];
                const value = matches[4];
                // Required
                if (attrType === '!') {
                    targetElement.attributesRequired = targetElement.attributesRequired || [];
                    targetElement.attributesRequired.push(attrName);
                    attr.required = true;
                }
                // Denied from global
                if (attrType === '-') {
                    delete attributes[attrName];
                    attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);
                    return;
                }
                // Default value
                if (attrPrefix) {
                    if (attrPrefix === '=') { // Default value
                        targetElement.attributesDefault = targetElement.attributesDefault || [];
                        targetElement.attributesDefault.push({ name: attrName, value });
                        attr.defaultValue = value;
                    }
                    else if (attrPrefix === '~') { // Forced value
                        targetElement.attributesForced = targetElement.attributesForced || [];
                        targetElement.attributesForced.push({ name: attrName, value });
                        attr.forcedValue = value;
                    }
                    else if (attrPrefix === '<') { // Required values
                        attr.validValues = Tools.makeMap(value, '?');
                    }
                }
                // Check for attribute patterns
                if (hasPatternsRegExp.test(attrName)) {
                    const attrPattern = attr;
                    targetElement.attributePatterns = targetElement.attributePatterns || [];
                    attrPattern.pattern = patternToRegExp(attrName);
                    targetElement.attributePatterns.push(attrPattern);
                }
                else {
                    // Add attribute to order list if it doesn't already exist
                    if (!attributes[attrName]) {
                        attributesOrder.push(attrName);
                    }
                    attributes[attrName] = attr;
                }
            }
        });
    };
    const cloneAttributesInto = (from, to) => {
        each$d(from.attributes, (value, key) => {
            to.attributes[key] = value;
        });
        to.attributesOrder.push(...from.attributesOrder);
    };
    const parseValidElementsRules = (globalElement, validElements) => {
        const elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
        return bind$3(split$1(validElements, ','), (rule) => {
            const matches = elementRuleRegExp.exec(rule);
            if (matches) {
                const prefix = matches[1];
                const elementName = matches[2];
                const outputName = matches[3];
                const attrsPrefix = matches[4];
                const attrData = matches[5];
                const element = {
                    attributes: {},
                    attributesOrder: []
                };
                globalElement.each((el) => cloneAttributesInto(el, element));
                if (prefix === '#') {
                    element.paddEmpty = true;
                }
                else if (prefix === '-') {
                    element.removeEmpty = true;
                }
                if (attrsPrefix === '!') {
                    element.removeEmptyAttrs = true;
                }
                if (attrData) {
                    parseValidElementsAttrDataIntoElement(attrData, element);
                }
                // Handle substitute elements such as b/strong
                if (outputName) {
                    element.outputName = elementName;
                }
                // Mutate the local globalElement option state if we find a global @ rule
                if (elementName === '@') {
                    // We only care about the first one
                    if (globalElement.isNone()) {
                        globalElement = Optional.some(element);
                    }
                    else {
                        return [];
                    }
                }
                return [outputName ? { name: elementName, element, aliasName: outputName } : { name: elementName, element }];
            }
            else {
                return [];
            }
        });
    };

    /**
     * Schema validator class.
     *
     * @class tinymce.html.Schema
     * @version 3.4
     * @example
     * if (tinymce.activeEditor.schema.isValidChild('p', 'span')) {
     *   alert('span is valid child of p.');
     * }
     *
     * if (tinymce.activeEditor.schema.getElementRule('p')) {
     *   alert('P is a valid element.');
     * }
     */
    const mapCache = {};
    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode;
    const createMap = (defaultValue, extendWith = {}) => {
        const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));
        return extend$2(value, extendWith);
    };
    // A curated list using the textBlockElements map and parts of the blockElements map from the schema
    // TODO: TINY-8728 Investigate if the extras can be added directly to the default text block elements
    const getTextRootBlockElements = (schema) => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());
    const compileElementMap = (value, mode) => {
        if (value) {
            const styles = {};
            if (isString(value)) {
                value = {
                    '*': value
                };
            }
            // Convert styles into a rule list
            each$b(value, (value, key) => {
                styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);
            });
            return styles;
        }
        else {
            return undefined;
        }
    };
    const Schema = (settings = {}) => {
        var _a;
        const elements = {};
        const children = {};
        let patternElements = [];
        const customElementsMap = {};
        const specialElements = {};
        // Creates an lookup table map object for the specified option or the default value
        const createLookupTable = (option, defaultValue, extendWith) => {
            const value = settings[option];
            if (!value) {
                // Get cached default map or make it if needed
                let newValue = mapCache[option];
                if (!newValue) {
                    newValue = createMap(defaultValue, extendWith);
                    mapCache[option] = newValue;
                }
                return newValue;
            }
            else {
                // Create custom map
                return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));
            }
        };
        const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';
        const schemaItems = makeSchema(schemaType);
        // Allow all elements and attributes if verify_html is set to false
        if (settings.verify_html === false) {
            settings.valid_elements = '*[*]';
        }
        const validStyles = compileElementMap(settings.valid_styles);
        const invalidStyles = compileElementMap(settings.invalid_styles, 'map');
        const validClasses = compileElementMap(settings.valid_classes, 'map');
        // Setup map objects
        const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');
        const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');
        const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' +
            'meta param embed source wbr track');
        const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' +
            'noshade nowrap readonly selected autoplay loop controls allowfullscreen');
        const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';
        const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre svg textarea summary', voidElementsMap);
        const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);
        const headings = 'h1 h2 h3 h4 h5 h6';
        const textBlockElementsMap = createLookupTable('text_block_elements', headings + ' p div address pre form ' +
            'blockquote center dir fieldset header footer article section hgroup aside main nav figure');
        const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' +
            'th tr td li ol ul caption dl dt dd noscript menu isindex option ' +
            'datalist select optgroup figcaption details summary html body multicol listing colgroup col', textBlockElementsMap);
        const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' +
            'dfn code mark q sup sub samp');
        const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');
        const wrapBlockElementsMap = createLookupTable('wrap_block_elements', 'pre ' + headings);
        // See https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
        each$b(('script noscript iframe noframes noembed title style textarea xmp plaintext').split(' '), (name) => {
            specialElements[name] = new RegExp('<\/' + name + '[^>]*>', 'gi');
        });
        // Parses the specified valid_elements string and adds to the current rules
        const addValidElements = (validElements) => {
            const globalElement = Optional.from(elements['@']);
            const hasPatternsRegExp = /[*?+]/;
            each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({ name, element, aliasName }) => {
                if (aliasName) {
                    elements[aliasName] = element;
                }
                // Add pattern or exact element
                if (hasPatternsRegExp.test(name)) {
                    const patternElement = element;
                    patternElement.pattern = patternToRegExp(name);
                    patternElements.push(patternElement);
                }
                else {
                    elements[name] = element;
                }
            });
        };
        const setValidElements = (validElements) => {
            // Clear any existing rules. Note that since `elements` is exposed we can't
            // overwrite it, so instead we delete all the properties
            patternElements = [];
            each$e(keys(elements), (name) => {
                delete elements[name];
            });
            addValidElements(validElements);
        };
        const addCustomElement = (name, spec) => {
            var _a, _b;
            // Flush cached items since we are altering the default maps
            delete mapCache.text_block_elements;
            delete mapCache.block_elements;
            const inline = spec.extends ? !isBlock(spec.extends) : false;
            const cloneName = spec.extends;
            children[name] = cloneName ? children[cloneName] : {};
            customElementsMap[name] = cloneName !== null && cloneName !== void 0 ? cloneName : name;
            // Treat all custom elements as being non-empty by default
            nonEmptyElementsMap[name.toUpperCase()] = {};
            nonEmptyElementsMap[name] = {};
            // If it's not marked as inline then add it to valid block elements
            if (!inline) {
                blockElementsMap[name.toUpperCase()] = {};
                blockElementsMap[name] = {};
            }
            // Add elements clone if needed
            if (cloneName && !elements[name] && elements[cloneName]) {
                const customRule = deepCloneElementRule(elements[cloneName]);
                delete customRule.removeEmptyAttrs;
                delete customRule.removeEmpty;
                elements[name] = customRule;
            }
            else {
                elements[name] = { attributesOrder: [], attributes: {} };
            }
            // Add custom attributes
            if (isArray$1(spec.attributes)) {
                const processAttrName = (name) => {
                    customRule.attributesOrder.push(name);
                    customRule.attributes[name] = {};
                };
                const customRule = (_a = elements[name]) !== null && _a !== void 0 ? _a : {};
                delete customRule.attributesDefault;
                delete customRule.attributesForced;
                delete customRule.attributePatterns;
                delete customRule.attributesRequired;
                customRule.attributesOrder = [];
                customRule.attributes = {};
                each$e(spec.attributes, (attrName) => {
                    const globalAttrs = getGlobalAttributeSet(schemaType);
                    parseValidChild(attrName).each(({ preset, name }) => {
                        if (preset) {
                            if (name === 'global') {
                                each$e(globalAttrs, processAttrName);
                            }
                        }
                        else {
                            processAttrName(name);
                        }
                    });
                });
                elements[name] = customRule;
            }
            // Add custom pad empty rule
            if (isBoolean(spec.padEmpty)) {
                const customRule = (_b = elements[name]) !== null && _b !== void 0 ? _b : {};
                customRule.paddEmpty = spec.padEmpty;
                elements[name] = customRule;
            }
            // Add custom children
            if (isArray$1(spec.children)) {
                const customElementChildren = {};
                const processNodeName = (name) => {
                    customElementChildren[name] = {};
                };
                const processPreset = (name) => {
                    getElementsPreset(schemaType, name).each((names) => {
                        each$e(names, processNodeName);
                    });
                };
                each$e(spec.children, (child) => {
                    parseValidChild(child).each(({ preset, name }) => {
                        if (preset) {
                            processPreset(name);
                        }
                        else {
                            processNodeName(name);
                        }
                    });
                });
                children[name] = customElementChildren;
            }
            // Add custom elements at extends positions
            if (cloneName) {
                each$d(children, (element, elmName) => {
                    if (element[cloneName]) {
                        children[elmName] = element = extend$2({}, children[elmName]);
                        element[name] = element[cloneName];
                    }
                });
            }
        };
        const addCustomElementsFromString = (customElements) => {
            each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({ name, cloneName }) => {
                addCustomElement(name, { extends: cloneName });
            });
        };
        const addCustomElements = (customElements) => {
            if (isObject(customElements)) {
                each$d(customElements, (spec, name) => addCustomElement(name, spec));
            }
            else if (isString(customElements)) {
                addCustomElementsFromString(customElements);
            }
        };
        // Adds valid children to the schema object
        const addValidChildren = (validChildren) => {
            each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({ operation, name, validChildren }) => {
                const parent = operation === 'replace' ? { '#comment': {} } : children[name];
                const processNodeName = (name) => {
                    if (operation === 'remove') {
                        delete parent[name];
                    }
                    else {
                        parent[name] = {};
                    }
                };
                const processPreset = (name) => {
                    getElementsPreset(schemaType, name).each((names) => {
                        each$e(names, processNodeName);
                    });
                };
                each$e(validChildren, ({ preset, name }) => {
                    if (preset) {
                        processPreset(name);
                    }
                    else {
                        processNodeName(name);
                    }
                });
                children[name] = parent;
            });
        };
        const getElementRule = (name) => {
            const element = elements[name];
            // Exact match found
            if (element) {
                return element;
            }
            // No exact match then try the patterns
            let i = patternElements.length;
            while (i--) {
                const patternElement = patternElements[i];
                if (patternElement.pattern.test(name)) {
                    return patternElement;
                }
            }
            return undefined;
        };
        const setup = () => {
            if (!settings.valid_elements) {
                // No valid elements defined then clone the elements from the schema spec
                each$b(schemaItems, (element, name) => {
                    elements[name] = {
                        attributes: element.attributes,
                        attributesOrder: element.attributesOrder
                    };
                    children[name] = element.children;
                });
                // Prefer strong/em over b/i
                each$b(split$1('strong/b em/i'), (item) => {
                    const items = split$1(item, '/');
                    elements[items[1]].outputName = items[0];
                });
                // Add default alt attribute for images, removed since alt="" is treated as presentational.
                // elements.img.attributesDefault = [{name: 'alt', value: ''}];
                // By default,
                // - padd the text inline element if it is empty and also a child of an empty root block
                // - in all other cases, remove the text inline element if it is empty
                each$b(textInlineElementsMap, (_val, name) => {
                    if (elements[name]) {
                        if (settings.padd_empty_block_inline_children) {
                            elements[name].paddInEmptyBlock = true;
                        }
                        elements[name].removeEmpty = true;
                    }
                });
                // Remove these if they are empty by default
                each$b(split$1('ol ul blockquote a table tbody'), (name) => {
                    if (elements[name]) {
                        elements[name].removeEmpty = true;
                    }
                });
                // Padd these by default
                each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), (name) => {
                    if (elements[name]) {
                        elements[name].paddEmpty = true;
                    }
                });
                // Remove these if they have no attributes
                each$b(split$1('span'), (name) => {
                    elements[name].removeEmptyAttrs = true;
                });
                // Remove these by default
                // TODO: Reenable in 4.1
                /* each(split('script style'), function(name) {
                 delete elements[name];
                 });*/
            }
            else {
                setValidElements(settings.valid_elements);
                each$b(schemaItems, (element, name) => {
                    children[name] = element.children;
                });
            }
            // Opt in is done with options like `extended_valid_elements`
            delete elements.svg;
            addCustomElements(settings.custom_elements);
            addValidChildren(settings.valid_children);
            addValidElements(settings.extended_valid_elements);
            // Todo: Remove this when we fix list handling to be valid
            addValidChildren('+ol[ul|ol],+ul[ul|ol]');
            // Some elements are not valid by themselves - require parents
            each$b({
                dd: 'dl',
                dt: 'dl',
                li: 'ul ol',
                td: 'tr',
                th: 'tr',
                tr: 'tbody thead tfoot',
                tbody: 'table',
                thead: 'table',
                tfoot: 'table',
                legend: 'fieldset',
                area: 'map',
                param: 'video audio object'
            }, (parents, item) => {
                if (elements[item]) {
                    elements[item].parentsRequired = split$1(parents);
                }
            });
            // Delete invalid elements
            if (settings.invalid_elements) {
                each$b(explode$2(settings.invalid_elements), (item) => {
                    if (elements[item]) {
                        delete elements[item];
                    }
                });
            }
            // If the user didn't allow span only allow internal spans
            if (!getElementRule('span')) {
                addValidElements('span[!data-mce-type|*]');
            }
        };
        /**
         * Name/value map object with valid parents and children to those parents.
         *
         * @field children
         * @type Object
         * @example
         * children = {
         *    div: { p:{}, h1:{} }
         * };
         */
        /**
         * Name/value map object with valid styles for each element.
         *
         * @method getValidStyles
         * @type Object
         */
        const getValidStyles = constant(validStyles);
        /**
         * Name/value map object with valid styles for each element.
         *
         * @method getInvalidStyles
         * @type Object
         */
        const getInvalidStyles = constant(invalidStyles);
        /**
         * Name/value map object with valid classes for each element.
         *
         * @method getValidClasses
         * @type Object
         */
        const getValidClasses = constant(validClasses);
        /**
         * Returns a map with boolean attributes.
         *
         * @method getBoolAttrs
         * @return {Object} Name/value lookup map for boolean attributes.
         */
        const getBoolAttrs = constant(boolAttrMap);
        /**
         * Returns a map with block elements.
         *
         * @method getBlockElements
         * @return {Object} Name/value lookup map for block elements.
         */
        const getBlockElements = constant(blockElementsMap);
        /**
         * Returns a map with text block elements. For example: <code>&#60;p&#62;</code>, <code>&#60;h1&#62;</code> to <code>&#60;h6&#62;</code>, <code>&#60;div&#62;</code> or <code>&#60;address&#62;</code>.
         *
         * @method getTextBlockElements
         * @return {Object} Name/value lookup map for block elements.
         */
        const getTextBlockElements = constant(textBlockElementsMap);
        /**
         * Returns a map of inline text format nodes. For example: <code>&#60;strong&#62;</code>, <code>&#60;span&#62;</code> or <code>&#60;ins&#62;</code>.
         *
         * @method getTextInlineElements
         * @return {Object} Name/value lookup map for text format elements.
         */
        const getTextInlineElements = constant(textInlineElementsMap);
        /**
         * Returns a map with void elements. For example: <code>&#60;br&#62;</code> or <code>&#60;img&#62;</code>.
         *
         * @method getVoidElements
         * @return {Object} Name/value lookup map for void elements.
         */
        const getVoidElements = constant(Object.seal(voidElementsMap));
        /**
         * Returns a map with self closing tags. For example: <code>&#60;li&#62;</code>.
         *
         * @method getSelfClosingElements
         * @return {Object} Name/value lookup map for self closing tags elements.
         */
        const getSelfClosingElements = constant(selfClosingElementsMap);
        /**
         * Returns a map with elements that should be treated as contents regardless if it has text
         * content in them or not. For example: <code>&#60;td&#62;</code>, <code>&#60;video&#62;</code> or <code>&#60;img&#62;</code>.
         *
         * @method getNonEmptyElements
         * @return {Object} Name/value lookup map for non empty elements.
         */
        const getNonEmptyElements = constant(nonEmptyElementsMap);
        /**
         * Returns a map with elements that the caret should be moved in front of after enter is
         * pressed.
         *
         * @method getMoveCaretBeforeOnEnterElements
         * @return {Object} Name/value lookup map for elements to place the caret in front of.
         */
        const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);
        /**
         * Returns a map with elements where white space is to be preserved. For example: <code>&#60;pre&#62;</code> or <code>&#60;script&#62;</code>.
         *
         * @method getWhitespaceElements
         * @return {Object} Name/value lookup map for white space elements.
         */
        const getWhitespaceElements = constant(whitespaceElementsMap);
        /**
         * Returns a map with elements that should be treated as transparent.
         *
         * @method getTransparentElements
         * @return {Object} Name/value lookup map for special elements.
         */
        const getTransparentElements = constant(transparentElementsMap);
        const getWrapBlockElements = constant(wrapBlockElementsMap);
        /**
         * Returns a map with special elements. These are elements that needs to be parsed
         * in a special way such as script, style, textarea etc. The map object values
         * are regexps used to find the end of the element.
         *
         * @method getSpecialElements
         * @return {Object} Name/value lookup map for special elements.
         */
        const getSpecialElements = constant(Object.seal(specialElements));
        /**
         * Returns true/false if the specified element and it's child is valid or not
         * according to the schema.
         *
         * @method isValidChild
         * @param {String} name Element name to check for.
         * @param {String} child Element child to verify.
         * @return {Boolean} True/false if the element is a valid child of the specified parent.
         */
        const isValidChild = (name, child) => {
            const parent = children[name.toLowerCase()];
            return !!(parent && parent[child.toLowerCase()]);
        };
        /**
         * Returns true/false if the specified element name and optional attribute is
         * valid according to the schema.
         *
         * @method isValid
         * @param {String} name Name of element to check.
         * @param {String} attr Optional attribute name to check for.
         * @return {Boolean} True/false if the element and attribute is valid.
         */
        const isValid = (name, attr) => {
            const rule = getElementRule(name);
            // Check if it's a valid element
            if (rule) {
                if (attr) {
                    // Check if attribute name exists
                    if (rule.attributes[attr]) {
                        return true;
                    }
                    // Check if attribute matches a regexp pattern
                    const attrPatterns = rule.attributePatterns;
                    if (attrPatterns) {
                        let i = attrPatterns.length;
                        while (i--) {
                            if (attrPatterns[i].pattern.test(attr)) {
                                return true;
                            }
                        }
                    }
                }
                else {
                    return true;
                }
            }
            // No match
            return false;
        };
        const isBlock = (name) => has$2(getBlockElements(), name);
        // Check if name starts with # to detect non-element node names like #text and #comment
        const isInline = (name) => !startsWith(name, '#') && isValid(name) && !isBlock(name);
        const isWrapper = (name) => has$2(getWrapBlockElements(), name) || isInline(name);
        /**
         * Returns true/false if the specified element is valid or not
         * according to the schema.
         *
         * @method getElementRule
         * @param {String} name Element name to check for.
         * @return {Object} Element object or undefined if the element isn't valid.
         */
        /**
         * Returns an map object of all custom elements.
         *
         * @method getCustomElements
         * @return {Object} Name/value map object of all custom elements.
         */
        const getCustomElements = constant(customElementsMap);
        /**
         * Parses a valid elements string and adds it to the schema. The valid elements
         * format is for example <code>element[attr=default|otherattr]</code>.
         * Existing rules will be replaced with the ones specified, so this extends the schema.
         *
         * @method addValidElements
         * @param {String} valid_elements String in the valid elements format to be parsed.
         */
        /**
         * Parses a valid elements string and sets it to the schema. The valid elements
         * format is for example <code>element[attr=default|otherattr]</code>.
         * Existing rules will be replaced with the ones specified, so this extends the schema.
         *
         * @method setValidElements
         * @param {String} valid_elements String in the valid elements format to be parsed.
         */
        /**
         * Adds custom non-HTML elements to the schema. For more information about adding custom elements see:
         * <a href="https://www.tiny.cloud/docs/tinymce/latest/content-filtering/#custom_elements">custom_elements</a>
         *
         * @method addCustomElements
         * @param {String/Object} custom_elements Comma separated list or record of custom elements to add.
         */
        /**
         * Parses a valid children string and adds them to the schema structure. The valid children
         * format is for example <code>element[child1|child2]</code>.
         *
         * @method addValidChildren
         * @param {String} valid_children Valid children elements string to parse
         */
        setup();
        return {
            type: schemaType,
            children,
            elements,
            getValidStyles,
            getValidClasses,
            getBlockElements,
            getInvalidStyles,
            getVoidElements,
            getTextBlockElements,
            getTextInlineElements,
            getBoolAttrs,
            getElementRule,
            getSelfClosingElements,
            getNonEmptyElements,
            getMoveCaretBeforeOnEnterElements,
            getWhitespaceElements,
            getTransparentElements,
            getSpecialElements,
            isValidChild,
            isValid,
            isBlock,
            isInline,
            isWrapper,
            getCustomElements,
            addValidElements,
            setValidElements,
            addCustomElements,
            addValidChildren
        };
    };

    const hexColour = (value) => ({
        value: normalizeHex(value)
    });
    const normalizeHex = (hex) => removeLeading(hex, '#').toUpperCase();
    const toHex = (component) => {
        const hex = component.toString(16);
        return (hex.length === 1 ? '0' + hex : hex).toUpperCase();
    };
    const fromRgba = (rgbaColour) => {
        const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);
        return hexColour(value);
    };

    const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i;
    // This regex will match rgba(0, 0, 0, 0.5) or rgba(0, 0, 0, 50%) , or without commas
    const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i;
    const rgbaColour = (red, green, blue, alpha) => ({
        red,
        green,
        blue,
        alpha
    });
    const fromStringValues = (red, green, blue, alpha) => {
        const r = parseInt(red, 10);
        const g = parseInt(green, 10);
        const b = parseInt(blue, 10);
        const a = parseFloat(alpha);
        return rgbaColour(r, g, b, a);
    };
    const getColorFormat = (colorString) => {
        if (rgbRegex.test(colorString)) {
            return 'rgb';
        }
        else if (rgbaRegex.test(colorString)) {
            return 'rgba';
        }
        return 'other';
    };
    const fromString = (rgbaString) => {
        const rgbMatch = rgbRegex.exec(rgbaString);
        if (rgbMatch !== null) {
            return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));
        }
        const rgbaMatch = rgbaRegex.exec(rgbaString);
        if (rgbaMatch !== null) {
            return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
        }
        return Optional.none();
    };
    const toString = (rgba) => `rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`;

    const rgbaToHexString = (color) => fromString(color)
        .map(fromRgba)
        .map((h) => '#' + h.value)
        .getOr(color);

    /**
     * This class is used to parse CSS styles. It also compresses styles to reduce the output size.
     *
     * @class tinymce.html.Styles
     * @version 3.4
     * @example
     * const Styles = tinymce.html.Styles({
     *   url_converter: (url) => {
     *     return url;
     *   }
     * });
     *
     * styles = Styles.parse('border: 1px solid red');
     * styles.color = 'red';
     *
     * console.log(tinymce.html.Styles().serialize(styles));
     */
    const Styles = (settings = {}, schema) => {
        /* jshint maxlen:255 */
        /* eslint max-len:0 */
        const urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
        const styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
        const trimRightRegExp = /\s+$/;
        const encodingLookup = {};
        let validStyles;
        let invalidStyles;
        const invisibleChar = zeroWidth;
        if (schema) {
            validStyles = schema.getValidStyles();
            invalidStyles = schema.getInvalidStyles();
        }
        const encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(' ');
        for (let i = 0; i < encodingItems.length; i++) {
            encodingLookup[encodingItems[i]] = invisibleChar + i;
            encodingLookup[invisibleChar + i] = encodingItems[i];
        }
        // eslint-disable-next-line consistent-this
        const self = {
            /**
             * Parses the specified style value into an object collection. This parser will also
             * merge and remove any redundant items that browsers might have added. URLs inside
             * the styles will also be converted to absolute/relative based on the settings.
             *
             * @method parse
             * @param {String} css Style value to parse. For example: `border:1px solid red;`
             * @return {Object} Object representation of that style. For example: `{ border: '1px solid red' }`
             */
            parse: (css) => {
                const styles = {};
                let isEncoded = false;
                const urlConverter = settings.url_converter;
                const urlConverterScope = settings.url_converter_scope || self;
                const compress = (prefix, suffix, noJoin) => {
                    const top = styles[prefix + '-top' + suffix];
                    if (!top) {
                        return;
                    }
                    const right = styles[prefix + '-right' + suffix];
                    if (!right) {
                        return;
                    }
                    const bottom = styles[prefix + '-bottom' + suffix];
                    if (!bottom) {
                        return;
                    }
                    const left = styles[prefix + '-left' + suffix];
                    if (!left) {
                        return;
                    }
                    const box = [top, right, bottom, left];
                    let i = box.length - 1;
                    while (i--) {
                        if (box[i] !== box[i + 1]) {
                            break;
                        }
                    }
                    if (i > -1 && noJoin) {
                        return;
                    }
                    styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');
                    delete styles[prefix + '-top' + suffix];
                    delete styles[prefix + '-right' + suffix];
                    delete styles[prefix + '-bottom' + suffix];
                    delete styles[prefix + '-left' + suffix];
                };
                /**
                 * Checks if the specific style can be compressed in other words if all border-width are equal.
                 */
                const canCompress = (key) => {
                    const value = styles[key];
                    if (!value) {
                        return;
                    }
                    // Make sure not to split values like 'rgb(100, 50, 100);
                    const values = value.indexOf(',') > -1 ? [value] : value.split(' ');
                    let i = values.length;
                    while (i--) {
                        if (values[i] !== values[0]) {
                            return false;
                        }
                    }
                    styles[key] = values[0];
                    return true;
                };
                /**
                 * Compresses multiple styles into one style.
                 */
                const compress2 = (target, a, b, c) => {
                    if (!canCompress(a)) {
                        return;
                    }
                    if (!canCompress(b)) {
                        return;
                    }
                    if (!canCompress(c)) {
                        return;
                    }
                    // Compress
                    styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];
                    delete styles[a];
                    delete styles[b];
                    delete styles[c];
                };
                // Encodes the specified string by replacing all \" \' ; : with _<num>
                const encode = (str) => {
                    isEncoded = true;
                    return encodingLookup[str];
                };
                // Decodes the specified string by replacing all _<num> with it's original value \" \' etc
                // It will also decode the \" \' if keepSlashes is set to false or omitted
                const decode = (str, keepSlashes) => {
                    if (isEncoded) {
                        str = str.replace(/\uFEFF[0-9]/g, (str) => {
                            return encodingLookup[str];
                        });
                    }
                    if (!keepSlashes) {
                        str = str.replace(/\\([\'\";:])/g, '$1');
                    }
                    return str;
                };
                const decodeSingleHexSequence = (escSeq) => {
                    return String.fromCharCode(parseInt(escSeq.slice(1), 16));
                };
                const decodeHexSequences = (value) => {
                    return value.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
                };
                const processUrl = (match, url, url2, url3, str, str2) => {
                    str = str || str2;
                    if (str) {
                        str = decode(str);
                        // Force strings into single quote format
                        return `'` + str.replace(/\'/g, `\\'`) + `'`;
                    }
                    url = decode(url || url2 || url3 || '');
                    if (!settings.allow_script_urls) {
                        const scriptUrl = url.replace(/[\s\r\n]+/g, '');
                        if (/(java|vb)script:/i.test(scriptUrl)) {
                            return '';
                        }
                        if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
                            return '';
                        }
                    }
                    // Convert the URL to relative/absolute depending on config
                    if (urlConverter) {
                        url = urlConverter.call(urlConverterScope, url, 'style');
                    }
                    // Output new URL format
                    return `url('` + url.replace(/\'/g, `\\'`) + `')`;
                };
                if (css) {
                    css = css.replace(/[\u0000-\u001F]/g, '');
                    // Encode \" \' % and ; and : inside strings so they don't interfere with the style parsing
                    css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, (str) => {
                        return str.replace(/[;:]/g, encode);
                    });
                    // Parse styles
                    let matches;
                    while ((matches = styleRegExp.exec(css))) {
                        styleRegExp.lastIndex = matches.index + matches[0].length;
                        let name = matches[1].replace(trimRightRegExp, '').toLowerCase();
                        let value = matches[2].replace(trimRightRegExp, '');
                        if (name && value) {
                            // Decode escaped sequences like \65 -> e
                            name = decodeHexSequences(name);
                            value = decodeHexSequences(value);
                            // Skip properties with double quotes and sequences like \" \' in their names
                            // See 'mXSS Attacks: Attacking well-secured Web-Applications by using innerHTML Mutations'
                            // https://cure53.de/fp170.pdf
                            if (name.indexOf(invisibleChar) !== -1 || name.indexOf('"') !== -1) {
                                continue;
                            }
                            // Don't allow behavior name or expression/comments within the values
                            if (!settings.allow_script_urls && (name === 'behavior' || /expression\s*\(|\/\*|\*\//.test(value))) {
                                continue;
                            }
                            // Opera will produce 700 instead of bold in their style values
                            if (name === 'font-weight' && value === '700') {
                                value = 'bold';
                            }
                            else if (name === 'color' || name === 'background-color') { // Lowercase colors like RED
                                value = value.toLowerCase();
                            }
                            // Convert RGB colors to HEX
                            if (getColorFormat(value) === 'rgb') {
                                fromString(value).each((rgba) => {
                                    value = rgbaToHexString(toString(rgba)).toLowerCase();
                                });
                            }
                            // Convert URLs and force them into url('value') format
                            value = value.replace(urlOrStrRegExp, processUrl);
                            styles[name] = isEncoded ? decode(value, true) : value;
                        }
                    }
                    // Compress the styles to reduce it's size for example IE will expand styles
                    compress('border', '', true);
                    compress('border', '-width');
                    compress('border', '-color');
                    compress('border', '-style');
                    compress('padding', '');
                    compress('margin', '');
                    compress2('border', 'border-width', 'border-style', 'border-color');
                    // Remove pointless border, IE produces these
                    if (styles.border === 'medium none') {
                        delete styles.border;
                    }
                    // IE 11 will produce a border-image: none when getting the style attribute from <p style="border: 1px solid red"></p>
                    // So let us assume it shouldn't be there
                    if (styles['border-image'] === 'none') {
                        delete styles['border-image'];
                    }
                }
                return styles;
            },
            /**
             * Serializes the specified style object into a string.
             *
             * @method serialize
             * @param {Object} styles Object to serialize as string. For example: `{ border: '1px solid red' }`
             * @param {String} elementName Optional element name, if specified only the styles that matches the schema will be serialized.
             * @return {String} String representation of the style object. For example: `border: 1px solid red`
             */
            serialize: (styles, elementName) => {
                let css = '';
                const serializeStyles = (elemName, validStyleList) => {
                    const styleList = validStyleList[elemName];
                    if (styleList) {
                        for (let i = 0, l = styleList.length; i < l; i++) {
                            const name = styleList[i];
                            const value = styles[name];
                            if (value) {
                                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
                            }
                        }
                    }
                };
                const isValid = (name, elemName) => {
                    if (!invalidStyles || !elemName) {
                        return true;
                    }
                    let styleMap = invalidStyles['*'];
                    if (styleMap && styleMap[name]) {
                        return false;
                    }
                    styleMap = invalidStyles[elemName];
                    return !(styleMap && styleMap[name]);
                };
                // Serialize styles according to schema
                if (elementName && validStyles) {
                    // Serialize global styles and element specific styles
                    serializeStyles('*', validStyles);
                    serializeStyles(elementName, validStyles);
                }
                else {
                    // Output the styles in the order they are inside the object
                    each$d(styles, (value, name) => {
                        if (value && isValid(name, elementName)) {
                            css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
                        }
                    });
                }
                return css;
            }
        };
        return self;
    };

    // Note: The values here aren't used. This is just used as a hash map to see if the key exists
    const deprecated = {
        keyLocation: true,
        layerX: true,
        layerY: true,
        returnValue: true,
        webkitMovementX: true,
        webkitMovementY: true,
        keyIdentifier: true,
        mozPressure: true
    };
    // Note: We can't rely on `instanceof` here as it won't work if the event was fired from another window.
    // Additionally, the constructor name might be `MouseEvent` or similar so we can't rely on the constructor name.
    const isNativeEvent = (event) => event instanceof Event || isFunction(event.initEvent);
    // Checks if it is our own isDefaultPrevented function
    const hasIsDefaultPrevented = (event) => event.isDefaultPrevented === always || event.isDefaultPrevented === never;
    // An event needs normalizing if it doesn't have the prevent default function or if it's a native event
    const needsNormalizing = (event) => isNullable(event.preventDefault) || isNativeEvent(event);
    const clone$2 = (originalEvent, data) => {
        const event = data !== null && data !== void 0 ? data : {};
        // Copy all properties from the original event
        for (const name in originalEvent) {
            // Some properties are deprecated and produces a warning so don't include them
            if (!has$2(deprecated, name)) {
                event[name] = originalEvent[name];
            }
        }
        // The composed path can't be cloned, so delegate instead
        if (isNonNullable(originalEvent.composedPath)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            event.composedPath = () => originalEvent.composedPath();
        }
        // The getModifierState won't work when cloned, so delegate instead
        if (isNonNullable(originalEvent.getModifierState)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            event.getModifierState = (keyArg) => originalEvent.getModifierState(keyArg);
        }
        // The getTargetRanges won't work when cloned, so delegate instead
        if (isNonNullable(originalEvent.getTargetRanges)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            event.getTargetRanges = () => originalEvent.getTargetRanges();
        }
        return event;
    };
    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {
        var _a;
        const event = clone$2(originalEvent, data);
        event.type = type;
        // Normalize target IE uses srcElement
        if (isNullable(event.target)) {
            event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;
        }
        if (needsNormalizing(originalEvent)) {
            // Add preventDefault method
            event.preventDefault = () => {
                event.defaultPrevented = true;
                event.isDefaultPrevented = always;
                // Execute preventDefault on the original event object
                if (isFunction(originalEvent.preventDefault)) {
                    originalEvent.preventDefault();
                }
            };
            // Add stopPropagation
            event.stopPropagation = () => {
                event.cancelBubble = true;
                event.isPropagationStopped = always;
                // Execute stopPropagation on the original event object
                if (isFunction(originalEvent.stopPropagation)) {
                    originalEvent.stopPropagation();
                }
            };
            // Add stopImmediatePropagation
            event.stopImmediatePropagation = () => {
                event.isImmediatePropagationStopped = always;
                event.stopPropagation();
            };
            // Add event delegation states
            if (!hasIsDefaultPrevented(event)) {
                event.isDefaultPrevented = event.defaultPrevented === true ? always : never;
                event.isPropagationStopped = event.cancelBubble === true ? always : never;
                event.isImmediatePropagationStopped = never;
            }
        }
        return event;
    };

    /**
     * This class wraps the browsers native event logic with more convenient methods.
     *
     * @class tinymce.dom.EventUtils
     */
    const eventExpandoPrefix = 'mce-data-';
    const mouseEventRe = /^(?:mouse|contextmenu)|click/;
    /**
     * Binds a native event to a callback on the speified target.
     */
    const addEvent = (target, name, callback, capture) => {
        target.addEventListener(name, callback, capture || false);
    };
    /**
     * Unbinds a native event callback on the specified target.
     */
    const removeEvent = (target, name, callback, capture) => {
        target.removeEventListener(name, callback, capture || false);
    };
    const isMouseEvent = (event) => isNonNullable(event) && mouseEventRe.test(event.type);
    /**
     * Normalizes a native event object or just adds the event specific methods on a custom event.
     */
    const fix = (originalEvent, data) => {
        const event = normalize$3(originalEvent.type, originalEvent, document, data);
        // Calculate pageX/Y if missing and clientX/Y available
        if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {
            const eventDoc = event.target.ownerDocument || document;
            const doc = eventDoc.documentElement;
            const body = eventDoc.body;
            const mouseEvent = event;
            mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                (doc && doc.clientLeft || body && body.clientLeft || 0);
            mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) -
                (doc && doc.clientTop || body && body.clientTop || 0);
        }
        return event;
    };
    /**
     * Bind a DOMContentLoaded event across browsers and executes the callback once the page DOM is initialized.
     * It will also set/check the domLoaded state of the event_utils instance so ready isn't called multiple times.
     */
    const bindOnReady = (win, callback, eventUtils) => {
        const doc = win.document, event = { type: 'ready' };
        if (eventUtils.domLoaded) {
            callback(event);
            return;
        }
        const isDocReady = () => {
            // Check complete or interactive state if there is a body
            // element on some iframes IE 8 will produce a null body
            return doc.readyState === 'complete' || (doc.readyState === 'interactive' && doc.body);
        };
        // Gets called when the DOM is ready
        const readyHandler = () => {
            removeEvent(win, 'DOMContentLoaded', readyHandler);
            removeEvent(win, 'load', readyHandler);
            if (!eventUtils.domLoaded) {
                eventUtils.domLoaded = true;
                callback(event);
            }
            // Clean memory for IE
            win = null;
        };
        if (isDocReady()) {
            readyHandler();
        }
        else {
            addEvent(win, 'DOMContentLoaded', readyHandler);
        }
        // Fallback if any of the above methods should fail for some odd reason
        if (!eventUtils.domLoaded) {
            addEvent(win, 'load', readyHandler);
        }
    };
    /**
     * This class enables you to bind/unbind native events to elements and normalize it's behavior across browsers.
     */
    class EventUtils {
        constructor() {
            // State if the DOMContentLoaded was executed or not
            this.domLoaded = false;
            this.events = {};
            this.count = 1;
            this.expando = eventExpandoPrefix + (+new Date()).toString(32);
            this.hasFocusIn = 'onfocusin' in document.documentElement;
            this.count = 1;
        }
        bind(target, names, callback, scope) {
            const self = this;
            let callbackList;
            const win = window;
            // Native event handler function patches the event and executes the callbacks for the expando
            const defaultNativeHandler = (evt) => {
                self.executeHandlers(fix(evt || win.event), id);
            };
            // Don't bind to text nodes or comments
            if (!target || isText$b(target) || isComment(target)) {
                return callback;
            }
            // Create or get events id for the target
            let id;
            if (!target[self.expando]) {
                id = self.count++;
                target[self.expando] = id;
                self.events[id] = {};
            }
            else {
                id = target[self.expando];
            }
            // Setup the specified scope or use the target as a default
            scope = scope || target;
            // Split names and bind each event, enables you to bind multiple events with one call
            const namesList = names.split(' ');
            let i = namesList.length;
            while (i--) {
                let name = namesList[i];
                let nativeHandler = defaultNativeHandler;
                let capture = false;
                let fakeName = false;
                // Use ready instead of DOMContentLoaded
                if (name === 'DOMContentLoaded') {
                    name = 'ready';
                }
                // DOM is already ready
                if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {
                    callback.call(scope, fix({ type: name }));
                    continue;
                }
                // Fake bubbling of focusin/focusout
                if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {
                    capture = true;
                    fakeName = name === 'focusin' ? 'focus' : 'blur';
                    nativeHandler = (evt) => {
                        const event = fix(evt || win.event);
                        event.type = event.type === 'focus' ? 'focusin' : 'focusout';
                        self.executeHandlers(event, id);
                    };
                }
                // Setup callback list and bind native event
                callbackList = self.events[id][name];
                if (!callbackList) {
                    self.events[id][name] = callbackList = [{ func: callback, scope }];
                    callbackList.fakeName = fakeName;
                    callbackList.capture = capture;
                    // callbackList.callback = callback;
                    // Add the nativeHandler to the callback list so that we can later unbind it
                    callbackList.nativeHandler = nativeHandler;
                    // Check if the target has native events support
                    if (name === 'ready') {
                        bindOnReady(target, nativeHandler, self);
                    }
                    else {
                        addEvent(target, fakeName || name, nativeHandler, capture);
                    }
                }
                else {
                    if (name === 'ready' && self.domLoaded) {
                        callback(fix({ type: name }));
                    }
                    else {
                        // If it already has an native handler then just push the callback
                        callbackList.push({ func: callback, scope });
                    }
                }
            }
            target = callbackList = null; // Clean memory for IE
            return callback;
        }
        unbind(target, names, callback) {
            // Don't bind to text nodes or comments
            if (!target || isText$b(target) || isComment(target)) {
                return this;
            }
            // Unbind event or events if the target has the expando
            const id = target[this.expando];
            if (id) {
                let eventMap = this.events[id];
                // Specific callback
                if (names) {
                    const namesList = names.split(' ');
                    let i = namesList.length;
                    while (i--) {
                        const name = namesList[i];
                        const callbackList = eventMap[name];
                        // Unbind the event if it exists in the map
                        if (callbackList) {
                            // Remove specified callback
                            if (callback) {
                                let ci = callbackList.length;
                                while (ci--) {
                                    if (callbackList[ci].func === callback) {
                                        const nativeHandler = callbackList.nativeHandler;
                                        const fakeName = callbackList.fakeName, capture = callbackList.capture;
                                        // Clone callbackList since unbind inside a callback would otherwise break the handlers loop
                                        const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                                        newCallbackList.nativeHandler = nativeHandler;
                                        newCallbackList.fakeName = fakeName;
                                        newCallbackList.capture = capture;
                                        eventMap[name] = newCallbackList;
                                    }
                                }
                            }
                            // Remove all callbacks if there isn't a specified callback or there is no callbacks left
                            if (!callback || callbackList.length === 0) {
                                delete eventMap[name];
                                removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
                            }
                        }
                    }
                }
                else {
                    // All events for a specific element
                    each$d(eventMap, (callbackList, name) => {
                        removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
                    });
                    eventMap = {};
                }
                // Check if object is empty, if it isn't then we won't remove the expando map
                for (const name in eventMap) {
                    if (has$2(eventMap, name)) {
                        return this;
                    }
                }
                // Delete event object
                delete this.events[id];
                // Remove expando from target
                try {
                    // IE will fail here since it can't delete properties from window
                    delete target[this.expando];
                }
                catch (_a) {
                    // IE will set it to null
                    target[this.expando] = null;
                }
            }
            return this;
        }
        /**
         * Fires the specified event on the specified target.
         * <br>
         * <em>Deprecated in TinyMCE 6.0 and has been marked for removal in TinyMCE 7.0. Use <code>dispatch</code> instead.</em>
         *
         * @method fire
         * @param {Object} target Target node/window or custom object.
         * @param {String} name Event name to fire.
         * @param {Object} args Optional arguments to send to the observers.
         * @return {EventUtils} Event utils instance.
         * @deprecated Use dispatch() instead
         */
        fire(target, name, args) {
            return this.dispatch(target, name, args);
        }
        /**
         * Dispatches the specified event on the specified target.
         *
         * @method dispatch
         * @param {Node/window} target Target node/window or custom object.
         * @param {String} name Event name to dispatch.
         * @param {Object} args Optional arguments to send to the observers.
         * @return {EventUtils} Event utils instance.
         */
        dispatch(target, name, args) {
            // Don't bind to text nodes or comments
            if (!target || isText$b(target) || isComment(target)) {
                return this;
            }
            // Build event object by patching the args
            const event = fix({ type: name, target }, args);
            do {
                // Found an expando that means there is listeners to execute
                const id = target[this.expando];
                if (id) {
                    this.executeHandlers(event, id);
                }
                // Walk up the DOM
                target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
            } while (target && !event.isPropagationStopped());
            return this;
        }
        /**
         * Removes all bound event listeners for the specified target. This will also remove any bound
         * listeners to child nodes within that target.
         *
         * @method clean
         * @param {Object} target Target node/window object.
         * @return {EventUtils} Event utils instance.
         */
        clean(target) {
            // Don't bind to text nodes or comments
            if (!target || isText$b(target) || isComment(target)) {
                return this;
            }
            // Unbind any element on the specified target
            if (target[this.expando]) {
                this.unbind(target);
            }
            // Target doesn't have getElementsByTagName it's probably a window object then use it's document to find the children
            if (!target.getElementsByTagName) {
                target = target.document;
            }
            // Remove events from each child element
            if (target && target.getElementsByTagName) {
                this.unbind(target);
                const children = target.getElementsByTagName('*');
                let i = children.length;
                while (i--) {
                    target = children[i];
                    if (target[this.expando]) {
                        this.unbind(target);
                    }
                }
            }
            return this;
        }
        /**
         * Destroys the event object. Call this to remove memory leaks.
         */
        destroy() {
            this.events = {};
        }
        // Legacy function for canceling events
        cancel(e) {
            if (e) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }
            return false;
        }
        /**
         * Executes all event handler callbacks for a specific event.
         *
         * @private
         * @param {Event} evt Event object.
         * @param {String} id Expando id value to look for.
         */
        executeHandlers(evt, id) {
            const container = this.events[id];
            const callbackList = container && container[evt.type];
            if (callbackList) {
                for (let i = 0, l = callbackList.length; i < l; i++) {
                    const callback = callbackList[i];
                    // Check if callback exists might be removed if a unbind is called inside the callback
                    if (callback && callback.func.call(callback.scope, evt) === false) {
                        evt.preventDefault();
                    }
                    // Should we stop propagation to immediate listeners
                    if (evt.isImmediatePropagationStopped()) {
                        return;
                    }
                }
            }
        }
    }
    EventUtils.Event = new EventUtils();

    /**
     * Utility class for various DOM manipulation and retrieval functions.
     *
     * @class tinymce.dom.DOMUtils
     * @example
     * // Add a class to an element by id in the page
     * tinymce.DOM.addClass('someid', 'someclass');
     *
     * // Add a class to an element by id inside the editor
     * tinymce.activeEditor.dom.addClass('someid', 'someclass');
     */
    // Shorten names
    const each$a = Tools.each;
    const grep = Tools.grep;
    const internalStyleName = 'data-mce-style';
    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');
    const legacySetAttribute = (elm, name, value) => {
        if (isNullable(value) || value === '') {
            remove$9(elm, name);
        }
        else {
            set$4(elm, name, value);
        }
    };
    // Convert camel cased names back to hyphenated names
    const camelCaseToHyphens = (name) => name.replace(/[A-Z]/g, (v) => '-' + v.toLowerCase());
    const findNodeIndex = (node, normalized) => {
        let idx = 0;
        if (node) {
            for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {
                const nodeType = tempNode.nodeType;
                // Normalize text nodes
                if (normalized && isText$b(tempNode)) {
                    if (nodeType === lastNodeType || !tempNode.data.length) {
                        continue;
                    }
                }
                idx++;
                lastNodeType = nodeType;
            }
        }
        return idx;
    };
    const updateInternalStyleAttr = (styles, elm) => {
        const rawValue = get$9(elm, 'style');
        const value = styles.serialize(styles.parse(rawValue), name(elm));
        legacySetAttribute(elm, internalStyleName, value);
    };
    const convertStyleToString = (cssValue, cssName) => {
        if (isNumber(cssValue)) {
            return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';
        }
        else {
            return cssValue;
        }
    };
    const applyStyle$1 = ($elm, cssName, cssValue) => {
        const normalizedName = camelCaseToHyphens(cssName);
        if (isNullable(cssValue) || cssValue === '') {
            remove$7($elm, normalizedName);
        }
        else {
            set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));
        }
    };
    const setupAttrHooks = (styles, settings, getContext) => {
        const keepValues = settings.keep_values;
        const keepUrlHook = {
            set: (elm, value, name) => {
                const sugarElm = SugarElement.fromDom(elm);
                if (isFunction(settings.url_converter) && isNonNullable(value)) {
                    value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);
                }
                const internalName = 'data-mce-' + name;
                legacySetAttribute(sugarElm, internalName, value);
                legacySetAttribute(sugarElm, name, value);
            },
            get: (elm, name) => {
                const sugarElm = SugarElement.fromDom(elm);
                return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);
            }
        };
        const attrHooks = {
            style: {
                set: (elm, value) => {
                    const sugarElm = SugarElement.fromDom(elm);
                    if (keepValues) {
                        legacySetAttribute(sugarElm, internalStyleName, value);
                    }
                    remove$9(sugarElm, 'style');
                    // If setting a style then delegate to the css api, otherwise
                    // this will cause issues when using a content security policy
                    if (isString(value)) {
                        setAll(sugarElm, styles.parse(value));
                    }
                },
                get: (elm) => {
                    const sugarElm = SugarElement.fromDom(elm);
                    const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');
                    return styles.serialize(styles.parse(value), name(sugarElm));
                }
            }
        };
        if (keepValues) {
            attrHooks.href = attrHooks.src = keepUrlHook;
        }
        return attrHooks;
    };
    /**
     * Constructs a new DOMUtils instance. Consult the TinyMCE Documentation for more details on settings etc for this class.
     *
     * @private
     * @constructor
     * @method DOMUtils
     * @param {Document} doc Document reference to bind the utility class to.
     * @param {settings} settings Optional settings collection.
     */
    const DOMUtils = (doc, settings = {}) => {
        const addedStyles = {};
        const win = window;
        const files = {};
        let counter = 0;
        const stdMode = true;
        const boxModel = true;
        const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {
            contentCssCors: settings.contentCssCors,
            referrerPolicy: settings.referrerPolicy,
            crossOrigin: (url) => {
                const crossOrigin = settings.crossOrigin;
                if (isFunction(crossOrigin)) {
                    return crossOrigin(url, 'stylesheet');
                }
                else {
                    return undefined;
                }
            }
        });
        const boundEvents = [];
        const schema = settings.schema ? settings.schema : Schema({});
        const styles = Styles({
            url_converter: settings.url_converter,
            url_converter_scope: settings.url_converter_scope,
        }, settings.schema);
        const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
        const blockElementsMap = schema.getBlockElements();
        /**
         * Returns true/false if the specified element is a block element or not.
         *
         * @method isBlock
         * @param {Node/String} node Element/Node to check.
         * @return {Boolean} True/False state if the node is a block element or not.
         */
        const isBlock = (node) => {
            if (isString(node)) {
                return has$2(blockElementsMap, node);
            }
            else {
                return isElement$7(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));
            }
        };
        const get = (elm) => elm && doc && isString(elm)
            ? doc.getElementById(elm)
            : elm;
        const _get = (elm) => {
            const value = get(elm);
            return isNonNullable(value) ? SugarElement.fromDom(value) : null;
        };
        const getAttrib = (elm, name, defaultVal = '') => {
            let value;
            const $elm = _get(elm);
            if (isNonNullable($elm) && isElement$8($elm)) {
                const hook = attrHooks[name];
                if (hook && hook.get) {
                    value = hook.get($elm.dom, name);
                }
                else {
                    value = get$9($elm, name);
                }
            }
            return isNonNullable(value) ? value : defaultVal;
        };
        const getAttribs = (elm) => {
            const node = get(elm);
            return isNullable(node) ? [] : node.attributes;
        };
        const setAttrib = (elm, name, value) => {
            run(elm, (e) => {
                if (isElement$7(e)) {
                    const $elm = SugarElement.fromDom(e);
                    const val = value === '' ? null : value;
                    const originalValue = get$9($elm, name);
                    const hook = attrHooks[name];
                    if (hook && hook.set) {
                        hook.set($elm.dom, val, name);
                    }
                    else {
                        legacySetAttribute($elm, name, val);
                    }
                    if (originalValue !== val && settings.onSetAttrib) {
                        settings.onSetAttrib({
                            attrElm: $elm.dom, // We lie here to not break backwards compatibility
                            attrName: name,
                            attrValue: val
                        });
                    }
                }
            });
        };
        const clone = (node, deep) => {
            return node.cloneNode(deep);
        };
        const getRoot = () => settings.root_element || doc.body;
        const getViewPort = (argWin) => {
            const vp = getBounds(argWin);
            // Returns viewport size excluding scrollbars
            return {
                x: vp.x,
                y: vp.y,
                w: vp.width,
                h: vp.height
            };
        };
        const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);
        const setStyle = (elm, name, value) => {
            run(elm, (e) => {
                const $elm = SugarElement.fromDom(e);
                applyStyle$1($elm, name, value);
                if (settings.update_styles) {
                    updateInternalStyleAttr(styles, $elm);
                }
            });
        };
        const setStyles = (elm, stylesArg) => {
            run(elm, (e) => {
                const $elm = SugarElement.fromDom(e);
                each$d(stylesArg, (v, n) => {
                    applyStyle$1($elm, n, v);
                });
                if (settings.update_styles) {
                    updateInternalStyleAttr(styles, $elm);
                }
            });
        };
        const getStyle = (elm, name, computed) => {
            const $elm = get(elm);
            if (isNullable($elm) || (!isHTMLElement($elm) && !isSVGElement($elm))) {
                return undefined;
            }
            if (computed) {
                return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));
            }
            else {
                // Camelcase it, if needed
                name = name.replace(/-(\D)/g, (a, b) => b.toUpperCase());
                if (name === 'float') {
                    name = 'cssFloat';
                }
                return $elm.style ? $elm.style[name] : undefined;
            }
        };
        const getSize = (elm) => {
            const $elm = get(elm);
            if (!$elm) {
                return { w: 0, h: 0 };
            }
            let w = getStyle($elm, 'width');
            let h = getStyle($elm, 'height');
            // Non pixel value, then force offset/clientWidth
            if (!w || w.indexOf('px') === -1) {
                w = '0';
            }
            // Non pixel value, then force offset/clientWidth
            if (!h || h.indexOf('px') === -1) {
                h = '0';
            }
            return {
                w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,
                h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight
            };
        };
        const getRect = (elm) => {
            const $elm = get(elm);
            const pos = getPos$1($elm);
            const size = getSize($elm);
            return {
                x: pos.x, y: pos.y,
                w: size.w, h: size.h
            };
        };
        const is = (elm, selector) => {
            if (!elm) {
                return false;
            }
            const elms = isArray$1(elm) ? elm : [elm];
            return exists(elms, (e) => {
                return is$2(SugarElement.fromDom(e), selector);
            });
        };
        const getParents = (elm, selector, root, collect) => {
            const result = [];
            let node = get(elm);
            collect = collect === undefined;
            // Default root on inline mode
            const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);
            // Wrap node name as func
            if (isString(selector)) {
                if (selector === '*') {
                    selector = isElement$7;
                }
                else {
                    const selectorVal = selector;
                    selector = (node) => is(node, selectorVal);
                }
            }
            while (node) {
                // TODO: Remove nullable check once TINY-6599 is complete
                if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {
                    break;
                }
                if (!selector || selector(node)) {
                    if (collect) {
                        result.push(node);
                    }
                    else {
                        return [node];
                    }
                }
                node = node.parentNode;
            }
            return collect ? result : null;
        };
        const getParent = (node, selector, root) => {
            const parents = getParents(node, selector, root, false);
            return parents && parents.length > 0 ? parents[0] : null;
        };
        const _findSib = (node, selector, name) => {
            let func = selector;
            if (node) {
                // If expression make a function of it using is
                if (isString(selector)) {
                    func = (node) => {
                        return is(node, selector);
                    };
                }
                // Loop all siblings
                for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {
                    if (isFunction(func) && func(tempNode)) {
                        return tempNode;
                    }
                }
            }
            return null;
        };
        const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');
        const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');
        const isParentNode = (node) => isFunction(node.querySelectorAll);
        const select = (selector, scope) => {
            var _a, _b;
            const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;
            return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];
        };
        const run = function (elm, func, scope) {
            const context = scope !== null && scope !== void 0 ? scope : this;
            if (isArray$1(elm)) {
                const result = [];
                each$a(elm, (e, i) => {
                    const node = get(e);
                    if (node) {
                        result.push(func.call(context, node, i));
                    }
                });
                return result;
            }
            else {
                const node = get(elm);
                return !node ? false : func.call(context, node);
            }
        };
        const setAttribs = (elm, attrs) => {
            run(elm, ($elm) => {
                each$d(attrs, (value, name) => {
                    setAttrib($elm, name, value);
                });
            });
        };
        const setHTML = (elm, html) => {
            run(elm, (e) => {
                const $elm = SugarElement.fromDom(e);
                set$3($elm, html);
            });
        };
        const add = (parentElm, name, attrs, html, create) => run(parentElm, (parentElm) => {
            const newElm = isString(name) ? doc.createElement(name) : name;
            if (isNonNullable(attrs)) {
                setAttribs(newElm, attrs);
            }
            if (html) {
                if (!isString(html) && html.nodeType) {
                    newElm.appendChild(html);
                }
                else if (isString(html)) {
                    setHTML(newElm, html);
                }
            }
            return !create ? parentElm.appendChild(newElm) : newElm;
        });
        const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);
        const decode = Entities.decode;
        const encode = Entities.encodeAllRaw;
        const createHTML = (name, attrs, html = '') => {
            let outHtml = '<' + name;
            for (const key in attrs) {
                if (hasNonNullableKey(attrs, key)) {
                    outHtml += ' ' + key + '="' + encode(attrs[key]) + '"';
                }
            }
            if (isEmpty$5(html) && has$2(schema.getVoidElements(), name)) {
                return outHtml + ' />';
            }
            else {
                return outHtml + '>' + html + '</' + name + '>';
            }
        };
        const createFragment = (html) => {
            const container = doc.createElement('div');
            const frag = doc.createDocumentFragment();
            // Append the container to the fragment so as to remove it from
            // the current document context
            frag.appendChild(container);
            if (html) {
                container.innerHTML = html;
            }
            let node;
            while ((node = container.firstChild)) {
                frag.appendChild(node);
            }
            // Remove the container now that all the children have been transferred
            frag.removeChild(container);
            return frag;
        };
        const remove = (node, keepChildren) => {
            return run(node, (n) => {
                const $node = SugarElement.fromDom(n);
                if (keepChildren) {
                    // Unwrap but don't keep any empty text nodes
                    each$e(children$1($node), (child) => {
                        if (isText$c(child) && child.dom.length === 0) {
                            remove$8(child);
                        }
                        else {
                            before$4($node, child);
                        }
                    });
                }
                remove$8($node);
                return $node.dom;
            });
        };
        const removeAllAttribs = (e) => run(e, (e) => {
            const attrs = e.attributes;
            for (let i = attrs.length - 1; i >= 0; i--) {
                e.removeAttributeNode(attrs.item(i));
            }
        });
        const parseStyle = (cssText) => styles.parse(cssText);
        const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);
        const addStyle = (cssText) => {
            // Prevent inline from loading the same styles twice
            if (self !== DOMUtils.DOM && doc === document) {
                if (addedStyles[cssText]) {
                    return;
                }
                addedStyles[cssText] = true;
            }
            // Create style element if needed
            let styleElm = doc.getElementById('mceDefaultStyles');
            if (!styleElm) {
                styleElm = doc.createElement('style');
                styleElm.id = 'mceDefaultStyles';
                styleElm.type = 'text/css';
                const head = doc.head;
                if (head.firstChild) {
                    head.insertBefore(styleElm, head.firstChild);
                }
                else {
                    head.appendChild(styleElm);
                }
            }
            // Append style data to old or new style element
            if (styleElm.styleSheet) {
                styleElm.styleSheet.cssText += cssText;
            }
            else {
                styleElm.appendChild(doc.createTextNode(cssText));
            }
        };
        const loadCSS = (urls) => {
            if (!urls) {
                urls = '';
            }
            each$e(urls.split(','), (url) => {
                files[url] = true;
                styleSheetLoader.load(url).catch(noop);
            });
        };
        const toggleClass = (elm, cls, state) => {
            run(elm, (e) => {
                if (isElement$7(e)) {
                    const $elm = SugarElement.fromDom(e);
                    // TINY-4520: DomQuery used to handle specifying multiple classes and the
                    // formatter relies on it due to the changes made for TINY-7227
                    const classes = cls.split(' ');
                    each$e(classes, (c) => {
                        if (isNonNullable(state)) {
                            const fn = state ? add$2 : remove$4;
                            fn($elm, c);
                        }
                        else {
                            toggle$1($elm, c);
                        }
                    });
                }
            });
        };
        const addClass = (elm, cls) => {
            toggleClass(elm, cls, true);
        };
        const removeClass = (elm, cls) => {
            toggleClass(elm, cls, false);
        };
        const hasClass = (elm, cls) => {
            const $elm = _get(elm);
            // TINY-4520: DomQuery used to handle specifying multiple classes and the
            // formatter relies on it due to the changes made for TINY-7227
            const classes = cls.split(' ');
            return isNonNullable($elm) && forall(classes, (c) => has($elm, c));
        };
        const show = (elm) => {
            run(elm, (e) => remove$7(SugarElement.fromDom(e), 'display'));
        };
        const hide = (elm) => {
            run(elm, (e) => set$2(SugarElement.fromDom(e), 'display', 'none'));
        };
        const isHidden = (elm) => {
            const $elm = _get(elm);
            return isNonNullable($elm) && is$4(getRaw$1($elm, 'display'), 'none');
        };
        const uniqueId = (prefix) => (!prefix ? 'mce_' : prefix) + (counter++);
        const getOuterHTML = (elm) => {
            const $elm = _get(elm);
            if (isNonNullable($elm)) {
                return isElement$7($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);
            }
            else {
                return '';
            }
        };
        const setOuterHTML = (elm, html) => {
            run(elm, ($elm) => {
                if (isElement$7($elm)) {
                    $elm.outerHTML = html;
                }
            });
        };
        const insertAfter = (node, reference) => {
            const referenceNode = get(reference);
            return run(node, (node) => {
                const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;
                const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;
                if (parent) {
                    if (nextSibling) {
                        parent.insertBefore(node, nextSibling);
                    }
                    else {
                        parent.appendChild(node);
                    }
                }
                return node;
            });
        };
        const replace = (newElm, oldElm, keepChildren) => run(oldElm, (elm) => {
            var _a;
            const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;
            if (keepChildren) {
                each$a(grep(elm.childNodes), (node) => {
                    replacee.appendChild(node);
                });
            }
            (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);
            return elm;
        });
        const rename = (elm, name) => {
            if (elm.nodeName !== name.toUpperCase()) {
                // Rename block element
                const newElm = create(name);
                // Copy attribs to new block
                each$a(getAttribs(elm), (attrNode) => {
                    setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
                });
                // Replace block
                replace(newElm, elm, true);
                return newElm;
            }
            else {
                return elm;
            }
        };
        const findCommonAncestor = (a, b) => {
            let ps = a;
            while (ps) {
                let pe = b;
                while (pe && ps !== pe) {
                    pe = pe.parentNode;
                }
                if (ps === pe) {
                    break;
                }
                ps = ps.parentNode;
            }
            if (!ps && a.ownerDocument) {
                return a.ownerDocument.documentElement;
            }
            else {
                return ps;
            }
        };
        const isEmpty = (node, elements, options) => {
            if (isPlainObject(elements)) {
                const isContent = (node) => {
                    const name = node.nodeName.toLowerCase();
                    return Boolean(elements[name]);
                };
                return isEmptyNode(schema, node, { ...options, isContent });
            }
            else {
                return isEmptyNode(schema, node, options);
            }
        };
        const createRng = () => doc.createRange();
        const split = (parentElm, splitElm, replacementElm) => {
            let range = createRng();
            let beforeFragment;
            let afterFragment;
            if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {
                const parentNode = parentElm.parentNode;
                // Get before chunk
                range.setStart(parentNode, findNodeIndex(parentElm));
                range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
                beforeFragment = range.extractContents();
                // Get after chunk
                range = createRng();
                range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
                range.setEnd(parentNode, findNodeIndex(parentElm) + 1);
                afterFragment = range.extractContents();
                // Insert before chunk
                parentNode.insertBefore(trimNode(self, beforeFragment, schema), parentElm);
                // Insert middle chunk
                if (replacementElm) {
                    parentNode.insertBefore(replacementElm, parentElm);
                    // pa.replaceChild(replacementElm, splitElm);
                }
                else {
                    parentNode.insertBefore(splitElm, parentElm);
                }
                // Insert after chunk
                parentNode.insertBefore(trimNode(self, afterFragment, schema), parentElm);
                remove(parentElm);
                return replacementElm || splitElm;
            }
            else {
                return undefined;
            }
        };
        const bind = (target, name, func, scope) => {
            if (isArray$1(target)) {
                let i = target.length;
                const rv = [];
                while (i--) {
                    rv[i] = bind(target[i], name, func, scope);
                }
                return rv;
            }
            else {
                // Collect all window/document events bound by editor instance
                if (settings.collect && (target === doc || target === win)) {
                    boundEvents.push([target, name, func, scope]);
                }
                return events.bind(target, name, func, scope || self);
            }
        };
        const unbind = (target, name, func) => {
            if (isArray$1(target)) {
                let i = target.length;
                const rv = [];
                while (i--) {
                    rv[i] = unbind(target[i], name, func);
                }
                return rv;
            }
            else {
                // Remove any bound events matching the input
                if (boundEvents.length > 0 && (target === doc || target === win)) {
                    let i = boundEvents.length;
                    while (i--) {
                        const [boundTarget, boundName, boundFunc] = boundEvents[i];
                        if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {
                            events.unbind(boundTarget, boundName, boundFunc);
                        }
                    }
                }
                return events.unbind(target, name, func);
            }
        };
        const dispatch = (target, name, evt) => events.dispatch(target, name, evt);
        const fire = (target, name, evt) => events.dispatch(target, name, evt);
        const getContentEditable = (node) => {
            if (node && isHTMLElement(node)) {
                // Check for fake content editable
                const contentEditable = node.getAttribute('data-mce-contenteditable');
                if (contentEditable && contentEditable !== 'inherit') {
                    return contentEditable;
                }
                // Check for real content editable
                return node.contentEditable !== 'inherit' ? node.contentEditable : null;
            }
            else {
                return null;
            }
        };
        const getContentEditableParent = (node) => {
            const root = getRoot();
            let state = null;
            for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
                state = getContentEditable(tempNode);
                if (state !== null) {
                    break;
                }
            }
            return state;
        };
        const isEditable = (node) => {
            if (isNonNullable(node)) {
                const scope = isElement$7(node) ? node : node.parentElement;
                return isNonNullable(scope) && isHTMLElement(scope) && isEditable$2(SugarElement.fromDom(scope));
            }
            else {
                return false;
            }
        };
        const destroy = () => {
            // Unbind all events bound to window/document by editor instance
            if (boundEvents.length > 0) {
                let i = boundEvents.length;
                while (i--) {
                    const [boundTarget, boundName, boundFunc] = boundEvents[i];
                    events.unbind(boundTarget, boundName, boundFunc);
                }
            }
            // Remove CSS files added to the dom
            each$d(files, (_, url) => {
                styleSheetLoader.unload(url);
                delete files[url];
            });
        };
        const isChildOf = (node, parent) => {
            return node === parent || parent.contains(node);
        };
        const dumpRng = (r) => ('startContainer: ' + r.startContainer.nodeName +
            ', startOffset: ' + r.startOffset +
            ', endContainer: ' + r.endContainer.nodeName +
            ', endOffset: ' + r.endOffset);
        // eslint-disable-next-line consistent-this
        const self = {
            doc,
            settings,
            win,
            files,
            stdMode,
            boxModel,
            styleSheetLoader,
            boundEvents,
            styles,
            schema,
            events,
            isBlock: isBlock,
            root: null,
            clone,
            /**
             * Returns the root node of the document. This is normally the body but might be a DIV. Parents like getParent will not
             * go above the point of this root node.
             *
             * @method getRoot
             * @return {Element} Root element for the utility class.
             */
            getRoot,
            /**
             * Returns the viewport of the window.
             *
             * @method getViewPort
             * @param {Window} win Optional window to get viewport of.
             * @return {Object} Viewport object with fields x, y, w and h.
             */
            getViewPort,
            /**
             * Returns the rectangle for a specific element.
             *
             * @method getRect
             * @param {Element/String} elm Element object or element ID to get rectangle from.
             * @return {Object} Rectangle for specified element object with x, y, w, h fields.
             */
            getRect,
            /**
             * Returns the size dimensions of the specified element.
             *
             * @method getSize
             * @param {Element/String} elm Element object or element ID to get rectangle from.
             * @return {Object} Rectangle for specified element object with w, h fields.
             */
            getSize,
            /**
             * Returns a node by the specified selector function. This function will
             * loop through all parent nodes and call the specified function for each node.
             * If the function then returns true indicating that it has found what it was looking for, the loop execution will then end
             * and the node it found will be returned.
             *
             * @method getParent
             * @param {Node/String} node DOM node to search parents on or ID string.
             * @param {Function} selector Selection function or CSS selector to execute on each node.
             * @param {Node} root Optional root element, never go beyond this point.
             * @return {Node} DOM Node or null if it wasn't found.
             */
            getParent,
            /**
             * Returns a node list of all parents matching the specified selector function or pattern.
             * If the function then returns true indicating that it has found what it was looking for and that node will be collected.
             *
             * @method getParents
             * @param {Node/String} node DOM node to search parents on or ID string.
             * @param {Function} selector Selection function to execute on each node or CSS pattern.
             * @param {Node} root Optional root element, never go beyond this point.
             * @return {Array} Array of nodes or null if it wasn't found.
             */
            getParents: getParents,
            /**
             * Returns the specified element by ID or the input element if it isn't a string.
             *
             * @method get
             * @param {String/Element} n Element id to look for or element to just pass though.
             * @return {Element} Element matching the specified id or null if it wasn't found.
             */
            get,
            /**
             * Returns the next node that matches selector or function
             *
             * @method getNext
             * @param {Node} node Node to find siblings from.
             * @param {String/function} selector Selector CSS expression or function.
             * @return {Node} Next node item matching the selector or null if it wasn't found.
             */
            getNext,
            /**
             * Returns the previous node that matches selector or function
             *
             * @method getPrev
             * @param {Node} node Node to find siblings from.
             * @param {String/function} selector Selector CSS expression or function.
             * @return {Node} Previous node item matching the selector or null if it wasn't found.
             */
            getPrev,
            // #ifndef jquery
            /**
             * Returns a list of the elements specified by the given CSS selector. For example: `div#a1 p.test`
             *
             * @method select
             * @param {String} selector Target CSS selector.
             * @param {Object} scope Optional root element/scope element to search in.
             * @return {Array} Array with all matched elements.
             * @example
             * // Adds a class to all paragraphs in the currently active editor
             * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
             *
             * // Adds a class to all spans that have the test class in the currently active editor
             * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('span.test'), 'someclass')
             */
            select,
            /**
             * Returns true/false if the specified element matches the specified css pattern.
             *
             * @method is
             * @param {Node/NodeList} elm DOM node to match or an array of nodes to match.
             * @param {String} selector CSS pattern to match the element against.
             */
            is,
            // #endif
            /**
             * Adds the specified element to another element or elements.
             *
             * @method add
             * @param {String/Element/Array} parentElm Element id string, DOM node element or array of ids or elements to add to.
             * @param {String/Element} name Name of new element to add or existing element to add.
             * @param {Object} attrs Optional object collection with arguments to add to the new element(s).
             * @param {String} html Optional inner HTML contents to add for each element.
             * @param {Boolean} create Optional flag if the element should be created or added.
             * @return {Element/Array} Element that got created, or an array of created elements if multiple input elements
             * were passed in.
             * @example
             * // Adds a new paragraph to the end of the active editor
             * tinymce.activeEditor.dom.add(tinymce.activeEditor.getBody(), 'p', { title: 'my title' }, 'Some content');
             */
            add,
            /**
             * Creates a new element.
             *
             * @method create
             * @param {String} name Name of new element.
             * @param {Object} attrs Optional object name/value collection with element attributes.
             * @param {String} html Optional HTML string to set as inner HTML of the element.
             * @return {Element} HTML DOM node element that got created.
             * @example
             * // Adds an element where the caret/selection is in the active editor
             * var el = tinymce.activeEditor.dom.create('div', { id: 'test', 'class': 'myclass' }, 'some content');
             * tinymce.activeEditor.selection.setNode(el);
             */
            create,
            /**
             * Creates HTML string for element. The element will be closed unless an empty inner HTML string is passed in.
             *
             * @method createHTML
             * @param {String} name Name of new element.
             * @param {Object} attrs Optional object name/value collection with element attributes.
             * @param {String} html Optional HTML string to set as inner HTML of the element.
             * @return {String} String with new HTML element, for example: <a href="#">test</a>.
             * @example
             * // Creates a html chunk and inserts it at the current selection/caret location
             * tinymce.activeEditor.insertContent(tinymce.activeEditor.dom.createHTML('a', { href: 'test.html' }, 'some line'));
             */
            createHTML,
            /**
             * Creates a document fragment out of the specified HTML string.
             *
             * @method createFragment
             * @param {String} html Html string to create fragment from.
             * @return {DocumentFragment} Document fragment node.
             */
            createFragment,
            /**
             * Removes/deletes the specified element(s) from the DOM.
             *
             * @method remove
             * @param {String/Element/Array} node ID of element or DOM element object or array containing multiple elements/ids.
             * @param {Boolean} keepChildren Optional state to keep children or not. If set to true all children will be
             * placed at the location of the removed element.
             * @return {Element/Array} HTML DOM element that got removed, or an array of removed elements if multiple input elements
             * were passed in.
             * @example
             * // Removes all paragraphs in the active editor
             * tinymce.activeEditor.dom.remove(tinymce.activeEditor.dom.select('p'));
             *
             * // Removes an element by id in the document
             * tinymce.DOM.remove('mydiv');
             */
            remove,
            /**
             * Sets the CSS style value on a HTML element. The name can be a camelcase string
             * or the CSS style name like background-color.
             *
             * @method setStyle
             * @param {String/Element/Array} elm HTML element/Array of elements to set CSS style value on.
             * @param {String} name Name of the style value to set.
             * @param {String} value Value to set on the style.
             * @example
             * // Sets a style value on all paragraphs in the currently active editor
             * tinymce.activeEditor.dom.setStyle(tinymce.activeEditor.dom.select('p'), 'background-color', 'red');
             *
             * // Sets a style value to an element by id in the current document
             * tinymce.DOM.setStyle('mydiv', 'background-color', 'red');
             */
            setStyle,
            /**
             * Returns the current style or runtime/computed value of an element.
             *
             * @method getStyle
             * @param {String/Element} elm HTML element or element id string to get style from.
             * @param {String} name Style name to return.
             * @param {Boolean} computed Computed style.
             * @return {String} Current style or computed style value of an element.
             */
            getStyle: getStyle,
            /**
             * Sets multiple styles on the specified element(s).
             *
             * @method setStyles
             * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set styles on.
             * @param {Object} styles Name/Value collection of style items to add to the element(s).
             * @example
             * // Sets styles on all paragraphs in the currently active editor
             * tinymce.activeEditor.dom.setStyles(tinymce.activeEditor.dom.select('p'), { 'background-color': 'red', 'color': 'green' });
             *
             * // Sets styles to an element by id in the current document
             * tinymce.DOM.setStyles('mydiv', { 'background-color': 'red', 'color': 'green' });
             */
            setStyles,
            /**
             * Removes all attributes from an element or elements.
             *
             * @method removeAllAttribs
             * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to remove attributes from.
             */
            removeAllAttribs,
            /**
             * Sets the specified attribute of an element or elements.
             *
             * @method setAttrib
             * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attribute on.
             * @param {String} name Name of attribute to set.
             * @param {String} value Value to set on the attribute - if this value is falsy like null, 0 or '' it will remove
             * the attribute instead.
             * @example
             * // Sets class attribute on all paragraphs in the active editor
             * tinymce.activeEditor.dom.setAttrib(tinymce.activeEditor.dom.select('p'), 'class', 'myclass');
             *
             * // Sets class attribute on a specific element in the current page
             * tinymce.dom.setAttrib('mydiv', 'class', 'myclass');
             */
            setAttrib,
            /**
             * Sets two or more specified attributes of an element or elements.
             *
             * @method setAttribs
             * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attributes on.
             * @param {Object} attrs Name/Value collection of attribute items to add to the element(s).
             * @example
             * // Sets class and title attributes on all paragraphs in the active editor
             * tinymce.activeEditor.dom.setAttribs(tinymce.activeEditor.dom.select('p'), { 'class': 'myclass', title: 'some title' });
             *
             * // Sets class and title attributes on a specific element in the current page
             * tinymce.DOM.setAttribs('mydiv', { 'class': 'myclass', title: 'some title' });
             */
            setAttribs,
            /**
             * Returns the specified attribute by name.
             *
             * @method getAttrib
             * @param {String/Element} elm Element string id or DOM element to get attribute from.
             * @param {String} name Name of attribute to get.
             * @param {String} defaultVal Optional default value to return if the attribute didn't exist.
             * @return {String} Attribute value string, default value or null if the attribute wasn't found.
             */
            getAttrib,
            /**
             * Returns the absolute x, y position of a node. The position will be returned in an object with x, y fields.
             *
             * @method getPos
             * @param {Element/String} elm HTML element or element id to get x, y position from.
             * @param {Element} rootElm Optional root element to stop calculations at.
             * @return {Object} Absolute position of the specified element object with x, y fields.
             */
            getPos: getPos$1,
            /**
             * Parses the specified style value into an object collection. This parser will also
             * merge and remove any redundant items that browsers might have added. It will also convert non-hex
             * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
             *
             * @method parseStyle
             * @param {String} cssText Style value to parse, for example: border:1px solid red;.
             * @return {Object} Object representation of that style, for example: {border: '1px solid red'}
             */
            parseStyle,
            /**
             * Serializes the specified style object into a string.
             *
             * @method serializeStyle
             * @param {Object} styles Object to serialize as string, for example: {border: '1px solid red'}
             * @param {String} name Optional element name.
             * @return {String} String representation of the style object, for example: border: 1px solid red.
             */
            serializeStyle,
            /**
             * Adds a style element at the top of the document with the specified cssText content.
             *
             * @method addStyle
             * @param {String} cssText CSS Text style to add to top of head of document.
             */
            addStyle,
            /**
             * Imports/loads the specified CSS file into the document bound to the class.
             *
             * @method loadCSS
             * @param {String} url URL to CSS file to load.
             * @example
             * // Loads a CSS file dynamically into the current document
             * tinymce.DOM.loadCSS('somepath/some.css');
             *
             * // Loads a CSS file into the currently active editor instance
             * tinymce.activeEditor.dom.loadCSS('somepath/some.css');
             *
             * // Loads a CSS file into an editor instance by id
             * tinymce.get('someid').dom.loadCSS('somepath/some.css');
             *
             * // Loads multiple CSS files into the current document
             * tinymce.DOM.loadCSS('somepath/some.css,somepath/someother.css');
             */
            loadCSS,
            /**
             * Adds a class to the specified element or elements.
             *
             * @method addClass
             * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
             * @param {String} cls Class name to add to each element.
             * @return {String/Array} String with new class value or array with new class values for all elements.
             * @example
             * // Adds a class to all paragraphs in the active editor
             * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'myclass');
             *
             * // Adds a class to a specific element in the current page
             * tinymce.DOM.addClass('mydiv', 'myclass');
             */
            addClass,
            /**
             * Removes a class from the specified element or elements.
             *
             * @method removeClass
             * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
             * @param {String} cls Class name to remove from each element.
             * @return {String/Array} String of remaining class name(s), or an array of strings if multiple input elements
             * were passed in.
             * @example
             * // Removes a class from all paragraphs in the active editor
             * tinymce.activeEditor.dom.removeClass(tinymce.activeEditor.dom.select('p'), 'myclass');
             *
             * // Removes a class from a specific element in the current page
             * tinymce.DOM.removeClass('mydiv', 'myclass');
             */
            removeClass,
            /**
             * Returns true if the specified element has the specified class.
             *
             * @method hasClass
             * @param {String/Element} elm HTML element or element id string to check CSS class on.
             * @param {String} cls CSS class to check for.
             * @return {Boolean} true/false if the specified element has the specified class.
             */
            hasClass,
            /**
             * Toggles the specified class on/off.
             *
             * @method toggleClass
             * @param {Element} elm Element to toggle class on.
             * @param {String} cls Class to toggle on/off.
             * @param {Boolean} state Optional state to set.
             */
            toggleClass,
            /**
             * Shows the specified element(s) by ID by setting the "display" style.
             *
             * @method show
             * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to show.
             */
            show,
            /**
             * Hides the specified element(s) by ID by setting the "display" style.
             *
             * @method hide
             * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to hide.
             * @example
             * // Hides an element by id in the document
             * tinymce.DOM.hide('myid');
             */
            hide,
            /**
             * Returns true/false if the element is hidden or not by checking the "display" style.
             *
             * @method isHidden
             * @param {String/Element} elm Id or element to check display state on.
             * @return {Boolean} true/false if the element is hidden or not.
             */
            isHidden,
            /**
             * Returns a unique id. This can be useful when generating elements on the fly.
             * This method will not check if the element already exists.
             *
             * @method uniqueId
             * @param {String} prefix Optional prefix to add in front of all ids - defaults to "mce_".
             * @return {String} Unique id.
             */
            uniqueId,
            /**
             * Sets the specified HTML content inside the element or elements. The HTML will first be processed. This means
             * URLs will get converted, hex color values fixed etc. Check processHTML for details.
             *
             * @method setHTML
             * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set HTML inside of.
             * @param {String} html HTML content to set as inner HTML of the element.
             * @example
             * // Sets the inner HTML of all paragraphs in the active editor
             * tinymce.activeEditor.dom.setHTML(tinymce.activeEditor.dom.select('p'), 'some inner html');
             *
             * // Sets the inner HTML of an element by id in the document
             * tinymce.DOM.setHTML('mydiv', 'some inner html');
             */
            setHTML,
            /**
             * Returns the outer HTML of an element.
             *
             * @method getOuterHTML
             * @param {String/Element} elm Element ID or element object to get outer HTML from.
             * @return {String} Outer HTML string.
             * @example
             * tinymce.DOM.getOuterHTML(editorElement);
             * tinymce.activeEditor.getOuterHTML(tinymce.activeEditor.getBody());
             */
            getOuterHTML,
            /**
             * Sets the specified outer HTML on an element or elements.
             *
             * @method setOuterHTML
             * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set outer HTML on.
             * @param {Object} html HTML code to set as outer value for the element.
             * @example
             * // Sets the outer HTML of all paragraphs in the active editor
             * tinymce.activeEditor.dom.setOuterHTML(tinymce.activeEditor.dom.select('p'), '<div>some html</div>');
             *
             * // Sets the outer HTML of an element by id in the document
             * tinymce.DOM.setOuterHTML('mydiv', '<div>some html</div>');
             */
            setOuterHTML,
            /**
             * Entity decodes a string. This method decodes any HTML entities, such as `&amp;aring;`.
             *
             * @method decode
             * @param {String} s String to decode entities on.
             * @return {String} Entity decoded string.
             */
            decode,
            /**
             * Entity encodes a string. This method encodes the most common entities, such as `<`, `>`, `"` and `&`.
             *
             * @method encode
             * @param {String} text String to encode with entities.
             * @return {String} Entity encoded string.
             */
            encode,
            /**
             * Inserts an element after the reference element.
             *
             * @method insertAfter
             * @param {Element} node Element to insert after the reference.
             * @param {Element/String/Array} referenceNode Reference element, element id or array of elements to insert after.
             * @return {Element/Array} Element that got added or an array with elements.
             */
            insertAfter,
            /**
             * Replaces the specified element or elements with the new element specified. The new element will
             * be cloned if multiple input elements are passed in.
             *
             * @method replace
             * @param {Element} newElm New element to replace old ones with.
             * @param {Element/String/Array} oldElm Element DOM node, element id or array of elements or ids to replace.
             * @param {Boolean} keepChildren Optional keep children state, if set to true child nodes from the old object will be added
             * to new ones.
             */
            replace,
            /**
             * Renames the specified element and keeps its attributes and children.
             *
             * @method rename
             * @param {Element} elm Element to rename.
             * @param {String} name Name of the new element.
             * @return {Element} New element or the old element if it needed renaming.
             */
            rename,
            /**
             * Find the common ancestor of two elements. This is a shorter method than using the DOM Range logic.
             *
             * @method findCommonAncestor
             * @param {Element} a Element to find common ancestor of.
             * @param {Element} b Element to find common ancestor of.
             * @return {Element} Common ancestor element of the two input elements.
             */
            findCommonAncestor,
            /**
             * Executes the specified function on the element by id or dom element node or array of elements/id.
             *
             * @method run
             * @param {String/Element/Array} elm ID or DOM element object or array with ids or elements.
             * @param {Function} func Function to execute for each item.
             * @param {Object} scope Optional scope to execute the function in.
             * @return {Object/Array} Single object, or an array of objects if multiple input elements were passed in.
             */
            run,
            /**
             * Returns a NodeList with attributes for the element.
             *
             * @method getAttribs
             * @param {HTMLElement/string} elm Element node or string id to get attributes from.
             * @return {NodeList} NodeList with attributes.
             */
            getAttribs,
            /**
             * Returns true/false if the specified node is to be considered empty or not.
             *
             * @method isEmpty
             * @param {Node} node The target node to check if it's empty.
             * @param {Object} elements Optional name/value object with elements that are automatically treated as non-empty elements.
             * @return {Boolean} true/false if the node is empty or not.
             * @example
             * tinymce.DOM.isEmpty(node, { img: true });
             */
            isEmpty,
            /**
             * Creates a new DOM Range object. This will use the native DOM Range API if it's
             * available. If it's not, it will fall back to the custom TinyMCE implementation.
             *
             * @method createRng
             * @return {DOMRange} DOM Range object.
             * @example
             * const rng = tinymce.DOM.createRng();
             * alert(rng.startContainer + "," + rng.startOffset);
             */
            createRng,
            /**
             * Returns the index of the specified node within its parent.
             *
             * @method nodeIndex
             * @param {Node} node Node to look for.
             * @param {Boolean} normalized Optional true/false state if the index is what it would be after a normalization.
             * @return {Number} Index of the specified node.
             */
            nodeIndex: findNodeIndex,
            /**
             * Splits an element into two new elements and places the specified split
             * element or elements between the new ones. For example splitting the paragraph at the bold element in
             * this example `<p>abc<b>abc</b>123</p>` would produce `<p>abc</p><b>abc</b><p>123</p>`.
             *
             * @method split
             * @param {Element} parentElm Parent element to split.
             * @param {Element} splitElm Element to split at.
             * @param {Element} replacementElm Optional replacement element to replace the split element with.
             * @return {Element} Returns the split element or the replacement element if that is specified.
             */
            split,
            /**
             * Adds an event handler to the specified object.
             *
             * @method bind
             * @param {Element/Document/Window/Array} target Target element to bind events to.
             * handler to or an array of elements/ids/documents.
             * @param {String} name Name of event handler to add, for example: click.
             * @param {Function} func Function to execute when the event occurs.
             * @param {Object} scope Optional scope to execute the function in.
             * @return {Function} Function callback handler the same as the one passed in.
             */
            bind: bind,
            /**
             * Removes the specified event handler by name and function from an element or collection of elements.
             *
             * @method unbind
             * @param {Element/Document/Window/Array} target Target element to unbind events on.
             * @param {String} name Event handler name, for example: "click"
             * @param {Function} func Function to remove.
             * @return {Boolean/Array} Bool state of true if the handler was removed, or an array of states if multiple input elements
             * were passed in.
             */
            unbind: unbind,
            /**
             * Fires the specified event name and optional object on the specified target.
             * <br>
             * <em>Deprecated in TinyMCE 6.0 and has been marked for removal in TinyMCE 7.0. Use <code>dispatch</code> instead.</em>
             *
             * @method fire
             * @param {Node/Document/Window} target Target element or object to fire event on.
             * @param {String} name Event name to fire.
             * @param {Object} evt Event object to send.
             * @return {Event} Event object.
             * @deprecated Use dispatch() instead
             */
            fire,
            /**
             * Dispatches the specified event name and optional object on the specified target.
             *
             * @method dispatch
             * @param {Node/Document/Window} target Target element or object to dispatch event on.
             * @param {String} name Name of the event to fire.
             * @param {Object} evt Event object to send.
             * @return {Event} Event object.
             */
            dispatch,
            // Returns the content editable state of a node
            getContentEditable,
            getContentEditableParent,
            /**
             * Checks if the specified node is editable within the given context of its parents.
             *
             * @method isEditable
             * @param {Node} node Node to check if it's editable.
             * @return {Boolean} Will be true if the node is editable and false if it's not editable.
             */
            isEditable,
            /**
             * Destroys all internal references to the DOM to solve memory leak issues.
             *
             * @method destroy
             */
            destroy,
            isChildOf,
            dumpRng
        };
        const attrHooks = setupAttrHooks(styles, settings, constant(self));
        return self;
    };
    /**
     * Instance of DOMUtils for the current document.
     *
     * @static
     * @property DOM
     * @type tinymce.dom.DOMUtils
     * @example
     * // Example of how to add a class to some element by id
     * tinymce.DOM.addClass('someid', 'someclass');
     */
    DOMUtils.DOM = DOMUtils(document);
    DOMUtils.nodeIndex = findNodeIndex;

    /**
     * This class handles asynchronous/synchronous loading of JavaScript files it will execute callbacks
     * when various items gets loaded. This class is useful to load external JavaScript files.
     *
     * @class tinymce.dom.ScriptLoader
     * @example
     * // Load a script from a specific URL using the global script loader
     * tinymce.ScriptLoader.load('somescript.js');
     *
     * // Load a script using a unique instance of the script loader
     * const scriptLoader = new tinymce.dom.ScriptLoader();
     *
     * scriptLoader.load('somescript.js');
     *
     * // Load multiple scripts
     * scriptLoader.add('somescript1.js');
     * scriptLoader.add('somescript2.js');
     * scriptLoader.add('somescript3.js');
     *
     * scriptLoader.loadQueue().then(() => {
     *   alert('All scripts are now loaded.');
     * });
     */
    const DOM$f = DOMUtils.DOM;
    const QUEUED = 0;
    const LOADING = 1;
    const LOADED = 2;
    const FAILED = 3;
    class ScriptLoader {
        constructor(settings = {}) {
            this.states = {};
            this.queue = [];
            this.scriptLoadedCallbacks = {};
            this.queueLoadedCallbacks = [];
            this.loading = false;
            this.settings = settings;
        }
        _setReferrerPolicy(referrerPolicy) {
            this.settings.referrerPolicy = referrerPolicy;
        }
        _setCrossOrigin(crossOrigin) {
            this.settings.crossOrigin = crossOrigin;
        }
        /**
         * Loads a specific script directly without adding it to the load queue.
         *
         * @method loadScript
         * @param {String} url Absolute URL to script to add.
         * @return {Promise} A promise that will resolve when the script loaded successfully or reject if it failed to load.
         */
        loadScript(url) {
            return new Promise((resolve, reject) => {
                const dom = DOM$f;
                let elm;
                const cleanup = () => {
                    dom.remove(id);
                    if (elm) {
                        elm.onerror = elm.onload = elm = null;
                    }
                };
                // Execute callback when script is loaded
                const done = () => {
                    cleanup();
                    resolve();
                };
                const error = () => {
                    // We can't mark it as done if there is a load error since
                    // A) We don't want to produce 404 errors on the server and
                    // B) the onerror event won't fire on all browsers.
                    cleanup();
                    reject('Failed to load script: ' + url);
                };
                const id = dom.uniqueId();
                // Create new script element
                elm = document.createElement('script');
                elm.id = id;
                elm.type = 'text/javascript';
                elm.src = Tools._addCacheSuffix(url);
                if (this.settings.referrerPolicy) {
                    // Note: Don't use elm.referrerPolicy = ... here as it doesn't work on Safari
                    dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);
                }
                const crossOrigin = this.settings.crossOrigin;
                if (isFunction(crossOrigin)) {
                    const resultCrossOrigin = crossOrigin(url);
                    if (resultCrossOrigin !== undefined) {
                        dom.setAttrib(elm, 'crossorigin', resultCrossOrigin);
                    }
                }
                elm.onload = done;
                // Add onerror event will get fired on some browsers but not all of them
                elm.onerror = error;
                // Add script to document
                (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);
            });
        }
        /**
         * Returns true/false if a script has been loaded or not.
         *
         * @method isDone
         * @param {String} url URL to check for.
         * @return {Boolean} true/false if the URL is loaded.
         */
        isDone(url) {
            return this.states[url] === LOADED;
        }
        /**
         * Marks a specific script to be loaded. This can be useful if a script got loaded outside
         * the script loader or to skip it from loading some script.
         *
         * @method markDone
         * @param {String} url Absolute URL to the script to mark as loaded.
         */
        markDone(url) {
            this.states[url] = LOADED;
        }
        /**
         * Adds a specific script to the load queue of the script loader.
         *
         * @method add
         * @param {String} url Absolute URL to script to add.
         * @return {Promise} A promise that will resolve when the script loaded successfully or reject if it failed to load.
         */
        add(url) {
            const self = this;
            self.queue.push(url);
            // Add url to load queue
            const state = self.states[url];
            if (state === undefined) {
                self.states[url] = QUEUED;
            }
            return new Promise((resolve, reject) => {
                // Store away callback for later execution
                if (!self.scriptLoadedCallbacks[url]) {
                    self.scriptLoadedCallbacks[url] = [];
                }
                self.scriptLoadedCallbacks[url].push({
                    resolve,
                    reject
                });
            });
        }
        load(url) {
            return this.add(url);
        }
        remove(url) {
            delete this.states[url];
            delete this.scriptLoadedCallbacks[url];
        }
        /**
         * Starts the loading of the queue.
         *
         * @method loadQueue
         * @return {Promise} A promise that is resolved when all queued items are loaded or rejected with the script urls that failed to load.
         */
        loadQueue() {
            const queue = this.queue;
            this.queue = [];
            return this.loadScripts(queue);
        }
        /**
         * Loads the specified queue of files and executes the callback ones they are loaded.
         * This method is generally not used outside this class but it might be useful in some scenarios.
         *
         * @method loadScripts
         * @param {Array} scripts Array of queue items to load.
         * @return {Promise} A promise that is resolved when all scripts are loaded or rejected with the script urls that failed to load.
         */
        loadScripts(scripts) {
            const self = this;
            const execCallbacks = (name, url) => {
                // Execute URL callback functions
                get$a(self.scriptLoadedCallbacks, url).each((callbacks) => {
                    each$e(callbacks, (callback) => callback[name](url));
                });
                delete self.scriptLoadedCallbacks[url];
            };
            const processResults = (results) => {
                const failures = filter$5(results, (result) => result.status === 'rejected');
                if (failures.length > 0) {
                    return Promise.reject(bind$3(failures, ({ reason }) => isArray$1(reason) ? reason : [reason]));
                }
                else {
                    return Promise.resolve();
                }
            };
            const load = (urls) => Promise.allSettled(map$3(urls, (url) => {
                // Script is already loaded then execute script callbacks directly
                if (self.states[url] === LOADED) {
                    execCallbacks('resolve', url);
                    return Promise.resolve();
                }
                else if (self.states[url] === FAILED) {
                    execCallbacks('reject', url);
                    return Promise.reject(url);
                }
                else {
                    // Script is not already loaded, so load it
                    self.states[url] = LOADING;
                    return self.loadScript(url).then(() => {
                        self.states[url] = LOADED;
                        execCallbacks('resolve', url);
                        // Immediately load additional scripts if any were added to the queue while loading this script
                        const queue = self.queue;
                        if (queue.length > 0) {
                            self.queue = [];
                            return load(queue).then(processResults);
                        }
                        else {
                            return Promise.resolve();
                        }
                    }, () => {
                        self.states[url] = FAILED;
                        execCallbacks('reject', url);
                        return Promise.reject(url);
                    });
                }
            }));
            const processQueue = (urls) => {
                self.loading = true;
                return load(urls).then((results) => {
                    self.loading = false;
                    // Start loading the next queued item
                    const nextQueuedItem = self.queueLoadedCallbacks.shift();
                    Optional.from(nextQueuedItem).each(call);
                    return processResults(results);
                });
            };
            // Wait for any other scripts to finish loading first, otherwise load immediately
            const uniqueScripts = stringArray(scripts);
            if (self.loading) {
                return new Promise((resolve, reject) => {
                    self.queueLoadedCallbacks.push(() => {
                        processQueue(uniqueScripts).then(resolve, reject);
                    });
                });
            }
            else {
                return processQueue(uniqueScripts);
            }
        }
    }
    ScriptLoader.ScriptLoader = new ScriptLoader();

    const isDuplicated = (items, item) => {
        const firstIndex = items.indexOf(item);
        return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;
    };
    const isRaw = (str) => isObject(str) && has$2(str, 'raw');
    const isTokenised = (str) => isArray$1(str) && str.length > 1;
    const data = {};
    const currentCode = Cell('en');
    const getLanguageData = () => get$a(data, currentCode.get());
    const getData$1 = () => map$2(data, (value) => ({ ...value }));
    /**
     * Sets the current language code.
     *
     * @method setCode
     * @param {String} newCode Current language code.
     */
    const setCode = (newCode) => {
        if (newCode) {
            currentCode.set(newCode);
        }
    };
    /**
     * Returns the current language code.
     *
     * @method getCode
     * @return {String} Current language code.
     */
    const getCode = () => currentCode.get();
    /**
     * Adds translations for a specific language code.
     * Translation keys are set to be case insensitive.
     *
     * @method add
     * @param {String} code Language code like sv_SE.
     * @param {Object} items Name/value object where key is english and value is the translation.
     */
    const add = (code, items) => {
        let langData = data[code];
        if (!langData) {
            data[code] = langData = {};
        }
        const lcNames = map$3(keys(items), (name) => name.toLowerCase());
        each$d(items, (translation, name) => {
            const lcName = name.toLowerCase();
            if (lcName !== name && isDuplicated(lcNames, lcName)) {
                if (!has$2(items, lcName)) {
                    langData[lcName] = translation;
                }
                langData[name] = translation;
            }
            else {
                langData[lcName] = translation;
            }
        });
    };
    /**
     * Translates the specified text.
     *
     * It has a few formats:
     * I18n.translate("Text");
     * I18n.translate(["Text {0}/{1}", 0, 1]);
     * I18n.translate({raw: "Raw string"});
     *
     * @method translate
     * @param {String/Object/Array} text Text to translate.
     * @return {String} String that got translated.
     */
    const translate = (text) => {
        const langData = getLanguageData().getOr({});
        /*
         * number - string
         * null, undefined and empty string - empty string
         * array - comma-delimited string
         * object - in [object Object]
         * function - in [object Function]
         */
        const toString = (obj) => {
            if (isFunction(obj)) {
                return Object.prototype.toString.call(obj);
            }
            return !isEmpty(obj) ? '' + obj : '';
        };
        const isEmpty = (text) => text === '' || text === null || text === undefined;
        const getLangData = (text) => {
            // make sure we work on a string and return a string
            const textStr = toString(text);
            return has$2(langData, textStr)
                ? toString(langData[textStr])
                : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);
        };
        const removeContext = (str) => str.replace(/{context:\w+}$/, '');
        const replaceWithEllipsisChar = (text) => text.replaceAll('...', ellipsis);
        // empty strings
        if (isEmpty(text)) {
            return '';
        }
        // Raw, already translated
        if (isRaw(text)) {
            return replaceWithEllipsisChar(toString(text.raw));
        }
        // Tokenised {translations}
        if (isTokenised(text)) {
            const values = text.slice(1);
            const substitued = getLangData(text[0]).replace(/\{([0-9]+)\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);
            return replaceWithEllipsisChar(removeContext(substitued));
        }
        // straight forward translation mapping
        return replaceWithEllipsisChar(removeContext(getLangData(text)));
    };
    /**
     * Returns true/false if the currently active language pack is rtl or not.
     *
     * @method isRtl
     * @return {Boolean} True if the current language pack is rtl.
     */
    const isRtl$1 = () => getLanguageData()
        .bind((items) => get$a(items, '_dir'))
        .exists((dir) => dir === 'rtl');
    /**
     * Returns true/false if specified language pack exists.
     *
     * @method hasCode
     * @param {String} code Code to check for.
     * @return {Boolean} True if the current language pack for the specified code exists.
     */
    const hasCode = (code) => has$2(data, code);
    const I18n = {
        getData: getData$1,
        setCode,
        getCode,
        add,
        translate,
        isRtl: isRtl$1,
        hasCode
    };

    const AddOnManager = () => {
        const items = [];
        const urls = {};
        const lookup = {};
        const _listeners = [];
        const runListeners = (name, state) => {
            const matchedListeners = filter$5(_listeners, (listener) => listener.name === name && listener.state === state);
            each$e(matchedListeners, (listener) => listener.resolve());
        };
        const isLoaded = (name) => has$2(urls, name);
        const isAdded = (name) => has$2(lookup, name);
        const get = (name) => {
            if (lookup[name]) {
                return lookup[name].instance;
            }
            return undefined;
        };
        const loadLanguagePack = (name, languages) => {
            const language = I18n.getCode();
            const wrappedLanguages = ',' + (languages || '') + ',';
            if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');
        };
        const requireLangPack = (name, languages) => {
            if (AddOnManager.languageLoad !== false) {
                if (isLoaded(name)) {
                    loadLanguagePack(name, languages);
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));
                }
            }
        };
        const add = (id, addOn) => {
            items.push(addOn);
            lookup[id] = { instance: addOn };
            runListeners(id, 'added');
            return addOn;
        };
        const remove = (name) => {
            delete urls[name];
            delete lookup[name];
        };
        const createUrl = (baseUrl, dep) => {
            if (isString(dep)) {
                return isString(baseUrl) ?
                    { prefix: '', resource: dep, suffix: '' } :
                    { prefix: baseUrl.prefix, resource: dep, suffix: baseUrl.suffix };
            }
            else {
                return dep;
            }
        };
        const load = (name, addOnUrl) => {
            if (urls[name]) {
                return Promise.resolve();
            }
            let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
            if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {
                urlString = AddOnManager.baseURL + '/' + urlString;
            }
            urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));
            const done = () => {
                runListeners(name, 'loaded');
                return Promise.resolve();
            };
            if (lookup[name]) {
                return done();
            }
            else {
                return ScriptLoader.ScriptLoader.add(urlString).then(done);
            }
        };
        const waitFor = (name, state = 'added') => {
            if (state === 'added' && isAdded(name)) {
                return Promise.resolve();
            }
            else if (state === 'loaded' && isLoaded(name)) {
                return Promise.resolve();
            }
            else {
                return new Promise((resolve) => {
                    _listeners.push({ name, state, resolve });
                });
            }
        };
        return {
            items,
            urls,
            lookup,
            /**
             * Returns the specified add on by the short name.
             *
             * @method get
             * @param {String} name Add-on to look for.
             * @return {tinymce.Theme/tinymce.Plugin} Theme or plugin add-on instance or undefined.
             */
            get,
            /**
             * Loads a language pack for the specified add-on.
             *
             * @method requireLangPack
             * @param {String} name Short name of the add-on.
             * @param {String} languages Optional comma or space separated list of languages to check if it matches the name.
             */
            requireLangPack,
            /**
             * Adds a instance of the add-on by it's short name.
             *
             * @method add
             * @param {String} id Short name/id for the add-on.
             * @param {tinymce.Theme/tinymce.Plugin} addOn Theme or plugin to add.
             * @return {tinymce.Theme/tinymce.Plugin} The same theme or plugin instance that got passed in.
             * @example
             * // Create a simple plugin
             * const TestPlugin = (ed, url) => {
             *   ed.on('click', (e) => {
             *     ed.windowManager.alert('Hello World!');
             *   });
             * };
             *
             * // Register plugin using the add method
             * tinymce.PluginManager.add('test', TestPlugin);
             *
             * // Initialize TinyMCE
             * tinymce.init({
             *   ...
             *   plugins: '-test' // Init the plugin but don't try to load it
             * });
             */
            add,
            remove,
            createUrl,
            /**
             * Loads an add-on from a specific url.
             *
             * @method load
             * @param {String} name Short name of the add-on that gets loaded.
             * @param {String} addOnUrl URL to the add-on that will get loaded.
             * @return {Promise} A promise that will resolve when the add-on is loaded successfully or reject if it failed to load.
             * @example
             * // Loads a plugin from an external URL
             * tinymce.PluginManager.load('myplugin', '/some/dir/someplugin/plugin.js');
             *
             * // Initialize TinyMCE
             * tinymce.init({
             *   ...
             *   plugins: '-myplugin' // Don't try to load it again
             * });
             */
            load,
            waitFor
        };
    };
    AddOnManager.languageLoad = true;
    AddOnManager.baseURL = '';
    AddOnManager.PluginManager = AddOnManager();
    AddOnManager.ThemeManager = AddOnManager();
    AddOnManager.ModelManager = AddOnManager();

    const annotation = constant('mce-annotation');
    const dataAnnotation = constant('data-mce-annotation');
    const dataAnnotationId = constant('data-mce-annotation-uid');
    const dataAnnotationActive = constant('data-mce-annotation-active');
    const dataAnnotationClasses = constant('data-mce-annotation-classes');
    const dataAnnotationAttributes = constant('data-mce-annotation-attrs');

    const isRoot$1 = (root) => (node) => eq(node, root);
    // Given the current editor selection, identify the uid of any current
    // annotation
    const identify = (editor, annotationName) => {
        const rng = editor.selection.getRng();
        const start = SugarElement.fromDom(rng.startContainer);
        const root = SugarElement.fromDom(editor.getBody());
        const selector = annotationName.fold(() => '.' + annotation(), (an) => `[${dataAnnotation()}="${an}"]`);
        const newStart = child$1(start, rng.startOffset).getOr(start);
        const closest = closest$3(newStart, selector, isRoot$1(root));
        return closest.bind((c) => getOpt(c, `${dataAnnotationId()}`).bind((uid) => getOpt(c, `${dataAnnotation()}`).map((name) => {
            const elements = findMarkers(editor, uid);
            return {
                uid,
                name,
                elements
            };
        })));
    };
    const isAnnotation = (elem) => isElement$8(elem) && has(elem, annotation());
    const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$1(elem, '[data-mce-bogus="all"]', isRoot$1(root));
    const findMarkers = (editor, uid) => {
        const body = SugarElement.fromDom(editor.getBody());
        const descendants$1 = descendants(body, `[${dataAnnotationId()}="${uid}"]`);
        return filter$5(descendants$1, (descendant) => !isBogusElement(descendant, body));
    };
    const findAll = (editor, name) => {
        const body = SugarElement.fromDom(editor.getBody());
        const markers = descendants(body, `[${dataAnnotation()}="${name}"]`);
        const directory = {};
        each$e(markers, (m) => {
            if (!isBogusElement(m, body)) {
                const uid = get$9(m, dataAnnotationId());
                const nodesAlready = get$a(directory, uid).getOr([]);
                directory[uid] = nodesAlready.concat([m]);
            }
        });
        return directory;
    };

    const setup$E = (editor, registry) => {
        const changeCallbacks = Cell({});
        const initData = () => ({
            listeners: [],
            previous: value$1()
        });
        const withCallbacks = (name, f) => {
            updateCallbacks(name, (data) => {
                f(data);
                return data;
            });
        };
        const updateCallbacks = (name, f) => {
            const callbackMap = changeCallbacks.get();
            const data = get$a(callbackMap, name).getOrThunk(initData);
            const outputData = f(data);
            callbackMap[name] = outputData;
            changeCallbacks.set(callbackMap);
        };
        const fireCallbacks = (name, uid, elements) => {
            withCallbacks(name, (data) => {
                each$e(data.listeners, (f) => f(true, name, {
                    uid,
                    nodes: map$3(elements, (elem) => elem.dom)
                }));
            });
        };
        const fireNoAnnotation = (name) => {
            withCallbacks(name, (data) => {
                each$e(data.listeners, (f) => f(false, name));
            });
        };
        const toggleActiveAttr = (uid, state) => {
            each$e(findMarkers(editor, uid), (elem) => {
                if (state) {
                    set$4(elem, dataAnnotationActive(), 'true');
                }
                else {
                    remove$9(elem, dataAnnotationActive());
                }
            });
        };
        // NOTE: Runs in alphabetical order.
        const onNodeChange = last$1(() => {
            const annotations = sort(registry.getNames());
            each$e(annotations, (name) => {
                updateCallbacks(name, (data) => {
                    const prev = data.previous.get();
                    identify(editor, Optional.some(name)).fold(() => {
                        prev.each((uid) => {
                            // Changed from something to nothing.
                            fireNoAnnotation(name);
                            data.previous.clear();
                            toggleActiveAttr(uid, false);
                        });
                    }, ({ uid, name, elements }) => {
                        // Changed from a different annotation (or nothing)
                        if (!is$4(prev, uid)) {
                            prev.each((uid) => toggleActiveAttr(uid, false));
                            fireCallbacks(name, uid, elements);
                            data.previous.set(uid);
                            toggleActiveAttr(uid, true);
                        }
                    });
                    return {
                        previous: data.previous,
                        listeners: data.listeners
                    };
                });
            });
        }, 30);
        editor.on('remove', () => {
            onNodeChange.cancel();
        });
        editor.on('NodeChange', () => {
            onNodeChange.throttle();
        });
        const addListener = (name, f) => {
            updateCallbacks(name, (data) => ({
                previous: data.previous,
                listeners: data.listeners.concat([f])
            }));
        };
        return {
            addListener
        };
    };

    const setup$D = (editor, registry) => {
        const dataAnnotation$1 = dataAnnotation();
        const identifyParserNode = (node) => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);
        const removeDirectAnnotation = (node) => {
            var _a, _b;
            node.attr(dataAnnotationId(), null);
            node.attr(dataAnnotation(), null);
            node.attr(dataAnnotationActive(), null);
            const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map((names) => names.split(',')).getOr([]);
            const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map((names) => names.split(',')).getOr([]);
            each$e(customAttrNames, (name) => node.attr(name, null));
            const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];
            const newClassList = difference(classList, [annotation()].concat(customClasses));
            node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);
            node.attr(dataAnnotationClasses(), null);
            node.attr(dataAnnotationAttributes(), null);
        };
        editor.serializer.addTempAttr(dataAnnotationActive());
        editor.serializer.addAttributeFilter(dataAnnotation$1, (nodes) => {
            for (const node of nodes) {
                identifyParserNode(node).each((settings) => {
                    if (settings.persistent === false) {
                        if (node.name === 'span') {
                            node.unwrap();
                        }
                        else {
                            removeDirectAnnotation(node);
                        }
                    }
                });
            }
        });
    };

    const create$a = () => {
        const annotations = {};
        const register = (name, settings) => {
            annotations[name] = {
                name,
                settings
            };
        };
        const lookup = (name) => get$a(annotations, name).map((a) => a.settings);
        const getNames = () => keys(annotations);
        return {
            register,
            lookup,
            getNames
        };
    };

    const TextWalker = (startNode, rootNode, isBoundary = never) => {
        const walker = new DomTreeWalker(startNode, rootNode);
        const walk = (direction) => {
            let next;
            do {
                next = walker[direction]();
            } while (next && !isText$b(next) && !isBoundary(next));
            return Optional.from(next).filter(isText$b);
        };
        return {
            current: () => Optional.from(walker.current()).filter(isText$b),
            next: () => walk('next'),
            prev: () => walk('prev'),
            prev2: () => walk('prev2')
        };
    };

    /**
     * The TextSeeker class enables you to seek for a specific point in text across the DOM.
     *
     * @class tinymce.dom.TextSeeker
     * @example
     * const seeker = tinymce.dom.TextSeeker(editor.dom);
     * const startOfWord = seeker.backwards(startNode, startOffset, (textNode, offset, text) => {
     *   const lastSpaceCharIndex = text.lastIndexOf(' ');
     *   if (lastSpaceCharIndex !== -1) {
     *     return lastSpaceCharIndex + 1;
     *   } else {
     *     // No space found so continue searching
     *     return -1;
     *   }
     * });
     */
    /**
     * Constructs a new TextSeeker instance.
     *
     * @constructor
     * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.
     * @param {Function} isBoundary Optional function to determine if the seeker should continue to walk past the node provided. The default is to search until a block or <code>br</code> element is found.
     */
    const TextSeeker = (dom, isBoundary) => {
        const isBlockBoundary = isBoundary ? isBoundary : (node) => dom.isBlock(node) || isBr$7(node) || isContentEditableFalse$a(node);
        const walk = (node, offset, walker, process) => {
            if (isText$b(node)) {
                const newOffset = process(node, offset, node.data);
                if (newOffset !== -1) {
                    return Optional.some({ container: node, offset: newOffset });
                }
            }
            return walker().bind((next) => walk(next.container, next.offset, walker, process));
        };
        /**
         * Search backwards through text nodes until a match, boundary, or root node has been found.
         *
         * @method backwards
         * @param {Node} node The node to start searching from.
         * @param {Number} offset The offset of the node to start searching from.
         * @param {Function} process A function that's passed the current text node, the current offset and the text content of the node. It should return the offset of the match or -1 to continue searching.
         * @param {Node} root An optional root node to constrain the search to.
         * @return {Object} An object containing the matched text node and offset. If no match is found, null will be returned.
         */
        const backwards = (node, offset, process, root) => {
            const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);
            return walk(node, offset, () => walker.prev().map((prev) => ({ container: prev, offset: prev.length })), process).getOrNull();
        };
        /**
         * Search forwards through text nodes until a match, boundary, or root node has been found.
         *
         * @method forwards
         * @param {Node} node The node to start searching from.
         * @param {Number} offset The offset of the node to start searching from.
         * @param {Function} process A function that's passed the current text node, the current offset and the text content of the node. It should return the offset of the match or -1 to continue searching.
         * @param {Node} root An optional root node to constrain the search to.
         * @return {Object} An object containing the matched text node and offset. If no match is found, null will be returned.
         */
        const forwards = (node, offset, process, root) => {
            const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);
            return walk(node, offset, () => walker.next().map((next) => ({ container: next, offset: 0 })), process).getOrNull();
        };
        return {
            backwards,
            forwards
        };
    };

    const tableCells = ['td', 'th'];
    const tableSections = ['thead', 'tbody', 'tfoot'];
    const textBlocks = [
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div', 'address', 'pre', 'form',
        'blockquote', 'center', 'dir', 'fieldset', 'header', 'footer', 'article',
        'section', 'hgroup', 'aside', 'nav', 'figure'
    ];
    const listItems$1 = ['li', 'dd', 'dt'];
    const lists = ['ul', 'ol', 'dl'];
    const wsElements = ['pre', 'script', 'textarea', 'style'];
    const lazyLookup = (items) => {
        let lookup;
        return (node) => {
            lookup = lookup ? lookup : mapToObject(items, always);
            return has$2(lookup, name(node));
        };
    };
    // WARNING: don't add anything to this file, the intention is to move these checks into the Schema
    const isTable$1 = (node) => name(node) === 'table';
    const isBr$6 = (node) => isElement$8(node) && name(node) === 'br';
    const isTextBlock$3 = lazyLookup(textBlocks);
    const isList$1 = lazyLookup(lists);
    const isListItem$2 = lazyLookup(listItems$1);
    const isTableSection = lazyLookup(tableSections);
    const isTableCell$2 = lazyLookup(tableCells);
    const isWsPreserveElement = lazyLookup(wsElements);

    const getLastChildren$1 = (elm) => {
        const children = [];
        let rawNode = elm.dom;
        while (rawNode) {
            children.push(SugarElement.fromDom(rawNode));
            rawNode = rawNode.lastChild;
        }
        return children;
    };
    const removeTrailingBr = (elm) => {
        const allBrs = descendants(elm, 'br');
        const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$6);
        if (allBrs.length === brs.length) {
            each$e(brs, remove$8);
        }
    };
    const createPaddingBr = () => {
        const br = SugarElement.fromTag('br');
        set$4(br, 'data-mce-bogus', '1');
        return br;
    };
    const fillWithPaddingBr = (elm) => {
        empty(elm);
        append$1(elm, createPaddingBr());
    };
    const trimBlockTrailingBr = (elm, schema) => {
        lastChild(elm).each((lastChild) => {
            prevSibling(lastChild).each((lastChildPrevSibling) => {
                if (schema.isBlock(name(elm)) && isBr$6(lastChild) && schema.isBlock(name(lastChildPrevSibling))) {
                    remove$8(lastChild);
                }
            });
        });
    };

    /**
     * Utility functions for working with zero width space
     * characters used as character containers etc.
     *
     * @private
     * @class tinymce.text.Zwsp
     * @example
     * const isZwsp = Zwsp.isZwsp('\uFEFF');
     * const abc = Zwsp.trim('a\uFEFFc');
     */
    // This is technically not a ZWSP but a ZWNBSP or a BYTE ORDER MARK it used to be a ZWSP
    const ZWSP$1 = zeroWidth;
    const isZwsp = isZwsp$2;
    const trim$2 = removeZwsp;
    const insert$5 = (editor) => editor.insertContent(ZWSP$1, { preserve_zwsp: true });

    /**
     * This module handles caret containers. A caret container is a node that
     * holds the caret for positional purposes.
     *
     * @private
     * @class tinymce.caret.CaretContainer
     */
    const isElement$6 = isElement$7;
    const isText$9 = isText$b;
    const isCaretContainerBlock$1 = (node) => {
        if (isText$9(node)) {
            node = node.parentNode;
        }
        return isElement$6(node) && node.hasAttribute('data-mce-caret');
    };
    const isCaretContainerInline = (node) => isText$9(node) && isZwsp(node.data);
    const isCaretContainer$2 = (node) => isCaretContainerBlock$1(node) || isCaretContainerInline(node);
    const hasContent = (node) => node.firstChild !== node.lastChild || !isBr$7(node.firstChild);
    const insertInline$1 = (node, before) => {
        var _a;
        const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
        const textNode = doc.createTextNode(ZWSP$1);
        const parentNode = node.parentNode;
        if (!before) {
            const sibling = node.nextSibling;
            if (isText$9(sibling)) {
                if (isCaretContainer$2(sibling)) {
                    return sibling;
                }
                if (startsWithCaretContainer$1(sibling)) {
                    sibling.splitText(1);
                    return sibling;
                }
            }
            if (node.nextSibling) {
                parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);
            }
            else {
                parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);
            }
        }
        else {
            const sibling = node.previousSibling;
            if (isText$9(sibling)) {
                if (isCaretContainer$2(sibling)) {
                    return sibling;
                }
                if (endsWithCaretContainer$1(sibling)) {
                    return sibling.splitText(sibling.data.length - 1);
                }
            }
            parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);
        }
        return textNode;
    };
    const isBeforeInline = (pos) => {
        const container = pos.container();
        if (!isText$b(container)) {
            return false;
        }
        // The text nodes may not be normalized, so check the current node and the previous one
        return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
    };
    const isAfterInline = (pos) => {
        const container = pos.container();
        if (!isText$b(container)) {
            return false;
        }
        // The text nodes may not be normalized, so check the current node and the next one
        return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
    };
    const insertBlock = (blockName, node, before) => {
        var _a;
        const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
        const blockNode = doc.createElement(blockName);
        blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');
        blockNode.setAttribute('data-mce-bogus', 'all');
        blockNode.appendChild(createPaddingBr().dom);
        const parentNode = node.parentNode;
        if (!before) {
            if (node.nextSibling) {
                parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);
            }
            else {
                parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);
            }
        }
        else {
            parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);
        }
        return blockNode;
    };
    const startsWithCaretContainer$1 = (node) => isText$9(node) && node.data[0] === ZWSP$1;
    const endsWithCaretContainer$1 = (node) => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;
    const trimBogusBr = (elm) => {
        var _a;
        const brs = elm.getElementsByTagName('br');
        const lastBr = brs[brs.length - 1];
        if (isBogus$1(lastBr)) {
            (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);
        }
    };
    const showCaretContainerBlock = (caretContainer) => {
        if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {
            trimBogusBr(caretContainer);
            caretContainer.removeAttribute('data-mce-caret');
            caretContainer.removeAttribute('data-mce-bogus');
            caretContainer.removeAttribute('style');
            caretContainer.removeAttribute('data-mce-style');
            caretContainer.removeAttribute('_moz_abspos');
            return caretContainer;
        }
        return null;
    };
    const isRangeInCaretContainerBlock = (range) => isCaretContainerBlock$1(range.startContainer);

    const round$2 = Math.round;
    const clone$1 = (rect) => {
        if (!rect) {
            return { left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0 };
        }
        return {
            left: round$2(rect.left),
            top: round$2(rect.top),
            bottom: round$2(rect.bottom),
            right: round$2(rect.right),
            width: round$2(rect.width),
            height: round$2(rect.height)
        };
    };
    const collapse = (rect, toStart) => {
        rect = clone$1(rect);
        if (toStart) {
            rect.right = rect.left;
        }
        else {
            rect.left = rect.left + rect.width;
            rect.right = rect.left;
        }
        rect.width = 0;
        return rect;
    };
    const isEqual = (rect1, rect2) => (rect1.left === rect2.left &&
        rect1.top === rect2.top &&
        rect1.bottom === rect2.bottom &&
        rect1.right === rect2.right);
    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
    const isAbove$1 = (rect1, rect2) => {
        const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
        if ((rect1.bottom - halfHeight) < rect2.top) {
            return true;
        }
        if (rect1.top > rect2.bottom) {
            return false;
        }
        return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
    };
    const isBelow$1 = (rect1, rect2) => {
        if (rect1.top > rect2.bottom) {
            return true;
        }
        if (rect1.bottom < rect2.top) {
            return false;
        }
        return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
    };
    const containsXY = (rect, clientX, clientY) => (clientX >= rect.left &&
        clientX <= rect.right &&
        clientY >= rect.top &&
        clientY <= rect.bottom);
    const boundingClientRectFromRects = (rects) => {
        return foldl(rects, (acc, rect) => {
            return acc.fold(() => Optional.some(rect), (prevRect) => {
                const left = Math.min(rect.left, prevRect.left);
                const top = Math.min(rect.top, prevRect.top);
                const right = Math.max(rect.right, prevRect.right);
                const bottom = Math.max(rect.bottom, prevRect.bottom);
                return Optional.some({
                    top,
                    right,
                    bottom,
                    left,
                    width: right - left,
                    height: bottom - top
                });
            });
        }, Optional.none());
    };
    const distanceToRectEdgeFromXY = (rect, x, y) => {
        const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);
        const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);
        return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
    };
    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));

    const getSelectedNode = (range) => {
        const startContainer = range.startContainer, startOffset = range.startOffset;
        if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {
            return startContainer.childNodes[startOffset];
        }
        return null;
    };
    const getNode$1 = (container, offset) => {
        if (isElement$7(container) && container.hasChildNodes()) {
            const childNodes = container.childNodes;
            const safeOffset = clamp$2(offset, 0, childNodes.length - 1);
            return childNodes[safeOffset];
        }
        else {
            return container;
        }
    };
    /** @deprecated Use getNode instead */
    const getNodeUnsafe = (container, offset) => {
        // If a negative offset is used on an element then `undefined` should be returned
        if (offset < 0 && isElement$7(container) && container.hasChildNodes()) {
            return undefined;
        }
        else {
            return getNode$1(container, offset);
        }
    };

    /**
     * This class contains logic for detecting extending characters.
     *
     * @private
     * @class tinymce.text.ExtendingChar
     * @example
     * const isExtending = ExtendingChar.isExtendingChar('a');
     */
    // Generated from: http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt
    // Only includes the characters in that fit into UCS-2 16 bit
    const extendingChars = new RegExp('[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A' +
        '\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0' +
        '\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C' +
        '\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3' +
        '\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC' +
        '\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57' +
        '\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56' +
        '\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44' +
        '\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9' +
        '\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97' +
        '\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074' +
        '\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5' +
        '\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18' +
        '\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34' +
        '\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9' +
        '\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9' +
        '\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1' +
        '\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1' +
        '\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC' +
        '\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1' +
        '\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]');
    const isExtendingChar = (ch) => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);

    const or = (...args) => {
        return (x) => {
            for (let i = 0; i < args.length; i++) {
                if (args[i](x)) {
                    return true;
                }
            }
            return false;
        };
    };
    const and = (...args) => {
        return (x) => {
            for (let i = 0; i < args.length; i++) {
                if (!args[i](x)) {
                    return false;
                }
            }
            return true;
        };
    };

    /**
     * This module contains logic for handling caret candidates. A caret candidate is
     * for example text nodes, images, input elements, cE=false elements etc.
     *
     * @private
     * @class tinymce.caret.CaretCandidate
     */
    const isContentEditableTrue$2 = isContentEditableTrue$3;
    const isContentEditableFalse$9 = isContentEditableFalse$a;
    const isBr$5 = isBr$7;
    const isText$8 = isText$b;
    const isInvalidTextElement = matchNodeNames$1(['script', 'style', 'textarea']);
    const isAtomicInline = matchNodeNames$1(['img', 'input', 'textarea', 'hr', 'iframe', 'video', 'audio', 'object', 'embed']);
    const isTable = matchNodeNames$1(['table']);
    const isCaretContainer$1 = isCaretContainer$2;
    const isCaretCandidate$3 = (node) => {
        if (isCaretContainer$1(node)) {
            return false;
        }
        if (isText$8(node)) {
            return !isInvalidTextElement(node.parentNode);
        }
        return isAtomicInline(node) || isBr$5(node) || isTable(node) || isNonUiContentEditableFalse(node);
    };
    // UI components on IE is marked with contenteditable=false and unselectable=true so lets not handle those as real content editables
    const isUnselectable = (node) => isElement$7(node) && node.getAttribute('unselectable') === 'true';
    const isNonUiContentEditableFalse = (node) => !isUnselectable(node) && isContentEditableFalse$9(node);
    const isInEditable = (node, root) => {
        for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
            if (isNonUiContentEditableFalse(tempNode)) {
                return false;
            }
            if (isContentEditableTrue$2(tempNode)) {
                return true;
            }
        }
        return true;
    };
    const isAtomicContentEditableFalse = (node) => {
        if (!isNonUiContentEditableFalse(node)) {
            return false;
        }
        return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {
            return result || isContentEditableTrue$2(elm);
        }, false);
    };
    const isAtomic$1 = (node) => isAtomicInline(node) || isAtomicContentEditableFalse(node);
    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);

    /**
     * This module contains logic for creating caret positions within a document a caretposition
     * is similar to a DOMRange object but it doesn't have two endpoints and is also more lightweight
     * since it's now updated live when the DOM changes.
     *
     * @private
     * @class tinymce.caret.CaretPosition
     * @example
     * const caretPos1 = CaretPosition(container, offset);
     * const caretPos2 = CaretPosition.fromRangeStart(someRange);
     */
    const isElement$5 = isElement$7;
    const isCaretCandidate$2 = isCaretCandidate$3;
    const isBlock$3 = matchStyleValues('display', 'block table');
    const isFloated = matchStyleValues('float', 'left right');
    const isValidElementCaretCandidate = and(isElement$5, isCaretCandidate$2, not(isFloated));
    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));
    const isText$7 = isText$b;
    const isBr$4 = isBr$7;
    const nodeIndex$1 = DOMUtils.nodeIndex;
    const resolveIndex$1 = getNodeUnsafe;
    const createRange$1 = (doc) => doc ? doc.createRange() : DOMUtils.DOM.createRng();
    const isWhiteSpace$1 = (chr) => isString(chr) && /[\r\n\t ]/.test(chr);
    const isRange = (rng) => !!rng.setStart && !!rng.setEnd;
    const isHiddenWhiteSpaceRange = (range) => {
        const container = range.startContainer;
        const offset = range.startOffset;
        if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$b(container)) {
            const text = container.data;
            if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {
                return true;
            }
        }
        return false;
    };
    // Hack for older WebKit versions that doesn't
    // support getBoundingClientRect on BR elements
    const getBrClientRect = (brNode) => {
        const doc = brNode.ownerDocument;
        const rng = createRange$1(doc);
        const nbsp$1 = doc.createTextNode(nbsp);
        const parentNode = brNode.parentNode;
        parentNode.insertBefore(nbsp$1, brNode);
        rng.setStart(nbsp$1, 0);
        rng.setEnd(nbsp$1, 1);
        const clientRect = clone$1(rng.getBoundingClientRect());
        parentNode.removeChild(nbsp$1);
        return clientRect;
    };
    // Safari will not return a rect for <p>a<br>|b</p> for some odd reason
    const getBoundingClientRectWebKitText = (rng) => {
        const sc = rng.startContainer;
        const ec = rng.endContainer;
        const so = rng.startOffset;
        const eo = rng.endOffset;
        if (sc === ec && isText$b(ec) && so === 0 && eo === 1) {
            const newRng = rng.cloneRange();
            newRng.setEndAfter(ec);
            return getBoundingClientRect$1(newRng);
        }
        else {
            return null;
        }
    };
    const isZeroRect = (r) => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;
    const getBoundingClientRect$1 = (item) => {
        var _a;
        let clientRect;
        const clientRects = item.getClientRects();
        if (clientRects.length > 0) {
            clientRect = clone$1(clientRects[0]);
        }
        else {
            clientRect = clone$1(item.getBoundingClientRect());
        }
        if (!isRange(item) && isBr$4(item) && isZeroRect(clientRect)) {
            return getBrClientRect(item);
        }
        if (isZeroRect(clientRect) && isRange(item)) {
            return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;
        }
        return clientRect;
    };
    const collapseAndInflateWidth = (clientRect, toStart) => {
        const newClientRect = collapse(clientRect, toStart);
        newClientRect.width = 1;
        newClientRect.right = newClientRect.left + 1;
        return newClientRect;
    };
    const getCaretPositionClientRects = (caretPosition) => {
        const clientRects = [];
        const addUniqueAndValidRect = (clientRect) => {
            if (clientRect.height === 0) {
                return;
            }
            if (clientRects.length > 0) {
                if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
                    return;
                }
            }
            clientRects.push(clientRect);
        };
        const addCharacterOffset = (container, offset) => {
            const range = createRange$1(container.ownerDocument);
            if (offset < container.data.length) {
                if (isExtendingChar(container.data[offset])) {
                    return;
                }
                // WebKit returns two client rects for a position after an extending
                // character a\uxxx|b so expand on "b" and collapse to start of "b" box
                if (isExtendingChar(container.data[offset - 1])) {
                    range.setStart(container, offset);
                    range.setEnd(container, offset + 1);
                    if (!isHiddenWhiteSpaceRange(range)) {
                        addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
                        return;
                    }
                }
            }
            if (offset > 0) {
                range.setStart(container, offset - 1);
                range.setEnd(container, offset);
                if (!isHiddenWhiteSpaceRange(range)) {
                    addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
                }
            }
            if (offset < container.data.length) {
                range.setStart(container, offset);
                range.setEnd(container, offset + 1);
                if (!isHiddenWhiteSpaceRange(range)) {
                    addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));
                }
            }
        };
        const container = caretPosition.container();
        const offset = caretPosition.offset();
        if (isText$7(container)) {
            addCharacterOffset(container, offset);
            return clientRects;
        }
        if (isElement$5(container)) {
            if (caretPosition.isAtEnd()) {
                const node = resolveIndex$1(container, offset);
                if (isText$7(node)) {
                    addCharacterOffset(node, node.data.length);
                }
                if (isValidElementCaretCandidate(node) && !isBr$4(node)) {
                    addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
                }
            }
            else {
                const node = resolveIndex$1(container, offset);
                if (isText$7(node)) {
                    addCharacterOffset(node, 0);
                }
                if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
                    addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
                    return clientRects;
                }
                const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);
                if (isValidElementCaretCandidate(beforeNode) && !isBr$4(beforeNode)) {
                    if (isBlock$3(beforeNode) || isBlock$3(node) || !isValidElementCaretCandidate(node)) {
                        addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));
                    }
                }
                if (isValidElementCaretCandidate(node)) {
                    addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));
                }
            }
        }
        return clientRects;
    };
    /**
     * Represents a location within the document by a container and an offset.
     *
     * @constructor
     * @param {Node} container Container node.
     * @param {Number} offset Offset within that container node.
     * @param {Array} clientRects Optional client rects array for the position.
     */
    const CaretPosition = (container, offset, clientRects) => {
        const isAtStart = () => {
            if (isText$7(container)) {
                return offset === 0;
            }
            return offset === 0;
        };
        const isAtEnd = () => {
            if (isText$7(container)) {
                return offset >= container.data.length;
            }
            return offset >= container.childNodes.length;
        };
        const toRange = () => {
            const range = createRange$1(container.ownerDocument);
            range.setStart(container, offset);
            range.setEnd(container, offset);
            return range;
        };
        const getClientRects = () => {
            if (!clientRects) {
                clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
            }
            return clientRects;
        };
        const isVisible = () => getClientRects().length > 0;
        const isEqual = (caretPosition) => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
        const getNode = (before) => resolveIndex$1(container, before ? offset - 1 : offset);
        return {
            /**
             * Returns the container node.
             *
             * @method container
             * @return {Node} Container node.
             */
            container: constant(container),
            /**
             * Returns the offset within the container node.
             *
             * @method offset
             * @return {Number} Offset within the container node.
             */
            offset: constant(offset),
            /**
             * Returns a range out of a the caret position.
             *
             * @method toRange
             * @return {DOMRange} range for the caret position.
             */
            toRange,
            /**
             * Returns the client rects for the caret position. Might be multiple rects between
             * block elements.
             *
             * @method getClientRects
             * @return {Array} Array of client rects.
             */
            getClientRects,
            /**
             * Returns true if the caret location is visible/displayed on screen.
             *
             * @method isVisible
             * @return {Boolean} true/false if the position is visible or not.
             */
            isVisible,
            /**
             * Returns true if the caret location is at the beginning of text node or container.
             *
             * @method isVisible
             * @return {Boolean} true/false if the position is at the beginning.
             */
            isAtStart,
            /**
             * Returns true if the caret location is at the end of text node or container.
             *
             * @method isVisible
             * @return {Boolean} true/false if the position is at the end.
             */
            isAtEnd,
            /**
             * Compares the caret position to another caret position. This will only compare the
             * container and offset not it's visual position.
             *
             * @method isEqual
             * @param {tinymce.caret.CaretPosition} caretPosition Caret position to compare with.
             * @return {Boolean} true if the caret positions are equal.
             */
            isEqual,
            /**
             * Returns the closest resolved node from a node index. That means if you have an offset after the
             * last node in a container it will return that last node.
             *
             * @method getNode
             * @return {Node} Node that is closest to the index.
             */
            getNode
        };
    };
    /**
     * Creates a caret position from the start of a range.
     *
     * @method fromRangeStart
     * @param {DOMRange} range DOM Range to create caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the start of DOM range.
     */
    CaretPosition.fromRangeStart = (range) => CaretPosition(range.startContainer, range.startOffset);
    /**
     * Creates a caret position from the end of a range.
     *
     * @method fromRangeEnd
     * @param {DOMRange} range DOM Range to create caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the end of DOM range.
     */
    CaretPosition.fromRangeEnd = (range) => CaretPosition(range.endContainer, range.endOffset);
    /**
     * Creates a caret position from a node and places the offset after it.
     *
     * @method after
     * @param {Node} node Node to get caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the node.
     */
    // TODO: TINY-8865 - This may not be safe to cast as Node and alternative solutions need to be looked into
    CaretPosition.after = (node) => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);
    /**
     * Creates a caret position from a node and places the offset before it.
     *
     * @method before
     * @param {Node} node Node to get caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the node.
     */
    // TODO: TINY-8865 - This may not be safe to cast as Node and alternative solutions need to be looked into
    CaretPosition.before = (node) => CaretPosition(node.parentNode, nodeIndex$1(node));
    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$2(pos1.getClientRects()), isAbove$1).getOr(false);
    CaretPosition.isBelow = (pos1, pos2) => lift2(last$2(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);
    CaretPosition.isAtStart = (pos) => pos ? pos.isAtStart() : false;
    CaretPosition.isAtEnd = (pos) => pos ? pos.isAtEnd() : false;
    CaretPosition.isTextPosition = (pos) => pos ? isText$b(pos.container()) : false;
    CaretPosition.isElementPosition = (pos) => !CaretPosition.isTextPosition(pos);

    const trimEmptyTextNode$1 = (dom, node) => {
        if (isText$b(node) && node.data.length === 0) {
            dom.remove(node);
        }
    };
    const insertNode = (dom, rng, node) => {
        rng.insertNode(node);
        trimEmptyTextNode$1(dom, node.previousSibling);
        trimEmptyTextNode$1(dom, node.nextSibling);
    };
    const insertFragment = (dom, rng, frag) => {
        const firstChild = Optional.from(frag.firstChild);
        const lastChild = Optional.from(frag.lastChild);
        rng.insertNode(frag);
        firstChild.each((child) => trimEmptyTextNode$1(dom, child.previousSibling));
        lastChild.each((child) => trimEmptyTextNode$1(dom, child.nextSibling));
    };
    // Wrapper to Range.insertNode which removes any empty text nodes created in the process.
    // Doesn't merge adjacent text nodes - this is according to the DOM spec.
    const rangeInsertNode = (dom, rng, node) => {
        if (isDocumentFragment(node)) {
            insertFragment(dom, rng, node);
        }
        else {
            insertNode(dom, rng, node);
        }
    };

    /**
     * This module creates or resolves xpath like string representation of a CaretPositions.
     *
     * The format is a / separated list of chunks with:
     * <element|text()>[index|after|before]
     *
     * For example:
     *  p[0]/b[0]/text()[0],1 = <p><b>a|c</b></p>
     *  p[0]/img[0],before = <p>|<img></p>
     *  p[0]/img[0],after = <p><img>|</p>
     *
     * @private
     * @static
     * @class tinymce.caret.CaretBookmark
     * @example
     * const bookmark = CaretBookmark.create(rootElm, CaretPosition.before(rootElm.firstChild));
     * const caretPosition = CaretBookmark.resolve(bookmark);
     */
    const isText$6 = isText$b;
    const isBogus = isBogus$1;
    const nodeIndex = DOMUtils.nodeIndex;
    const normalizedParent = (node) => {
        const parentNode = node.parentNode;
        if (isBogus(parentNode)) {
            return normalizedParent(parentNode);
        }
        return parentNode;
    };
    const getChildNodes = (node) => {
        if (!node) {
            return [];
        }
        return reduce(node.childNodes, (result, node) => {
            if (isBogus(node) && node.nodeName !== 'BR') {
                result = result.concat(getChildNodes(node));
            }
            else {
                result.push(node);
            }
            return result;
        }, []);
    };
    const normalizedTextOffset = (node, offset) => {
        let tempNode = node;
        while ((tempNode = tempNode.previousSibling)) {
            if (!isText$6(tempNode)) {
                break;
            }
            offset += tempNode.data.length;
        }
        return offset;
    };
    const equal = (a) => (b) => a === b;
    const normalizedNodeIndex = (node) => {
        let nodes, index;
        nodes = getChildNodes(normalizedParent(node));
        index = findIndex$1(nodes, equal(node), node);
        nodes = nodes.slice(0, index + 1);
        const numTextFragments = reduce(nodes, (result, node, i) => {
            if (isText$6(node) && isText$6(nodes[i - 1])) {
                result++;
            }
            return result;
        }, 0);
        nodes = filter$3(nodes, matchNodeNames$1([node.nodeName]));
        index = findIndex$1(nodes, equal(node), node);
        return index - numTextFragments;
    };
    const createPathItem = (node) => {
        const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();
        return name + '[' + normalizedNodeIndex(node) + ']';
    };
    const parentsUntil$1 = (root, node, predicate) => {
        const parents = [];
        for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
            if (predicate && predicate(tempNode)) {
                break;
            }
            parents.push(tempNode);
        }
        return parents;
    };
    const create$9 = (root, caretPosition) => {
        let path = [];
        let container = caretPosition.container();
        let offset = caretPosition.offset();
        let outputOffset;
        if (isText$6(container)) {
            outputOffset = normalizedTextOffset(container, offset);
        }
        else {
            const childNodes = container.childNodes;
            if (offset >= childNodes.length) {
                outputOffset = 'after';
                offset = childNodes.length - 1;
            }
            else {
                outputOffset = 'before';
            }
            container = childNodes[offset];
        }
        path.push(createPathItem(container));
        let parents = parentsUntil$1(root, container);
        parents = filter$3(parents, not(isBogus$1));
        path = path.concat(map$1(parents, (node) => {
            return createPathItem(node);
        }));
        return path.reverse().join('/') + ',' + outputOffset;
    };
    const resolvePathItem = (node, name, index) => {
        let nodes = getChildNodes(node);
        nodes = filter$3(nodes, (node, index) => {
            return !isText$6(node) || !isText$6(nodes[index - 1]);
        });
        nodes = filter$3(nodes, matchNodeNames$1([name]));
        return nodes[index];
    };
    const findTextPosition = (container, offset) => {
        let node = container;
        let targetOffset = 0;
        while (isText$6(node)) {
            const dataLen = node.data.length;
            if (offset >= targetOffset && offset <= targetOffset + dataLen) {
                container = node;
                offset = offset - targetOffset;
                break;
            }
            if (!isText$6(node.nextSibling)) {
                container = node;
                offset = dataLen;
                break;
            }
            targetOffset += dataLen;
            node = node.nextSibling;
        }
        if (isText$6(container) && offset > container.data.length) {
            offset = container.data.length;
        }
        return CaretPosition(container, offset);
    };
    const resolve$1 = (root, path) => {
        if (!path) {
            return null;
        }
        const parts = path.split(',');
        const paths = parts[0].split('/');
        const offset = parts.length > 1 ? parts[1] : 'before';
        const container = reduce(paths, (result, value) => {
            const match = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
            if (!match) {
                return null;
            }
            if (match[1] === 'text()') {
                match[1] = '#text';
            }
            return resolvePathItem(result, match[1], parseInt(match[2], 10));
        }, root);
        if (!container) {
            return null;
        }
        if (!isText$6(container) && container.parentNode) {
            let nodeOffset;
            if (offset === 'after') {
                nodeOffset = nodeIndex(container) + 1;
            }
            else {
                nodeOffset = nodeIndex(container);
            }
            return CaretPosition(container.parentNode, nodeOffset);
        }
        return findTextPosition(container, parseInt(offset, 10));
    };

    const isContentEditableFalse$8 = isContentEditableFalse$a;
    const getNormalizedTextOffset$1 = (trim, container, offset) => {
        let trimmedOffset = trim(container.data.slice(0, offset)).length;
        for (let node = container.previousSibling; node && isText$b(node); node = node.previousSibling) {
            trimmedOffset += trim(node.data).length;
        }
        return trimmedOffset;
    };
    const getPoint = (dom, trim, normalized, rng, start) => {
        const container = start ? rng.startContainer : rng.endContainer;
        let offset = start ? rng.startOffset : rng.endOffset;
        const point = [];
        const root = dom.getRoot();
        if (isText$b(container)) {
            point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);
        }
        else {
            let after = 0;
            const childNodes = container.childNodes;
            if (offset >= childNodes.length && childNodes.length) {
                after = 1;
                offset = Math.max(0, childNodes.length - 1);
            }
            point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
        }
        for (let node = container; node && node !== root; node = node.parentNode) {
            point.push(dom.nodeIndex(node, normalized));
        }
        return point;
    };
    const getLocation = (trim, selection, normalized, rng) => {
        const dom = selection.dom;
        const start = getPoint(dom, trim, normalized, rng, true);
        const forward = selection.isForward();
        const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};
        if (!selection.isCollapsed()) {
            const end = getPoint(dom, trim, normalized, rng, false);
            return { start, end, forward, ...fakeCaret };
        }
        else {
            return { start, forward, ...fakeCaret };
        }
    };
    const findIndex = (dom, name, element) => {
        let count = 0;
        Tools.each(dom.select(name), (node) => {
            if (node.getAttribute('data-mce-bogus') === 'all') {
                return;
            }
            else if (node === element) {
                return false;
            }
            else {
                count++;
                return;
            }
        });
        return count;
    };
    const moveEndPoint$1 = (rng, start) => {
        let container = start ? rng.startContainer : rng.endContainer;
        let offset = start ? rng.startOffset : rng.endOffset;
        // normalize Table Cell selection
        if (isElement$7(container) && container.nodeName === 'TR') {
            const childNodes = container.childNodes;
            container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
            if (container) {
                offset = start ? 0 : container.childNodes.length;
                if (start) {
                    rng.setStart(container, offset);
                }
                else {
                    rng.setEnd(container, offset);
                }
            }
        }
    };
    const normalizeTableCellSelection = (rng) => {
        moveEndPoint$1(rng, true);
        moveEndPoint$1(rng, false);
        return rng;
    };
    const findSibling = (node, offset) => {
        if (isElement$7(node)) {
            node = getNode$1(node, offset);
            if (isContentEditableFalse$8(node)) {
                return node;
            }
        }
        if (isCaretContainer$2(node)) {
            if (isText$b(node) && isCaretContainerBlock$1(node)) {
                node = node.parentNode;
            }
            let sibling = node.previousSibling;
            if (isContentEditableFalse$8(sibling)) {
                return sibling;
            }
            sibling = node.nextSibling;
            if (isContentEditableFalse$8(sibling)) {
                return sibling;
            }
        }
        return undefined;
    };
    const findAdjacentContentEditableFalseElm = (rng) => {
        return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
    };
    const getOffsetBookmark = (trim, normalized, selection) => {
        const element = selection.getNode();
        const rng = selection.getRng();
        if (element.nodeName === 'IMG' || isContentEditableFalse$8(element)) {
            const name = element.nodeName;
            return { name, index: findIndex(selection.dom, name, element) };
        }
        const sibling = findAdjacentContentEditableFalseElm(rng);
        if (sibling) {
            const name = sibling.tagName;
            return { name, index: findIndex(selection.dom, name, sibling) };
        }
        return getLocation(trim, selection, normalized, rng);
    };
    const getCaretBookmark = (selection) => {
        const rng = selection.getRng();
        return {
            start: create$9(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),
            end: create$9(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),
            forward: selection.isForward()
        };
    };
    const getRangeBookmark = (selection) => {
        return { rng: selection.getRng(), forward: selection.isForward() };
    };
    const createBookmarkSpan = (dom, id, filled) => {
        const args = { 'data-mce-type': 'bookmark', id, 'style': 'overflow:hidden;line-height:0px' };
        return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);
    };
    const getPersistentBookmark = (selection, filled) => {
        const dom = selection.dom;
        let rng = selection.getRng();
        const id = dom.uniqueId();
        const collapsed = selection.isCollapsed();
        const element = selection.getNode();
        const name = element.nodeName;
        const forward = selection.isForward();
        if (name === 'IMG') {
            return { name, index: findIndex(dom, name, element) };
        }
        // W3C method
        const rng2 = normalizeTableCellSelection(rng.cloneRange());
        // Insert end marker
        if (!collapsed) {
            rng2.collapse(false);
            const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);
            rangeInsertNode(dom, rng2, endBookmarkNode);
        }
        rng = normalizeTableCellSelection(rng);
        rng.collapse(true);
        const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);
        rangeInsertNode(dom, rng, startBookmarkNode);
        selection.moveToBookmark({ id, keep: true, forward });
        return { id, forward };
    };
    const getBookmark$3 = (selection, type, normalized = false) => {
        if (type === 2) {
            return getOffsetBookmark(trim$2, normalized, selection);
        }
        else if (type === 3) {
            return getCaretBookmark(selection);
        }
        else if (type) {
            return getRangeBookmark(selection);
        }
        else {
            return getPersistentBookmark(selection, false);
        }
    };
    const getUndoBookmark = curry(getOffsetBookmark, identity, true);

    const isInlinePattern = (pattern) => pattern.type === 'inline-command' || pattern.type === 'inline-format';
    const isBlockPattern = (pattern) => pattern.type === 'block-command' || pattern.type === 'block-format';
    const hasBlockTrigger = (pattern, trigger) => (pattern.type === 'block-command' || pattern.type === 'block-format') && pattern.trigger === trigger;
    const normalizePattern = (pattern) => {
        var _a;
        const err = (message) => Result.error({ message, pattern });
        const formatOrCmd = (name, onFormat, onCommand) => {
            if (pattern.format !== undefined) {
                let formats;
                if (isArray$1(pattern.format)) {
                    if (!forall(pattern.format, isString)) {
                        return err(name + ' pattern has non-string items in the `format` array');
                    }
                    formats = pattern.format;
                }
                else if (isString(pattern.format)) {
                    formats = [pattern.format];
                }
                else {
                    return err(name + ' pattern has non-string `format` parameter');
                }
                return Result.value(onFormat(formats));
            }
            else if (pattern.cmd !== undefined) {
                if (!isString(pattern.cmd)) {
                    return err(name + ' pattern has non-string `cmd` parameter');
                }
                return Result.value(onCommand(pattern.cmd, pattern.value));
            }
            else {
                return err(name + ' pattern is missing both `format` and `cmd` parameters');
            }
        };
        if (!isObject(pattern)) {
            return err('Raw pattern is not an object');
        }
        if (!isString(pattern.start)) {
            return err('Raw pattern is missing `start` parameter');
        }
        if (pattern.end !== undefined) {
            // inline pattern
            if (!isString(pattern.end)) {
                return err('Inline pattern has non-string `end` parameter');
            }
            if (pattern.start.length === 0 && pattern.end.length === 0) {
                return err('Inline pattern has empty `start` and `end` parameters');
            }
            let start = pattern.start;
            let end = pattern.end;
            // when the end is empty swap with start as it is more efficient
            if (end.length === 0) {
                end = start;
                start = '';
            }
            return formatOrCmd('Inline', (format) => ({ type: 'inline-format', start, end, format }), (cmd, value) => ({ type: 'inline-command', start, end, cmd, value }));
        }
        else if (pattern.replacement !== undefined) {
            // replacement pattern
            if (!isString(pattern.replacement)) {
                return err('Replacement pattern has non-string `replacement` parameter');
            }
            if (pattern.start.length === 0) {
                return err('Replacement pattern has empty `start` parameter');
            }
            return Result.value({
                type: 'inline-command',
                start: '',
                end: pattern.start,
                cmd: 'mceInsertContent',
                value: pattern.replacement
            });
        }
        else {
            // block pattern
            const trigger = (_a = pattern.trigger) !== null && _a !== void 0 ? _a : 'space';
            if (pattern.start.length === 0) {
                return err('Block pattern has empty `start` parameter');
            }
            return formatOrCmd('Block', (formats) => ({
                type: 'block-format',
                start: pattern.start,
                format: formats[0],
                trigger
            }), (command, commandValue) => ({
                type: 'block-command',
                start: pattern.start,
                cmd: command,
                value: commandValue,
                trigger
            }));
        }
    };
    const getBlockPatterns = (patterns) => filter$5(patterns, isBlockPattern);
    const getInlinePatterns = (patterns) => filter$5(patterns, isInlinePattern);
    const createPatternSet = (patterns, dynamicPatternsLookup) => ({
        inlinePatterns: getInlinePatterns(patterns),
        blockPatterns: getBlockPatterns(patterns),
        dynamicPatternsLookup
    });
    const filterByTrigger = (patterns, trigger) => {
        return {
            ...patterns,
            blockPatterns: filter$5(patterns.blockPatterns, (pattern) => hasBlockTrigger(pattern, trigger))
        };
    };
    const fromRawPatterns = (patterns) => {
        const normalized = partition$1(map$3(patterns, normalizePattern));
        // eslint-disable-next-line no-console
        each$e(normalized.errors, (err) => console.error(err.message, err.pattern));
        return normalized.values;
    };
    const fromRawPatternsLookup = (lookupFn) => {
        return (ctx) => {
            const rawPatterns = lookupFn(ctx);
            return fromRawPatterns(rawPatterns);
        };
    };

    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);
    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);
    const fireRemove = (editor) => {
        editor.dispatch('remove');
    };
    const fireDetach = (editor) => {
        editor.dispatch('detach');
    };
    const fireSwitchMode = (editor, mode) => {
        editor.dispatch('SwitchMode', { mode });
    };
    const fireObjectResizeStart = (editor, target, width, height, origin) => {
        editor.dispatch('ObjectResizeStart', { target, width, height, origin });
    };
    const fireObjectResized = (editor, target, width, height, origin) => {
        editor.dispatch('ObjectResized', { target, width, height, origin });
    };
    const firePreInit = (editor) => {
        editor.dispatch('PreInit');
    };
    const firePostRender = (editor) => {
        editor.dispatch('PostRender');
    };
    const fireInit = (editor) => {
        editor.dispatch('Init');
    };
    const firePlaceholderToggle = (editor, state) => {
        editor.dispatch('PlaceholderToggle', { state });
    };
    const fireError = (editor, errorType, error) => {
        editor.dispatch(errorType, error);
    };
    const fireFormatApply = (editor, format, node, vars) => {
        editor.dispatch('FormatApply', { format, node, vars });
    };
    const fireFormatRemove = (editor, format, node, vars) => {
        editor.dispatch('FormatRemove', { format, node, vars });
    };
    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);
    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);
    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);
    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);
    const fireAutocompleterStart = (editor, args) => {
        editor.dispatch('AutocompleterStart', args);
    };
    const fireAutocompleterUpdate = (editor, args) => {
        editor.dispatch('AutocompleterUpdate', args);
    };
    const fireAutocompleterUpdateActiveRange = (editor, args) => {
        editor.dispatch('AutocompleterUpdateActiveRange', args);
    };
    const fireAutocompleterEnd = (editor) => {
        editor.dispatch('AutocompleterEnd');
    };
    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', { content: html, internal });
    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', { node, internal });
    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });
    const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', { state });
    const fireDisabledStateChange = (editor, state) => editor.dispatch('DisabledStateChange', { state });
    const fireCloseTooltips = (editor) => editor.dispatch('CloseActiveTooltips');

    const deviceDetection$1 = detect$1().deviceType;
    const isTouch = deviceDetection$1.isTouch();
    const DOM$e = DOMUtils.DOM;
    const getHash = (value) => {
        const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');
        return foldl(items, (output, item) => {
            const arr = item.split('=');
            const key = arr[0];
            const val = arr.length > 1 ? arr[1] : key;
            output[trim$4(key)] = trim$4(val);
            return output;
        }, {});
    };
    const isRegExp = (x) => is$5(x, RegExp);
    const option$1 = (name) => (editor) => editor.options.get(name);
    const stringOrObjectProcessor = (value) => isString(value) || isObject(value);
    const bodyOptionProcessor = (editor, defaultValue = '') => (value) => {
        const valid = isString(value);
        if (valid) {
            if (value.indexOf('=') !== -1) {
                const bodyObj = getHash(value);
                return { value: get$a(bodyObj, editor.id).getOr(defaultValue), valid };
            }
            else {
                return { value, valid };
            }
        }
        else {
            return { valid: false, message: 'Must be a string.' };
        }
    };
    const register$7 = (editor) => {
        const registerOption = editor.options.register;
        registerOption('id', {
            processor: 'string',
            default: editor.id
        });
        registerOption('selector', {
            processor: 'string'
        });
        registerOption('target', {
            processor: 'object'
        });
        registerOption('suffix', {
            processor: 'string'
        });
        registerOption('cache_suffix', {
            processor: 'string'
        });
        registerOption('base_url', {
            processor: 'string'
        });
        registerOption('referrer_policy', {
            processor: 'string',
            default: ''
        });
        registerOption('crossorigin', {
            processor: 'function',
            default: constant(undefined)
        });
        registerOption('language_load', {
            processor: 'boolean',
            default: true
        });
        registerOption('inline', {
            processor: 'boolean',
            default: false
        });
        registerOption('iframe_attrs', {
            processor: 'object',
            default: {}
        });
        registerOption('doctype', {
            processor: 'string',
            default: '<!DOCTYPE html>'
        });
        registerOption('document_base_url', {
            processor: 'string',
            default: editor.editorManager.documentBaseURL
        });
        registerOption('body_id', {
            processor: bodyOptionProcessor(editor, 'tinymce'),
            default: 'tinymce'
        });
        registerOption('body_class', {
            processor: bodyOptionProcessor(editor),
            default: ''
        });
        registerOption('content_security_policy', {
            processor: 'string',
            default: ''
        });
        registerOption('br_in_pre', {
            processor: 'boolean',
            default: true
        });
        registerOption('forced_root_block', {
            processor: (value) => {
                const valid = isString(value) && isNotEmpty(value);
                if (valid) {
                    return { value, valid };
                }
                else {
                    return { valid: false, message: 'Must be a non-empty string.' };
                }
            },
            default: 'p'
        });
        registerOption('forced_root_block_attrs', {
            processor: 'object',
            default: {}
        });
        registerOption('newline_behavior', {
            processor: (value) => {
                const valid = contains$2(['block', 'linebreak', 'invert', 'default'], value);
                return valid ? { value, valid } : { valid: false, message: 'Must be one of: block, linebreak, invert or default.' };
            },
            default: 'default'
        });
        registerOption('br_newline_selector', {
            processor: 'string',
            default: '.mce-toc h2,figcaption,caption'
        });
        registerOption('no_newline_selector', {
            processor: 'string',
            default: ''
        });
        registerOption('keep_styles', {
            processor: 'boolean',
            default: true
        });
        registerOption('end_container_on_empty_block', {
            processor: (value) => {
                if (isBoolean(value)) {
                    return { valid: true, value };
                }
                else if (isString(value)) {
                    return { valid: true, value };
                }
                else {
                    return { valid: false, message: 'Must be boolean or a string' };
                }
            },
            default: 'blockquote'
        });
        registerOption('font_size_style_values', {
            processor: 'string',
            default: 'xx-small,x-small,small,medium,large,x-large,xx-large'
        });
        registerOption('font_size_legacy_values', {
            processor: 'string',
            // See: http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size
            default: 'xx-small,small,medium,large,x-large,xx-large,300%'
        });
        registerOption('font_size_classes', {
            processor: 'string',
            default: ''
        });
        registerOption('automatic_uploads', {
            processor: 'boolean',
            default: true
        });
        registerOption('images_reuse_filename', {
            processor: 'boolean',
            default: false
        });
        registerOption('images_replace_blob_uris', {
            processor: 'boolean',
            default: true
        });
        registerOption('icons', {
            processor: 'string',
            default: ''
        });
        registerOption('icons_url', {
            processor: 'string',
            default: ''
        });
        registerOption('images_upload_url', {
            processor: 'string',
            default: ''
        });
        registerOption('images_upload_base_path', {
            processor: 'string',
            default: ''
        });
        registerOption('images_upload_credentials', {
            processor: 'boolean',
            default: false
        });
        registerOption('images_upload_handler', {
            processor: 'function'
        });
        registerOption('language', {
            processor: 'string',
            default: 'en'
        });
        registerOption('language_url', {
            processor: 'string',
            default: ''
        });
        registerOption('entity_encoding', {
            processor: 'string',
            default: 'named'
        });
        registerOption('indent', {
            processor: 'boolean',
            default: true
        });
        registerOption('indent_before', {
            processor: 'string',
            default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' +
                'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'
        });
        registerOption('indent_after', {
            processor: 'string',
            default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' +
                'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'
        });
        registerOption('indent_use_margin', {
            processor: 'boolean',
            default: false
        });
        registerOption('indentation', {
            processor: 'string',
            default: '40px'
        });
        registerOption('content_css', {
            processor: (value) => {
                const valid = value === false || isString(value) || isArrayOf(value, isString);
                if (valid) {
                    if (isString(value)) {
                        return { value: map$3(value.split(','), trim$4), valid };
                    }
                    else if (isArray$1(value)) {
                        return { value, valid };
                    }
                    else if (value === false) {
                        return { value: [], valid };
                    }
                    else {
                        return { value, valid };
                    }
                }
                else {
                    return { valid: false, message: 'Must be false, a string or an array of strings.' };
                }
            },
            default: isInline$2(editor) ? [] : ['default']
        });
        registerOption('content_style', {
            processor: 'string'
        });
        registerOption('content_css_cors', {
            processor: 'boolean',
            default: false
        });
        registerOption('font_css', {
            processor: (value) => {
                const valid = isString(value) || isArrayOf(value, isString);
                if (valid) {
                    const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$4);
                    return { value: newValue, valid };
                }
                else {
                    return { valid: false, message: 'Must be a string or an array of strings.' };
                }
            },
            default: []
        });
        registerOption('extended_mathml_attributes', {
            processor: 'string[]'
        });
        registerOption('extended_mathml_elements', {
            processor: 'string[]'
        });
        registerOption('inline_boundaries', {
            processor: 'boolean',
            default: true
        });
        registerOption('inline_boundaries_selector', {
            processor: 'string',
            default: 'a[href],code,span.mce-annotation'
        });
        registerOption('object_resizing', {
            processor: (value) => {
                const valid = isBoolean(value) || isString(value);
                if (valid) {
                    if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {
                        return { value: '', valid };
                    }
                    else {
                        return { value: value === true ? 'table,img,figure.image,div,video,iframe' : value, valid };
                    }
                }
                else {
                    return { valid: false, message: 'Must be boolean or a string' };
                }
            },
            // No nice way to do object resizing on touch devices at this stage
            default: !isTouch
        });
        registerOption('resize_img_proportional', {
            processor: 'boolean',
            default: true
        });
        registerOption('event_root', {
            processor: 'string'
        });
        registerOption('service_message', {
            processor: 'string'
        });
        registerOption('onboarding', {
            processor: 'boolean',
            default: true
        });
        registerOption('tiny_cloud_entry_url', {
            processor: 'string'
        });
        registerOption('theme', {
            processor: (value) => value === false || isString(value) || isFunction(value),
            default: 'silver'
        });
        registerOption('theme_url', {
            processor: 'string'
        });
        registerOption('formats', {
            processor: 'object'
        });
        registerOption('format_empty_lines', {
            processor: 'boolean',
            default: false
        });
        registerOption('format_noneditable_selector', {
            processor: 'string',
            default: ''
        });
        registerOption('preview_styles', {
            processor: (value) => {
                const valid = value === false || isString(value);
                if (valid) {
                    return { value: value === false ? '' : value, valid };
                }
                else {
                    return { valid: false, message: 'Must be false or a string' };
                }
            },
            default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'
        });
        registerOption('custom_ui_selector', {
            processor: 'string',
            default: ''
        });
        registerOption('hidden_input', {
            processor: 'boolean',
            default: true
        });
        registerOption('submit_patch', {
            processor: 'boolean',
            default: true
        });
        registerOption('encoding', {
            processor: 'string'
        });
        registerOption('add_form_submit_trigger', {
            processor: 'boolean',
            default: true
        });
        registerOption('add_unload_trigger', {
            processor: 'boolean',
            default: true
        });
        registerOption('custom_undo_redo_levels', {
            processor: 'number',
            default: 0
        });
        registerOption('disable_nodechange', {
            processor: 'boolean',
            default: false
        });
        registerOption('disabled', {
            processor: (value) => {
                if (isBoolean(value)) {
                    if (editor.initialized && isDisabled$1(editor) !== value) {
                        // Schedules the callback to run in the next microtask queue once the option is updated
                        // TODO: TINY-11586 - Implement `onChange` callback when the value of an option changes
                        // eslint-disable-next-line @typescript-eslint/no-floating-promises
                        Promise.resolve().then(() => {
                            fireDisabledStateChange(editor, value);
                        });
                    }
                    return { valid: true, value };
                }
                return { valid: false, message: 'The value must be a boolean.' };
            },
            default: false
        });
        registerOption('readonly', {
            processor: 'boolean',
            default: false
        });
        registerOption('editable_root', {
            processor: 'boolean',
            default: true
        });
        registerOption('plugins', {
            processor: 'string[]',
            default: []
        });
        registerOption('external_plugins', {
            processor: 'object'
        });
        registerOption('forced_plugins', {
            processor: 'string[]'
        });
        registerOption('model', {
            processor: 'string',
            default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'
        });
        registerOption('model_url', {
            processor: 'string'
        });
        registerOption('block_unsupported_drop', {
            processor: 'boolean',
            default: true
        });
        registerOption('visual', {
            processor: 'boolean',
            default: true
        });
        registerOption('visual_table_class', {
            processor: 'string',
            default: 'mce-item-table'
        });
        registerOption('visual_anchor_class', {
            processor: 'string',
            default: 'mce-item-anchor'
        });
        registerOption('iframe_aria_text', {
            processor: 'string',
            default: 'Rich Text Area'.concat(editor.hasPlugin('help') ? '. Press ALT-0 for help.' : '')
        });
        registerOption('setup', {
            processor: 'function'
        });
        registerOption('init_instance_callback', {
            processor: 'function'
        });
        registerOption('url_converter', {
            processor: 'function',
            // Note: Don't bind here, as the binding is handled via the `url_converter_scope`
            // eslint-disable-next-line @typescript-eslint/unbound-method
            default: editor.convertURL
        });
        registerOption('url_converter_scope', {
            processor: 'object',
            default: editor
        });
        registerOption('urlconverter_callback', {
            processor: 'function'
        });
        registerOption('allow_conditional_comments', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_html_data_urls', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_svg_data_urls', {
            processor: 'boolean'
        });
        registerOption('allow_html_in_named_anchor', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_html_in_comments', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_script_urls', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_unsafe_link_target', {
            processor: 'boolean',
            default: false
        });
        registerOption('allow_mathml_annotation_encodings', {
            processor: (value) => {
                const valid = isArrayOf(value, isString);
                return valid ? { value, valid } : { valid: false, message: 'Must be an array of strings.' };
            },
            default: []
        });
        registerOption('convert_fonts_to_spans', {
            processor: 'boolean',
            default: true,
            deprecated: true
        });
        registerOption('fix_list_elements', {
            processor: 'boolean',
            default: false
        });
        registerOption('preserve_cdata', {
            processor: 'boolean',
            default: false
        });
        registerOption('remove_trailing_brs', {
            processor: 'boolean',
            default: true
        });
        registerOption('pad_empty_with_br', {
            processor: 'boolean',
            default: false,
        });
        registerOption('inline_styles', {
            processor: 'boolean',
            default: true,
            deprecated: true
        });
        registerOption('element_format', {
            processor: 'string',
            default: 'html'
        });
        registerOption('entities', {
            processor: 'string'
        });
        registerOption('schema', {
            processor: 'string',
            default: 'html5'
        });
        registerOption('convert_urls', {
            processor: 'boolean',
            default: true
        });
        registerOption('relative_urls', {
            processor: 'boolean',
            default: true
        });
        registerOption('remove_script_host', {
            processor: 'boolean',
            default: true
        });
        registerOption('custom_elements', {
            processor: stringOrObjectProcessor
        });
        registerOption('extended_valid_elements', {
            processor: 'string'
        });
        registerOption('invalid_elements', {
            processor: 'string'
        });
        registerOption('invalid_styles', {
            processor: stringOrObjectProcessor
        });
        registerOption('valid_children', {
            processor: 'string'
        });
        registerOption('valid_classes', {
            processor: stringOrObjectProcessor
        });
        registerOption('valid_elements', {
            processor: 'string'
        });
        registerOption('valid_styles', {
            processor: stringOrObjectProcessor
        });
        registerOption('verify_html', {
            processor: 'boolean',
            default: true
        });
        registerOption('auto_focus', {
            processor: (value) => isString(value) || value === true
        });
        registerOption('browser_spellcheck', {
            processor: 'boolean',
            default: false
        });
        registerOption('protect', {
            processor: 'array'
        });
        registerOption('images_file_types', {
            processor: 'string',
            default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'
        });
        registerOption('deprecation_warnings', {
            processor: 'boolean',
            default: true
        });
        registerOption('a11y_advanced_options', {
            processor: 'boolean',
            default: false
        });
        registerOption('api_key', {
            processor: 'string'
        });
        registerOption('license_key', {
            processor: 'string'
        });
        registerOption('paste_block_drop', {
            processor: 'boolean',
            default: false
        });
        registerOption('paste_data_images', {
            processor: 'boolean',
            default: true
        });
        registerOption('paste_preprocess', {
            processor: 'function'
        });
        registerOption('paste_postprocess', {
            processor: 'function'
        });
        registerOption('paste_webkit_styles', {
            processor: 'string',
            default: 'none'
        });
        registerOption('paste_remove_styles_if_webkit', {
            processor: 'boolean',
            default: true
        });
        registerOption('paste_merge_formats', {
            processor: 'boolean',
            default: true
        });
        registerOption('smart_paste', {
            processor: 'boolean',
            default: true
        });
        registerOption('paste_as_text', {
            processor: 'boolean',
            default: false
        });
        registerOption('paste_tab_spaces', {
            processor: 'number',
            default: 4
        });
        registerOption('text_patterns', {
            processor: (value) => {
                if (isArrayOf(value, isObject) || value === false) {
                    const patterns = value === false ? [] : value;
                    return { value: fromRawPatterns(patterns), valid: true };
                }
                else {
                    return { valid: false, message: 'Must be an array of objects or false.' };
                }
            },
            default: [
                { start: '*', end: '*', format: 'italic' },
                { start: '**', end: '**', format: 'bold' },
                { start: '#', format: 'h1', trigger: 'space' },
                { start: '##', format: 'h2', trigger: 'space' },
                { start: '###', format: 'h3', trigger: 'space' },
                { start: '####', format: 'h4', trigger: 'space' },
                { start: '#####', format: 'h5', trigger: 'space' },
                { start: '######', format: 'h6', trigger: 'space' },
                { start: '1.', cmd: 'InsertOrderedList', trigger: 'space' },
                { start: '*', cmd: 'InsertUnorderedList', trigger: 'space' },
                { start: '-', cmd: 'InsertUnorderedList', trigger: 'space' },
                { start: '>', cmd: 'mceBlockQuote', trigger: 'space' },
                { start: '---', cmd: 'InsertHorizontalRule', trigger: 'space' },
            ]
        });
        registerOption('text_patterns_lookup', {
            processor: (value) => {
                if (isFunction(value)) {
                    return {
                        value: fromRawPatternsLookup(value),
                        valid: true,
                    };
                }
                else {
                    return { valid: false, message: 'Must be a single function' };
                }
            },
            default: (_ctx) => []
        });
        registerOption('noneditable_class', {
            processor: 'string',
            default: 'mceNonEditable'
        });
        registerOption('editable_class', {
            processor: 'string',
            default: 'mceEditable'
        });
        registerOption('noneditable_regexp', {
            processor: (value) => {
                if (isArrayOf(value, isRegExp)) {
                    return { value, valid: true };
                }
                else if (isRegExp(value)) {
                    return { value: [value], valid: true };
                }
                else {
                    return { valid: false, message: 'Must be a RegExp or an array of RegExp.' };
                }
            },
            default: []
        });
        registerOption('table_tab_navigation', {
            processor: 'boolean',
            default: true
        });
        registerOption('highlight_on_focus', {
            processor: 'boolean',
            default: true
        });
        registerOption('xss_sanitization', {
            processor: 'boolean',
            default: true
        });
        registerOption('details_initial_state', {
            processor: (value) => {
                const valid = contains$2(['inherited', 'collapsed', 'expanded'], value);
                return valid ? { value, valid } : { valid: false, message: 'Must be one of: inherited, collapsed, or expanded.' };
            },
            default: 'inherited'
        });
        registerOption('details_serialized_state', {
            processor: (value) => {
                const valid = contains$2(['inherited', 'collapsed', 'expanded'], value);
                return valid ? { value, valid } : { valid: false, message: 'Must be one of: inherited, collapsed, or expanded.' };
            },
            default: 'inherited'
        });
        registerOption('init_content_sync', {
            processor: 'boolean',
            default: false
        });
        registerOption('newdocument_content', {
            processor: 'string',
            default: ''
        });
        registerOption('sandbox_iframes', {
            processor: 'boolean',
            default: true
        });
        registerOption('sandbox_iframes_exclusions', {
            processor: 'string[]',
            default: [
                'youtube.com',
                'youtu.be',
                'vimeo.com',
                'player.vimeo.com',
                'dailymotion.com',
                'embed.music.apple.com',
                'open.spotify.com',
                'giphy.com',
                'dai.ly',
                'codepen.io',
            ]
        });
        registerOption('convert_unsafe_embeds', {
            processor: 'boolean',
            default: true
        });
        registerOption('user_id', {
            processor: 'string',
            default: 'Anonymous'
        });
        registerOption('fetch_users', {
            processor: (value) => {
                if (value === undefined) {
                    return { valid: true, value: undefined };
                }
                if (isFunction(value)) {
                    return { valid: true, value };
                }
                return {
                    valid: false,
                    message: 'fetch_users must be a function that returns a Promise<ExpectedUser[]>'
                };
            }
        });
        // These options must be registered later in the init sequence due to their default values
        editor.on('ScriptsLoaded', () => {
            registerOption('directionality', {
                processor: 'string',
                default: I18n.isRtl() ? 'rtl' : undefined
            });
            registerOption('placeholder', {
                processor: 'string',
                // Fallback to the original elements placeholder if not set in the settings
                default: DOM$e.getAttrib(editor.getElement(), 'placeholder')
            });
        });
        registerOption('lists_indent_on_tab', {
            processor: 'boolean',
            default: true
        });
        registerOption('list_max_depth', {
            processor: (value) => {
                const valid = isNumber(value);
                if (valid) {
                    if (value < 0) {
                        throw new Error('list_max_depth cannot be set to lower than 0');
                    }
                    return { value, valid };
                }
                else {
                    return { valid: false, message: 'Must be a number' };
                }
            },
        });
    };
    const getIframeAttrs = option$1('iframe_attrs');
    const getDocType = option$1('doctype');
    const getDocumentBaseUrl = option$1('document_base_url');
    const getBodyId = option$1('body_id');
    const getBodyClass = option$1('body_class');
    const getContentSecurityPolicy = option$1('content_security_policy');
    const shouldPutBrInPre$1 = option$1('br_in_pre');
    const getForcedRootBlock = option$1('forced_root_block');
    const getForcedRootBlockAttrs = option$1('forced_root_block_attrs');
    const getNewlineBehavior = option$1('newline_behavior');
    const getBrNewLineSelector = option$1('br_newline_selector');
    const getNoNewLineSelector = option$1('no_newline_selector');
    const shouldKeepStyles = option$1('keep_styles');
    const shouldEndContainerOnEmptyBlock = option$1('end_container_on_empty_block');
    const isAutomaticUploadsEnabled = option$1('automatic_uploads');
    const shouldReuseFileName = option$1('images_reuse_filename');
    const shouldReplaceBlobUris = option$1('images_replace_blob_uris');
    const getIconPackName = option$1('icons');
    const getIconsUrl = option$1('icons_url');
    const getImageUploadUrl = option$1('images_upload_url');
    const getImageUploadBasePath = option$1('images_upload_base_path');
    const getImagesUploadCredentials = option$1('images_upload_credentials');
    const getImagesUploadHandler = option$1('images_upload_handler');
    const shouldUseContentCssCors = option$1('content_css_cors');
    const getReferrerPolicy = option$1('referrer_policy');
    const getCrossOrigin = option$1('crossorigin');
    const getLanguageCode = option$1('language');
    const getLanguageUrl = option$1('language_url');
    const shouldIndentUseMargin = option$1('indent_use_margin');
    const getIndentation = option$1('indentation');
    const getContentCss = option$1('content_css');
    const getContentStyle = option$1('content_style');
    const getFontCss = option$1('font_css');
    const getDirectionality = option$1('directionality');
    const getInlineBoundarySelector = option$1('inline_boundaries_selector');
    const getObjectResizing = option$1('object_resizing');
    const getResizeImgProportional = option$1('resize_img_proportional');
    const getPlaceholder = option$1('placeholder');
    const getEventRoot = option$1('event_root');
    const getServiceMessage = option$1('service_message');
    const getTheme = option$1('theme');
    const getThemeUrl = option$1('theme_url');
    const getModel = option$1('model');
    const getModelUrl = option$1('model_url');
    const isInlineBoundariesEnabled = option$1('inline_boundaries');
    const getFormats = option$1('formats');
    const getPreviewStyles = option$1('preview_styles');
    const canFormatEmptyLines = option$1('format_empty_lines');
    const getFormatNoneditableSelector = option$1('format_noneditable_selector');
    const getCustomUiSelector = option$1('custom_ui_selector');
    const isInline$2 = option$1('inline');
    const hasHiddenInput = option$1('hidden_input');
    const shouldPatchSubmit = option$1('submit_patch');
    const shouldAddFormSubmitTrigger = option$1('add_form_submit_trigger');
    const shouldAddUnloadTrigger = option$1('add_unload_trigger');
    const getCustomUndoRedoLevels = option$1('custom_undo_redo_levels');
    const shouldDisableNodeChange = option$1('disable_nodechange');
    const isReadOnly$1 = option$1('readonly');
    const hasEditableRoot$1 = option$1('editable_root');
    const hasContentCssCors = option$1('content_css_cors');
    const getPlugins = option$1('plugins');
    const getExternalPlugins$1 = option$1('external_plugins');
    const shouldBlockUnsupportedDrop = option$1('block_unsupported_drop');
    const isVisualAidsEnabled = option$1('visual');
    const getVisualAidsTableClass = option$1('visual_table_class');
    const getVisualAidsAnchorClass = option$1('visual_anchor_class');
    const getIframeAriaText = option$1('iframe_aria_text');
    const getSetupCallback = option$1('setup');
    const getInitInstanceCallback = option$1('init_instance_callback');
    const getUrlConverterCallback = option$1('urlconverter_callback');
    const getAutoFocus = option$1('auto_focus');
    const shouldBrowserSpellcheck = option$1('browser_spellcheck');
    const getProtect = option$1('protect');
    const shouldPasteBlockDrop = option$1('paste_block_drop');
    const shouldPasteDataImages = option$1('paste_data_images');
    const getPastePreProcess = option$1('paste_preprocess');
    const getPastePostProcess = option$1('paste_postprocess');
    const getNewDocumentContent = option$1('newdocument_content');
    const getPasteWebkitStyles = option$1('paste_webkit_styles');
    const shouldPasteRemoveWebKitStyles = option$1('paste_remove_styles_if_webkit');
    const shouldPasteMergeFormats = option$1('paste_merge_formats');
    const isSmartPasteEnabled = option$1('smart_paste');
    const isPasteAsTextEnabled = option$1('paste_as_text');
    const getPasteTabSpaces = option$1('paste_tab_spaces');
    const shouldAllowHtmlDataUrls = option$1('allow_html_data_urls');
    const getTextPatterns = option$1('text_patterns');
    const getTextPatternsLookup = option$1('text_patterns_lookup');
    const getNonEditableClass = option$1('noneditable_class');
    const getEditableClass = option$1('editable_class');
    const getNonEditableRegExps = option$1('noneditable_regexp');
    const shouldPreserveCData = option$1('preserve_cdata');
    const shouldHighlightOnFocus = option$1('highlight_on_focus');
    const shouldSanitizeXss = option$1('xss_sanitization');
    const shouldUseDocumentWrite = option$1('init_content_sync');
    const hasTextPatternsLookup = (editor) => editor.options.isSet('text_patterns_lookup');
    const getFontStyleValues = (editor) => Tools.explode(editor.options.get('font_size_style_values'));
    const getFontSizeClasses = (editor) => Tools.explode(editor.options.get('font_size_classes'));
    const isEncodingXml = (editor) => editor.options.get('encoding') === 'xml';
    const getAllowedImageFileTypes = (editor) => Tools.explode(editor.options.get('images_file_types'));
    const hasTableTabNavigation = option$1('table_tab_navigation');
    const getDetailsInitialState = option$1('details_initial_state');
    const getDetailsSerializedState = option$1('details_serialized_state');
    const shouldSandboxIframes = option$1('sandbox_iframes');
    const getSandboxIframesExclusions = (editor) => editor.options.get('sandbox_iframes_exclusions');
    const shouldConvertUnsafeEmbeds = option$1('convert_unsafe_embeds');
    const getLicenseKey = option$1('license_key');
    const getApiKey = option$1('api_key');
    const isDisabled$1 = option$1('disabled');
    const getUserId = option$1('user_id');
    const getFetchUsers = option$1('fetch_users');
    const shouldIndentOnTab = option$1('lists_indent_on_tab');
    const getListMaxDepth = (editor) => Optional.from(editor.options.get('list_max_depth'));

    const isElement$4 = isElement$7;
    const isText$5 = isText$b;
    const removeNode$1 = (node) => {
        const parentNode = node.parentNode;
        if (parentNode) {
            parentNode.removeChild(node);
        }
    };
    const trimCount = (text) => {
        const trimmedText = trim$2(text);
        return {
            count: text.length - trimmedText.length,
            text: trimmedText
        };
    };
    const deleteZwspChars = (caretContainer) => {
        // We use the Text.deleteData API here so as to preserve selection offsets
        let idx;
        while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {
            caretContainer.deleteData(idx, 1);
        }
    };
    const removeUnchanged = (caretContainer, pos) => {
        remove$2(caretContainer);
        return pos;
    };
    const removeTextAndReposition = (caretContainer, pos) => {
        const before = trimCount(caretContainer.data.substr(0, pos.offset()));
        const after = trimCount(caretContainer.data.substr(pos.offset()));
        const text = before.text + after.text;
        if (text.length > 0) {
            deleteZwspChars(caretContainer);
            return CaretPosition(caretContainer, pos.offset() - before.count);
        }
        else {
            return pos;
        }
    };
    const removeElementAndReposition = (caretContainer, pos) => {
        const parentNode = pos.container();
        const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map((index) => {
            return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;
        }).getOr(pos);
        remove$2(caretContainer);
        return newPosition;
    };
    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
    const remove$2 = (caretContainerNode) => {
        if (isElement$4(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {
            if (hasContent(caretContainerNode)) {
                caretContainerNode.removeAttribute('data-mce-caret');
            }
            else {
                removeNode$1(caretContainerNode);
            }
        }
        if (isText$5(caretContainerNode)) {
            deleteZwspChars(caretContainerNode);
            if (caretContainerNode.data.length === 0) {
                removeNode$1(caretContainerNode);
            }
        }
    };

    const isContentEditableFalse$7 = isContentEditableFalse$a;
    const isMedia$1 = isMedia$2;
    const isTableCell$1 = isTableCell$3;
    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';
    const getAbsoluteClientRect = (root, element, before) => {
        const clientRect = collapse(element.getBoundingClientRect(), before);
        let scrollX;
        let scrollY;
        if (root.tagName === 'BODY') {
            const docElm = root.ownerDocument.documentElement;
            scrollX = root.scrollLeft || docElm.scrollLeft;
            scrollY = root.scrollTop || docElm.scrollTop;
        }
        else {
            const rootRect = root.getBoundingClientRect();
            scrollX = root.scrollLeft - rootRect.left;
            scrollY = root.scrollTop - rootRect.top;
        }
        clientRect.left += scrollX;
        clientRect.right += scrollX;
        clientRect.top += scrollY;
        clientRect.bottom += scrollY;
        clientRect.width = 1;
        let margin = element.offsetWidth - element.clientWidth;
        if (margin > 0) {
            if (before) {
                margin *= -1;
            }
            clientRect.left += margin;
            clientRect.right += margin;
        }
        return clientRect;
    };
    const trimInlineCaretContainers = (root) => {
        var _a, _b;
        const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);
        for (let i = 0; i < fakeCaretTargetNodes.length; i++) {
            const node = fakeCaretTargetNodes[i].dom;
            let sibling = node.previousSibling;
            if (endsWithCaretContainer$1(sibling)) {
                const data = sibling.data;
                if (data.length === 1) {
                    (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);
                }
                else {
                    sibling.deleteData(data.length - 1, 1);
                }
            }
            sibling = node.nextSibling;
            if (startsWithCaretContainer$1(sibling)) {
                const data = sibling.data;
                if (data.length === 1) {
                    (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);
                }
                else {
                    sibling.deleteData(0, 1);
                }
            }
        }
    };
    const FakeCaret = (editor, root, isBlock, hasFocus) => {
        const lastVisualCaret = value$1();
        let cursorInterval;
        let caretContainerNode;
        const caretBlock = getForcedRootBlock(editor);
        const dom = editor.dom;
        const show = (before, element) => {
            let rng;
            hide();
            if (isTableCell$1(element)) {
                return null;
            }
            if (isBlock(element)) {
                const caretContainer = insertBlock(caretBlock, element, before);
                const clientRect = getAbsoluteClientRect(root, element, before);
                dom.setStyle(caretContainer, 'top', clientRect.top);
                dom.setStyle(caretContainer, 'caret-color', 'transparent');
                caretContainerNode = caretContainer;
                const caret = dom.create('div', { 'class': 'mce-visual-caret', 'data-mce-bogus': 'all' });
                dom.setStyles(caret, { ...clientRect });
                dom.add(root, caret);
                lastVisualCaret.set({ caret, element, before });
                if (before) {
                    dom.addClass(caret, 'mce-visual-caret-before');
                }
                startBlink();
                rng = element.ownerDocument.createRange();
                rng.setStart(caretContainer, 0);
                rng.setEnd(caretContainer, 0);
            }
            else {
                caretContainerNode = insertInline$1(element, before);
                rng = element.ownerDocument.createRange();
                if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
                    rng.setStart(caretContainerNode, 0);
                    rng.setEnd(caretContainerNode, 0);
                }
                else {
                    rng.setStart(caretContainerNode, 1);
                    rng.setEnd(caretContainerNode, 1);
                }
                return rng;
            }
            return rng;
        };
        const hide = () => {
            // TODO: TINY-6015 - Ensure cleaning up the fake caret preserves the selection, as currently
            //  the CaretContainerRemove.remove below will change the selection in some cases
            trimInlineCaretContainers(root);
            if (caretContainerNode) {
                remove$2(caretContainerNode);
                caretContainerNode = null;
            }
            lastVisualCaret.on((caretState) => {
                dom.remove(caretState.caret);
                lastVisualCaret.clear();
            });
            if (cursorInterval) {
                clearInterval(cursorInterval);
                cursorInterval = undefined;
            }
        };
        const startBlink = () => {
            cursorInterval = window.setInterval(() => {
                lastVisualCaret.on((caretState) => {
                    if (hasFocus()) {
                        dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');
                    }
                    else {
                        dom.addClass(caretState.caret, 'mce-visual-caret-hidden');
                    }
                });
            }, 500);
        };
        const reposition = () => {
            lastVisualCaret.on((caretState) => {
                const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
                dom.setStyles(caretState.caret, { ...clientRect });
            });
        };
        const destroy = () => clearInterval(cursorInterval);
        const getCss = () => ('.mce-visual-caret {' +
            'position: absolute;' +
            'background-color: black;' +
            'background-color: currentcolor;' +
            // 'background-color: red;' +
            '}' +
            '.mce-visual-caret-hidden {' +
            'display: none;' +
            '}' +
            '*[data-mce-caret] {' +
            'position: absolute;' +
            'left: -1000px;' +
            'right: auto;' +
            'top: 0;' +
            'margin: 0;' +
            'padding: 0;' +
            '}');
        return {
            isShowing: lastVisualCaret.isSet,
            show,
            hide,
            getCss,
            reposition,
            destroy
        };
    };
    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();
    const isInlineFakeCaretTarget = (node) => isContentEditableFalse$7(node) || isMedia$1(node);
    const isFakeCaretTarget = (node) => {
        const isTarget = isInlineFakeCaretTarget(node) || (isTable$2(node) && isFakeCaretTableBrowser());
        return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2);
    };

    const isContentEditableTrue$1 = isContentEditableTrue$3;
    const isContentEditableFalse$6 = isContentEditableFalse$a;
    const isMedia = isMedia$2;
    const isBlockLike = matchStyleValues('display', 'block table table-cell table-row table-caption list-item');
    const isCaretContainer = isCaretContainer$2;
    const isCaretContainerBlock = isCaretContainerBlock$1;
    const isElement$3 = isElement$7;
    const isText$4 = isText$b;
    const isCaretCandidate$1 = isCaretCandidate$3;
    const isForwards = (direction) => direction === 1 /* HDirection.Forwards */;
    const isBackwards = (direction) => direction === -1 /* HDirection.Backwards */;
    const skipCaretContainers = (walk, shallow) => {
        let node;
        while ((node = walk(shallow))) {
            if (!isCaretContainerBlock(node)) {
                return node;
            }
        }
        return null;
    };
    const findNode = (node, direction, predicateFn, rootNode, shallow) => {
        const walker = new DomTreeWalker(node, rootNode);
        const isCefOrCaretContainer = isContentEditableFalse$6(node) || isCaretContainerBlock(node);
        let tempNode;
        if (isBackwards(direction)) {
            if (isCefOrCaretContainer) {
                tempNode = skipCaretContainers(walker.prev.bind(walker), true);
                if (predicateFn(tempNode)) {
                    return tempNode;
                }
            }
            while ((tempNode = skipCaretContainers(walker.prev.bind(walker), shallow))) {
                if (predicateFn(tempNode)) {
                    return tempNode;
                }
            }
        }
        if (isForwards(direction)) {
            if (isCefOrCaretContainer) {
                tempNode = skipCaretContainers(walker.next.bind(walker), true);
                if (predicateFn(tempNode)) {
                    return tempNode;
                }
            }
            while ((tempNode = skipCaretContainers(walker.next.bind(walker), shallow))) {
                if (predicateFn(tempNode)) {
                    return tempNode;
                }
            }
        }
        return null;
    };
    const getEditingHost = (node, rootNode) => {
        const isCETrue = (node) => isContentEditableTrue$1(node.dom);
        const isRoot = (node) => node.dom === rootNode;
        return ancestor$5(SugarElement.fromDom(node), isCETrue, isRoot)
            .map((elm) => elm.dom)
            .getOr(rootNode);
    };
    const getParentBlock$3 = (node, rootNode) => {
        while (node && node !== rootNode) {
            if (isBlockLike(node)) {
                return node;
            }
            node = node.parentNode;
        }
        return null;
    };
    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);
    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {
        if (!caretPosition) {
            return Optional.none();
        }
        const container = caretPosition.container();
        const offset = caretPosition.offset();
        if (!isElement$3(container)) {
            return Optional.none();
        }
        return Optional.from(container.childNodes[offset + relativeOffset]);
    };
    const beforeAfter = (before, node) => {
        var _a;
        const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
        const range = doc.createRange();
        if (before) {
            range.setStartBefore(node);
            range.setEndBefore(node);
        }
        else {
            range.setStartAfter(node);
            range.setEndAfter(node);
        }
        return range;
    };
    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);
    const lean = (left, root, node) => {
        const siblingName = left ? 'previousSibling' : 'nextSibling';
        let tempNode = node;
        while (tempNode && tempNode !== root) {
            let sibling = tempNode[siblingName];
            if (sibling && isCaretContainer(sibling)) {
                sibling = sibling[siblingName];
            }
            if (isContentEditableFalse$6(sibling) || isMedia(sibling)) {
                if (isNodesInSameBlock(root, sibling, tempNode)) {
                    return sibling;
                }
                break;
            }
            if (isCaretCandidate$1(sibling)) {
                break;
            }
            tempNode = tempNode.parentNode;
        }
        return null;
    };
    const before$1 = curry(beforeAfter, true);
    const after$1 = curry(beforeAfter, false);
    const normalizeRange$2 = (direction, root, range) => {
        let node;
        const leanLeft = curry(lean, true, root);
        const leanRight = curry(lean, false, root);
        const container = range.startContainer;
        const offset = range.startOffset;
        if (isCaretContainerBlock$1(container)) {
            const block = isText$4(container) ? container.parentNode : container;
            const location = block.getAttribute('data-mce-caret');
            if (location === 'before') {
                node = block.nextSibling;
                if (isFakeCaretTarget(node)) {
                    return before$1(node);
                }
            }
            if (location === 'after') {
                node = block.previousSibling;
                if (isFakeCaretTarget(node)) {
                    return after$1(node);
                }
            }
        }
        if (!range.collapsed) {
            return range;
        }
        if (isText$b(container)) {
            if (isCaretContainer(container)) {
                if (direction === 1) {
                    node = leanRight(container);
                    if (node) {
                        return before$1(node);
                    }
                    node = leanLeft(container);
                    if (node) {
                        return after$1(node);
                    }
                }
                if (direction === -1) {
                    node = leanLeft(container);
                    if (node) {
                        return after$1(node);
                    }
                    node = leanRight(container);
                    if (node) {
                        return before$1(node);
                    }
                }
                return range;
            }
            if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {
                if (direction === 1) {
                    node = leanRight(container);
                    if (node) {
                        return before$1(node);
                    }
                }
                return range;
            }
            if (startsWithCaretContainer$1(container) && offset <= 1) {
                if (direction === -1) {
                    node = leanLeft(container);
                    if (node) {
                        return after$1(node);
                    }
                }
                return range;
            }
            if (offset === container.data.length) {
                node = leanRight(container);
                if (node) {
                    return before$1(node);
                }
                return range;
            }
            if (offset === 0) {
                node = leanLeft(container);
                if (node) {
                    return after$1(node);
                }
                return range;
            }
        }
        return range;
    };
    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$6);
    const getNormalizedRangeEndPoint = (direction, root, range) => {
        const normalizedRange = normalizeRange$2(direction, root, range);
        return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);
    };
    const getElementFromPosition = (pos) => Optional.from(pos.getNode()).map(SugarElement.fromDom);
    const getElementFromPrevPosition = (pos) => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
    const getVisualCaretPosition = (walkFn, caretPosition) => {
        let pos = caretPosition;
        while ((pos = walkFn(pos))) {
            if (pos.isVisible()) {
                return pos;
            }
        }
        return pos;
    };
    const isMoveInsideSameBlock = (from, to) => {
        const inSameBlock = isInSameBlock(from, to);
        // Handle bogus BR <p>abc|<br></p>
        if (!inSameBlock && isBr$7(from.getNode())) {
            return true;
        }
        return inSameBlock;
    };

    const isContentEditableFalse$5 = isContentEditableFalse$a;
    const isText$3 = isText$b;
    const isElement$2 = isElement$7;
    const isBr$3 = isBr$7;
    const isCaretCandidate = isCaretCandidate$3;
    const isAtomic = isAtomic$1;
    const isEditableCaretCandidate = isEditableCaretCandidate$1;
    const getParents$3 = (node, root) => {
        const parents = [];
        let tempNode = node;
        while (tempNode && tempNode !== root) {
            parents.push(tempNode);
            tempNode = tempNode.parentNode;
        }
        return parents;
    };
    const nodeAtIndex = (container, offset) => {
        if (container.hasChildNodes() && offset < container.childNodes.length) {
            return container.childNodes[offset];
        }
        return null;
    };
    const getCaretCandidatePosition = (direction, node) => {
        if (isForwards(direction)) {
            if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {
                return CaretPosition.before(node);
            }
            if (isText$3(node)) {
                return CaretPosition(node, 0);
            }
        }
        if (isBackwards(direction)) {
            if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {
                return CaretPosition.after(node);
            }
            if (isText$3(node)) {
                return CaretPosition(node, node.data.length);
            }
        }
        if (isBackwards(direction)) {
            if (isBr$3(node)) {
                return CaretPosition.before(node);
            }
            return CaretPosition.after(node);
        }
        return CaretPosition.before(node);
    };
    const moveForwardFromBr = (root, nextNode) => {
        const nextSibling = nextNode.nextSibling;
        if (nextSibling && isCaretCandidate(nextSibling)) {
            if (isText$3(nextSibling)) {
                return CaretPosition(nextSibling, 0);
            }
            else {
                return CaretPosition.before(nextSibling);
            }
        }
        else {
            return findCaretPosition$1(1 /* HDirection.Forwards */, CaretPosition.after(nextNode), root);
        }
    };
    const findCaretPosition$1 = (direction, startPos, root) => {
        let node;
        let nextNode;
        let innerNode;
        let caretPosition;
        if (!isElement$2(root) || !startPos) {
            return null;
        }
        if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {
            caretPosition = CaretPosition.after(root.lastChild);
            if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$2(root.lastChild)) {
                return isBr$3(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;
            }
        }
        else {
            caretPosition = startPos;
        }
        const container = caretPosition.container();
        let offset = caretPosition.offset();
        if (isText$3(container)) {
            if (isBackwards(direction) && offset > 0) {
                return CaretPosition(container, --offset);
            }
            if (isForwards(direction) && offset < container.length) {
                return CaretPosition(container, ++offset);
            }
            node = container;
        }
        else {
            if (isBackwards(direction) && offset > 0) {
                nextNode = nodeAtIndex(container, offset - 1);
                if (isCaretCandidate(nextNode)) {
                    if (!isAtomic(nextNode)) {
                        innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
                        if (innerNode) {
                            if (isText$3(innerNode)) {
                                return CaretPosition(innerNode, innerNode.data.length);
                            }
                            return CaretPosition.after(innerNode);
                        }
                    }
                    if (isText$3(nextNode)) {
                        return CaretPosition(nextNode, nextNode.data.length);
                    }
                    return CaretPosition.before(nextNode);
                }
            }
            if (isForwards(direction) && offset < container.childNodes.length) {
                nextNode = nodeAtIndex(container, offset);
                if (isCaretCandidate(nextNode)) {
                    if (isBr$3(nextNode)) {
                        return moveForwardFromBr(root, nextNode);
                    }
                    if (!isAtomic(nextNode)) {
                        innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
                        if (innerNode) {
                            if (isText$3(innerNode)) {
                                return CaretPosition(innerNode, 0);
                            }
                            return CaretPosition.before(innerNode);
                        }
                    }
                    if (isText$3(nextNode)) {
                        return CaretPosition(nextNode, 0);
                    }
                    return CaretPosition.after(nextNode);
                }
            }
            node = nextNode ? nextNode : caretPosition.getNode();
        }
        if (node && ((isForwards(direction) && caretPosition.isAtEnd()) || (isBackwards(direction) && caretPosition.isAtStart()))) {
            node = findNode(node, direction, always, root, true);
            if (isEditableCaretCandidate(node, root)) {
                return getCaretCandidatePosition(direction, node);
            }
        }
        nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;
        const rootContentEditableFalseElm = last(filter$5(getParents$3(container, root), isContentEditableFalse$5));
        if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
            if (isForwards(direction)) {
                caretPosition = CaretPosition.after(rootContentEditableFalseElm);
            }
            else {
                caretPosition = CaretPosition.before(rootContentEditableFalseElm);
            }
            return caretPosition;
        }
        if (nextNode) {
            return getCaretCandidatePosition(direction, nextNode);
        }
        return null;
    };
    const CaretWalker = (root) => ({
        /**
           * Returns the next logical caret position from the specified input
           * caretPosition or null if there isn't any more positions left for example
           * at the end specified root element.
           *
           * @method next
           * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
           * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
           */
        next: (caretPosition) => {
            return findCaretPosition$1(1 /* HDirection.Forwards */, caretPosition, root);
        },
        /**
           * Returns the previous logical caret position from the specified input
           * caretPosition or null if there isn't any more positions left for example
           * at the end specified root element.
           *
           * @method prev
           * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
           * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
           */
        prev: (caretPosition) => {
            return findCaretPosition$1(-1 /* HDirection.Backwards */, caretPosition, root);
        }
    });

    const walkToPositionIn = (forward, root, start) => {
        const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);
        return fromPosition(forward, root, position);
    };
    const afterElement = (node) => isBr$7(node) ? CaretPosition.before(node) : CaretPosition.after(node);
    const isBeforeOrStart = (position) => {
        if (CaretPosition.isTextPosition(position)) {
            return position.offset() === 0;
        }
        else {
            return isCaretCandidate$3(position.getNode());
        }
    };
    const isAfterOrEnd = (position) => {
        if (CaretPosition.isTextPosition(position)) {
            const container = position.container();
            return position.offset() === container.data.length;
        }
        else {
            return isCaretCandidate$3(position.getNode(true));
        }
    };
    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);
    const isAtBr = (position) => !CaretPosition.isTextPosition(position) && isBr$7(position.getNode());
    const shouldSkipPosition = (forward, from, to) => {
        if (forward) {
            return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);
        }
        else {
            return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);
        }
    };
    // Finds: <p>a|<b>b</b></p> -> <p>a<b>|b</b></p>
    const fromPosition = (forward, root, pos) => {
        const walker = CaretWalker(root);
        return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
    };
    // Finds: <p>a|<b>b</b></p> -> <p>a<b>b|</b></p>
    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind((to) => {
        if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {
            return fromPosition(forward, root, to);
        }
        else {
            return Optional.some(to);
        }
    });
    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from)
        .bind((pos) => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));
    const positionIn = (forward, element) => {
        const startNode = forward ? element.firstChild : element.lastChild;
        if (isText$b(startNode)) {
            return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));
        }
        else if (startNode) {
            if (isCaretCandidate$3(startNode)) {
                return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));
            }
            else {
                return walkToPositionIn(forward, element, startNode);
            }
        }
        else {
            return Optional.none();
        }
    };
    const nextPosition = curry(fromPosition, true);
    const prevPosition = curry(fromPosition, false);
    const firstPositionIn = curry(positionIn, true);
    const lastPositionIn = curry(positionIn, false);

    const CARET_ID = '_mce_caret';
    const isCaretNode = (node) => isElement$7(node) && node.id === CARET_ID;
    const getParentCaretContainer = (body, node) => {
        let currentNode = node;
        while (currentNode && currentNode !== body) {
            if (isCaretNode(currentNode)) {
                return currentNode;
            }
            currentNode = currentNode.parentNode;
        }
        return null;
    };

    const isStringPathBookmark = (bookmark) => isString(bookmark.start);
    const isRangeBookmark = (bookmark) => has$2(bookmark, 'rng');
    const isIdBookmark = (bookmark) => has$2(bookmark, 'id');
    const isIndexBookmark = (bookmark) => has$2(bookmark, 'name');
    const isPathBookmark = (bookmark) => Tools.isArray(bookmark.start);

    const isForwardBookmark = (bookmark) => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;
    const addBogus = (dom, node) => {
        // Adds a bogus BR element for empty block elements
        if (isElement$7(node) && dom.isBlock(node) && !node.innerHTML) {
            node.innerHTML = '<br data-mce-bogus="1" />';
        }
        return node;
    };
    const resolveCaretPositionBookmark = (dom, bookmark) => {
        const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));
        const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));
        return lift2(startPos, endPos, (start, end) => {
            const range = dom.createRng();
            range.setStart(start.container(), start.offset());
            range.setEnd(end.container(), end.offset());
            return { range, forward: isForwardBookmark(bookmark) };
        });
    };
    const insertZwsp = (node, rng) => {
        var _a;
        const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
        const textNode = doc.createTextNode(ZWSP$1);
        node.appendChild(textNode);
        rng.setStart(textNode, 0);
        rng.setEnd(textNode, 0);
    };
    const isEmpty$3 = (node) => !node.hasChildNodes();
    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, (pos) => {
        rng.setStart(pos.container(), pos.offset());
        rng.setEnd(pos.container(), pos.offset());
        return true;
    });
    // Since we trim zwsp from undo levels the caret format containers
    // may be empty if so pad them with a zwsp and move caret there
    const padEmptyCaretContainer = (root, node, rng) => {
        if (isEmpty$3(node) && getParentCaretContainer(root, node)) {
            insertZwsp(node, rng);
            return true;
        }
        else {
            return false;
        }
    };
    const setEndPoint = (dom, start, bookmark, rng) => {
        const point = bookmark[start ? 'start' : 'end'];
        const root = dom.getRoot();
        if (point) {
            let node = root;
            let offset = point[0];
            // Find container node
            for (let i = point.length - 1; node && i >= 1; i--) {
                const children = node.childNodes;
                if (padEmptyCaretContainer(root, node, rng)) {
                    return true;
                }
                if (point[i] > children.length - 1) {
                    if (padEmptyCaretContainer(root, node, rng)) {
                        return true;
                    }
                    return tryFindRangePosition(node, rng);
                }
                node = children[point[i]];
            }
            // Move text offset to best suitable location
            if (isText$b(node)) {
                offset = Math.min(point[0], node.data.length);
            }
            // Move element offset to best suitable location
            if (isElement$7(node)) {
                offset = Math.min(point[0], node.childNodes.length);
            }
            // Set offset within container node
            if (start) {
                rng.setStart(node, offset);
            }
            else {
                rng.setEnd(node, offset);
            }
        }
        return true;
    };
    const isValidTextNode = (node) => isText$b(node) && node.data.length > 0;
    const restoreEndPoint = (dom, suffix, bookmark) => {
        const marker = dom.get(bookmark.id + '_' + suffix);
        const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;
        const keep = bookmark.keep;
        if (marker && markerParent) {
            let container;
            let offset;
            if (suffix === 'start') {
                if (!keep) {
                    container = markerParent;
                    offset = dom.nodeIndex(marker);
                }
                else {
                    if (marker.hasChildNodes()) {
                        container = marker.firstChild;
                        offset = 1;
                    }
                    else if (isValidTextNode(marker.nextSibling)) {
                        container = marker.nextSibling;
                        offset = 0;
                    }
                    else if (isValidTextNode(marker.previousSibling)) {
                        container = marker.previousSibling;
                        offset = marker.previousSibling.data.length;
                    }
                    else {
                        container = markerParent;
                        offset = dom.nodeIndex(marker) + 1;
                    }
                }
            }
            else {
                if (!keep) {
                    container = markerParent;
                    offset = dom.nodeIndex(marker);
                }
                else {
                    if (marker.hasChildNodes()) {
                        container = marker.firstChild;
                        offset = 1;
                    }
                    else if (isValidTextNode(marker.previousSibling)) {
                        container = marker.previousSibling;
                        offset = marker.previousSibling.data.length;
                    }
                    else {
                        container = markerParent;
                        offset = dom.nodeIndex(marker);
                    }
                }
            }
            if (!keep) {
                const prev = marker.previousSibling;
                const next = marker.nextSibling;
                // Remove all marker text nodes
                Tools.each(Tools.grep(marker.childNodes), (node) => {
                    if (isText$b(node)) {
                        node.data = node.data.replace(/\uFEFF/g, '');
                    }
                });
                // Remove marker but keep children if for example contents where inserted into the marker
                // Also remove duplicated instances of the marker for example by a
                // split operation or by WebKit auto split on paste feature
                let otherMarker;
                while ((otherMarker = dom.get(bookmark.id + '_' + suffix))) {
                    dom.remove(otherMarker, true);
                }
                // If siblings are text nodes then merge them unless it's Opera since it some how removes the node
                // and we are sniffing since adding a lot of detection code for a browser with 3% of the market
                // isn't worth the effort. Sorry, Opera but it's just a fact
                if (isText$b(next) && isText$b(prev) && !Env.browser.isOpera()) {
                    const idx = prev.data.length;
                    prev.appendData(next.data);
                    dom.remove(next);
                    container = prev;
                    offset = idx;
                }
            }
            return Optional.some(CaretPosition(container, offset));
        }
        else {
            return Optional.none();
        }
    };
    const resolvePaths = (dom, bookmark) => {
        const range = dom.createRng();
        if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {
            return Optional.some({ range, forward: isForwardBookmark(bookmark) });
        }
        else {
            return Optional.none();
        }
    };
    const resolveId = (dom, bookmark) => {
        const startPos = restoreEndPoint(dom, 'start', bookmark);
        const endPos = restoreEndPoint(dom, 'end', bookmark);
        return lift2(startPos, endPos.or(startPos), (spos, epos) => {
            const range = dom.createRng();
            range.setStart(addBogus(dom, spos.container()), spos.offset());
            range.setEnd(addBogus(dom, epos.container()), epos.offset());
            return { range, forward: isForwardBookmark(bookmark) };
        });
    };
    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map((elm) => {
        const range = dom.createRng();
        range.selectNode(elm);
        return { range, forward: true };
    });
    const resolve = (selection, bookmark) => {
        const dom = selection.dom;
        if (bookmark) {
            if (isPathBookmark(bookmark)) {
                return resolvePaths(dom, bookmark);
            }
            else if (isStringPathBookmark(bookmark)) {
                return resolveCaretPositionBookmark(dom, bookmark);
            }
            else if (isIdBookmark(bookmark)) {
                return resolveId(dom, bookmark);
            }
            else if (isIndexBookmark(bookmark)) {
                return resolveIndex(dom, bookmark);
            }
            else if (isRangeBookmark(bookmark)) {
                return Optional.some({ range: bookmark.rng, forward: isForwardBookmark(bookmark) });
            }
        }
        return Optional.none();
    };

    const getBookmark$2 = (selection, type, normalized) => {
        return getBookmark$3(selection, type, normalized);
    };
    const moveToBookmark = (selection, bookmark) => {
        resolve(selection, bookmark).each(({ range, forward }) => {
            selection.setRng(range, forward);
        });
    };
    const isBookmarkNode$1 = (node) => {
        return isElement$7(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';
    };

    const is = (expected) => (actual) => expected === actual;
    const isNbsp = is(nbsp);
    const isWhiteSpace = (chr) => chr !== '' && ' \f\n\r\t\v'.indexOf(chr) !== -1;
    const isContent = (chr) => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);

    const getRanges = (selection) => {
        const ranges = [];
        if (selection) {
            for (let i = 0; i < selection.rangeCount; i++) {
                ranges.push(selection.getRangeAt(i));
            }
        }
        return ranges;
    };
    const getSelectedNodes = (ranges) => {
        return bind$3(ranges, (range) => {
            const node = getSelectedNode(range);
            return node ? [SugarElement.fromDom(node)] : [];
        });
    };
    const hasMultipleRanges = (selection) => {
        return getRanges(selection).length > 1;
    };

    const getCellsFromRanges = (ranges) => filter$5(getSelectedNodes(ranges), isTableCell$2);
    const getCellsFromElement = (elm) => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');
    const getCellsFromElementOrRanges = (ranges, element) => {
        const selectedCells = getCellsFromElement(element);
        return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);
    };
    const getCellsFromEditor = (editor) => getCellsFromElementOrRanges(getRanges(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));
    const getClosestTable = (cell, isRoot) => ancestor$4(cell, 'table', isRoot);

    const getStartNode = (rng) => {
        const sc = rng.startContainer, so = rng.startOffset;
        if (isText$b(sc)) {
            return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();
        }
        else {
            return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);
        }
    };
    const getEndNode = (rng) => {
        const ec = rng.endContainer, eo = rng.endOffset;
        if (isText$b(ec)) {
            return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();
        }
        else {
            return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);
        }
    };
    const getFirstChildren = (node) => {
        return firstChild(node).fold(constant([node]), (child) => {
            return [node].concat(getFirstChildren(child));
        });
    };
    const getLastChildren = (node) => {
        return lastChild(node).fold(constant([node]), (child) => {
            if (name(child) === 'br') {
                return prevSibling(child).map((sibling) => {
                    return [node].concat(getLastChildren(sibling));
                }).getOr([]);
            }
            else {
                return [node].concat(getLastChildren(child));
            }
        });
    };
    const hasAllContentsSelected = (elm, rng) => {
        return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {
            const start = find$2(getFirstChildren(elm), curry(eq, startNode));
            const end = find$2(getLastChildren(elm), curry(eq, endNode));
            return start.isSome() && end.isSome();
        }).getOr(false);
    };
    const moveEndPoint = (dom, rng, node, start) => {
        const root = node;
        const walker = new DomTreeWalker(node, root);
        const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2(['td', 'th', 'table'], name.toLowerCase()));
        let currentNode = node;
        do {
            if (isText$b(currentNode) && Tools.trim(currentNode.data).length !== 0) {
                if (start) {
                    rng.setStart(currentNode, 0);
                }
                else {
                    rng.setEnd(currentNode, currentNode.data.length);
                }
                return;
            }
            // BR/IMG/INPUT elements but not table cells
            if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {
                if (start) {
                    rng.setStartBefore(currentNode);
                }
                else {
                    if (currentNode.nodeName === 'BR') {
                        rng.setEndBefore(currentNode);
                    }
                    else {
                        rng.setEndAfter(currentNode);
                    }
                }
                return;
            }
        } while ((currentNode = (start ? walker.next() : walker.prev())));
        // Failed to find any text node or other suitable location then move to the root of body
        if (root.nodeName === 'BODY') {
            if (start) {
                rng.setStart(root, 0);
            }
            else {
                rng.setEnd(root, root.childNodes.length);
            }
        }
    };
    const hasAnyRanges = (editor) => {
        const sel = editor.selection.getSel();
        return isNonNullable(sel) && sel.rangeCount > 0;
    };
    const runOnRanges = (editor, executor) => {
        // Check to see if a fake selection is active. If so then we are simulating a multi range
        // selection so we should return a range for each selected node.
        // Note: Currently tables are the only thing supported for fake selections.
        const fakeSelectionNodes = getCellsFromEditor(editor);
        if (fakeSelectionNodes.length > 0) {
            each$e(fakeSelectionNodes, (elem) => {
                const node = elem.dom;
                const fakeNodeRng = editor.dom.createRng();
                fakeNodeRng.setStartBefore(node);
                fakeNodeRng.setEndAfter(node);
                executor(fakeNodeRng, true);
            });
        }
        else {
            executor(editor.selection.getRng(), false);
        }
    };
    const preserve = (selection, fillBookmark, executor) => {
        const bookmark = getPersistentBookmark(selection, fillBookmark);
        executor(bookmark);
        selection.moveToBookmark(bookmark);
    };
    const isSelectionOverWholeNode = (range, nodeTypePredicate) => range.startContainer === range.endContainer
        && range.endOffset - range.startOffset === 1
        && nodeTypePredicate(range.startContainer.childNodes[range.startOffset]);
    const isSelectionOverWholeHTMLElement = (range) => isSelectionOverWholeNode(range, isHTMLElement);
    const isSelectionOverWholeTextNode = (range) => isSelectionOverWholeNode(range, isText$b);
    const isSelectionOverWholeAnchor = (range) => isSelectionOverWholeNode(range, isAnchor);

    const isNode = (node) => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);
    const isElementNode$1 = (node) => isElement$7(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$1(node);
    // In TinyMCE, directly selected elements are indicated with the data-mce-selected attribute
    // Elements that can be directly selected include control elements such as img, media elements, noneditable elements and others
    const isElementDirectlySelected = (dom, node) => {
        // Table cells are a special case and are separately handled from native editor selection
        if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {
            const selectedAttr = dom.getAttrib(node, 'data-mce-selected');
            const value = parseInt(selectedAttr, 10);
            // Avoid cases where data-mce-selected is not a positive number e.g. inline-boundary
            return !isNaN(value) && value > 0;
        }
        else {
            return false;
        }
    };
    // TODO: TINY-9130 Look at making SelectionUtils.preserve maintain the noneditable selection instead
    const preserveSelection = (editor, action, shouldMoveStart) => {
        const { selection, dom } = editor;
        const selectedNodeBeforeAction = selection.getNode();
        const isSelectedBeforeNodeNoneditable = isContentEditableFalse$a(selectedNodeBeforeAction);
        preserve(selection, true, () => {
            action();
        });
        // Check previous selected node before the action still exists in the DOM
        // and is still noneditable
        const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$a(selectedNodeBeforeAction);
        if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {
            editor.selection.select(selectedNodeBeforeAction);
        }
        else if (shouldMoveStart(selection.getStart())) {
            moveStartToNearestText(dom, selection);
        }
    };
    // Note: The reason why we only care about moving the start is because MatchFormat and its function use the start of the selection to determine if a selection has a given format or not
    const moveStartToNearestText = (dom, selection) => {
        var _a, _b;
        const rng = selection.getRng();
        const { startContainer, startOffset } = rng;
        const selectedNode = selection.getNode();
        if (isElementDirectlySelected(dom, selectedNode)) {
            return;
        }
        // Try move startContainer/startOffset to a suitable text node
        if (isElement$7(startContainer)) {
            const nodes = startContainer.childNodes;
            const root = dom.getRoot();
            let walker;
            if (startOffset < nodes.length) {
                const startNode = nodes[startOffset];
                walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);
            }
            else {
                const startNode = nodes[nodes.length - 1];
                walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);
                walker.next(true);
            }
            for (let node = walker.current(); node; node = walker.next()) {
                // If we have found a noneditable element before we have found any text
                // then we cannot move forward any further as otherwise the start could be put inside
                // the non-editable element which is not valid
                if (dom.getContentEditable(node) === 'false') {
                    return;
                }
                else if (isText$b(node) && !isWhiteSpaceNode$1(node)) {
                    rng.setStart(node, 0);
                    selection.setRng(rng);
                    return;
                }
            }
        }
    };
    /**
     * Returns the next/previous non whitespace node.
     *
     * @private
     * @param {Node} node Node to start at.
     * @param {Boolean} next (Optional) Include next or previous node defaults to previous.
     * @param {Boolean} inc (Optional) Include the current node in checking. Defaults to false.
     * @return {Node} Next or previous node or undefined if it wasn't found.
     */
    const getNonWhiteSpaceSibling = (node, next, inc) => {
        if (node) {
            const nextName = next ? 'nextSibling' : 'previousSibling';
            for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
                if (isElement$7(node) || !isWhiteSpaceNode$1(node)) {
                    return node;
                }
            }
        }
        return undefined;
    };
    const isTextBlock$2 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);
    const isValid = (ed, parent, child) => {
        return ed.schema.isValidChild(parent, child);
    };
    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {
        if (isNonNullable(node) && isText$b(node)) {
            // If spaces are allowed, treat them as a non-breaking space
            const data = allowSpaces ? node.data.replace(/ /g, '\u00a0') : node.data;
            return isWhitespaceText(data);
        }
        else {
            return false;
        }
    };
    const isEmptyTextNode$1 = (node) => {
        return isNonNullable(node) && isText$b(node) && node.length === 0;
    };
    const isWrapNoneditableTarget = (editor, node) => {
        const baseDataSelector = '[data-mce-cef-wrappable]';
        const formatNoneditableSelector = getFormatNoneditableSelector(editor);
        const selector = isEmpty$5(formatNoneditableSelector) ? baseDataSelector : `${baseDataSelector},${formatNoneditableSelector}`;
        return is$2(SugarElement.fromDom(node), selector);
    };
    // A noneditable element is wrappable if it:
    // - is valid target (has data-mce-cef-wrappable attribute or matches selector from option)
    // - has no editable descendants - removing formats in the editable region can result in the wrapped noneditable being split which is undesirable
    const isWrappableNoneditable = (editor, node) => {
        const dom = editor.dom;
        return (isElementNode$1(node) &&
            dom.getContentEditable(node) === 'false' &&
            isWrapNoneditableTarget(editor, node) &&
            dom.select('[contenteditable="true"]', node).length === 0);
    };
    /**
     * Replaces variables in the value. The variable format is %var.
     *
     * @private
     * @param {String} value Value to replace variables in.
     * @param {Object} vars Name/value array with variables to replace.
     * @return {String} New value with replaced variables.
     */
    const replaceVars = (value, vars) => {
        if (isFunction(value)) {
            return value(vars);
        }
        else if (isNonNullable(vars)) {
            value = value.replace(/%(\w+)/g, (str, name) => {
                return vars[name] || str;
            });
        }
        return value;
    };
    /**
     * Compares two string/nodes regardless of their case.
     *
     * @private
     * @param {String/Node} str1 Node or string to compare.
     * @param {String/Node} str2 Node or string to compare.
     * @return {Boolean} True/false if they match.
     */
    const isEq$5 = (str1, str2) => {
        str1 = str1 || '';
        str2 = str2 || '';
        str1 = '' + (str1.nodeName || str1);
        str2 = '' + (str2.nodeName || str2);
        return str1.toLowerCase() === str2.toLowerCase();
    };
    const normalizeStyleValue = (value, name) => {
        if (isNullable(value)) {
            return null;
        }
        else {
            let strValue = String(value);
            // Force the format to hex
            if (name === 'color' || name === 'backgroundColor') {
                strValue = rgbaToHexString(strValue);
            }
            // Opera will return bold as 700
            if (name === 'fontWeight' && value === 700) {
                strValue = 'bold';
            }
            // Normalize fontFamily so "'Font name', Font" becomes: "Font name,Font"
            if (name === 'fontFamily') {
                strValue = strValue.replace(/[\'\"]/g, '').replace(/,\s+/g, ',');
            }
            return strValue;
        }
    };
    const getStyle = (dom, node, name) => {
        const style = dom.getStyle(node, name);
        return normalizeStyleValue(style, name);
    };
    const getTextDecoration = (dom, node) => {
        let decoration;
        dom.getParent(node, (n) => {
            if (isElement$7(n)) {
                decoration = dom.getStyle(n, 'text-decoration');
                return !!decoration && decoration !== 'none';
            }
            else {
                return false;
            }
        });
        return decoration;
    };
    const getParents$2 = (dom, node, selector) => {
        return dom.getParents(node, selector, dom.getRoot());
    };
    const isFormatPredicate = (editor, formatName, predicate) => {
        const formats = editor.formatter.get(formatName);
        return isNonNullable(formats) && exists(formats, predicate);
    };
    const isVariableFormatName = (editor, formatName) => {
        const hasVariableValues = (format) => {
            const isVariableValue = (val) => isFunction(val) || val.length > 1 && val.charAt(0) === '%';
            return exists(['styles', 'attributes'], (key) => get$a(format, key).exists((field) => {
                const fieldValues = isArray$1(field) ? field : values(field);
                return exists(fieldValues, isVariableValue);
            }));
        };
        return isFormatPredicate(editor, formatName, hasVariableValues);
    };
    /**
     * Checks if the two formats are similar based on the format type, attributes, styles and classes
     */
    const areSimilarFormats = (editor, formatName, otherFormatName) => {
        // Note: MatchFormat.matchNode() uses these parameters to check if a format matches a node
        // Therefore, these are ideal to check if two formats are similar
        const validKeys = ['inline', 'block', 'selector', 'attributes', 'styles', 'classes'];
        const filterObj = (format) => filter$4(format, (_, key) => exists(validKeys, (validKey) => validKey === key));
        return isFormatPredicate(editor, formatName, (fmt1) => {
            const filteredFmt1 = filterObj(fmt1);
            return isFormatPredicate(editor, otherFormatName, (fmt2) => {
                const filteredFmt2 = filterObj(fmt2);
                return equal$1(filteredFmt1, filteredFmt2);
            });
        });
    };
    const isBlockFormat = (format) => hasNonNullableKey(format, 'block');
    const isWrappingBlockFormat = (format) => isBlockFormat(format) && format.wrapper === true;
    const isNonWrappingBlockFormat = (format) => isBlockFormat(format) && format.wrapper !== true;
    const isSelectorFormat = (format) => hasNonNullableKey(format, 'selector');
    const isInlineFormat = (format) => hasNonNullableKey(format, 'inline');
    const isMixedFormat = (format) => isSelectorFormat(format) && isInlineFormat(format) && is$4(get$a(format, 'mixed'), true);
    const shouldExpandToSelector = (format) => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);
    const getEmptyCaretContainers = (node) => {
        const nodes = [];
        let tempNode = node;
        while (tempNode) {
            if ((isText$b(tempNode) && tempNode.data !== ZWSP$1) || tempNode.childNodes.length > 1) {
                return [];
            }
            // Collect nodes
            if (isElement$7(tempNode)) {
                nodes.push(tempNode);
            }
            tempNode = tempNode.firstChild;
        }
        return nodes;
    };
    const isCaretContainerEmpty = (node) => {
        return getEmptyCaretContainers(node).length > 0;
    };
    const isEmptyCaretFormatElement = (element) => {
        return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
    };

    const isBookmarkNode = isBookmarkNode$1;
    const getParents$1 = getParents$2;
    const isWhiteSpaceNode = isWhiteSpaceNode$1;
    const isTextBlock$1 = isTextBlock$2;
    const isBogusBr$1 = (node) => {
        return isBr$7(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;
    };
    // Expands the node to the closes contentEditable false element if it exists
    const findParentContentEditable = (dom, node) => {
        let parent = node;
        while (parent) {
            if (isElement$7(parent) && dom.getContentEditable(parent)) {
                return dom.getContentEditable(parent) === 'false' ? parent : node;
            }
            parent = parent.parentNode;
        }
        return node;
    };
    const walkText = (start, node, offset, predicate) => {
        const str = node.data;
        if (start) {
            for (let i = offset; i > 0; i--) {
                if (predicate(str.charAt(i - 1))) {
                    return i;
                }
            }
        }
        else {
            for (let i = offset; i < str.length; i++) {
                if (predicate(str.charAt(i))) {
                    return i;
                }
            }
        }
        return -1;
    };
    const findSpace = (start, node, offset) => walkText(start, node, offset, (c) => isNbsp(c) || isWhiteSpace(c));
    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);
    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {
        let lastTextNode;
        const closestRoot = dom.getParent(container, (node) => isEditingHost(node) || dom.isBlock(node));
        const rootNode = isNonNullable(closestRoot) ? closestRoot : body;
        const walk = (container, offset, pred) => {
            const textSeeker = TextSeeker(dom);
            const walker = start ? textSeeker.backwards : textSeeker.forwards;
            return Optional.from(walker(container, offset, (text, textOffset) => {
                if (isBookmarkNode(text.parentNode)) {
                    return -1;
                }
                else {
                    lastTextNode = text;
                    return pred(start, text, textOffset);
                }
            }, rootNode));
        };
        const spaceResult = walk(container, offset, findSpace);
        return spaceResult.bind((result) => includeTrailingSpaces ?
            walk(result.container, result.offset + (start ? -1 : 0), findContent) :
            Optional.some(result)).orThunk(() => lastTextNode ?
            Optional.some({ container: lastTextNode, offset: start ? 0 : lastTextNode.length }) :
            Optional.none());
    };
    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {
        const sibling = container[siblingName];
        if (isText$b(container) && isEmpty$5(container.data) && sibling) {
            container = sibling;
        }
        const parents = getParents$1(dom, container);
        for (let i = 0; i < parents.length; i++) {
            for (let y = 0; y < formatList.length; y++) {
                const curFormat = formatList[y];
                // If collapsed state is set then skip formats that doesn't match that
                if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {
                    continue;
                }
                if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {
                    return parents[i];
                }
            }
        }
        return container;
    };
    const findBlockEndPoint = (dom, formatList, container, siblingName) => {
        var _a;
        let node = container;
        const root = dom.getRoot();
        const format = formatList[0];
        // Expand to block of similar type
        if (isBlockFormat(format)) {
            node = format.wrapper ? null : dom.getParent(container, format.block, root);
        }
        // Expand to first wrappable block element or any block element
        if (!node) {
            const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH,SUMMARY')) !== null && _a !== void 0 ? _a : root;
            node = dom.getParent(isText$b(container) ? container.parentNode : container, 
            // Fixes #6183 where it would expand to editable parent element in inline mode
            (node) => node !== root && isTextBlock$1(dom.schema, node), scopeRoot);
        }
        // Exclude inner lists from wrapping
        if (node && isBlockFormat(format) && format.wrapper) {
            node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;
        }
        // Didn't find a block element look for first/last wrappable element
        if (!node) {
            node = container;
            while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {
                node = node[siblingName];
                // Break on BR but include it will be removed later on
                // we can't remove it now since we need to check if it can be wrapped
                if (isEq$5(node, 'br')) {
                    break;
                }
            }
        }
        return node || container;
    };
    // We're at the edge if the parent is a block and there's no next sibling. Alternatively,
    // if we reach the root or can't walk further we also consider it to be a boundary.
    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {
        const parent = container.parentNode;
        if (isNonNullable(container[siblingName])) {
            return false;
        }
        else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {
            return true;
        }
        else {
            return isAtBlockBoundary$1(dom, root, parent, siblingName);
        }
    };
    // This function walks up the tree if there is no siblings before/after the node.
    // If a sibling is found then the container is returned
    const findParentContainer = (dom, formatList, container, offset, start, expandToBlock) => {
        let parent = container;
        const siblingName = start ? 'previousSibling' : 'nextSibling';
        const root = dom.getRoot();
        // If it's a text node and the offset is inside the text
        if (isText$b(container) && !isWhiteSpaceNode(container)) {
            if (start ? offset > 0 : offset < container.data.length) {
                return container;
            }
        }
        while (parent) {
            if (isEditingHost(parent)) {
                return container;
            }
            // Stop expanding on block elements
            if (!formatList[0].block_expand && dom.isBlock(parent)) {
                return expandToBlock ? parent : container;
            }
            // Walk left/right
            for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
                // Allow spaces if not at the edge of a block element, as the spaces won't have been collapsed
                const allowSpaces = isText$b(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);
                if (!isBookmarkNode(sibling) && !isBogusBr$1(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {
                    return parent;
                }
            }
            // Check if we can move up are we at root level or body level
            if (parent === root || parent.parentNode === root) {
                container = parent;
                break;
            }
            parent = parent.parentNode;
        }
        return container;
    };
    const isSelfOrParentBookmark = (container) => isBookmarkNode(container.parentNode) || isBookmarkNode(container);
    const expandRng = (dom, rng, formatList, expandOptions = {}) => {
        const { includeTrailingSpace = false, expandToBlock = true } = expandOptions;
        const editableHost = dom.getParent(rng.commonAncestorContainer, (node) => isEditingHost(node));
        const root = isNonNullable(editableHost) ? editableHost : dom.getRoot();
        let { startContainer, startOffset, endContainer, endOffset } = rng;
        const format = formatList[0];
        // If index based start position then resolve it
        if (isElement$7(startContainer) && startContainer.hasChildNodes()) {
            startContainer = getNode$1(startContainer, startOffset);
            if (isText$b(startContainer)) {
                startOffset = 0;
            }
        }
        // If index based end position then resolve it
        if (isElement$7(endContainer) && endContainer.hasChildNodes()) {
            endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);
            if (isText$b(endContainer)) {
                endOffset = endContainer.data.length;
            }
        }
        // Expand to closest contentEditable element
        startContainer = findParentContentEditable(dom, startContainer);
        endContainer = findParentContentEditable(dom, endContainer);
        // Exclude bookmark nodes if possible
        if (isSelfOrParentBookmark(startContainer)) {
            startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
            if (rng.collapsed) {
                startContainer = startContainer.previousSibling || startContainer;
            }
            else {
                startContainer = startContainer.nextSibling || startContainer;
            }
            if (isText$b(startContainer)) {
                startOffset = rng.collapsed ? startContainer.length : 0;
            }
        }
        if (isSelfOrParentBookmark(endContainer)) {
            endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
            if (rng.collapsed) {
                endContainer = endContainer.nextSibling || endContainer;
            }
            else {
                endContainer = endContainer.previousSibling || endContainer;
            }
            if (isText$b(endContainer)) {
                endOffset = rng.collapsed ? 0 : endContainer.length;
            }
        }
        if (rng.collapsed) {
            // Expand left to closest word boundary
            const startPoint = findWordEndPoint(dom, root, startContainer, startOffset, true, includeTrailingSpace);
            startPoint.each(({ container, offset }) => {
                startContainer = container;
                startOffset = offset;
            });
            // Expand right to closest word boundary
            const endPoint = findWordEndPoint(dom, root, endContainer, endOffset, false, includeTrailingSpace);
            endPoint.each(({ container, offset }) => {
                endContainer = container;
                endOffset = offset;
            });
        }
        // Move start/end point up the tree if the leaves are sharp and if we are in different containers
        // Example * becomes !: !<p><b><i>*text</i><i>text*</i></b></p>!
        // This will reduce the number of wrapper elements that needs to be created
        // Move start point up the tree
        if (isInlineFormat(format) || format.block_expand) {
            if (!isInlineFormat(format) || (!isText$b(startContainer) || startOffset === 0)) {
                startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true, expandToBlock);
            }
            if (!isInlineFormat(format) || (!isText$b(endContainer) || endOffset === endContainer.data.length)) {
                endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false, expandToBlock);
            }
        }
        // Expand start/end container to matching selector
        if (shouldExpandToSelector(format)) {
            // Find new startContainer/endContainer if there is better one
            startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');
            endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');
        }
        // Expand start/end container to matching block element or text node
        if (isBlockFormat(format) || isSelectorFormat(format)) {
            // Find new startContainer/endContainer if there is better one
            startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');
            endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');
            // Non block element then try to expand up the leaf
            if (isBlockFormat(format)) {
                if (!dom.isBlock(startContainer)) {
                    startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true, expandToBlock);
                    if (isText$b(startContainer)) {
                        startOffset = 0;
                    }
                }
                if (!dom.isBlock(endContainer)) {
                    endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false, expandToBlock);
                    if (isText$b(endContainer)) {
                        endOffset = endContainer.data.length;
                    }
                }
            }
        }
        // Setup index for startContainer
        if (isElement$7(startContainer) && startContainer.parentNode) {
            startOffset = dom.nodeIndex(startContainer);
            startContainer = startContainer.parentNode;
        }
        // Setup index for endContainer
        if (isElement$7(endContainer) && endContainer.parentNode) {
            endOffset = dom.nodeIndex(endContainer) + 1;
            endContainer = endContainer.parentNode;
        }
        // Return new range like object
        return {
            startContainer,
            startOffset,
            endContainer,
            endOffset
        };
    };

    const walk$3 = (dom, rng, callback) => {
        var _a;
        const startOffset = rng.startOffset;
        const startContainer = getNode$1(rng.startContainer, startOffset);
        const endOffset = rng.endOffset;
        const endContainer = getNode$1(rng.endContainer, endOffset - 1);
        /**
         * Excludes start/end text node if they are out side the range
         *
         * @private
         * @param {Array} nodes Nodes to exclude items from.
         * @return {Array} Array with nodes excluding the start/end container if needed.
         */
        const exclude = (nodes) => {
            // First node is excluded
            const firstNode = nodes[0];
            if (isText$b(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {
                nodes.splice(0, 1);
            }
            // Last node is excluded
            const lastNode = nodes[nodes.length - 1];
            if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$b(lastNode)) {
                nodes.splice(nodes.length - 1, 1);
            }
            return nodes;
        };
        const collectSiblings = (node, name, endNode) => {
            const siblings = [];
            for (; node && node !== endNode; node = node[name]) {
                siblings.push(node);
            }
            return siblings;
        };
        const findEndPoint = (node, root) => dom.getParent(node, (node) => node.parentNode === root, root);
        const walkBoundary = (startNode, endNode, next) => {
            const siblingName = next ? 'nextSibling' : 'previousSibling';
            for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {
                parent = node.parentNode;
                const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);
                if (siblings.length) {
                    if (!next) {
                        siblings.reverse();
                    }
                    callback(exclude(siblings));
                }
            }
        };
        // Same container
        if (startContainer === endContainer) {
            return callback(exclude([startContainer]));
        }
        // Find common ancestor and end points
        const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();
        // Process left side
        if (dom.isChildOf(startContainer, endContainer)) {
            return walkBoundary(startContainer, ancestor, true);
        }
        // Process right side
        if (dom.isChildOf(endContainer, startContainer)) {
            return walkBoundary(endContainer, ancestor);
        }
        // Find start/end point
        const startPoint = findEndPoint(startContainer, ancestor) || startContainer;
        const endPoint = findEndPoint(endContainer, ancestor) || endContainer;
        // Walk left leaf
        walkBoundary(startContainer, startPoint, true);
        // Walk the middle from start to end point
        const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);
        if (siblings.length) {
            callback(exclude(siblings));
        }
        // Walk right leaf
        walkBoundary(endContainer, endPoint);
    };

    const validBlocks = [
        // Codesample plugin
        'pre[class*=language-][contenteditable="false"]',
        // Image plugin - captioned image
        'figure.image',
        // Mediaembed plugin
        'div[data-ephox-embed-iri]',
        // Pageembed plugin
        'div.tiny-pageembed',
        // Tableofcontents plugin
        'div.mce-toc',
        'div[data-mce-toc]',
        // Footnootes plugin
        'div.mce-footnotes'
    ];
    const isZeroWidth = (elem) => isText$c(elem) && get$4(elem) === ZWSP$1;
    const context = (editor, elem, wrapName, nodeName) => parentElement(elem).fold(() => "skipping" /* ChildContext.Skipping */, (parent) => {
        // We used to skip these, but given that they might be representing empty paragraphs, it probably
        // makes sense to treat them just like text nodes
        if (nodeName === 'br' || isZeroWidth(elem)) {
            return "valid" /* ChildContext.Valid */;
        }
        else if (isAnnotation(elem)) {
            return "existing" /* ChildContext.Existing */;
        }
        else if (isCaretNode(elem.dom)) {
            return "caret" /* ChildContext.Caret */;
        }
        else if (exists(validBlocks, (selector) => is$2(elem, selector))) {
            return "valid-block" /* ChildContext.ValidBlock */;
        }
        else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {
            return "invalid-child" /* ChildContext.InvalidChild */;
        }
        else {
            return "valid" /* ChildContext.Valid */;
        }
    });

    const applyWordGrab = (editor, rng) => {
        const r = expandRng(editor.dom, rng, [{ inline: 'span' }]);
        rng.setStart(r.startContainer, r.startOffset);
        rng.setEnd(r.endContainer, r.endOffset);
        editor.selection.setRng(rng);
    };
    const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {
        const { uid = masterUId, ...otherData } = data;
        add$2(elem, annotation());
        set$4(elem, `${dataAnnotationId()}`, uid);
        set$4(elem, `${dataAnnotation()}`, annotationName);
        const { attributes = {}, classes = [] } = decorate(uid, otherData);
        setAll$1(elem, attributes);
        add$1(elem, classes);
        if (directAnnotation) {
            if (classes.length > 0) {
                set$4(elem, `${dataAnnotationClasses()}`, classes.join(','));
            }
            const attributeNames = keys(attributes);
            if (attributeNames.length > 0) {
                set$4(elem, `${dataAnnotationAttributes()}`, attributeNames.join(','));
            }
        }
    };
    const removeDirectAnnotation = (elem) => {
        remove$4(elem, annotation());
        remove$9(elem, `${dataAnnotationId()}`);
        remove$9(elem, `${dataAnnotation()}`);
        remove$9(elem, `${dataAnnotationActive()}`);
        const customAttrNames = getOpt(elem, `${dataAnnotationAttributes()}`).map((names) => names.split(',')).getOr([]);
        const customClasses = getOpt(elem, `${dataAnnotationClasses()}`).map((names) => names.split(',')).getOr([]);
        each$e(customAttrNames, (name) => remove$9(elem, name));
        remove$3(elem, customClasses);
        remove$9(elem, `${dataAnnotationClasses()}`);
        remove$9(elem, `${dataAnnotationAttributes()}`);
    };
    const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {
        const master = SugarElement.fromTag('span', eDoc);
        applyAnnotation(master, uid, data, annotationName, decorate, false);
        return master;
    };
    const annotate = (editor, rng, uid, annotationName, decorate, data) => {
        // Setup all the wrappers that are going to be used.
        const newWrappers = [];
        // Setup the spans for the comments
        const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);
        // Set the current wrapping element
        const wrapper = value$1();
        // Clear the current wrapping element, so that subsequent calls to
        // getOrOpenWrapper spawns a new one.
        const finishWrapper = () => {
            wrapper.clear();
        };
        // Get the existing wrapper, or spawn a new one.
        const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {
            const nu = shallow(master);
            newWrappers.push(nu);
            wrapper.set(nu);
            return nu;
        });
        const processElements = (elems) => {
            each$e(elems, processElement);
        };
        const processElement = (elem) => {
            const ctx = context(editor, elem, 'span', name(elem));
            switch (ctx) {
                case "invalid-child" /* ChildContext.InvalidChild */: {
                    finishWrapper();
                    const children = children$1(elem);
                    processElements(children);
                    finishWrapper();
                    break;
                }
                case "valid-block" /* ChildContext.ValidBlock */: {
                    finishWrapper();
                    applyAnnotation(elem, uid, data, annotationName, decorate, true);
                    break;
                }
                case "valid" /* ChildContext.Valid */: {
                    const w = getOrOpenWrapper();
                    wrap$2(elem, w);
                    break;
                }
            }
        };
        const processNodes = (nodes) => {
            const elems = map$3(nodes, SugarElement.fromDom);
            processElements(elems);
        };
        walk$3(editor.dom, rng, (nodes) => {
            finishWrapper();
            processNodes(nodes);
        });
        return newWrappers;
    };
    const annotateWithBookmark = (editor, name, settings, data) => {
        editor.undoManager.transact(() => {
            const selection = editor.selection;
            const initialRng = selection.getRng();
            const hasFakeSelection = getCellsFromEditor(editor).length > 0;
            const masterUid = generate$1('mce-annotation');
            if (initialRng.collapsed && !hasFakeSelection) {
                applyWordGrab(editor, initialRng);
            }
            // Even after applying word grab, we could not find a selection. Therefore,
            // just make a wrapper and insert it at the current cursor
            if (selection.getRng().collapsed && !hasFakeSelection) {
                const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);
                // Put something visible in the marker
                set$3(wrapper, nbsp);
                selection.getRng().insertNode(wrapper.dom);
                selection.select(wrapper.dom);
            }
            else {
                // The bookmark is responsible for splitting the nodes beforehand at the selection points
                // The "false" here means a zero width cursor is NOT put in the bookmark. It seems to be required
                // to stop an empty paragraph splitting into two paragraphs. Probably a better way exists.
                preserve(selection, false, () => {
                    runOnRanges(editor, (selectionRng) => {
                        annotate(editor, selectionRng, masterUid, name, settings.decorate, data);
                    });
                });
            }
        });
    };

    const Annotator = (editor) => {
        const registry = create$a();
        setup$D(editor, registry);
        const changes = setup$E(editor, registry);
        const isSpan = isTag('span');
        const removeAnnotations = (elements) => {
            each$e(elements, (element) => {
                if (isSpan(element)) {
                    unwrap(element);
                }
                else {
                    removeDirectAnnotation(element);
                }
            });
        };
        return {
            /**
             * Registers a specific annotator by name
             *
             * @method register
             * @param {String} name the name of the annotation
             * @param {Object} settings settings for the annotation (e.g. decorate)
             */
            register: (name, settings) => {
                registry.register(name, settings);
            },
            /**
             * Applies the annotation at the current selection using data
             *
             * @method annotate
             * @param {String} name the name of the annotation to apply
             * @param {Object} data information to pass through to this particular
             * annotation
             */
            annotate: (name, data) => {
                registry.lookup(name).each((settings) => {
                    annotateWithBookmark(editor, name, settings, data);
                });
            },
            /**
             * Executes the specified callback when the current selection matches the annotation or not.
             *
             * @method annotationChanged
             * @param {String} name Name of annotation to listen for
             * @param {Function} callback Callback with (state, name, and data) fired when the annotation
             * at the cursor changes. If state if false, data will not be provided.
             */
            annotationChanged: (name, callback) => {
                changes.addListener(name, callback);
            },
            /**
             * Removes any annotations from the current selection that match
             * the name
             *
             * @method remove
             * @param {String} name the name of the annotation to remove
             */
            remove: (name) => {
                identify(editor, Optional.some(name)).each(({ elements }) => {
                    /**
                     * TINY-9399: It is important to keep the bookmarking in the callback
                     * because it adjusts selection in a way that `identify` function
                     * cannot retain the selected word.
                     */
                    const bookmark = editor.selection.getBookmark();
                    removeAnnotations(elements);
                    editor.selection.moveToBookmark(bookmark);
                });
            },
            /**
             * Removes all annotations that match the specified name from the entire document.
             *
             * @method removeAll
             * @param {String} name the name of the annotation to remove
             */
            removeAll: (name) => {
                const bookmark = editor.selection.getBookmark();
                each$d(findAll(editor, name), (elements, _) => {
                    removeAnnotations(elements);
                });
                editor.selection.moveToBookmark(bookmark);
            },
            /**
             * Retrieve all the annotations for a given name
             *
             * @method getAll
             * @param {String} name the name of the annotations to retrieve
             * @return {Object} an index of annotations from uid => DOM nodes
             */
            getAll: (name) => {
                const directory = findAll(editor, name);
                return map$2(directory, (elems) => map$3(elems, (elem) => elem.dom));
            }
        };
    };

    /**
     * Constructs a new BookmarkManager instance for a specific selection instance.
     *
     * @constructor
     * @method BookmarkManager
     * @param {tinymce.dom.Selection} selection Selection instance to handle bookmarks for.
     */
    const BookmarkManager = (selection) => {
        return {
            /**
             * Returns a bookmark location for the current selection. This bookmark object
             * can then be used to restore the selection after some content modification to the document.
             *
             * @method getBookmark
             * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
             * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
             * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
             * @example
             * // Stores a bookmark of the current selection
             * const bm = tinymce.activeEditor.selection.getBookmark();
             *
             * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
             *
             * // Restore the selection bookmark
             * tinymce.activeEditor.selection.moveToBookmark(bm);
             */
            getBookmark: curry(getBookmark$2, selection),
            /**
             * Restores the selection to the specified bookmark.
             *
             * @method moveToBookmark
             * @param {Object} bookmark Bookmark to restore selection from.
             * @example
             * // Stores a bookmark of the current selection
             * const bm = tinymce.activeEditor.selection.getBookmark();
             *
             * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
             *
             * // Restore the selection bookmark
             * tinymce.activeEditor.selection.moveToBookmark(bm);
             */
            moveToBookmark: curry(moveToBookmark, selection)
        };
    };
    /**
     * Returns true/false if the specified node is a bookmark node or not.
     *
     * @static
     * @method isBookmarkNode
     * @param {DOMNode} node DOM Node to check if it's a bookmark node or not.
     * @return {Boolean} true/false if the node is a bookmark node or not.
     */
    BookmarkManager.isBookmarkNode = isBookmarkNode$1;

    const isXYWithinRange = (clientX, clientY, range) => {
        if (range.collapsed) {
            return false;
        }
        else {
            return exists(range.getClientRects(), (rect) => containsXY(rect, clientX, clientY));
        }
    };

    const clamp$1 = (offset, element) => {
        const max = isText$c(element) ? get$4(element).length : children$1(element).length + 1;
        if (offset > max) {
            return max;
        }
        else if (offset < 0) {
            return 0;
        }
        return offset;
    };
    const normalizeRng = (rng) => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));
    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));
    const isRngInRoot = (root) => (rng) => isOrContains(root, rng.start) && isOrContains(root, rng.finish);
    // TINY-9259: We need to store the selection on Firefox since if the editor is hidden the selection.getRng() api will not work as expected.
    const shouldStore = (editor) => editor.inline || Env.browser.isFirefox();
    const nativeRangeToSelectionRange = (r) => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);
    const readRange = (win) => {
        const selection = win.getSelection();
        const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));
        return rng.map(nativeRangeToSelectionRange);
    };
    const getBookmark$1 = (root) => {
        const win = defaultView(root);
        return readRange(win.dom)
            .filter(isRngInRoot(root));
    };
    const validate = (root, bookmark) => Optional.from(bookmark)
        .filter(isRngInRoot(root))
        .map(normalizeRng);
    const bookmarkToNativeRng = (bookmark) => {
        const rng = document.createRange();
        try {
            // Might throw IndexSizeError
            rng.setStart(bookmark.start.dom, bookmark.soffset);
            rng.setEnd(bookmark.finish.dom, bookmark.foffset);
            return Optional.some(rng);
        }
        catch (_a) {
            return Optional.none();
        }
    };
    const store = (editor) => {
        const newBookmark = shouldStore(editor) ? getBookmark$1(SugarElement.fromDom(editor.getBody())) : Optional.none();
        editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
    };
    const getRng = (editor) => {
        const bookmark = editor.bookmark ? editor.bookmark : Optional.none();
        return bookmark
            .bind((x) => validate(SugarElement.fromDom(editor.getBody()), x))
            .bind(bookmarkToNativeRng);
    };
    const restore = (editor) => {
        getRng(editor).each((rng) => editor.selection.setRng(rng));
    };

    /**
     * This class manages the focus/blur state of the editor. This class is needed since some
     * browsers fire false focus/blur states when the selection is moved to a UI dialog or similar.
     *
     * This class will fire two events focus and blur on the editor instances that got affected.
     * It will also handle the restore of selection when the focus is lost and returned.
     *
     * @class tinymce.FocusManager
     * @private
     */
    /**
     * Returns true if the specified element is part of the UI for example an button or text input.
     *
     * @static
     * @method isEditorUIElement
     * @param  {Element} elm Element to check if it's part of the UI or not.
     * @return {Boolean} True/false state if the element is part of the UI or not.
     */
    const isEditorUIElement$1 = (elm) => {
        // Needs to be converted to string since svg can have focus: #6776
        const className = elm.className.toString();
        return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;
    };
    const FocusManager = {
        isEditorUIElement: isEditorUIElement$1
    };

    /**
     * Utility class for working with delayed actions like setTimeout.
     *
     * @class tinymce.util.Delay
     */
    const wrappedSetTimeout = (callback, time) => {
        if (!isNumber(time)) {
            time = 0;
        }
        return window.setTimeout(callback, time);
    };
    const wrappedSetInterval = (callback, time) => {
        if (!isNumber(time)) {
            time = 0;
        }
        return window.setInterval(callback, time);
    };
    const Delay = {
        /**
         * Sets a timeout that's similar to the native browser <a href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout">setTimeout</a>
         * API, except that it checks if the editor instance is still alive when the callback gets executed.
         *
         * @method setEditorTimeout
         * @param {tinymce.Editor} editor Editor instance to check the removed state on.
         * @param {Function} callback Callback to execute when timer runs out.
         * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
         * @return {Number} Timeout id number.
         */
        setEditorTimeout: (editor, callback, time) => {
            return wrappedSetTimeout(() => {
                if (!editor.removed) {
                    callback();
                }
            }, time);
        },
        /**
         * Sets an interval timer that's similar to native browser <a href="https://developer.mozilla.org/en-US/docs/Web/API/setInterval">setInterval</a>
         * API, except that it checks if the editor instance is still alive when the callback gets executed.
         *
         * @method setEditorInterval
         * @param {Function} callback Callback to execute when interval time runs out.
         * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
         * @return {Number} Timeout id number.
         */
        setEditorInterval: (editor, callback, time) => {
            const timer = wrappedSetInterval(() => {
                if (!editor.removed) {
                    callback();
                }
                else {
                    window.clearInterval(timer);
                }
            }, time);
            return timer;
        }
    };

    const walkUp = (navigation, doc) => {
        const frame = navigation.view(doc);
        return frame.fold(constant([]), (f) => {
            const parent = navigation.owner(f);
            const rest = walkUp(navigation, parent);
            return [f].concat(rest);
        });
    };
    const pathTo = (element, navigation) => {
        const d = navigation.owner(element);
        return walkUp(navigation, d);
    };

    const view = (doc) => {
        var _a;
        // Only walk up to the document this script is defined in.
        // This prevents walking up to the parent window when the editor is in an iframe.
        const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
        return element.map(SugarElement.fromDom);
    };
    const owner = (element) => documentOrOwner(element);

    var Navigation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        view: view,
        owner: owner
    });

    const find = (element) => {
        const doc = getDocument();
        const scroll = get$5(doc);
        const frames = pathTo(element, Navigation);
        const offset = viewport(element);
        const r = foldr(frames, (b, a) => {
            const loc = viewport(a);
            return {
                left: b.left + loc.left,
                top: b.top + loc.top
            };
        }, { left: 0, top: 0 });
        return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);
    };

    const isManualNodeChange = (e) => {
        return e.type === 'nodechange' && e.selectionChange;
    };
    const registerPageMouseUp = (editor, throttledStore) => {
        const mouseUpPage = () => {
            throttledStore.throttle();
        };
        DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);
        editor.on('remove', () => {
            DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);
        });
    };
    const registerMouseUp = (editor, throttledStore) => {
        editor.on('mouseup touchend', (_e) => {
            throttledStore.throttle();
        });
    };
    const registerEditorEvents = (editor, throttledStore) => {
        registerMouseUp(editor, throttledStore);
        editor.on('keyup NodeChange AfterSetSelectionRange', (e) => {
            if (!isManualNodeChange(e)) {
                store(editor);
            }
        });
    };
    const register$6 = (editor) => {
        const throttledStore = first$1(() => {
            store(editor);
        }, 0);
        editor.on('init', () => {
            if (editor.inline) {
                registerPageMouseUp(editor, throttledStore);
            }
            registerEditorEvents(editor, throttledStore);
        });
        editor.on('remove', () => {
            throttledStore.cancel();
        });
    };

    let documentFocusInHandler;
    const DOM$d = DOMUtils.DOM;
    const isEditorUIElement = (elm) => {
        // Since this can be overridden by third party we need to use the API reference here
        return isElement$7(elm) && FocusManager.isEditorUIElement(elm);
    };
    const isEditorContentAreaElement = (elm) => {
        const classList = elm.classList;
        if (classList !== undefined) {
            // tox-edit-area__iframe === iframe container element
            // mce-content-body === inline body element
            return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');
        }
        else {
            return false;
        }
    };
    const isUIElement = (editor, elm) => {
        const customSelector = getCustomUiSelector(editor);
        const parent = DOM$d.getParent(elm, (elm) => {
            return (isEditorUIElement(elm) ||
                (customSelector ? editor.dom.is(elm, customSelector) : false));
        });
        return parent !== null;
    };
    const getActiveElement = (editor) => {
        try {
            const root = getRootNode(SugarElement.fromDom(editor.getElement()));
            return active(root).fold(() => document.body, (x) => x.dom);
        }
        catch (_a) {
            // IE sometimes fails to get the activeElement when resizing table
            // TODO: Investigate this
            return document.body;
        }
    };
    const registerEvents$1 = (editorManager, e) => {
        const editor = e.editor;
        register$6(editor);
        const toggleContentAreaOnFocus = (editor, fn) => {
            // Inline editors have a different approach to highlight the content area on focus
            if (shouldHighlightOnFocus(editor) && editor.inline !== true) {
                const contentArea = SugarElement.fromDom(editor.getContainer());
                fn(contentArea, 'tox-edit-focus');
            }
        };
        const bringEditorIntoView = (editor) => {
            const minimumVisibility = 25;
            if (!editor.iframeElement) {
                return;
            }
            const element = SugarElement.fromDom(editor.iframeElement);
            const op = find(element);
            const viewportBounds = getBounds(window);
            if (op.top < viewportBounds.y || op.top > (viewportBounds.bottom - minimumVisibility)) {
                element.dom.scrollIntoView({ block: 'center' });
            }
        };
        editor.on('focusin', () => {
            const focusedEditor = editorManager.focusedEditor;
            if (isEditorContentAreaElement(getActiveElement(editor))) {
                toggleContentAreaOnFocus(editor, add$2);
            }
            if (focusedEditor !== editor) {
                if (focusedEditor) {
                    focusedEditor.dispatch('blur', { focusedEditor: editor });
                }
                editorManager.setActive(editor);
                editorManager.focusedEditor = editor;
                editor.dispatch('focus', { blurredEditor: focusedEditor });
                editor.focus(true);
                const browser = detect$1().browser;
                if (editor.inline !== true && (browser.isSafari() || browser.isChromium())) {
                    bringEditorIntoView(editor);
                }
            }
        });
        editor.on('focusout', () => {
            Delay.setEditorTimeout(editor, () => {
                const focusedEditor = editorManager.focusedEditor;
                // Remove focus highlight when the content area is no longer the active editor element, or if the highlighted editor is not the current focused editor
                if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {
                    toggleContentAreaOnFocus(editor, remove$4);
                }
                // Still the same editor the blur was outside any editor UI
                if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {
                    editor.dispatch('blur', { focusedEditor: null });
                    editorManager.focusedEditor = null;
                }
            });
        });
        // Check if focus is moved to an element outside the active editor by checking if the target node
        // isn't within the body of the activeEditor nor a UI element such as a dialog child control
        if (!documentFocusInHandler) {
            documentFocusInHandler = (e) => {
                const activeEditor = editorManager.activeEditor;
                if (activeEditor) {
                    getOriginalEventTarget(e).each((target) => {
                        const elem = target;
                        if (elem.ownerDocument === document) {
                            // Fire a blur event if the element isn't a UI element
                            if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {
                                activeEditor.dispatch('blur', { focusedEditor: null });
                                editorManager.focusedEditor = null;
                            }
                        }
                    });
                }
            };
            DOM$d.bind(document, 'focusin', documentFocusInHandler);
        }
    };
    const unregisterDocumentEvents = (editorManager, e) => {
        if (editorManager.focusedEditor === e.editor) {
            editorManager.focusedEditor = null;
        }
        if (!editorManager.activeEditor && documentFocusInHandler) {
            DOM$d.unbind(document, 'focusin', documentFocusInHandler);
            documentFocusInHandler = null;
        }
    };
    const setup$C = (editorManager) => {
        editorManager.on('AddEditor', curry(registerEvents$1, editorManager));
        editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));
    };

    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, (node) => editor.dom.getContentEditable(node) === 'true');
    const hasContentEditableFalseParent$1 = (editor, node) => editor.dom.getParent(node, (node) => editor.dom.getContentEditable(node) === 'false') !== null;
    const getCollapsedNode = (rng) => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();
    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind((node) => {
        if (isTableSection(node)) {
            return Optional.some(node);
        }
        else if (!contains(root, node)) {
            return Optional.some(root);
        }
        else {
            return Optional.none();
        }
    });
    const normalizeSelection = (editor, rng) => {
        getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind((elm) => {
            return firstPositionIn(elm.dom);
        }).fold(() => {
            editor.selection.normalize();
        }, (caretPos) => editor.selection.setRng(caretPos.toRange()));
    };
    const focusBody = (body) => {
        if (body.setActive) {
            // IE 11 sometimes throws "Invalid function" then fallback to focus
            // setActive is better since it doesn't scroll to the element being focused
            try {
                body.setActive();
            }
            catch (_a) {
                body.focus();
            }
        }
        else {
            body.focus();
        }
    };
    const hasElementFocus = (elm) => hasFocus$1(elm) || search(elm).isSome();
    const hasIframeFocus = (editor) => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));
    const hasInlineFocus = (editor) => {
        const rawBody = editor.getBody();
        return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
    };
    const hasUiFocus = (editor) => {
        const dos = getRootNode(SugarElement.fromDom(editor.getElement()));
        // Editor container is the obvious one (Menubar, Toolbar, Status bar, Sidebar) and dialogs and menus are in an auxiliary element (silver theme specific)
        // This can't use Focus.search() because only the theme has this element reference
        return active(dos)
            .filter((elem) => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom))
            .isSome();
    };
    const hasFocus = (editor) => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
    const hasEditorOrUiFocus = (editor) => hasFocus(editor) || hasUiFocus(editor);
    const focusEditor = (editor) => {
        const selection = editor.selection;
        const body = editor.getBody();
        let rng = selection.getRng();
        editor.quirks.refreshContentEditable();
        const restoreBookmark = (editor) => {
            getRng(editor).each((bookmarkRng) => {
                editor.selection.setRng(bookmarkRng);
                rng = bookmarkRng;
            });
        };
        if (!hasFocus(editor) && editor.hasEditableRoot()) {
            restoreBookmark(editor);
        }
        // Move focus to contentEditable=true child if needed
        const contentEditableHost = getContentEditableHost(editor, selection.getNode());
        if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {
            if (!hasContentEditableFalseParent$1(editor, contentEditableHost)) {
                focusBody(body);
            }
            focusBody(contentEditableHost);
            if (!editor.hasEditableRoot()) {
                restoreBookmark(editor);
            }
            normalizeSelection(editor, rng);
            activateEditor(editor);
            return;
        }
        // Focus the window iframe
        if (!editor.inline) {
            // WebKit needs this call to fire focusin event properly see #5948
            // But Opera pre Blink engine will produce an empty selection so skip Opera
            if (!Env.browser.isOpera()) {
                focusBody(body);
            }
            editor.getWin().focus();
        }
        // Focus the body as well since it's contentEditable
        if (Env.browser.isFirefox() || editor.inline) {
            focusBody(body);
            normalizeSelection(editor, rng);
        }
        activateEditor(editor);
    };
    const activateEditor = (editor) => editor.editorManager.setActive(editor);
    const focus = (editor, skipFocus) => {
        if (editor.removed) {
            return;
        }
        if (skipFocus) {
            activateEditor(editor);
        }
        else {
            focusEditor(editor);
        }
    };

    /**
     * This file exposes a set of the common KeyCodes for use. Please grow it as needed.
     */
    const VK = {
        BACKSPACE: 8,
        DELETE: 46,
        DOWN: 40,
        ENTER: 13,
        ESC: 27,
        LEFT: 37,
        RIGHT: 39,
        SPACEBAR: 32,
        TAB: 9,
        UP: 38,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        modifierPressed: (e) => {
            return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);
        },
        metaKeyPressed: (e) => {
            // Check if ctrl or meta key is pressed. Edge case for AltGr on Windows where it produces ctrlKey+altKey states
            return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;
        }
    };

    const elementSelectionAttr = 'data-mce-selected';
    const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';
    const abs = Math.abs;
    const round$1 = Math.round;
    // Details about each resize handle how to scale etc
    const resizeHandles = {
        // Name: x multiplier, y multiplier, delta size x, delta size y
        nw: [0, 0, -1, -1],
        ne: [1, 0, 1, -1],
        se: [1, 1, 1, 1],
        sw: [0, 1, -1, 1]
    };
    const isTouchEvent = (evt) => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;
    /**
     * This class handles control selection of elements. Controls are elements
     * that can be resized and needs to be selected as a whole. It adds custom resize handles
     * to all browser engines that support properly disabling the built in resize logic.
     *
     * @private
     * @class tinymce.dom.ControlSelection
     */
    const ControlSelection = (selection, editor) => {
        const dom = editor.dom;
        const editableDoc = editor.getDoc();
        const rootDocument = document;
        const rootElement = editor.getBody();
        let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;
        let startX, startY, startW, startH, ratio, resizeStarted;
        let width;
        let height;
        let startScrollWidth;
        let startScrollHeight;
        const isImage = (elm) => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));
        const isMedia = (elm) => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');
        const isEventOnImageOutsideRange = (evt, range) => {
            if (isTouchEvent(evt)) {
                const touch = evt.touches[0];
                return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);
            }
            else {
                return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);
            }
        };
        const contextMenuSelectImage = (evt) => {
            const target = evt.target;
            if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
                editor.selection.select(target);
            }
        };
        const getResizeTargets = (elm) => {
            if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {
                // When resizing a preview object we need to resize both the original element and the wrapper span
                return [elm, elm.firstElementChild];
            }
            else if (dom.is(elm, 'figure.image')) {
                return [elm.querySelector('img')];
            }
            else {
                return [elm];
            }
        };
        const isResizable = (elm) => {
            const selector = getObjectResizing(editor);
            if (!selector || editor.mode.isReadOnly()) {
                return false;
            }
            if (elm.getAttribute('data-mce-resize') === 'false') {
                return false;
            }
            if (elm === editor.getBody()) {
                return false;
            }
            if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {
                return is$2(SugarElement.fromDom(elm.firstElementChild), selector);
            }
            else {
                return is$2(SugarElement.fromDom(elm), selector);
            }
        };
        const createGhostElement = (dom, elm) => {
            if (isMedia(elm)) {
                return dom.create('img', { src: Env.transparentSrc });
            }
            else if (isTable$2(elm)) {
                const isNorth = startsWith(selectedHandle.name, 'n');
                const rowSelect = isNorth ? head : last$2;
                const tableElm = elm.cloneNode(true);
                // Get row, remove all height styles
                rowSelect(dom.select('tr', tableElm)).each((tr) => {
                    const cells = dom.select('td,th', tr);
                    dom.setStyle(tr, 'height', null);
                    each$e(cells, (cell) => dom.setStyle(cell, 'height', null));
                });
                return tableElm;
            }
            else {
                return elm.cloneNode(true);
            }
        };
        const setSizeProp = (element, name, value) => {
            if (isNonNullable(value)) {
                // Resize by using style or attribute
                const targets = getResizeTargets(element);
                each$e(targets, (target) => {
                    if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {
                        dom.setStyle(target, name, value);
                    }
                    else {
                        dom.setAttrib(target, name, '' + value);
                    }
                });
            }
        };
        const setGhostElmSize = (ghostElm, width, height) => {
            setSizeProp(ghostElm, 'width', width);
            setSizeProp(ghostElm, 'height', height);
        };
        const resizeGhostElement = (e) => {
            let deltaX, deltaY, proportional;
            let resizeHelperX, resizeHelperY;
            // Calc new width/height
            deltaX = e.screenX - startX;
            deltaY = e.screenY - startY;
            // Calc new size
            width = deltaX * selectedHandle[2] + startW;
            height = deltaY * selectedHandle[3] + startH;
            // Never scale down lower than 5 pixels
            width = width < 5 ? 5 : width;
            height = height < 5 ? 5 : height;
            if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {
                proportional = !VK.modifierPressed(e);
            }
            else {
                proportional = VK.modifierPressed(e);
            }
            // Constrain proportions
            if (proportional) {
                if (abs(deltaX) > abs(deltaY)) {
                    height = round$1(width * ratio);
                    width = round$1(height / ratio);
                }
                else {
                    width = round$1(height / ratio);
                    height = round$1(width * ratio);
                }
            }
            // Update ghost size
            setGhostElmSize(selectedElmGhost, width, height);
            // Update resize helper position
            resizeHelperX = selectedHandle.startPos.x + deltaX;
            resizeHelperY = selectedHandle.startPos.y + deltaY;
            resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
            resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
            dom.setStyles(resizeHelper, {
                left: resizeHelperX,
                top: resizeHelperY,
                display: 'block'
            });
            resizeHelper.innerHTML = width + ' &times; ' + height;
            /* TODO: TINY-11702 dom.setStyle() has no effect because the value is NaN
              // Update ghost X position if needed
              if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
                dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));
              }
        
              // Update ghost Y position if needed
              if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
                dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));
              }
            */
            // Calculate how must overflow we got
            deltaX = rootElement.scrollWidth - startScrollWidth;
            deltaY = rootElement.scrollHeight - startScrollHeight;
            // Re-position the resize helper based on the overflow
            if (deltaX + deltaY !== 0) {
                dom.setStyles(resizeHelper, {
                    left: resizeHelperX - deltaX,
                    top: resizeHelperY - deltaY
                });
            }
            if (!resizeStarted) {
                fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);
                resizeStarted = true;
            }
        };
        const endGhostResize = () => {
            const wasResizeStarted = resizeStarted;
            resizeStarted = false;
            // Set width/height properties
            if (wasResizeStarted) {
                setSizeProp(selectedElm, 'width', width);
                setSizeProp(selectedElm, 'height', height);
            }
            dom.unbind(editableDoc, 'mousemove', resizeGhostElement);
            dom.unbind(editableDoc, 'mouseup', endGhostResize);
            if (rootDocument !== editableDoc) {
                dom.unbind(rootDocument, 'mousemove', resizeGhostElement);
                dom.unbind(rootDocument, 'mouseup', endGhostResize);
            }
            // Remove ghost/helper and update resize handle positions
            dom.remove(selectedElmGhost);
            dom.remove(resizeHelper);
            dom.remove(resizeBackdrop);
            showResizeRect(selectedElm);
            if (wasResizeStarted) {
                fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);
                dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));
            }
            editor.nodeChanged();
        };
        const showResizeRect = (targetElm) => {
            unbindResizeHandleEvents();
            // Get position and size of target
            const position = dom.getPos(targetElm, rootElement);
            const selectedElmX = position.x;
            const selectedElmY = position.y;
            const rect = targetElm.getBoundingClientRect(); // Fix for Gecko offsetHeight for table with caption
            const targetWidth = rect.width || (rect.right - rect.left);
            const targetHeight = rect.height || (rect.bottom - rect.top);
            // Reset width/height if user selects a new image/table
            if (selectedElm !== targetElm) {
                hideResizeRect();
                selectedElm = targetElm;
                width = height = 0;
            }
            // Makes it possible to disable resizing
            const e = editor.dispatch('ObjectSelected', { target: targetElm });
            if (isResizable(targetElm) && !e.isDefaultPrevented()) {
                each$d(resizeHandles, (handle, name) => {
                    const startDrag = (e) => {
                        // Note: We're guaranteed to have at least one target here
                        const target = getResizeTargets(selectedElm)[0];
                        startX = e.screenX;
                        startY = e.screenY;
                        startW = target.clientWidth;
                        startH = target.clientHeight;
                        ratio = startH / startW;
                        selectedHandle = handle;
                        selectedHandle.name = name;
                        selectedHandle.startPos = {
                            x: targetWidth * handle[0] + selectedElmX,
                            y: targetHeight * handle[1] + selectedElmY
                        };
                        startScrollWidth = rootElement.scrollWidth;
                        startScrollHeight = rootElement.scrollHeight;
                        resizeBackdrop = dom.add(rootElement, 'div', {
                            'class': 'mce-resize-backdrop',
                            'data-mce-bogus': 'all'
                        });
                        dom.setStyles(resizeBackdrop, {
                            position: 'fixed',
                            left: '0',
                            top: '0',
                            width: '100%',
                            height: '100%'
                        });
                        selectedElmGhost = createGhostElement(dom, selectedElm);
                        dom.addClass(selectedElmGhost, 'mce-clonedresizable');
                        dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');
                        selectedElmGhost.contentEditable = 'false'; // Hides IE move layer cursor
                        dom.setStyles(selectedElmGhost, {
                            left: selectedElmX,
                            top: selectedElmY,
                            margin: 0
                        });
                        // Set initial ghost size
                        setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
                        selectedElmGhost.removeAttribute(elementSelectionAttr);
                        rootElement.appendChild(selectedElmGhost);
                        dom.bind(editableDoc, 'mousemove', resizeGhostElement);
                        dom.bind(editableDoc, 'mouseup', endGhostResize);
                        if (rootDocument !== editableDoc) {
                            dom.bind(rootDocument, 'mousemove', resizeGhostElement);
                            dom.bind(rootDocument, 'mouseup', endGhostResize);
                        }
                        resizeHelper = dom.add(rootElement, 'div', {
                            'class': 'mce-resize-helper',
                            'data-mce-bogus': 'all'
                        }, startW + ' &times; ' + startH);
                    };
                    // Get existing or render resize handle
                    let handleElm = dom.get('mceResizeHandle' + name);
                    if (handleElm) {
                        dom.remove(handleElm);
                    }
                    handleElm = dom.add(rootElement, 'div', {
                        'id': 'mceResizeHandle' + name,
                        'data-mce-bogus': 'all',
                        'class': 'mce-resizehandle',
                        'unselectable': true,
                        'style': 'cursor:' + name + '-resize; margin:0; padding:0'
                    });
                    dom.bind(handleElm, 'mousedown', (e) => {
                        e.stopImmediatePropagation();
                        e.preventDefault();
                        startDrag(e);
                    });
                    handle.elm = handleElm;
                    // Position element
                    dom.setStyles(handleElm, {
                        left: (targetWidth * handle[0] + selectedElmX) - (handleElm.offsetWidth / 2),
                        top: (targetHeight * handle[1] + selectedElmY) - (handleElm.offsetHeight / 2)
                    });
                });
            }
            else {
                hideResizeRect(false);
            }
        };
        const throttledShowResizeRect = first$1(showResizeRect, 0);
        const hideResizeRect = (removeSelected = true) => {
            throttledShowResizeRect.cancel();
            unbindResizeHandleEvents();
            if (selectedElm && removeSelected) {
                selectedElm.removeAttribute(elementSelectionAttr);
            }
            each$d(resizeHandles, (value, name) => {
                const handleElm = dom.get('mceResizeHandle' + name);
                if (handleElm) {
                    dom.unbind(handleElm);
                    dom.remove(handleElm);
                }
            });
        };
        const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);
        const updateResizeRect = (e) => {
            // Ignore all events while resizing, if the editor instance is composing or the editor was removed
            if (resizeStarted || editor.removed || editor.composing) {
                return;
            }
            const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();
            const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector)
                .map((e) => e.dom)
                .filter((e) => dom.isEditable(e.parentElement) || (e.nodeName === 'IMG' && dom.isEditable(e)))
                .getOrUndefined();
            // Store the original data-mce-selected value or fallback to '1' if not set
            const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';
            // Remove data-mce-selected from all elements since they might have been copied using Ctrl+c/v
            each$e(dom.select(`img[${elementSelectionAttr}],hr[${elementSelectionAttr}]`), (img) => {
                img.removeAttribute(elementSelectionAttr);
            });
            if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && hasEditorOrUiFocus(editor)) {
                disableGeckoResize();
                const startElm = selection.getStart(true);
                if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
                    // Note: We must ensure the selected attribute is added first before showing the rect so that we don't get any selection flickering
                    dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);
                    throttledShowResizeRect.throttle(controlElm);
                    return;
                }
            }
            hideResizeRect();
        };
        const unbindResizeHandleEvents = () => {
            each$d(resizeHandles, (handle) => {
                if (handle.elm) {
                    dom.unbind(handle.elm);
                    // eslint-disable-next-line @typescript-eslint/no-array-delete
                    delete handle.elm;
                }
            });
        };
        const disableGeckoResize = () => {
            try {
                // Disable object resizing on Gecko
                editor.getDoc().execCommand('enableObjectResizing', false, 'false');
            }
            catch (_a) {
                // Ignore
            }
        };
        editor.on('init', () => {
            disableGeckoResize();
            editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);
            // Update resize rect while typing in a table
            editor.on('keyup compositionend', (e) => {
                // Don't update the resize rect while composing since it blows away the IME see: #2710
                if (selectedElm && selectedElm.nodeName === 'TABLE') {
                    updateResizeRect(e);
                }
            });
            editor.on('hide blur', hideResizeRect);
            editor.on('contextmenu longpress', contextMenuSelectImage, true);
            // Hide rect on focusout since it would float on top of windows otherwise
            // editor.on('focusout', hideResizeRect);
        });
        editor.on('remove', unbindResizeHandleEvents);
        const destroy = () => {
            throttledShowResizeRect.cancel();
            selectedElm = selectedElmGhost = resizeBackdrop = null;
        };
        return {
            isResizable,
            showResizeRect,
            hideResizeRect,
            updateResizeRect,
            destroy
        };
    };

    const fromPoint = (clientX, clientY, doc) => {
        const win = defaultView(SugarElement.fromDom(doc));
        return getAtPoint(win.dom, clientX, clientY).map((simRange) => {
            const rng = doc.createRange();
            rng.setStart(simRange.start.dom, simRange.soffset);
            rng.setEnd(simRange.finish.dom, simRange.foffset);
            return rng;
        }).getOrUndefined();
    };

    const isEq$4 = (rng1, rng2) => {
        return isNonNullable(rng1) && isNonNullable(rng2) &&
            (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) &&
            (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
    };

    const findParent = (node, rootNode, predicate) => {
        let currentNode = node;
        while (currentNode && currentNode !== rootNode) {
            if (predicate(currentNode)) {
                return currentNode;
            }
            currentNode = currentNode.parentNode;
        }
        return null;
    };
    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;
    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, (node) => node.nodeName === name);
    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);
    const hasBrBeforeAfter = (dom, node, left) => {
        const parentNode = node.parentNode;
        if (parentNode) {
            const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());
            let currentNode;
            while ((currentNode = walker[left ? 'prev' : 'next']())) {
                if (isBr$7(currentNode)) {
                    return true;
                }
            }
        }
        return false;
    };
    const isPrevNode = (node, name) => { var _a; return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name; };
    const hasContentEditableFalseParent = (root, node) => {
        let currentNode = node;
        while (currentNode && currentNode !== root) {
            if (isContentEditableFalse$a(currentNode)) {
                return true;
            }
            currentNode = currentNode.parentNode;
        }
        return false;
    };
    // Walks the dom left/right to find a suitable text node to move the endpoint into
    // It will only walk within the current parent block or body and will stop if it hits a block or a BR/IMG
    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {
        const body = dom.getRoot();
        const nonEmptyElementsMap = dom.schema.getNonEmptyElements();
        const parentNode = startNode.parentNode;
        let lastInlineElement;
        let node;
        if (!parentNode) {
            return Optional.none();
        }
        const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;
        // Lean left before the BR element if it's the only BR within a block element. Gecko bug: #6680
        // This: <p><br>|</p> becomes <p>|<br></p>
        if (left && isBr$7(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {
            return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));
        }
        // Walk left until we hit a text node we can move to or a block/br/img
        const walker = new DomTreeWalker(startNode, parentBlockContainer);
        while ((node = walker[left ? 'prev' : 'next']())) {
            // Break if we hit a non content editable node
            if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {
                return Optional.none();
            }
            // Found text node that has a length
            if (isText$b(node) && node.data.length > 0) {
                if (!hasParentWithName(node, body, 'A')) {
                    return Optional.some(CaretPosition(node, left ? node.data.length : 0));
                }
                return Optional.none();
            }
            // Break if we find a block or a BR/IMG/INPUT etc
            if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
                return Optional.none();
            }
            lastInlineElement = node;
        }
        if (isComment(lastInlineElement)) {
            return Optional.none();
        }
        // Only fetch the last inline element when in caret mode for now
        if (collapsed && lastInlineElement) {
            return Optional.some(CaretPosition(lastInlineElement, 0));
        }
        return Optional.none();
    };
    const normalizeEndPoint = (dom, collapsed, start, rng) => {
        const body = dom.getRoot();
        let node;
        let normalized = false;
        let container = start ? rng.startContainer : rng.endContainer;
        let offset = start ? rng.startOffset : rng.endOffset;
        const isAfterNode = isElement$7(container) && offset === container.childNodes.length;
        const nonEmptyElementsMap = dom.schema.getNonEmptyElements();
        let directionLeft = start;
        if (isCaretContainer$2(container)) {
            return Optional.none();
        }
        if (isElement$7(container) && offset > container.childNodes.length - 1) {
            directionLeft = false;
        }
        // If the container is a document move it to the body element
        if (isDocument$1(container)) {
            container = body;
            offset = 0;
        }
        // If the container is body try move it into the closest text node or position
        if (container === body) {
            // If start is before/after a image, table etc
            if (directionLeft) {
                node = container.childNodes[offset > 0 ? offset - 1 : 0];
                if (node) {
                    if (isCaretContainer$2(node)) {
                        return Optional.none();
                    }
                    if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {
                        return Optional.none();
                    }
                }
            }
            // Resolve the index
            if (container.hasChildNodes()) {
                offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
                container = container.childNodes[offset];
                offset = isText$b(container) && isAfterNode ? container.data.length : 0;
                // Don't normalize non collapsed selections like <p>[a</p><table></table>]
                if (!collapsed && container === body.lastChild && isTable$2(container)) {
                    return Optional.none();
                }
                if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {
                    return Optional.none();
                }
                if (isDetails(container)) {
                    return Optional.none();
                }
                // Don't walk into elements that doesn't have any child nodes like a IMG
                if (container.hasChildNodes() && !isTable$2(container)) {
                    // Walk the DOM to find a text node to place the caret at or a BR
                    node = container;
                    const walker = new DomTreeWalker(container, body);
                    do {
                        if (isContentEditableFalse$a(node) || isCaretContainer$2(node)) {
                            normalized = false;
                            break;
                        }
                        // Found a text node use that position
                        if (isText$b(node) && node.data.length > 0) {
                            offset = directionLeft ? 0 : node.data.length;
                            container = node;
                            normalized = true;
                            break;
                        }
                        // Found a BR/IMG/PRE element that we can place the caret before
                        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {
                            offset = dom.nodeIndex(node);
                            container = node.parentNode;
                            // Put caret after image and pre tag when moving the end point
                            if (!directionLeft) {
                                offset++;
                            }
                            normalized = true;
                            break;
                        }
                    } while ((node = (directionLeft ? walker.next() : walker.prev())));
                }
            }
        }
        // Lean the caret to the left if possible
        if (collapsed) {
            // So this: <b>x</b><i>|x</i>
            // Becomes: <b>x|</b><i>x</i>
            // Seems that only gecko has issues with this
            if (isText$b(container) && offset === 0) {
                findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each((pos) => {
                    container = pos.container();
                    offset = pos.offset();
                    normalized = true;
                });
            }
            // Lean left into empty inline elements when the caret is before a BR
            // So this: <i><b></b><i>|<br></i>
            // Becomes: <i><b>|</b><i><br></i>
            // Seems that only gecko has issues with this.
            // Special edge case for <p><a>x</a>|<br></p> since we don't want <p><a>x|</a><br></p>
            if (isElement$7(container)) {
                node = container.childNodes[offset];
                // Offset is after the containers last child
                // then use the previous child for normalization
                if (!node) {
                    node = container.childNodes[offset - 1];
                }
                if (node && isBr$7(node) && !isPrevNode(node, 'A') &&
                    !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {
                    findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each((pos) => {
                        container = pos.container();
                        offset = pos.offset();
                        normalized = true;
                    });
                }
            }
        }
        // Lean the start of the selection right if possible
        // So this: x[<b>x]</b>
        // Becomes: x<b>[x]</b>
        if (directionLeft && !collapsed && isText$b(container) && offset === container.data.length) {
            findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each((pos) => {
                container = pos.container();
                offset = pos.offset();
                normalized = true;
            });
        }
        return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();
    };
    const normalize$2 = (dom, rng) => {
        const collapsed = rng.collapsed, normRng = rng.cloneRange();
        const startPos = CaretPosition.fromRangeStart(rng);
        normalizeEndPoint(dom, collapsed, true, normRng).each((pos) => {
            // #TINY-1595: Do not move the caret to previous line
            if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
                normRng.setStart(pos.container(), pos.offset());
            }
        });
        if (!collapsed) {
            normalizeEndPoint(dom, collapsed, false, normRng).each((pos) => {
                normRng.setEnd(pos.container(), pos.offset());
            });
        }
        // If it was collapsed then make sure it still is
        if (collapsed) {
            normRng.collapse(true);
        }
        return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);
    };

    const splitText = (node, offset) => {
        return node.splitText(offset);
    };
    const split = (rng) => {
        let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
        // Handle single text node
        if (startContainer === endContainer && isText$b(startContainer)) {
            if (startOffset > 0 && startOffset < startContainer.data.length) {
                endContainer = splitText(startContainer, startOffset);
                startContainer = endContainer.previousSibling;
                if (endOffset > startOffset) {
                    endOffset = endOffset - startOffset;
                    const newContainer = splitText(endContainer, endOffset).previousSibling;
                    startContainer = endContainer = newContainer;
                    endOffset = newContainer.data.length;
                    startOffset = 0;
                }
                else {
                    endOffset = 0;
                }
            }
        }
        else {
            // Split startContainer text node if needed
            if (isText$b(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {
                startContainer = splitText(startContainer, startOffset);
                startOffset = 0;
            }
            // Split endContainer text node if needed
            if (isText$b(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {
                const newContainer = splitText(endContainer, endOffset).previousSibling;
                endContainer = newContainer;
                endOffset = newContainer.data.length;
            }
        }
        return {
            startContainer,
            startOffset,
            endContainer,
            endOffset
        };
    };

    /**
     * This class contains a few utility methods for ranges.
     *
     * @class tinymce.dom.RangeUtils
     */
    const RangeUtils = (dom) => {
        /**
         * Walks the specified range like object and executes the callback for each sibling collection it finds.
         *
         * @private
         * @method walk
         * @param {RangeObject} rng Range like object.
         * @param {Function} callback Callback function to execute for each sibling collection.
         */
        const walk = (rng, callback) => {
            return walk$3(dom, rng, callback);
        };
        /**
         * Splits the specified range at it's start/end points.
         *
         * @private
         * @param {RangeObject} rng Range to split.
         * @return {RangeObject} Range position object.
         */
        const split$1 = split;
        /**
         * Normalizes the specified range by finding the closest best suitable caret location.
         *
         * @private
         * @param {Range} rng Range to normalize.
         * @return {Boolean} True or false if the specified range was normalized or not.
         */
        const normalize = (rng) => {
            return normalize$2(dom, rng).fold(never, (normalizedRng) => {
                rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
                rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
                return true;
            });
        };
        /**
         * Returns a range expanded around the entire word the provided selection was collapsed within.
         *
         * @method expand
         * @param {Range} rng The initial range to work from.
         * @param {Object} options Optional options provided to the expansion. Defaults to { type: 'word' }
         * @return {Range} Returns the expanded range.
         */
        const expand = (rng, options = { type: 'word' }) => {
            if (options.type === 'word') {
                const rangeLike = expandRng(dom, rng, [{ inline: 'span' }], { includeTrailingSpace: false, expandToBlock: false });
                const newRange = dom.createRng();
                newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);
                newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);
                return newRange;
            }
            return rng;
        };
        return {
            walk,
            split: split$1,
            expand,
            normalize
        };
    };
    /**
     * Compares two ranges and checks if they are equal.
     *
     * @static
     * @method compareRanges
     * @param {RangeObject} rng1 First range to compare.
     * @param {RangeObject} rng2 First range to compare.
     * @return {Boolean} True or false if the ranges are equal.
     */
    RangeUtils.compareRanges = isEq$4;
    /**
     * Gets the caret range for the given x/y location.
     *
     * @static
     * @method getCaretRangeFromPoint
     * @param {Number} clientX X coordinate for range
     * @param {Number} clientY Y coordinate for range
     * @param {Document} doc Document that the x and y coordinates are relative to
     * @returns {Range} Caret range
     */
    RangeUtils.getCaretRangeFromPoint = fromPoint;
    RangeUtils.getSelectedNode = getSelectedNode;
    RangeUtils.getNode = getNode$1;

    const excludeFromDescend = (element) => name(element) === 'textarea';
    const fireScrollIntoViewEvent = (editor, data) => {
        const scrollEvent = editor.dispatch('ScrollIntoView', data);
        return scrollEvent.isDefaultPrevented();
    };
    const fireAfterScrollIntoViewEvent = (editor, data) => {
        editor.dispatch('AfterScrollIntoView', data);
    };
    const descend = (element, offset) => {
        const children = children$1(element);
        if (children.length === 0 || excludeFromDescend(element)) {
            return { element, offset };
        }
        else if (offset < children.length && !excludeFromDescend(children[offset])) {
            return { element: children[offset], offset: 0 };
        }
        else {
            const last = children[children.length - 1];
            if (excludeFromDescend(last)) {
                return { element, offset };
            }
            else {
                if (name(last) === 'img') {
                    return { element: last, offset: 1 };
                }
                else if (isText$c(last)) {
                    return { element: last, offset: get$4(last).length };
                }
                else {
                    return { element: last, offset: children$1(last).length };
                }
            }
        }
    };
    const markerInfo = (element, cleanupFun) => {
        const pos = absolute(element);
        const height = get$6(element);
        return {
            element,
            bottom: pos.top + height,
            height,
            pos,
            cleanup: cleanupFun
        };
    };
    const createMarker$1 = (element, offset) => {
        const startPoint = descend(element, offset);
        const span = SugarElement.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + ZWSP$1 + '</span>');
        before$4(startPoint.element, span);
        return markerInfo(span, () => remove$8(span));
    };
    const elementMarker = (element) => markerInfo(SugarElement.fromDom(element), noop);
    const withMarker = (editor, f, rng, alignToTop) => {
        preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);
    };
    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {
        const data = { elm: marker.element.dom, alignToTop };
        if (fireScrollIntoViewEvent(editor, data)) {
            return;
        }
        const scrollTop = get$5(doc).top;
        f(editor, doc, scrollTop, marker, alignToTop);
        fireAfterScrollIntoViewEvent(editor, data);
    };
    const applyWithMarker = (editor, f, rng, alignToTop) => {
        const body = SugarElement.fromDom(editor.getBody());
        const doc = SugarElement.fromDom(editor.getDoc());
        reflow(body);
        const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);
        withScrollEvents(editor, doc, f, marker, alignToTop);
        marker.cleanup();
    };
    const withElement = (editor, element, f, alignToTop) => {
        const doc = SugarElement.fromDom(editor.getDoc());
        withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);
    };
    const preserveWith = (editor, f, rng) => {
        const startElement = rng.startContainer;
        const startOffset = rng.startOffset;
        const endElement = rng.endContainer;
        const endOffset = rng.endOffset;
        f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
        const newRng = editor.dom.createRng();
        newRng.setStart(startElement, startOffset);
        newRng.setEnd(endElement, endOffset);
        editor.selection.setRng(rng);
    };
    const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {
        const pos = marker.pos;
        // with default font size 16px font and 1.3 line height (~21px per line),
        // adding roughly 50% extra space gives about 30px of breathing room ensuring comfortable spacing.
        const scrollMargin = 30;
        if (alignToTop) {
            // When scrolling to top, add margin to the top position
            to(pos.left, Math.max(0, pos.top - scrollMargin), doc);
        }
        else {
            // The position we want to scroll to is the...
            // (absolute position of the marker, minus the view height) plus (the height of the marker)
            // When scrolling to bottom, add margin to ensure content isn't at the very bottom
            const y = (pos.top - viewHeight) + marker.height + scrollMargin;
            to(-editor.getBody().getBoundingClientRect().left, y, doc);
        }
    };
    const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {
        const viewportBottom = viewHeight + scrollTop;
        const markerTop = marker.pos.top;
        const markerBottom = marker.bottom;
        const largerThanViewport = markerBottom - markerTop >= viewHeight;
        // above the screen, scroll to top by default
        if (markerTop < scrollTop) {
            scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);
            // completely below the screen. Default scroll to the top if element height is larger
            // than the viewport, otherwise default to scrolling to the bottom
        }
        else if (markerTop > viewportBottom) {
            const align = largerThanViewport ? alignToTop !== false : alignToTop === true;
            scrollToMarker(editor, marker, viewHeight, align, doc);
            // partially below the bottom, only scroll if element height is less than viewport
        }
        else if (markerBottom > viewportBottom && !largerThanViewport) {
            scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);
        }
    };
    const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {
        const viewHeight = defaultView(doc).dom.innerHeight;
        intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);
    };
    const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {
        const frameViewHeight = defaultView(doc).dom.innerHeight; // height of iframe container
        // If the position is outside the iframe viewport, scroll to it
        intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);
        // If the new position is outside the window viewport, scroll to it
        const op = find(marker.element);
        const viewportBounds = getBounds(window);
        if (op.top < viewportBounds.y) {
            intoView(marker.element, alignToTop !== false);
        }
        else if (op.top > viewportBounds.bottom) {
            intoView(marker.element, alignToTop === true);
        }
    };
    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);
    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);
    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);
    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);
    const scrollElementIntoView = (editor, element, alignToTop) => {
        const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
        scroller(editor, element, alignToTop);
    };
    // This method is made to deal with the user pressing enter, it is not useful
    // if we want for example scroll in content after a paste event.
    const scrollRangeIntoView = (editor, rng, alignToTop) => {
        const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
        scroller(editor, rng, alignToTop);
    };

    const isEditableRange = (dom, rng) => {
        if (rng.collapsed) {
            return dom.isEditable(rng.startContainer);
        }
        else {
            return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);
        }
    };

    const getEndpointElement = (root, rng, start, real, resolve) => {
        const container = start ? rng.startContainer : rng.endContainer;
        const offset = start ? rng.startOffset : rng.endOffset;
        return Optional.from(container)
            .map(SugarElement.fromDom)
            .map((elm) => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm)
            .bind((elm) => isElement$8(elm) ? Optional.some(elm) : parent(elm).filter(isElement$8))
            .map((elm) => elm.dom)
            .getOr(root);
    };
    const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));
    const getEnd = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);
    const skipEmptyTextNodes = (node, forwards) => {
        const orig = node;
        while (node && isText$b(node) && node.length === 0) {
            node = forwards ? node.nextSibling : node.previousSibling;
        }
        return node || orig;
    };
    const getNode = (root, rng) => {
        // Range maybe lost after the editor is made visible again
        if (!rng) {
            return root;
        }
        let startContainer = rng.startContainer;
        let endContainer = rng.endContainer;
        const startOffset = rng.startOffset;
        const endOffset = rng.endOffset;
        let node = rng.commonAncestorContainer;
        // Handle selection a image or other control like element such as anchors
        if (!rng.collapsed) {
            if (startContainer === endContainer) {
                if (endOffset - startOffset < 2) {
                    if (startContainer.hasChildNodes()) {
                        node = startContainer.childNodes[startOffset];
                    }
                }
            }
            // If the anchor node is a element instead of a text node then return this element
            // if (tinymce.isWebKit && sel.anchorNode && sel.anchorNode.nodeType == 1)
            // return sel.anchorNode.childNodes[sel.anchorOffset];
            // Handle cases where the selection is immediately wrapped around a node and return that node instead of it's parent.
            // This happens when you double click an underlined word in FireFox.
            if (isText$b(startContainer) && isText$b(endContainer)) {
                if (startContainer.length === startOffset) {
                    startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
                }
                else {
                    startContainer = startContainer.parentNode;
                }
                if (endOffset === 0) {
                    endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
                }
                else {
                    endContainer = endContainer.parentNode;
                }
                if (startContainer && startContainer === endContainer) {
                    node = startContainer;
                }
            }
        }
        const elm = isText$b(node) ? node.parentNode : node;
        return isHTMLElement(elm) ? elm : root;
    };
    const getSelectedBlocks = (dom, rng, startElm, endElm) => {
        const selectedBlocks = [];
        const root = dom.getRoot();
        const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);
        const end = dom.getParent(endElm || getEnd(root, rng, rng.collapsed), dom.isBlock);
        if (start && start !== root) {
            selectedBlocks.push(start);
        }
        if (start && end && start !== end) {
            let node;
            const walker = new DomTreeWalker(start, root);
            while ((node = walker.next()) && node !== end) {
                if (dom.isBlock(node)) {
                    selectedBlocks.push(node);
                }
            }
        }
        if (end && start !== end && end !== root) {
            selectedBlocks.push(end);
        }
        return selectedBlocks;
    };
    const select = (dom, node, content) => Optional.from(node).bind((node) => Optional.from(node.parentNode).map((parent) => {
        const idx = dom.nodeIndex(node);
        const rng = dom.createRng();
        rng.setStart(parent, idx);
        rng.setEnd(parent, idx + 1);
        // Find first/last text node or BR element
        if (content) {
            moveEndPoint(dom, rng, node, true);
            moveEndPoint(dom, rng, node, false);
        }
        return rng;
    }));

    const processRanges = (editor, ranges) => map$3(ranges, (range) => {
        const evt = editor.dispatch('GetSelectionRange', { range });
        return evt.range !== range ? evt.range : range;
    });

    const typeLookup = {
        '#text': 3,
        '#comment': 8,
        '#cdata': 4,
        '#pi': 7,
        '#doctype': 10,
        '#document-fragment': 11
    };
    // Walks the tree left/right
    const walk$2 = (node, root, prev) => {
        const startName = prev ? 'lastChild' : 'firstChild';
        const siblingName = prev ? 'prev' : 'next';
        // Walk into nodes if it has a start
        if (node[startName]) {
            return node[startName];
        }
        // Return the sibling if it has one
        if (node !== root) {
            let sibling = node[siblingName];
            if (sibling) {
                return sibling;
            }
            // Walk up the parents to look for siblings
            for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {
                sibling = parent[siblingName];
                if (sibling) {
                    return sibling;
                }
            }
        }
        return undefined;
    };
    const isEmptyTextNode = (node) => {
        var _a;
        const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
        // Non whitespace content
        if (!isWhitespaceText(text)) {
            return false;
        }
        // Parent is not a span and only spaces or is a span but has styles
        const parentNode = node.parent;
        if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {
            return false;
        }
        return true;
    };
    // Check if node contains data-bookmark attribute, name attribute, id attribute or is a named anchor
    const isNonEmptyElement = (node) => {
        const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');
        return (node.attr('name') || (node.attr('id') && !node.firstChild) || node.attr('data-mce-bookmark') || isNamedAnchor);
    };
    /**
     * This class is a minimalistic implementation of a DOM like node used by the DomParser class.
     *
     * @class tinymce.html.Node
     * @version 3.4
     * @example
     * const node = new tinymce.html.Node('strong', 1);
     * someRoot.append(node);
     */
    class AstNode {
        /**
         * Creates a node of a specific type.
         *
         * @static
         * @method create
         * @param {String} name Name of the node type to create for example "b" or "#text".
         * @param {Object} attrs Name/value collection of attributes that will be applied to elements.
         */
        static create(name, attrs) {
            // Create node
            const node = new AstNode(name, typeLookup[name] || 1);
            // Add attributes if needed
            if (attrs) {
                each$d(attrs, (value, attrName) => {
                    node.attr(attrName, value);
                });
            }
            return node;
        }
        /**
         * Constructs a new Node instance.
         *
         * @constructor
         * @method Node
         * @param {String} name Name of the node type.
         * @param {Number} type Numeric type representing the node.
         */
        constructor(name, type) {
            this.name = name;
            this.type = type;
            if (type === 1) {
                this.attributes = [];
                this.attributes.map = {}; // Should be considered internal
            }
        }
        /**
         * Replaces the current node with the specified one.
         *
         * @method replace
         * @param {tinymce.html.Node} node Node to replace the current node with.
         * @return {tinymce.html.Node} The old node that got replaced.
         * @example
         * someNode.replace(someNewNode);
         */
        replace(node) {
            const self = this;
            if (node.parent) {
                node.remove();
            }
            self.insert(node, self);
            self.remove();
            return self;
        }
        attr(name, value) {
            const self = this;
            if (!isString(name)) {
                if (isNonNullable(name)) {
                    each$d(name, (value, key) => {
                        self.attr(key, value);
                    });
                }
                return self;
            }
            const attrs = self.attributes;
            if (attrs) {
                if (value !== undefined) {
                    // Remove attribute
                    if (value === null) {
                        if (name in attrs.map) {
                            delete attrs.map[name];
                            let i = attrs.length;
                            while (i--) {
                                if (attrs[i].name === name) {
                                    attrs.splice(i, 1);
                                    return self;
                                }
                            }
                        }
                        return self;
                    }
                    // Set attribute
                    if (name in attrs.map) {
                        // Set attribute
                        let i = attrs.length;
                        while (i--) {
                            if (attrs[i].name === name) {
                                attrs[i].value = value;
                                break;
                            }
                        }
                    }
                    else {
                        attrs.push({ name, value });
                    }
                    attrs.map[name] = value;
                    return self;
                }
                return attrs.map[name];
            }
            return undefined;
        }
        /**
         * Does a shallow clones the node into a new node. It will also exclude id attributes since
         * there should only be one id per document.
         *
         * @method clone
         * @return {tinymce.html.Node} New copy of the original node.
         * @example
         * const clonedNode = node.clone();
         */
        clone() {
            const self = this;
            const clone = new AstNode(self.name, self.type);
            const selfAttrs = self.attributes;
            // Clone element attributes
            if (selfAttrs) {
                const cloneAttrs = [];
                cloneAttrs.map = {};
                for (let i = 0, l = selfAttrs.length; i < l; i++) {
                    const selfAttr = selfAttrs[i];
                    // Clone everything except id
                    if (selfAttr.name !== 'id') {
                        cloneAttrs[cloneAttrs.length] = { name: selfAttr.name, value: selfAttr.value };
                        cloneAttrs.map[selfAttr.name] = selfAttr.value;
                    }
                }
                clone.attributes = cloneAttrs;
            }
            clone.value = self.value;
            return clone;
        }
        /**
         * Wraps the node in in another node.
         *
         * @method wrap
         * @example
         * node.wrap(wrapperNode);
         */
        wrap(wrapper) {
            const self = this;
            if (self.parent) {
                self.parent.insert(wrapper, self);
                wrapper.append(self);
            }
            return self;
        }
        /**
         * Unwraps the node in other words it removes the node but keeps the children.
         *
         * @method unwrap
         * @example
         * node.unwrap();
         */
        unwrap() {
            const self = this;
            for (let node = self.firstChild; node;) {
                const next = node.next;
                self.insert(node, self, true);
                node = next;
            }
            self.remove();
        }
        /**
         * Removes the node from it's parent.
         *
         * @method remove
         * @return {tinymce.html.Node} Current node that got removed.
         * @example
         * node.remove();
         */
        remove() {
            const self = this, parent = self.parent, next = self.next, prev = self.prev;
            if (parent) {
                if (parent.firstChild === self) {
                    parent.firstChild = next;
                    if (next) {
                        next.prev = null;
                    }
                }
                else if (prev) {
                    prev.next = next;
                }
                if (parent.lastChild === self) {
                    parent.lastChild = prev;
                    if (prev) {
                        prev.next = null;
                    }
                }
                else if (next) {
                    next.prev = prev;
                }
                self.parent = self.next = self.prev = null;
            }
            return self;
        }
        /**
         * Appends a new node as a child of the current node.
         *
         * @method append
         * @param {tinymce.html.Node} node Node to append as a child of the current one.
         * @return {tinymce.html.Node} The node that got appended.
         * @example
         * node.append(someNode);
         */
        append(node) {
            const self = this;
            if (node.parent) {
                node.remove();
            }
            const last = self.lastChild;
            if (last) {
                last.next = node;
                node.prev = last;
                self.lastChild = node;
            }
            else {
                self.lastChild = self.firstChild = node;
            }
            node.parent = self;
            return node;
        }
        /**
         * Inserts a node at a specific position as a child of this node.
         *
         * @method insert
         * @param {tinymce.html.Node} node Node to insert as a child of this node.
         * @param {tinymce.html.Node} refNode Reference node to set node before/after.
         * @param {Boolean} before Optional state to insert the node before the reference node.
         * @return {tinymce.html.Node} The node that got inserted.
         * @example
         * parentNode.insert(newChildNode, oldChildNode);
         */
        insert(node, refNode, before) {
            if (node.parent) {
                node.remove();
            }
            const parent = refNode.parent || this;
            if (before) {
                if (refNode === parent.firstChild) {
                    parent.firstChild = node;
                }
                else if (refNode.prev) {
                    refNode.prev.next = node;
                }
                node.prev = refNode.prev;
                node.next = refNode;
                refNode.prev = node;
            }
            else {
                if (refNode === parent.lastChild) {
                    parent.lastChild = node;
                }
                else if (refNode.next) {
                    refNode.next.prev = node;
                }
                node.next = refNode.next;
                node.prev = refNode;
                refNode.next = node;
            }
            node.parent = parent;
            return node;
        }
        /**
         * Get all descendants by name.
         *
         * @method getAll
         * @param {String} name Name of the descendant nodes to collect.
         * @return {Array} Array with descendant nodes matching the specified name.
         */
        getAll(name) {
            const self = this;
            const collection = [];
            for (let node = self.firstChild; node; node = walk$2(node, self)) {
                if (node.name === name) {
                    collection.push(node);
                }
            }
            return collection;
        }
        /**
         * Get all children of this node.
         *
         * @method children
         * @return {Array} Array containing child nodes.
         */
        children() {
            const self = this;
            const collection = [];
            for (let node = self.firstChild; node; node = node.next) {
                collection.push(node);
            }
            return collection;
        }
        /**
         * Removes all children of the current node.
         *
         * @method empty
         * @return {tinymce.html.Node} The current node that got cleared.
         */
        empty() {
            const self = this;
            // Remove all children
            if (self.firstChild) {
                const nodes = [];
                // Collect the children
                for (let node = self.firstChild; node; node = walk$2(node, self)) {
                    nodes.push(node);
                }
                // Remove the children
                let i = nodes.length;
                while (i--) {
                    const node = nodes[i];
                    node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
                }
            }
            self.firstChild = self.lastChild = null;
            return self;
        }
        /**
         * Returns true/false if the node is to be considered empty or not.
         *
         * @method isEmpty
         * @param {Object} elements Name/value object with elements that are automatically treated as non empty elements.
         * @param {Object} whitespace Name/value object with elements that are automatically treated whitespace preservables.
         * @param {Function} predicate Optional predicate that gets called after the other rules determine that the node is empty. Should return true if the node is a content node.
         * @return {Boolean} true/false if the node is empty or not.
         * @example
         * node.isEmpty({ img: true });
         */
        isEmpty(elements, whitespace = {}, predicate) {
            var _a;
            const self = this;
            let node = self.firstChild;
            if (isNonEmptyElement(self)) {
                return false;
            }
            if (node) {
                do {
                    if (node.type === 1) {
                        // Ignore bogus elements
                        if (node.attr('data-mce-bogus')) {
                            continue;
                        }
                        // Keep empty elements like <img />
                        if (elements[node.name]) {
                            return false;
                        }
                        if (isNonEmptyElement(node)) {
                            return false;
                        }
                    }
                    // Keep comments
                    if (node.type === 8) {
                        return false;
                    }
                    // Keep non whitespace text nodes
                    if (node.type === 3 && !isEmptyTextNode(node)) {
                        return false;
                    }
                    // Keep whitespace preserve elements
                    if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {
                        return false;
                    }
                    // Predicate tells that the node is contents
                    if (predicate && predicate(node)) {
                        return false;
                    }
                } while ((node = walk$2(node, self)));
            }
            return true;
        }
        /**
         * Walks to the next or previous node and returns that node or null if it wasn't found.
         *
         * @method walk
         * @param {Boolean} prev Optional previous node state defaults to false.
         * @return {tinymce.html.Node} Node that is next to or previous of the current node.
         */
        walk(prev) {
            return walk$2(this, null, prev);
        }
    }

    // TINY-10305: Map over array for faster lookup.
    const unescapedTextParents = Tools.makeMap('NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT', ' ');
    const containsZwsp = (node) => isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);
    const getTemporaryNodeSelector = (tempAttrs) => `${tempAttrs.length === 0 ? '' : `${map$3(tempAttrs, (attr) => `[${attr}]`).join(',')},`}[data-mce-bogus="all"]`;
    const getTemporaryNodes = (tempAttrs, body) => body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));
    const createZwspCommentWalker = (body) => document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, (node) => containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);
    const createUnescapedZwspTextWalker = (body) => document.createTreeWalker(body, NodeFilter.SHOW_TEXT, (node) => {
        if (containsZwsp(node)) {
            const parent = node.parentNode;
            return parent && has$2(unescapedTextParents, parent.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
        else {
            return NodeFilter.FILTER_SKIP;
        }
    });
    const hasZwspComment = (body) => createZwspCommentWalker(body).nextNode() !== null;
    const hasUnescapedZwspText = (body) => createUnescapedZwspTextWalker(body).nextNode() !== null;
    const hasTemporaryNode = (tempAttrs, body) => body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;
    const trimTemporaryNodes = (tempAttrs, body) => {
        each$e(getTemporaryNodes(tempAttrs, body), (elm) => {
            const element = SugarElement.fromDom(elm);
            if (get$9(element, 'data-mce-bogus') === 'all') {
                remove$8(element);
            }
            else {
                each$e(tempAttrs, (attr) => {
                    if (has$1(element, attr)) {
                        remove$9(element, attr);
                    }
                });
            }
        });
    };
    const emptyAllNodeValuesInWalker = (walker) => {
        let curr = walker.nextNode();
        while (curr !== null) {
            curr.nodeValue = null;
            curr = walker.nextNode();
        }
    };
    const emptyZwspComments = compose(emptyAllNodeValuesInWalker, createZwspCommentWalker);
    const emptyUnescapedZwspTexts = compose(emptyAllNodeValuesInWalker, createUnescapedZwspTextWalker);
    const trim$1 = (body, tempAttrs) => {
        const conditionalTrims = [
            {
                condition: curry(hasTemporaryNode, tempAttrs),
                action: curry(trimTemporaryNodes, tempAttrs)
            },
            {
                condition: hasZwspComment,
                action: emptyZwspComments
            },
            {
                condition: hasUnescapedZwspText,
                action: emptyUnescapedZwspTexts
            }
        ];
        let trimmed = body;
        let cloned = false;
        each$e(conditionalTrims, ({ condition, action }) => {
            if (condition(trimmed)) {
                if (!cloned) {
                    trimmed = body.cloneNode(true);
                    cloned = true;
                }
                action(trimmed);
            }
        });
        return trimmed;
    };

    const cleanupBogusElements = (parent) => {
        const bogusElements = descendants(parent, '[data-mce-bogus]');
        each$e(bogusElements, (elem) => {
            const bogusValue = get$9(elem, 'data-mce-bogus');
            if (bogusValue === 'all') {
                remove$8(elem);
            }
            else if (isBr$6(elem)) {
                // Need to keep bogus padding brs represented as a zero-width space so that they aren't collapsed by the browser
                before$4(elem, SugarElement.fromText(zeroWidth));
                remove$8(elem);
            }
            else {
                unwrap(elem);
            }
        });
    };
    const cleanupInputNames = (parent) => {
        const inputs = descendants(parent, 'input');
        each$e(inputs, (input) => {
            remove$9(input, 'name');
        });
    };

    const trimEmptyContents = (editor, html) => {
        const blockName = getForcedRootBlock(editor);
        const emptyRegExp = new RegExp(`^(<${blockName}[^>]*>(&nbsp;|&#160;|\\s|\u00a0|<br \\/>|)<\\/${blockName}>[\r\n]*|<br \\/>[\r\n]*)$`);
        return html.replace(emptyRegExp, '');
    };
    const getPlainTextContent = (editor, body) => {
        const doc = editor.getDoc();
        const dos = getRootNode(SugarElement.fromDom(editor.getBody()));
        const offscreenDiv = SugarElement.fromTag('div', doc);
        set$4(offscreenDiv, 'data-mce-bogus', 'all');
        setAll(offscreenDiv, {
            position: 'fixed',
            left: '-9999999px',
            top: '0'
        });
        set$3(offscreenDiv, body.innerHTML);
        cleanupBogusElements(offscreenDiv);
        cleanupInputNames(offscreenDiv);
        // Append the wrapper element so that the browser will evaluate styles when getting the `innerText`
        const root = getContentContainer(dos);
        append$1(root, offscreenDiv);
        const content = trim$2(offscreenDiv.dom.innerText);
        remove$8(offscreenDiv);
        return content;
    };
    const getContentFromBody = (editor, args, body) => {
        let content;
        if (args.format === 'raw') {
            content = Tools.trim(trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));
        }
        else if (args.format === 'text') {
            content = getPlainTextContent(editor, body);
        }
        else if (args.format === 'tree') {
            content = editor.serializer.serialize(body, args);
        }
        else {
            content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
        }
        // Trim if not using a whitespace preserve format/element
        const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));
        return shouldTrim && isString(content) ? Tools.trim(content) : content;
    };
    const getContentInternal = (editor, args) => Optional.from(editor.getBody())
        .fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), (body) => getContentFromBody(editor, args, body));

    /**
     * This class is used to write HTML tags out it can be used with the Serializer.
     *
     * @class tinymce.html.Writer
     * @version 3.4
     * @example
     * const writer = tinymce.html.Writer({ indent: true });
     * writer.start('node', { attr: 'value' });
     * writer.end('node');
     * console.log(writer.getContent());
     */
    const makeMap$1 = Tools.makeMap;
    const Writer = (settings) => {
        const html = [];
        settings = settings || {};
        const indent = settings.indent;
        const indentBefore = makeMap$1(settings.indent_before || '');
        const indentAfter = makeMap$1(settings.indent_after || '');
        const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);
        const htmlOutput = settings.element_format !== 'xhtml';
        return {
            /**
             * Writes a start element, such as `<p id="a">`.
             *
             * @method start
             * @param {String} name Name of the element.
             * @param {Array} attrs Optional array of objects containing an attribute name and value, or undefined if the element has no attributes.
             * @param {Boolean} empty Optional empty state if the tag should serialize as a void element. For example: `<img />`
             */
            start: (name, attrs, empty) => {
                if (indent && indentBefore[name] && html.length > 0) {
                    const value = html[html.length - 1];
                    if (value.length > 0 && value !== '\n') {
                        html.push('\n');
                    }
                }
                html.push('<', name);
                if (attrs) {
                    for (let i = 0, l = attrs.length; i < l; i++) {
                        const attr = attrs[i];
                        html.push(' ', attr.name, '="', encode(attr.value, true), '"');
                    }
                }
                if (!empty || htmlOutput) {
                    html[html.length] = '>';
                }
                else {
                    html[html.length] = ' />';
                }
                if (empty && indent && indentAfter[name] && html.length > 0) {
                    const value = html[html.length - 1];
                    if (value.length > 0 && value !== '\n') {
                        html.push('\n');
                    }
                }
            },
            /**
             * Writes an end element, such as `</p>`.
             *
             * @method end
             * @param {String} name Name of the element.
             */
            end: (name) => {
                let value;
                /* if (indent && indentBefore[name] && html.length > 0) {
                  value = html[html.length - 1];
          
                  if (value.length > 0 && value !== '\n')
                    html.push('\n');
                }*/
                html.push('</', name, '>');
                if (indent && indentAfter[name] && html.length > 0) {
                    value = html[html.length - 1];
                    if (value.length > 0 && value !== '\n') {
                        html.push('\n');
                    }
                }
            },
            /**
             * Writes a text node.
             *
             * @method text
             * @param {String} text String to write out.
             * @param {Boolean} raw Optional raw state. If true, the contents won't get encoded.
             */
            text: (text, raw) => {
                if (text.length > 0) {
                    html[html.length] = raw ? text : encode(text);
                }
            },
            /**
             * Writes a cdata node, such as `<![CDATA[data]]>`.
             *
             * @method cdata
             * @param {String} text String to write out inside the cdata.
             */
            cdata: (text) => {
                html.push('<![CDATA[', text, ']]>');
            },
            /**
             * Writes a comment node, such as `<!-- Comment -->`.
             *
             * @method comment
             * @param {String} text String to write out inside the comment.
             */
            comment: (text) => {
                html.push('<!--', text, '-->');
            },
            /**
             * Writes a processing instruction (PI) node, such as `<?xml attr="value" ?>`.
             *
             * @method pi
             * @param {String} name Name of the pi.
             * @param {String} text String to write out inside the pi.
             */
            pi: (name, text) => {
                if (text) {
                    html.push('<?', name, ' ', encode(text), '?>');
                }
                else {
                    html.push('<?', name, '?>');
                }
                if (indent) {
                    html.push('\n');
                }
            },
            /**
             * Writes a doctype node, such as `<!DOCTYPE data>`.
             *
             * @method doctype
             * @param {String} text String to write out inside the doctype.
             */
            doctype: (text) => {
                html.push('<!DOCTYPE', text, '>', indent ? '\n' : '');
            },
            /**
             * Resets the internal buffer. For example, if one wants to reuse the writer.
             *
             * @method reset
             */
            reset: () => {
                html.length = 0;
            },
            /**
             * Returns the contents that was serialized.
             *
             * @method getContent
             * @return {String} HTML contents that got written down.
             */
            getContent: () => {
                return html.join('').replace(/\n$/, '');
            }
        };
    };

    /**
     * This class is used to serialize down the DOM tree into a string using a Writer instance.
     *
     * @class tinymce.html.Serializer
     * @version 3.4
     * @example
     * tinymce.html.Serializer().serialize(tinymce.html.DomParser().parse('<p>text</p>'));
     */
    const HtmlSerializer = (settings = {}, schema = Schema()) => {
        const writer = Writer(settings);
        settings.validate = 'validate' in settings ? settings.validate : true;
        /**
         * Serializes the specified node into a string.
         *
         * @method serialize
         * @param {tinymce.html.Node} node Node instance to serialize.
         * @return {String} String with HTML based on the DOM tree.
         * @example
         * tinymce.html.Serializer().serialize(tinymce.html.DomParser().parse('<p>text</p>'));
         */
        const serialize = (node) => {
            const validate = settings.validate;
            const handlers = {
                // #text
                3: (node) => {
                    var _a;
                    writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);
                },
                // #comment
                8: (node) => {
                    var _a;
                    writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');
                },
                // Processing instruction
                7: (node) => {
                    writer.pi(node.name, node.value);
                },
                // Doctype
                10: (node) => {
                    var _a;
                    writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');
                },
                // CDATA
                4: (node) => {
                    var _a;
                    writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');
                },
                // Document fragment
                11: (node) => {
                    let tempNode = node;
                    if ((tempNode = tempNode.firstChild)) {
                        do {
                            walk(tempNode);
                        } while ((tempNode = tempNode.next));
                    }
                }
            };
            writer.reset();
            const walk = (node) => {
                var _a;
                const handler = handlers[node.type];
                if (!handler) {
                    const name = node.name;
                    const isEmpty = name in schema.getVoidElements();
                    let attrs = node.attributes;
                    // Sort attributes
                    if (validate && attrs && attrs.length > 1) {
                        const sortedAttrs = [];
                        sortedAttrs.map = {};
                        const elementRule = schema.getElementRule(node.name);
                        if (elementRule) {
                            for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
                                const attrName = elementRule.attributesOrder[i];
                                if (attrName in attrs.map) {
                                    const attrValue = attrs.map[attrName];
                                    sortedAttrs.map[attrName] = attrValue;
                                    sortedAttrs.push({ name: attrName, value: attrValue });
                                }
                            }
                            for (let i = 0, l = attrs.length; i < l; i++) {
                                const attrName = attrs[i].name;
                                if (!(attrName in sortedAttrs.map)) {
                                    const attrValue = attrs.map[attrName];
                                    sortedAttrs.map[attrName] = attrValue;
                                    sortedAttrs.push({ name: attrName, value: attrValue });
                                }
                            }
                            attrs = sortedAttrs;
                        }
                    }
                    writer.start(name, attrs, isEmpty);
                    if (isNonHtmlElementRootName(name)) {
                        if (isString(node.value)) {
                            writer.text(node.value, true);
                        }
                        writer.end(name);
                    }
                    else {
                        if (!isEmpty) {
                            let child = node.firstChild;
                            if (child) {
                                // Pre and textarea elements treat the first newline character as optional and will omit it. As such, if the content starts
                                // with a newline we need to add in an additional newline to prevent the current newline in the value being treated as optional
                                // See https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
                                if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\n') {
                                    writer.text('\n', true);
                                }
                                do {
                                    walk(child);
                                } while ((child = child.next));
                            }
                            writer.end(name);
                        }
                    }
                }
                else {
                    handler(node);
                }
            };
            // Serialize element or text nodes and treat all other nodes as fragments
            if (node.type === 1 && !settings.inner) {
                walk(node);
            }
            else if (node.type === 3) {
                handlers[3](node);
            }
            else {
                handlers[11](node);
            }
            return writer.getContent();
        };
        return {
            serialize
        };
    };

    const nonInheritableStyles = new Set();
    (() => {
        // TODO: TINY-7326 Figure out what else should go in the nonInheritableStyles list
        const nonInheritableStylesArr = [
            'margin', 'margin-left', 'margin-right', 'margin-top', 'margin-bottom',
            'padding', 'padding-left', 'padding-right', 'padding-top', 'padding-bottom',
            'border', 'border-width', 'border-style', 'border-color',
            'background', 'background-attachment', 'background-clip',
            'background-image', 'background-origin', 'background-position', 'background-repeat', 'background-size',
            'float', 'position', 'left', 'right', 'top', 'bottom',
            'z-index', 'display', 'transform',
            'width', 'max-width', 'min-width', 'height', 'max-height', 'min-height',
            'overflow', 'overflow-x', 'overflow-y', 'text-overflow', 'vertical-align',
            'transition', 'transition-delay', 'transition-duration', 'transition-property', 'transition-timing-function'
        ];
        each$e(nonInheritableStylesArr, (style) => {
            nonInheritableStyles.add(style);
        });
    })();
    const conditionalNonInheritableStyles = new Set();
    (() => {
        // These styles are only noninheritable when applied to an element with a noninheritable style
        // For example, background-color is visible on an element with padding, even when children have background-color;
        // however, when the element has no padding, background-color is either visible or overridden by children
        const conditionalNonInheritableStylesArr = [
            'background-color'
        ];
        each$e(conditionalNonInheritableStylesArr, (style) => {
            conditionalNonInheritableStyles.add(style);
        });
    })();
    // TODO: TINY-7326 Figure out what else should be added to the shorthandStyleProps list
    // Does not include non-inherited shorthand style properties
    const shorthandStyleProps = ['font', 'text-decoration', 'text-emphasis'];
    const getStyles$1 = (dom, node) => dom.parseStyle(dom.getAttrib(node, 'style'));
    const getStyleProps = (dom, node) => keys(getStyles$1(dom, node));
    const isNonInheritableStyle = (style) => nonInheritableStyles.has(style);
    const isConditionalNonInheritableStyle = (style) => conditionalNonInheritableStyles.has(style);
    const hasNonInheritableStyles = (dom, node) => exists(getStyleProps(dom, node), (style) => isNonInheritableStyle(style));
    const hasConditionalNonInheritableStyles = (dom, node) => hasNonInheritableStyles(dom, node) &&
        exists(getStyleProps(dom, node), (style) => isConditionalNonInheritableStyle(style));
    const getLonghandStyleProps = (styles) => filter$5(styles, (style) => exists(shorthandStyleProps, (prop) => startsWith(style, prop)));
    const hasStyleConflict = (dom, node, parentNode) => {
        const nodeStyleProps = getStyleProps(dom, node);
        const parentNodeStyleProps = getStyleProps(dom, parentNode);
        const valueMismatch = (prop) => {
            var _a, _b;
            const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';
            const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';
            return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;
        };
        return exists(nodeStyleProps, (nodeStyleProp) => {
            const propExists = (props) => exists(props, (prop) => prop === nodeStyleProp);
            // If parent has a longhand property e.g. margin-left but the child (node) style is margin, need to get the margin-left value of node to be able to do a proper comparison
            // This is because getting the style using the key of 'margin' on a 'margin-left' parent would give a string of space separated values or empty string depending on the browser
            if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {
                const longhandProps = getLonghandStyleProps(parentNodeStyleProps);
                return exists(longhandProps, valueMismatch);
            }
            else {
                return valueMismatch(nodeStyleProp);
            }
        });
    };

    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$b).exists((text) => {
        const delta = forward ? 0 : -1;
        return predicate(text.data.charAt(pos.offset() + delta));
    });
    const isBeforeSpace = curry(isChar, true, isWhiteSpace);
    const isAfterSpace = curry(isChar, false, isWhiteSpace);
    const isEmptyText = (pos) => {
        const container = pos.container();
        return isText$b(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));
    };
    const matchesElementPosition = (before, predicate) => (pos) => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();
    const isImageBlock = (node) => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';
    const isCefNode = (node) => isContentEditableFalse$a(node) && !isBogusAll(node);
    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);
    const isBeforeMedia = matchesElementPosition(true, isMedia$2);
    const isAfterMedia = matchesElementPosition(false, isMedia$2);
    const isBeforeTable = matchesElementPosition(true, isTable$2);
    const isAfterTable = matchesElementPosition(false, isTable$2);
    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);

    const dropLast = (xs) => xs.slice(0, -1);
    const parentsUntil = (start, root, predicate) => {
        if (contains(root, start)) {
            return dropLast(parents$1(start, (elm) => {
                return predicate(elm) || eq(elm, root);
            }));
        }
        else {
            return [];
        }
    };
    const parents = (start, root) => parentsUntil(start, root, never);
    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));

    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);
    const isBlock$2 = (schema) => (el) => schema.isBlock(name(el));
    const getClosestBlock$1 = (root, pos, schema) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2(schema));
    const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos)
        .forall((newPos) => getClosestBlock$1(root, pos, schema).fold(() => !isInSameBlock(newPos, pos, root.dom), (fromBlock) => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));
    const isAtBlockBoundary = (forward, root, pos, schema) => getClosestBlock$1(root, pos, schema).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall((newPos) => !isInSameBlock(newPos, pos, root.dom)), (parent) => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());
    const isAtStartOfBlock = curry(isAtBlockBoundary, false);
    const isAtEndOfBlock = curry(isAtBlockBoundary, true);
    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);

    const isBr$2 = (pos) => getElementFromPosition(pos).exists(isBr$6);
    const findBr = (forward, root, pos, schema) => {
        const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), (el) => schema.isBlock(name(el)));
        const scope = head(parentBlocks).getOr(root);
        return fromPosition(forward, scope.dom, pos).filter(isBr$2);
    };
    const isBeforeBr$1 = (root, pos, schema) => getElementFromPosition(pos).exists(isBr$6) || findBr(true, root, pos, schema).isSome();
    const isAfterBr = (root, pos, schema) => getElementFromPrevPosition(pos).exists(isBr$6) || findBr(false, root, pos, schema).isSome();
    const findPreviousBr = curry(findBr, false);
    const findNextBr = curry(findBr, true);

    const isInMiddleOfText = (pos) => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
    const getClosestBlock = (root, pos, schema) => {
        const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), (el) => schema.isBlock(name(el)));
        return head(parentBlocks).getOr(root);
    };
    const hasSpaceBefore = (root, pos, schema) => {
        if (isInMiddleOfText(pos)) {
            return isAfterSpace(pos);
        }
        else {
            return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isAfterSpace);
        }
    };
    const hasSpaceAfter = (root, pos, schema) => {
        if (isInMiddleOfText(pos)) {
            return isBeforeSpace(pos);
        }
        else {
            return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isBeforeSpace);
        }
    };
    const isPreValue = (value) => contains$2(['pre', 'pre-wrap'], value);
    const isInPre = (pos) => getElementFromPosition(pos)
        .bind((elm) => closest$4(elm, isElement$8))
        .exists((elm) => isPreValue(get$7(elm, 'white-space')));
    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();
    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();
    const isAtLineBoundary = (root, pos, schema) => (isAtBeginningOfBody(root, pos) ||
        isAtEndOfBody(root, pos) ||
        isAtStartOfBlock(root, pos, schema) ||
        isAtEndOfBlock(root, pos, schema) ||
        isAfterBr(root, pos, schema) ||
        isBeforeBr$1(root, pos, schema));
    const isCefBlock = (node) => isNonNullable(node) && isContentEditableFalse$a(node) && isBlockLike(node);
    // Check the next/previous element in case it is a cef and the next/previous caret position then would skip it, then check
    // the next next/previous caret position ( for example in case the next element is a strong, containing a cef ).
    const isSiblingCefBlock = (root, direction) => (container) => {
        return isCefBlock(new DomTreeWalker(container, root)[direction]());
    };
    const isBeforeCefBlock = (root, pos) => {
        const nextPos = nextPosition(root.dom, pos).getOr(pos);
        const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');
        return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));
    };
    const isAfterCefBlock = (root, pos) => {
        const prevPos = prevPosition(root.dom, pos).getOr(pos);
        const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');
        return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));
    };
    const needsToHaveNbsp = (root, pos, schema) => {
        if (isInPre(pos)) {
            return false;
        }
        else {
            return isAtLineBoundary(root, pos, schema) || hasSpaceBefore(root, pos, schema) || hasSpaceAfter(root, pos, schema);
        }
    };
    const needsToBeNbspLeft = (root, pos, schema) => {
        if (isInPre(pos)) {
            return false;
        }
        else {
            return isAtStartOfBlock(root, pos, schema) || isBeforeBlock(root, pos, schema) || isAfterBr(root, pos, schema) || hasSpaceBefore(root, pos, schema) || isAfterCefBlock(root, pos);
        }
    };
    const leanRight = (pos) => {
        const container = pos.container();
        const offset = pos.offset();
        if (isText$b(container) && offset < container.data.length) {
            return CaretPosition(container, offset + 1);
        }
        else {
            return pos;
        }
    };
    const needsToBeNbspRight = (root, pos, schema) => {
        if (isInPre(pos)) {
            return false;
        }
        else {
            return isAtEndOfBlock(root, pos, schema) || isAfterBlock(root, pos, schema) || isBeforeBr$1(root, pos, schema) || hasSpaceAfter(root, pos, schema) || isBeforeCefBlock(root, pos);
        }
    };
    const needsToBeNbsp = (root, pos, schema) => needsToBeNbspLeft(root, pos, schema) || needsToBeNbspRight(root, leanRight(pos), schema);
    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));
    const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));
    const hasNbsp = (pos) => {
        const container = pos.container();
        return isText$b(container) && contains$1(container.data, nbsp);
    };
    const normalizeNbspMiddle = (text) => {
        const chars = text.split('');
        return map$3(chars, (chr, i) => {
            if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {
                return ' ';
            }
            else {
                return chr;
            }
        }).join('');
    };
    const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {
        const text = node.data;
        const firstPos = CaretPosition(node, 0);
        if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos, schema)) {
            node.data = ' ' + text.slice(1);
            return true;
        }
        else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos, schema)) {
            node.data = nbsp + text.slice(1);
            return true;
        }
        else {
            return false;
        }
    };
    const normalizeNbspInMiddleOfTextNode = (node) => {
        const text = node.data;
        const newText = normalizeNbspMiddle(text);
        if (newText !== text) {
            node.data = newText;
            return true;
        }
        else {
            return false;
        }
    };
    const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {
        const text = node.data;
        const lastPos = CaretPosition(node, text.length - 1);
        if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos, schema)) {
            node.data = text.slice(0, -1) + ' ';
            return true;
        }
        else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos, schema)) {
            node.data = text.slice(0, -1) + nbsp;
            return true;
        }
        else {
            return false;
        }
    };
    const normalizeNbsps$1 = (root, pos, schema) => {
        const container = pos.container();
        if (!isText$b(container)) {
            return Optional.none();
        }
        if (hasNbsp(pos)) {
            const normalized = normalizeNbspAtStart(root, container, false, schema) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false, schema);
            return someIf(normalized, pos);
        }
        else if (needsToBeNbsp(root, pos, schema)) {
            const normalized = normalizeNbspAtStart(root, container, true, schema) || normalizeNbspAtEnd(root, container, true, schema);
            return someIf(normalized, pos);
        }
        else {
            return Optional.none();
        }
    };
    const normalizeNbspsInEditor = (editor) => {
        const root = SugarElement.fromDom(editor.getBody());
        if (editor.selection.isCollapsed()) {
            normalizeNbsps$1(root, CaretPosition.fromRangeStart(editor.selection.getRng()), editor.schema).each((pos) => {
                editor.selection.setRng(pos.toRange());
            });
        }
    };

    const normalize$1 = (node, offset, count, schema) => {
        if (count === 0) {
            return;
        }
        const elm = SugarElement.fromDom(node);
        const root = ancestor$5(elm, (el) => schema.isBlock(name(el))).getOr(elm);
        // Get the whitespace
        const whitespace = node.data.slice(offset, offset + count);
        // Determine if we're at the end or start of the content
        const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);
        const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);
        // Replace the original whitespace with the normalized whitespace content
        node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));
    };
    const normalizeWhitespaceAfter = (node, offset, schema) => {
        const content = node.data.slice(offset);
        const whitespaceCount = content.length - lTrim(content).length;
        normalize$1(node, offset, whitespaceCount, schema);
    };
    const normalizeWhitespaceBefore = (node, offset, schema) => {
        const content = node.data.slice(0, offset);
        const whitespaceCount = content.length - rTrim(content).length;
        normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);
    };
    const mergeTextNodes = (prevNode, nextNode, schema, normalizeWhitespace, mergeToPrev = true) => {
        const whitespaceOffset = rTrim(prevNode.data).length;
        const newNode = mergeToPrev ? prevNode : nextNode;
        const removeNode = mergeToPrev ? nextNode : prevNode;
        // Merge the elements
        if (mergeToPrev) {
            newNode.appendData(removeNode.data);
        }
        else {
            newNode.insertData(0, removeNode.data);
        }
        remove$8(SugarElement.fromDom(removeNode));
        // Normalize the whitespace around the merged elements, to ensure it doesn't get lost
        if (normalizeWhitespace) {
            normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);
        }
        return newNode;
    };

    const needsReposition = (pos, elm) => {
        const container = pos.container();
        const offset = pos.offset();
        return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();
    };
    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;
    const beforeOrStartOf = (node) => isText$b(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
    const afterOrEndOf = (node) => isText$b(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);
    const getPreviousSiblingCaretPosition = (elm) => {
        if (isCaretCandidate$3(elm.previousSibling)) {
            return Optional.some(afterOrEndOf(elm.previousSibling));
        }
        else {
            return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();
        }
    };
    const getNextSiblingCaretPosition = (elm) => {
        if (isCaretCandidate$3(elm.nextSibling)) {
            return Optional.some(beforeOrStartOf(elm.nextSibling));
        }
        else {
            return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();
        }
    };
    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {
        return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode)
            .bind((node) => prevPosition(rootElement, CaretPosition.before(node)))
            .orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));
    };
    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));
    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm))
        .orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));
    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm)
        .orThunk(() => getPreviousSiblingCaretPosition(elm))
        .orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));
    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));
    const setSelection$1 = (editor, forward, pos) => {
        pos.fold(() => {
            editor.focus();
        }, (pos) => {
            editor.selection.setRng(pos.toRange(), forward);
        });
    };
    const eqRawNode = (rawNode) => (elm) => elm.dom === rawNode;
    const isBlock$1 = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));
    const paddEmptyBlock = (schema, elm, preserveEmptyCaret) => {
        if (isEmpty$4(schema, elm)) {
            const br = SugarElement.fromHtml('<br data-mce-bogus="1">');
            // Remove all bogus elements except caret
            if (preserveEmptyCaret) {
                each$e(children$1(elm), (node) => {
                    if (!isEmptyCaretFormatElement(node)) {
                        remove$8(node);
                    }
                });
            }
            else {
                empty(elm);
            }
            append$1(elm, br);
            return Optional.some(CaretPosition.before(br.dom));
        }
        else {
            return Optional.none();
        }
    };
    const deleteNormalized = (elm, afterDeletePosOpt, schema, normalizeWhitespace) => {
        const prevTextOpt = prevSibling(elm).filter(isText$c);
        const nextTextOpt = nextSibling(elm).filter(isText$c);
        // Delete the element
        remove$8(elm);
        // Merge and normalize any prev/next text nodes, so that they are merged and don't lose meaningful whitespace
        // eg. <p>a <span></span> b</p> -> <p>a &nsbp;b</p> or <p><span></span> a</p> -> <p>&nbsp;a</a>
        return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {
            const prevNode = prev.dom, nextNode = next.dom;
            const offset = prevNode.data.length;
            mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);
            // Update the cursor position if required
            return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;
        }).orThunk(() => {
            if (normalizeWhitespace) {
                prevTextOpt.each((elm) => normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema));
                nextTextOpt.each((elm) => normalizeWhitespaceAfter(elm.dom, 0, schema));
            }
            return afterDeletePosOpt;
        });
    };
    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));
    const deleteElement$2 = (editor, forward, elm, moveCaret = true, preserveEmptyCaret = false) => {
        // Existing delete logic
        const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);
        const parentBlock = ancestor$5(elm, curry(isBlock$1, editor), eqRawNode(editor.getBody()));
        const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, editor.schema, isInlineElement(editor, elm));
        if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent('');
            editor.selection.setCursorLocation();
        }
        else {
            parentBlock.bind((elm) => paddEmptyBlock(editor.schema, elm, preserveEmptyCaret)).fold(() => {
                if (moveCaret) {
                    setSelection$1(editor, forward, normalizedAfterDeletePos);
                }
            }, (paddPos) => {
                if (moveCaret) {
                    setSelection$1(editor, forward, Optional.some(paddPos));
                }
            });
        }
    };

    const strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
    const hasStrongRtl = (text) => strongRtl.test(text);

    const isInlineTarget = (editor, elm) => is$2(SugarElement.fromDom(elm), getInlineBoundarySelector(editor))
        && !isTransparentBlock(editor.schema, elm)
        && editor.dom.isEditable(elm);
    const isRtl = (element) => { var _a; return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : ''); };
    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);
    const findRootInline = (isInlineTarget, rootNode, pos) => {
        const parents = findInlineParents(isInlineTarget, rootNode, pos);
        return Optional.from(parents[parents.length - 1]);
    };
    const hasSameParentBlock = (rootNode, node1, node2) => {
        const block1 = getParentBlock$3(node1, rootNode);
        const block2 = getParentBlock$3(node2, rootNode);
        return isNonNullable(block1) && block1 === block2;
    };
    const isAtZwsp = (pos) => isBeforeInline(pos) || isAfterInline(pos);
    const normalizePosition = (forward, pos) => {
        const container = pos.container(), offset = pos.offset();
        if (forward) {
            if (isCaretContainerInline(container)) {
                if (isText$b(container.nextSibling)) {
                    return CaretPosition(container.nextSibling, 0);
                }
                else {
                    return CaretPosition.after(container);
                }
            }
            else {
                return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;
            }
        }
        else {
            if (isCaretContainerInline(container)) {
                if (isText$b(container.previousSibling)) {
                    return CaretPosition(container.previousSibling, container.previousSibling.data.length);
                }
                else {
                    return CaretPosition.before(container);
                }
            }
            else {
                return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;
            }
        }
    };
    const normalizeForwards = curry(normalizePosition, true);
    const normalizeBackwards = curry(normalizePosition, false);

    const execCommandIgnoreInputEvents = (editor, command) => {
        // We need to prevent the input events from being fired by execCommand when delete is used internally
        const inputBlocker = (e) => e.stopImmediatePropagation();
        editor.on('beforeinput input', inputBlocker, true);
        editor.getDoc().execCommand(command);
        editor.off('beforeinput input', inputBlocker);
    };
    // ASSUMPTION: The editor command 'delete' doesn't have any `beforeinput` and `input` trapping
    // because those events are only triggered by native contenteditable behaviour.
    const execEditorDeleteCommand = (editor) => {
        editor.execCommand('delete');
    };
    const execNativeDeleteCommand = (editor) => execCommandIgnoreInputEvents(editor, 'Delete');
    const execNativeForwardDeleteCommand = (editor) => execCommandIgnoreInputEvents(editor, 'ForwardDelete');
    const isBeforeRoot = (rootNode) => (elm) => is$4(parent(elm), rootNode, eq);
    const isTextBlockOrListItem = (element) => isTextBlock$3(element) || isListItem$2(element);
    const getParentBlock$2 = (rootNode, elm) => {
        if (contains(rootNode, elm)) {
            return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));
        }
        else {
            return Optional.none();
        }
    };
    const paddEmptyBody = (editor, moveSelection = true) => {
        if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent('', { no_selection: !moveSelection });
        }
    };
    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
        const normalizedFirstPos = normalizePosition(true, firstPos);
        const normalizedLastPos = normalizePosition(false, lastPos);
        const normalizedFromPos = normalizePosition(false, fromPos);
        if (forward) {
            return nextPosition(elm, normalizedFromPos).exists((nextPos) => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));
        }
        else {
            return prevPosition(elm, normalizedFromPos).exists((prevPos) => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));
        }
    }).getOr(true);
    const freefallRtl = (root) => {
        const child = isComment$1(root) ? prevSibling(root) : lastChild(root);
        return child.bind(freefallRtl).orThunk(() => Optional.some(root));
    };
    const deleteRangeContents = (editor, rng, root, moveSelection = true) => {
        var _a;
        rng.deleteContents();
        // Pad the last block node
        const lastNode = freefallRtl(root).getOr(root);
        const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);
        // If the block is the editor body then we need to insert the root block as well
        if (lastBlock.dom === editor.getBody()) {
            paddEmptyBody(editor, moveSelection);
        }
        else if (isEmpty$4(editor.schema, lastBlock, { checkRootAsContent: false })) {
            fillWithPaddingBr(lastBlock);
            if (moveSelection) {
                editor.selection.setCursorLocation(lastBlock.dom, 0);
            }
        }
        // Clean up any additional leftover nodes. If the last block wasn't a direct child, then we also need to clean up siblings
        if (!eq(root, lastBlock)) {
            const additionalCleanupNodes = is$4(parent(lastBlock), root) ? [] : siblings(lastBlock);
            each$e(additionalCleanupNodes.concat(children$1(root)), (node) => {
                if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$4(editor.schema, node)) {
                    remove$8(node);
                }
            });
        }
    };

    const isRootFromElement = (root) => (cur) => eq(root, cur);
    const getTableCells = (table) => descendants(table, 'td,th');
    const getTable$1 = (node, isRoot) => getClosestTable(SugarElement.fromDom(node), isRoot);
    const selectionInTableWithNestedTable = (details) => {
        return lift2(details.startTable, details.endTable, (startTable, endTable) => {
            const isStartTableParentOfEndTable = descendant(startTable, (t) => eq(t, endTable));
            const isEndTableParentOfStartTable = descendant(endTable, (t) => eq(t, startTable));
            return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable ? details : {
                ...details,
                startTable: isStartTableParentOfEndTable ? Optional.none() : details.startTable,
                endTable: isEndTableParentOfStartTable ? Optional.none() : details.endTable,
                isSameTable: false,
                isMultiTable: false
            };
        }).getOr(details);
    };
    const adjustQuirksInDetails = (details) => {
        return selectionInTableWithNestedTable(details);
    };
    const getTableDetailsFromRange = (rng, isRoot) => {
        const startTable = getTable$1(rng.startContainer, isRoot);
        const endTable = getTable$1(rng.endContainer, isRoot);
        const isStartInTable = startTable.isSome();
        const isEndInTable = endTable.isSome();
        // Partial selection - selection is not within the same table
        const isSameTable = lift2(startTable, endTable, eq).getOr(false);
        const isMultiTable = !isSameTable && isStartInTable && isEndInTable;
        return adjustQuirksInDetails({
            startTable,
            endTable,
            isStartInTable,
            isEndInTable,
            isSameTable,
            isMultiTable
        });
    };

    const tableCellRng = (start, end) => ({
        start,
        end,
    });
    const tableSelection = (rng, table, cells) => ({
        rng,
        table,
        cells
    });
    const deleteAction = Adt.generate([
        { singleCellTable: ['rng', 'cell'] },
        { fullTable: ['table'] },
        { partialTable: ['cells', 'outsideDetails'] },
        { multiTable: ['startTableCells', 'endTableCells', 'betweenRng'] },
    ]);
    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);
    const isExpandedCellRng = (cellRng) => !eq(cellRng.start, cellRng.end);
    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot)
        .bind((startParentTable) => getClosestTable(cellRng.end, isRoot)
        .bind((endParentTable) => someIf(eq(startParentTable, endParentTable), startParentTable)));
    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) &&
        getTableFromCellRng(cellRng, isRoot).exists((table) => {
            const rows = table.dom.rows;
            return rows.length === 1 && rows[0].cells.length === 1;
        });
    const getCellRng = (rng, isRoot) => {
        const startCell = getClosestCell$1(rng.startContainer, isRoot);
        const endCell = getClosestCell$1(rng.endContainer, isRoot);
        return lift2(startCell, endCell, tableCellRng);
    };
    const getCellRangeFromStartTable = (isRoot) => (startCell) => getClosestTable(startCell, isRoot).bind((table) => last$2(getTableCells(table)).map((endCell) => tableCellRng(startCell, endCell)));
    const getCellRangeFromEndTable = (isRoot) => (endCell) => getClosestTable(endCell, isRoot).bind((table) => head(getTableCells(table)).map((startCell) => tableCellRng(startCell, endCell)));
    const getTableSelectionFromCellRng = (isRoot) => (cellRng) => getTableFromCellRng(cellRng, isRoot).map((table) => tableSelection(cellRng, table, getTableCells(table)));
    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {
        if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {
            return Optional.none();
        }
        else if (selectionDetails.isSameTable) {
            const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));
            return Optional.some({
                start: sameTableSelection,
                end: sameTableSelection
            });
        }
        else {
            // Covers partial table selection (either start or end will have a tableSelection) and multitable selection (both start and end will have a tableSelection)
            const startCell = getClosestCell$1(rng.startContainer, isRoot);
            const endCell = getClosestCell$1(rng.endContainer, isRoot);
            const startTableSelection = startCell
                .bind(getCellRangeFromStartTable(isRoot))
                .bind(getTableSelectionFromCellRng(isRoot));
            const endTableSelection = endCell
                .bind(getCellRangeFromEndTable(isRoot))
                .bind(getTableSelectionFromCellRng(isRoot));
            return Optional.some({
                start: startTableSelection,
                end: endTableSelection
            });
        }
    };
    const getCellIndex = (cells, cell) => findIndex$2(cells, (x) => eq(x, cell));
    const getSelectedCells = (tableSelection) => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));
    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists((cellRng) => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));
    const unselectCells = (rng, selectionDetails) => {
        const { startTable, endTable } = selectionDetails;
        const otherContentRng = rng.cloneRange();
        // If the table is some, it should be unselected (works for single table and multitable cases)
        startTable.each((table) => otherContentRng.setStartAfter(table.dom));
        endTable.each((table) => otherContentRng.setEndBefore(table.dom));
        return otherContentRng;
    };
    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot)
        .bind(({ start, end }) => start.or(end))
        .bind((tableSelection) => {
        const { isSameTable } = selectionDetails;
        const selectedCells = getSelectedCells(tableSelection).getOr([]);
        if (isSameTable && tableSelection.cells.length === selectedCells.length) {
            return Optional.some(deleteAction.fullTable(tableSelection.table));
        }
        else if (selectedCells.length > 0) {
            if (isSameTable) {
                return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));
            }
            else {
                const otherContentRng = unselectCells(rng, selectionDetails);
                return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({
                    ...selectionDetails,
                    rng: otherContentRng
                })));
            }
        }
        else {
            return Optional.none();
        }
    });
    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot)
        .bind(({ start, end }) => {
        const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);
        const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);
        if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {
            const otherContentRng = unselectCells(rng, selectionDetails);
            return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));
        }
        else {
            return Optional.none();
        }
    });
    const getActionFromRange = (root, rng) => {
        const isRoot = isRootFromElement(root);
        const optCellRng = getCellRng(rng, isRoot);
        const selectionDetails = getTableDetailsFromRange(rng, isRoot);
        if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {
            // SingleCellTable
            return optCellRng.map((cellRng) => deleteAction.singleCellTable(rng, cellRng.start));
        }
        else if (selectionDetails.isMultiTable) {
            // MultiTable
            return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);
        }
        else {
            // FullTable, PartialTable with no rng or PartialTable with outside rng
            return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);
        }
    };

    // Reset the contenteditable state and fill the content with a padding br
    const cleanCells = (cells) => each$e(cells, (cell) => {
        remove$9(cell, 'contenteditable');
        fillWithPaddingBr(cell);
    });
    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);
    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {
        emptyBlock.each((block) => {
            if (startInTable) {
                // Note that we don't need to set the selection as it'll be within the table
                remove$8(block);
            }
            else {
                // Set the cursor location as it'll move when filling with padding
                fillWithPaddingBr(block);
                editor.selection.setCursorLocation(block.dom, 0);
            }
        });
    };
    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {
        const insideTableRng = rng.cloneRange();
        if (isFirstCellInSelection) {
            insideTableRng.setStart(rng.startContainer, rng.startOffset);
            insideTableRng.setEndAfter(cell.dom.lastChild);
        }
        else {
            insideTableRng.setStartBefore(cell.dom.firstChild);
            insideTableRng.setEnd(rng.endContainer, rng.endOffset);
        }
        deleteCellContents(editor, insideTableRng, cell, false).each((action) => action());
    };
    const collapseAndRestoreCellSelection = (editor) => {
        const selectedCells = getCellsFromEditor(editor);
        const selectedNode = SugarElement.fromDom(editor.selection.getNode());
        if (isTableCell$3(selectedNode.dom) && isEmpty$4(editor.schema, selectedNode)) {
            editor.selection.setCursorLocation(selectedNode.dom, 0);
        }
        else {
            editor.selection.collapse(true);
        }
        // Restore the data-mce-selected attribute if multiple cells were selected, as if it was a cef element
        // then selection overrides would remove it as it was using an offscreen selection clone.
        if (selectedCells.length > 1 && exists(selectedCells, (cell) => eq(cell, selectedNode))) {
            set$4(selectedNode, 'data-mce-selected', '1');
        }
    };
    /*
     * Runs when
     * - the start and end of the selection is contained within the same table (called directly from deleteRange)
     * - part of a table and content outside is selected
     */
    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {
        const editorRng = editor.selection.getRng();
        const cellsToClean = outsideDetails.bind(({ rng, isStartInTable }) => {
            /*
             * Delete all content outside of the table that is in the selection
             * - Get the outside block before deleting the contents
             * - Delete the contents outside
             * - Handle the block outside the table if it is empty since rng.deleteContents leaves it
             */
            const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);
            rng.deleteContents();
            handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(curry(isEmpty$4, editor.schema)));
            /*
             * The only time we can have only part of the cell contents selected is when part of the selection
             * is outside the table (otherwise we use the Darwin fake selection, which always selects entire cells),
             * in which case we need to delete the contents inside and check if the entire contents of the cell have been deleted.
             *
             * Note: The endPointCell is the only cell which may have only part of its contents selected.
             */
            const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];
            deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);
            if (!isEmpty$4(editor.schema, endPointCell)) {
                return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));
            }
            else {
                return Optional.none();
            }
        }).getOr(cells);
        // Remove content from cells we need to clean
        cleanCells(cellsToClean);
        // Collapse the original selection after deleting everything
        collapseAndRestoreCellSelection(editor);
    });
    /*
     * Runs when the start of the selection is in a table and the end of the selection is in another table
     */
    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {
        const rng = editor.selection.getRng();
        const startCell = startTableCells[0];
        const endCell = endTableCells[endTableCells.length - 1];
        deleteContentInsideCell(editor, startCell, rng, true);
        deleteContentInsideCell(editor, endCell, rng, false);
        // Only clean empty cells, the first and last cells have the potential to still have content
        const startTableCellsToClean = isEmpty$4(editor.schema, startCell) ? startTableCells : startTableCells.slice(1);
        const endTableCellsToClean = isEmpty$4(editor.schema, endCell) ? endTableCells : endTableCells.slice(0, -1);
        cleanCells(startTableCellsToClean.concat(endTableCellsToClean));
        // Delete all content in between the start table and end table
        betweenRng.deleteContents();
        // This will collapse the selection into the cell of the start table
        collapseAndRestoreCellSelection(editor);
    });
    // Delete the contents of a range inside a cell. Runs on tables that are a single cell or partial selections that need to be cleaned up.
    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {
        deleteRangeContents(editor, rng, cell, moveSelection);
    });
    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));
    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng)
        .bind((action) => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));
    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);
    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), (caption) => deleteCaptionRange(editor, caption));
    const deleteRange$4 = (editor, startElm, selectedCells) => {
        const rootNode = SugarElement.fromDom(editor.getBody());
        const rng = editor.selection.getRng();
        return selectedCells.length !== 0 ?
            emptySingleTableCells(editor, selectedCells, Optional.none()) :
            deleteTableRange(editor, rootNode, rng, startElm);
    };
    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);
    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));
    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => 
    // TODO: TINY-8865 - This may not be safe to cast as Node below and alternative solutions need to be looked into
    navigate(forward, editor.getBody(), from)
        .bind((to) => getParentCell(rootElm, SugarElement.fromDom(to.getNode()))
        .bind((toCell) => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));
    const emptyElement = (editor, elm) => Optional.some(() => {
        fillWithPaddingBr(elm);
        editor.selection.setCursorLocation(elm.dom, 0);
    });
    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind((first) => lastPositionIn(fromCaption.dom).map((last) => forward ?
        from.isEqual(first) && to.isEqual(last) :
        from.isEqual(last) && to.isEqual(first))).getOr(true);
    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);
    const validateCaretCaption = (rootElm, fromCaption, to) => 
    // TODO: TINY-8865 - This may not be safe to cast as Node below and alternative solutions need to be looked into
    getParentCaption(rootElm, SugarElement.fromDom(to.getNode()))
        .fold(() => Optional.some(noop), (toCaption) => someIf(!eq(toCaption, fromCaption), noop));
    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), (to) => isDeleteOfLastCharPos(fromCaption, forward, from, to) ?
        emptyCaretCaption(editor, fromCaption) :
        validateCaretCaption(rootElm, fromCaption, to));
    const deleteCaretCells = (editor, forward, rootElm, startElm) => {
        const from = CaretPosition.fromRangeStart(editor.selection.getRng());
        return getParentCell(rootElm, startElm).bind((fromCell) => isEmpty$4(editor.schema, fromCell, { checkRootAsContent: false }) ?
            emptyElement(editor, fromCell) :
            deleteBetweenCells(editor, rootElm, forward, fromCell, from));
    };
    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {
        const from = CaretPosition.fromRangeStart(editor.selection.getRng());
        return isEmpty$4(editor.schema, fromCaption) ?
            emptyElement(editor, fromCaption) :
            deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);
    };
    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);
    const isBeforeOrAfterTable = (editor, forward) => {
        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
        return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos)
            .exists((pos) => isNearTable(forward, pos));
    };
    const deleteCaret$3 = (editor, forward, startElm) => {
        const rootElm = SugarElement.fromDom(editor.getBody());
        return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm)
            .orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), (fromCaption) => deleteCaretCaption(editor, forward, rootElm, fromCaption));
    };
    const backspaceDelete$d = (editor, forward) => {
        const startElm = SugarElement.fromDom(editor.selection.getStart(true));
        const cells = getCellsFromEditor(editor);
        return editor.selection.isCollapsed() && cells.length === 0 ?
            deleteCaret$3(editor, forward, startElm) :
            deleteRange$4(editor, startElm, cells);
    };

    const getContentEditableRoot$1 = (root, node) => {
        let tempNode = node;
        while (tempNode && tempNode !== root) {
            if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$a(tempNode)) {
                return tempNode;
            }
            tempNode = tempNode.parentNode;
        }
        return null;
    };

    const internalAttributesPrefixes = [
        'data-ephox-',
        'data-mce-',
        'data-alloy-',
        'data-snooker-',
        '_'
    ];
    /**
     * Utility class for various element specific functions.
     *
     * @private
     * @class tinymce.dom.ElementUtils
     */
    const each$9 = Tools.each;
    const ElementUtils = (editor) => {
        const dom = editor.dom;
        const internalAttributes = new Set(editor.serializer.getTempAttrs());
        /**
         * Compares two nodes and checks if it's attributes and styles matches.
         * This doesn't compare classes as items since their order is significant.
         *
         * @method compare
         * @param {Node} node1 First node to compare with.
         * @param {Node} node2 Second node to compare with.
         * @return {Boolean} True/false if the nodes are the same or not.
         */
        const compare = (node1, node2) => {
            // Not the same name or type
            if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {
                return false;
            }
            /**
             * Returns all the nodes attributes excluding internal ones, styles and classes.
             *
             * @private
             * @param {Node} node Node to get attributes from.
             * @return {Object} Name/value object with attributes and attribute values.
             */
            const getAttribs = (node) => {
                const attribs = {};
                each$9(dom.getAttribs(node), (attr) => {
                    const name = attr.nodeName.toLowerCase();
                    // Don't compare internal attributes or style
                    if (name !== 'style' && !isAttributeInternal(name)) {
                        attribs[name] = dom.getAttrib(node, name);
                    }
                });
                return attribs;
            };
            /**
             * Compares two objects checks if it's key + value exists in the other one.
             *
             * @private
             * @param {Object} obj1 First object to compare.
             * @param {Object} obj2 Second object to compare.
             * @return {Boolean} True/false if the objects matches or not.
             */
            const compareObjects = (obj1, obj2) => {
                for (const name in obj1) {
                    // Obj1 has item obj2 doesn't have
                    if (has$2(obj1, name)) {
                        const value = obj2[name];
                        // Obj2 doesn't have obj1 item
                        if (isUndefined(value)) {
                            return false;
                        }
                        // Obj2 item has a different value
                        if (obj1[name] !== value) {
                            return false;
                        }
                        // Delete similar value
                        delete obj2[name];
                    }
                }
                // Check if obj 2 has something obj 1 doesn't have
                for (const name in obj2) {
                    // Obj2 has item obj1 doesn't have
                    if (has$2(obj2, name)) {
                        return false;
                    }
                }
                return true;
            };
            if (isElement$7(node1) && isElement$7(node2)) {
                // Attribs are not the same
                if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
                    return false;
                }
                // Styles are not the same
                if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {
                    return false;
                }
            }
            return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
        };
        const isAttributeInternal = (attributeName) => exists(internalAttributesPrefixes, (value) => startsWith(attributeName, value)) || internalAttributes.has(attributeName);
        return {
            compare,
            isAttributeInternal
        };
    };

    const getNormalizedPoint$1 = (container, offset) => {
        if (isText$b(container)) {
            return { container, offset };
        }
        const node = RangeUtils.getNode(container, offset);
        if (isText$b(node)) {
            return {
                container: node,
                offset: offset >= container.childNodes.length ? node.data.length : 0
            };
        }
        else if (node.previousSibling && isText$b(node.previousSibling)) {
            return {
                container: node.previousSibling,
                offset: node.previousSibling.data.length
            };
        }
        else if (node.nextSibling && isText$b(node.nextSibling)) {
            return {
                container: node.nextSibling,
                offset: 0
            };
        }
        return { container, offset };
    };
    const normalizeRange$1 = (rng) => {
        const outRng = rng.cloneRange();
        const rangeStart = getNormalizedPoint$1(rng.startContainer, rng.startOffset);
        outRng.setStart(rangeStart.container, rangeStart.offset);
        const rangeEnd = getNormalizedPoint$1(rng.endContainer, rng.endOffset);
        outRng.setEnd(rangeEnd.container, rangeEnd.offset);
        return outRng;
    };

    // TODO: This is a clone of the list bookmark code if we move lists to core then de-duplicate this #TINY-12172
    const DOM$c = DOMUtils.DOM;
    /**
     * Returns a range bookmark. This will convert indexed bookmarks into temporary span elements with
     * index 0 so that they can be restored properly after the DOM has been modified. Text bookmarks will not have spans
     * added to them since they can be restored after a dom operation.
     *
     * So this: <p><b>|</b><b>|</b></p>
     * becomes: <p><b><span data-mce-type="bookmark">|</span></b><b data-mce-type="bookmark">|</span></b></p>
     */
    const createBookmark$1 = (rng) => {
        const bookmark = {};
        const setupEndPoint = (start) => {
            let container = rng[start ? 'startContainer' : 'endContainer'];
            let offset = rng[start ? 'startOffset' : 'endOffset'];
            if (isElement$7(container)) {
                const offsetNode = DOM$c.create('span', { 'data-mce-type': 'bookmark' });
                if (container.hasChildNodes()) {
                    if (offset === container.childNodes.length) {
                        container.appendChild(offsetNode);
                    }
                    else {
                        container.insertBefore(offsetNode, container.childNodes[offset]);
                    }
                }
                else {
                    container.appendChild(offsetNode);
                }
                container = offsetNode;
                offset = 0;
            }
            bookmark[start ? 'startContainer' : 'endContainer'] = container;
            bookmark[start ? 'startOffset' : 'endOffset'] = offset;
        };
        setupEndPoint(true);
        if (!rng.collapsed) {
            setupEndPoint();
        }
        return bookmark;
    };
    const resolveBookmark$2 = (bookmark) => {
        const restoreEndPoint = (start) => {
            const nodeIndex = (container) => {
                var _a;
                let node = (_a = container.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild;
                let idx = 0;
                while (node) {
                    if (node === container) {
                        return idx;
                    }
                    // Skip data-mce-type=bookmark nodes
                    if (!isElement$7(node) || node.getAttribute('data-mce-type') !== 'bookmark') {
                        idx++;
                    }
                    node = node.nextSibling;
                }
                return -1;
            };
            let container = bookmark[start ? 'startContainer' : 'endContainer'];
            let offset = bookmark[start ? 'startOffset' : 'endOffset'];
            if (!container) {
                return;
            }
            if (isElement$7(container) && container.parentNode) {
                const node = container;
                offset = nodeIndex(container);
                container = container.parentNode;
                DOM$c.remove(node);
                if (!container.hasChildNodes() && DOM$c.isBlock(container)) {
                    container.appendChild(DOM$c.create('br'));
                }
            }
            bookmark[start ? 'startContainer' : 'endContainer'] = container;
            bookmark[start ? 'startOffset' : 'endOffset'] = offset;
        };
        restoreEndPoint(true);
        restoreEndPoint();
        const rng = DOM$c.createRng();
        rng.setStart(bookmark.startContainer, bookmark.startOffset);
        if (bookmark.endContainer) {
            rng.setEnd(bookmark.endContainer, bookmark.endOffset);
        }
        return normalizeRange$1(rng);
    };

    const applyStyles = (dom, elm, format, vars) => {
        Tools.each(format.styles, (value, name) => {
            dom.setStyle(elm, name, replaceVars(value, vars));
        });
        // Needed for the WebKit span spam bug
        // TODO: Remove this once WebKit/Blink fixes this
        if (format.styles) {
            const styleVal = dom.getAttrib(elm, 'style');
            if (styleVal) {
                dom.setAttrib(elm, 'data-mce-style', styleVal);
            }
        }
    };
    const setElementFormat = (ed, elm, fmt, vars, node) => {
        const dom = ed.dom;
        if (isFunction(fmt.onformat)) {
            fmt.onformat(elm, fmt, vars, node);
        }
        applyStyles(dom, elm, fmt, vars);
        Tools.each(fmt.attributes, (value, name) => {
            dom.setAttrib(elm, name, replaceVars(value, vars));
        });
        Tools.each(fmt.classes, (value) => {
            const newValue = replaceVars(value, vars);
            if (!dom.hasClass(elm, newValue)) {
                dom.addClass(elm, newValue);
            }
        });
    };

    const isApplyFormat = (format) => !isArray$1(format.attributes) && !isArray$1(format.styles);

    const isEq$3 = isEq$5;
    const matchesUnInheritedFormatSelector = (ed, node, name) => {
        const formatList = ed.formatter.get(name);
        if (formatList) {
            for (let i = 0; i < formatList.length; i++) {
                const format = formatList[i];
                if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {
                    return true;
                }
            }
        }
        return false;
    };
    const matchParents = (editor, node, name, vars, similar) => {
        const root = editor.dom.getRoot();
        if (node === root) {
            return false;
        }
        // Find first node with similar format settings
        const matchedNode = editor.dom.getParent(node, (elm) => {
            if (matchesUnInheritedFormatSelector(editor, elm, name)) {
                return true;
            }
            return elm.parentNode === root || !!matchNode$1(editor, elm, name, vars, true);
        });
        // Do an exact check on the similar format element
        return !!matchNode$1(editor, matchedNode, name, vars, similar);
    };
    const matchName = (dom, node, format) => {
        // Check for inline match
        if (isInlineFormat(format) && isEq$3(node, format.inline)) {
            return true;
        }
        // Check for block match
        if (isBlockFormat(format) && isEq$3(node, format.block)) {
            return true;
        }
        // Check for selector match
        if (isSelectorFormat(format)) {
            return isElement$7(node) && dom.is(node, format.selector);
        }
        return false;
    };
    const matchItems = (dom, node, format, itemName, similar, vars) => {
        const items = format[itemName];
        const matchAttributes = itemName === 'attributes';
        // Custom match
        if (isFunction(format.onmatch)) {
            // onmatch is generic in a way that we can't really express without casting
            return format.onmatch(node, format, itemName);
        }
        // Check all items
        if (items) {
            // Non indexed object
            if (!isArrayLike(items)) {
                for (const key in items) {
                    if (has$2(items, key)) {
                        const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);
                        const expectedValue = replaceVars(items[key], vars);
                        const isEmptyValue = isNullable(value) || isEmpty$5(value);
                        if (isEmptyValue && isNullable(expectedValue)) {
                            continue;
                        }
                        if (similar && isEmptyValue && !format.exact) {
                            return false;
                        }
                        if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {
                            return false;
                        }
                    }
                }
            }
            else {
                // Only one match needed for indexed arrays
                for (let i = 0; i < items.length; i++) {
                    if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {
                        return true;
                    }
                }
            }
        }
        return true;
    };
    const matchNode$1 = (ed, node, name, vars, similar) => {
        const formatList = ed.formatter.get(name);
        const dom = ed.dom;
        if (formatList && isElement$7(node)) {
            // Check each format in list
            for (let i = 0; i < formatList.length; i++) {
                const format = formatList[i];
                // Name name, attributes, styles and classes
                if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {
                    // Match classes
                    const classes = format.classes;
                    if (classes) {
                        for (let x = 0; x < classes.length; x++) {
                            if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {
                                return;
                            }
                        }
                    }
                    return format;
                }
            }
        }
        return undefined;
    };
    const match$2 = (editor, name, vars, node, similar) => {
        // Check specified node
        if (node) {
            return matchParents(editor, node, name, vars, similar);
        }
        // Check selected node
        node = editor.selection.getNode();
        if (matchParents(editor, node, name, vars, similar)) {
            return true;
        }
        // Check start node if it's different
        const startNode = editor.selection.getStart();
        if (startNode !== node) {
            if (matchParents(editor, startNode, name, vars, similar)) {
                return true;
            }
        }
        return false;
    };
    const matchAll = (editor, names, vars) => {
        const matchedFormatNames = [];
        const checkedMap = {};
        // Check start of selection for formats
        const startElement = editor.selection.getStart();
        editor.dom.getParent(startElement, (node) => {
            for (let i = 0; i < names.length; i++) {
                const name = names[i];
                if (!checkedMap[name] && matchNode$1(editor, node, name, vars)) {
                    checkedMap[name] = true;
                    matchedFormatNames.push(name);
                }
            }
        }, editor.dom.getRoot());
        return matchedFormatNames;
    };
    const closest = (editor, names) => {
        const isRoot = (elm) => eq(elm, SugarElement.fromDom(editor.getBody()));
        const match = (elm, name) => matchNode$1(editor, elm.dom, name) ? Optional.some(name) : Optional.none();
        return Optional.from(editor.selection.getStart(true)).bind((rawElm) => closest$1(SugarElement.fromDom(rawElm), (elm) => findMap(names, (name) => match(elm, name)), isRoot)).getOrNull();
    };
    const canApply = (editor, name) => {
        const formatList = editor.formatter.get(name);
        const dom = editor.dom;
        if (formatList && editor.selection.isEditable()) {
            const startNode = editor.selection.getStart();
            const parents = getParents$2(dom, startNode);
            for (let x = formatList.length - 1; x >= 0; x--) {
                const format = formatList[x];
                // Format is not selector based then always return TRUE
                if (!isSelectorFormat(format)) {
                    return true;
                }
                for (let i = parents.length - 1; i >= 0; i--) {
                    if (dom.is(parents[i], format.selector)) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    /**
     *  Get all of the format names present on the specified node
     */
    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {
        const matchSimilar = isVariableFormatName(editor, name);
        if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {
            return acc.concat([name]);
        }
        else {
            return acc;
        }
    }, []);

    const ZWSP = ZWSP$1;
    const importNode = (ownerDocument, node) => {
        return ownerDocument.importNode(node, true);
    };
    const findFirstTextNode = (node) => {
        if (node) {
            const walker = new DomTreeWalker(node, node);
            for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {
                if (isText$b(tempNode)) {
                    return tempNode;
                }
            }
        }
        return null;
    };
    const createCaretContainer = (fill) => {
        const caretContainer = SugarElement.fromTag('span');
        setAll$1(caretContainer, {
            // style: 'color:red',
            'id': CARET_ID,
            'data-mce-bogus': '1',
            'data-mce-type': 'format-caret'
        });
        if (fill) {
            append$1(caretContainer, SugarElement.fromText(ZWSP));
        }
        return caretContainer;
    };
    const trimZwspFromCaretContainer = (caretContainerNode) => {
        const textNode = findFirstTextNode(caretContainerNode);
        if (textNode && textNode.data.charAt(0) === ZWSP) {
            textNode.deleteData(0, 1);
        }
        return textNode;
    };
    const removeCaretContainerNode = (editor, node, moveCaret) => {
        const dom = editor.dom, selection = editor.selection;
        if (isCaretContainerEmpty(node)) {
            deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret, true);
        }
        else {
            const rng = selection.getRng();
            const block = dom.getParent(node, dom.isBlock);
            // Store the current selection offsets
            const startContainer = rng.startContainer;
            const startOffset = rng.startOffset;
            const endContainer = rng.endContainer;
            const endOffset = rng.endOffset;
            const textNode = trimZwspFromCaretContainer(node);
            dom.remove(node, true);
            // Restore the selection after unwrapping the node and removing the zwsp
            if (startContainer === textNode && startOffset > 0) {
                rng.setStart(textNode, startOffset - 1);
            }
            if (endContainer === textNode && endOffset > 0) {
                rng.setEnd(textNode, endOffset - 1);
            }
            if (block && dom.isEmpty(block)) {
                fillWithPaddingBr(SugarElement.fromDom(block));
            }
            selection.setRng(rng);
        }
    };
    // Removes the caret container for the specified node or all on the current document
    const removeCaretContainer = (editor, node, moveCaret) => {
        const dom = editor.dom, selection = editor.selection;
        if (!node) {
            node = getParentCaretContainer(editor.getBody(), selection.getStart());
            if (!node) {
                while ((node = dom.get(CARET_ID))) {
                    removeCaretContainerNode(editor, node, moveCaret);
                }
            }
        }
        else {
            removeCaretContainerNode(editor, node, moveCaret);
        }
    };
    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {
        var _a, _b;
        const dom = editor.dom;
        const block = dom.getParent(formatNode, curry(isTextBlock$2, editor.schema));
        if (block && dom.isEmpty(block)) {
            // Replace formatNode with caretContainer when removing format from empty block like <p><b>|</b></p>
            (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);
        }
        else {
            removeTrailingBr(SugarElement.fromDom(formatNode));
            if (dom.isEmpty(formatNode)) {
                (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);
            }
            else {
                dom.insertAfter(caretContainer, formatNode);
            }
        }
    };
    const appendNode = (parentNode, node) => {
        parentNode.appendChild(node);
        return node;
    };
    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {
        var _a;
        const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {
            return appendNode(parentNode, formatNode.cloneNode(false));
        }, caretContainer);
        const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;
        return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));
    };
    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {
        const formatter = editor.formatter;
        const dom = editor.dom;
        // Find all formats present on the format node
        const validFormats = filter$5(keys(formatter.get()), (formatName) => formatName !== name && !contains$1(formatName, 'removeformat'));
        const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);
        // Filter out any matched formats that are 'visually' equivalent to the 'name' format since they are not unique formats on the node
        const uniqueFormats = filter$5(matchedFormats, (fmtName) => !areSimilarFormats(editor, fmtName, name));
        // If more than one format is present, then there's additional formats that should be retained. So clone the node,
        // remove the format and then return cleaned format node
        if (uniqueFormats.length > 0) {
            const clonedFormatNode = formatNode.cloneNode(false);
            dom.add(caretContainer, clonedFormatNode);
            formatter.remove(name, vars, clonedFormatNode, similar);
            dom.remove(clonedFormatNode);
            return Optional.some(clonedFormatNode);
        }
        else {
            return Optional.none();
        }
    };
    const normalizeNbsps = (node) => set$1(node, get$4(node).replace(new RegExp(`${nbsp}$`), ' '));
    const normalizeNbspsBetween = (editor, caretContainer) => {
        const handler = () => {
            if (caretContainer !== null && !editor.dom.isEmpty(caretContainer)) {
                prevSibling(SugarElement.fromDom(caretContainer)).each((node) => {
                    if (isText$c(node)) {
                        normalizeNbsps(node);
                    }
                    else {
                        descendant$2(node, (e) => isText$c(e)).each((textNode) => {
                            if (isText$c(textNode)) {
                                normalizeNbsps(textNode);
                            }
                        });
                    }
                });
            }
        };
        editor.once('input', (e) => {
            if (e.data && !isWhiteSpace(e.data)) {
                if (!e.isComposing) {
                    handler();
                }
                else {
                    editor.once('compositionend', () => {
                        handler();
                    });
                }
            }
        });
    };
    const applyCaretFormat = (editor, name, vars) => {
        let caretContainer;
        const selection = editor.selection;
        const formatList = editor.formatter.get(name);
        if (!formatList) {
            return;
        }
        const selectionRng = selection.getRng();
        let offset = selectionRng.startOffset;
        const container = selectionRng.startContainer;
        const text = container.nodeValue;
        caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
        // Expand to word if caret is in the middle of a text node and the char before/after is a alpha numeric character
        const wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
        if (text && offset > 0 && offset < text.length &&
            wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {
            // Get bookmark of caret position
            const bookmark = selection.getBookmark();
            // Collapse bookmark range (WebKit)
            selectionRng.collapse(true);
            // Expand the range to the closest word and split it at those points
            let rng = expandRng(editor.dom, selectionRng, formatList);
            rng = split(rng);
            // Apply the format to the range
            editor.formatter.apply(name, vars, rng);
            // Move selection back to caret position
            selection.moveToBookmark(bookmark);
        }
        else {
            let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;
            if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {
                // Need to import the node into the document on IE or we get a lovely WrongDocument exception
                caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);
                textNode = caretContainer.firstChild;
                selectionRng.insertNode(caretContainer);
                offset = 1;
                normalizeNbspsBetween(editor, caretContainer);
                editor.formatter.apply(name, vars, caretContainer);
            }
            else {
                editor.formatter.apply(name, vars, caretContainer);
            }
            // Move selection to text node
            selection.setCursorLocation(textNode, offset);
        }
    };
    const removeCaretFormat = (editor, name, vars, similar) => {
        const dom = editor.dom;
        const selection = editor.selection;
        let hasContentAfter = false;
        const formatList = editor.formatter.get(name);
        if (!formatList) {
            return;
        }
        const rng = selection.getRng();
        const container = rng.startContainer;
        const offset = rng.startOffset;
        let node = container;
        if (isText$b(container)) {
            if (offset !== container.data.length) {
                hasContentAfter = true;
            }
            node = node.parentNode;
        }
        const parents = [];
        let formatNode;
        while (node) {
            if (matchNode$1(editor, node, name, vars, similar)) {
                formatNode = node;
                break;
            }
            if (node.nextSibling) {
                hasContentAfter = true;
            }
            parents.push(node);
            node = node.parentNode;
        }
        // Node doesn't have the specified format
        if (!formatNode) {
            return;
        }
        // Is there contents after the caret then remove the format on the element
        if (hasContentAfter) {
            const bookmark = selection.getBookmark();
            // Collapse bookmark range (WebKit)
            rng.collapse(true);
            // Expand the range to the closest word and split it at those points
            let expandedRng = expandRng(dom, rng, formatList, { includeTrailingSpace: true });
            expandedRng = split(expandedRng);
            // TODO: Figure out how on earth this works, as it shouldn't since remove format
            //  definitely seems to require an actual Range
            editor.formatter.remove(name, vars, expandedRng, similar);
            selection.moveToBookmark(bookmark);
        }
        else {
            const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
            const parentsAfter = isNonNullable(caretContainer) ? dom.getParents(formatNode.parentNode, always, caretContainer) : [];
            const newCaretContainer = createCaretContainer(false).dom;
            insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);
            const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);
            const caretTextNode = insertFormatNodesIntoCaretContainer([
                ...parents,
                ...cleanedFormatNode.toArray(),
                ...parentsAfter
            ], newCaretContainer);
            if (caretContainer) {
                removeCaretContainerNode(editor, caretContainer, isNonNullable(caretContainer));
            }
            selection.setCursorLocation(caretTextNode, 1);
            normalizeNbspsBetween(editor, newCaretContainer);
            if (dom.isEmpty(formatNode)) {
                dom.remove(formatNode);
            }
        }
    };
    const disableCaretContainer = (editor, keyCode, moveCaret) => {
        const selection = editor.selection, body = editor.getBody();
        removeCaretContainer(editor, null, moveCaret);
        // Remove caret container if it's empty
        if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {
            removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);
        }
        // Remove caret container on keydown and it's left/right arrow keys
        if (keyCode === 37 || keyCode === 39) {
            removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);
        }
    };
    const endsWithNbsp = (element) => isText$b(element) && endsWith(element.data, nbsp);
    const setup$B = (editor) => {
        editor.on('mouseup keydown', (e) => {
            disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));
        });
    };
    const createCaretFormat = (formatNodes) => {
        const caretContainer = createCaretContainer(false);
        const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);
        return { caretContainer, caretPosition: CaretPosition(innerMost, 0) };
    };
    const replaceWithCaretFormat = (targetNode, formatNodes) => {
        const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
        before$4(SugarElement.fromDom(targetNode), caretContainer);
        remove$8(SugarElement.fromDom(targetNode));
        return caretPosition;
    };
    const createCaretFormatAtStart$1 = (rng, formatNodes) => {
        const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
        rng.insertNode(caretContainer.dom);
        return caretPosition;
    };
    const isFormatElement = (editor, element) => {
        if (isCaretNode(element.dom)) {
            return false;
        }
        const inlineElements = editor.schema.getTextInlineElements();
        return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$1(element.dom);
    };

    const listItemStyles = ['fontWeight', 'fontStyle', 'color', 'fontSize', 'fontFamily'];
    const hasListStyles = (fmt) => isObject(fmt.styles) && exists(keys(fmt.styles), (name) => contains$2(listItemStyles, name));
    const findExpandedListItemFormat = (formats) => find$2(formats, (fmt) => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));
    const getExpandedListItemFormat = (formatter, format) => {
        const formatList = formatter.get(format);
        return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();
    };
    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();
    const isRngEndAtEndOfElement = (rng, elm) => {
        return nextPosition(elm, CaretPosition.fromRangeEnd(rng))
            .exists((pos) => !isBr$7(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;
    };
    const isEditableListItem = (dom) => (elm) => isListItem$3(elm) && dom.isEditable(elm);
    const getFullySelectedBlocks = (selection) => {
        const blocks = selection.getSelectedBlocks();
        const rng = selection.getRng();
        if (selection.isCollapsed()) {
            return [];
        }
        if (blocks.length === 1) {
            return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];
        }
        else {
            const first = head(blocks).filter((elm) => isRngStartAtStartOfElement(rng, elm)).toArray();
            const last = last$2(blocks).filter((elm) => isRngEndAtEndOfElement(rng, elm)).toArray();
            const middle = blocks.slice(1, -1);
            return first.concat(middle).concat(last);
        }
    };
    const getFullySelectedListItems = (selection) => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));
    const getPartiallySelectedListItems = (selection) => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));

    const each$8 = Tools.each;
    const isElementNode = (node) => isElement$7(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$1(node);
    const findElementSibling = (node, siblingName) => {
        for (let sibling = node; sibling; sibling = sibling[siblingName]) {
            if (isText$b(sibling) && isNotEmpty(sibling.data)) {
                return node;
            }
            if (isElement$7(sibling) && !isBookmarkNode$1(sibling)) {
                return sibling;
            }
        }
        return node;
    };
    const mergeSiblingsNodes = (editor, prev, next) => {
        const elementUtils = ElementUtils(editor);
        const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);
        const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);
        // Check if next/prev exists and that they are elements
        if (isPrevEditable && isNextEditable) {
            // If previous sibling is empty then jump over it
            const prevSibling = findElementSibling(prev, 'previousSibling');
            const nextSibling = findElementSibling(next, 'nextSibling');
            // Compare next and previous nodes
            if (elementUtils.compare(prevSibling, nextSibling)) {
                // Append nodes between
                for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {
                    const tmpSibling = sibling;
                    sibling = sibling.nextSibling;
                    prevSibling.appendChild(tmpSibling);
                }
                editor.dom.remove(nextSibling);
                Tools.each(Tools.grep(nextSibling.childNodes), (node) => {
                    prevSibling.appendChild(node);
                });
                return prevSibling;
            }
        }
        return next;
    };
    const mergeSiblings = (editor, format, vars, node) => {
        var _a;
        // Merge next and previous siblings if they are similar <b>text</b><b>text</b> becomes <b>texttext</b>
        // Note: mergeSiblingNodes attempts to not merge sibilings if they are noneditable
        if (node && format.merge_siblings !== false) {
            // Previous sibling
            const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;
            // Next sibling
            mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));
        }
    };
    const clearChildStyles = (dom, format, node) => {
        if (format.clear_child_styles) {
            const selector = format.links ? '*:not(a)' : '*';
            each$8(dom.select(selector, node), (childNode) => {
                if (isElementNode(childNode) && dom.isEditable(childNode)) {
                    each$8(format.styles, (_value, name) => {
                        dom.setStyle(childNode, name, '');
                    });
                }
            });
        }
    };
    const processChildElements = (node, filter, process) => {
        each$8(node.childNodes, (node) => {
            if (isElementNode(node)) {
                if (filter(node)) {
                    process(node);
                }
                if (node.hasChildNodes()) {
                    processChildElements(node, filter, process);
                }
            }
        });
    };
    const unwrapEmptySpan = (dom, node) => {
        if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {
            dom.remove(node, true);
        }
    };
    const hasStyle = (dom, name) => (node) => !!(node && getStyle(dom, node, name));
    const applyStyle = (dom, name, value) => (node) => {
        dom.setStyle(node, name, value);
        if (node.getAttribute('style') === '') {
            node.removeAttribute('style');
        }
        unwrapEmptySpan(dom, node);
    };

    const removeResult = Adt.generate([
        { keep: [] },
        { rename: ['name'] },
        { removed: [] }
    ]);
    const MCE_ATTR_RE = /^(src|href|style)$/;
    const each$7 = Tools.each;
    const isEq$2 = isEq$5;
    const isTableCellOrRow = (node) => /^(TR|TH|TD)$/.test(node.nodeName);
    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);
    const getContainer = (ed, rng, start) => {
        let container = rng[start ? 'startContainer' : 'endContainer'];
        let offset = rng[start ? 'startOffset' : 'endOffset'];
        if (isElement$7(container)) {
            const lastIdx = container.childNodes.length - 1;
            if (!start && offset) {
                offset--;
            }
            container = container.childNodes[offset > lastIdx ? lastIdx : offset];
        }
        // If start text node is excluded then walk to the next node
        if (isText$b(container) && start && offset >= container.data.length) {
            container = new DomTreeWalker(container, ed.getBody()).next() || container;
        }
        // If end text node is excluded then walk to the previous node
        if (isText$b(container) && !start && offset === 0) {
            container = new DomTreeWalker(container, ed.getBody()).prev() || container;
        }
        return container;
    };
    const normalizeTableSelection = (node, start) => {
        const prop = start ? 'firstChild' : 'lastChild';
        const childNode = node[prop];
        if (isTableCellOrRow(node) && childNode) {
            if (node.nodeName === 'TR') {
                return childNode[prop] || childNode;
            }
            else {
                return childNode;
            }
        }
        return node;
    };
    const wrap$1 = (dom, node, name, attrs) => {
        var _a;
        const wrapper = dom.create(name, attrs);
        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);
        wrapper.appendChild(node);
        return wrapper;
    };
    const wrapWithSiblings = (dom, node, next, name, attrs) => {
        const start = SugarElement.fromDom(node);
        const wrapper = SugarElement.fromDom(dom.create(name, attrs));
        const siblings = next ? nextSiblings(start) : prevSiblings(start);
        append(wrapper, siblings);
        if (next) {
            before$4(start, wrapper);
            prepend(wrapper, start);
        }
        else {
            after$4(start, wrapper);
            append$1(wrapper, start);
        }
        return wrapper.dom;
    };
    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';
    /**
     * Removes the node and wrap it's children in paragraphs before doing so or
     * appends BR elements to the beginning/end of the block element if forcedRootBlocks is disabled.
     *
     * If the div in the node below gets removed:
     *  text<div>text</div>text
     *
     * Output becomes:
     *  text<div><br />text<br /></div>text
     *
     * So when the div is removed the result is:
     *  text<br />text<br />text
     *
     * @private
     * @param {Node} node Node to remove + apply BR/P elements to.
     * @param {Object} format Format rule.
     * @return {Node} Input node.
     */
    const removeNode = (ed, node, format) => {
        const parentNode = node.parentNode;
        let rootBlockElm;
        const dom = ed.dom;
        const forcedRootBlock = getForcedRootBlock(ed);
        if (isBlockFormat(format)) {
            // Wrap the block in a forcedRootBlock if we are at the root of document
            if (parentNode === dom.getRoot()) {
                if (!format.list_block || !isEq$2(node, format.list_block)) {
                    each$e(from(node.childNodes), (node) => {
                        if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {
                            if (!rootBlockElm) {
                                rootBlockElm = wrap$1(dom, node, forcedRootBlock);
                                dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));
                            }
                            else {
                                rootBlockElm.appendChild(node);
                            }
                        }
                        else {
                            rootBlockElm = null;
                        }
                    });
                }
            }
        }
        // Never remove nodes that aren't the specified inline element if a selector is specified too
        if (isMixedFormat(format) && !isEq$2(format.inline, node)) {
            return;
        }
        dom.remove(node, true);
    };
    // Attributes or styles can be either an array of names or an object containing name/value pairs
    const processFormatAttrOrStyle = (name, value, vars) => {
        // Indexed array
        if (isNumber(name)) {
            return {
                name: value,
                value: null
            };
        }
        else {
            return {
                name,
                value: replaceVars(value, vars)
            };
        }
    };
    const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {
        if (dom.getAttrib(elm, 'style') === '') {
            elm.removeAttribute('style');
            elm.removeAttribute('data-mce-style');
        }
    };
    const removeStyles$1 = (dom, elm, format, vars, compareNode) => {
        let stylesModified = false;
        each$7(format.styles, (value, name) => {
            const { name: styleName, value: styleValue } = processFormatAttrOrStyle(name, value, vars);
            const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);
            if (format.remove_similar || isNull(styleValue) || !isElement$7(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {
                dom.setStyle(elm, styleName, '');
            }
            stylesModified = true;
        });
        if (stylesModified) {
            removeEmptyStyleAttributeIfNeeded(dom, elm);
        }
    };
    const removeListStyleFormats = (editor, name, vars) => {
        if (name === 'removeformat') {
            each$e(getPartiallySelectedListItems(editor.selection), (li) => {
                each$e(listItemStyles, (name) => editor.dom.setStyle(li, name, ''));
                removeEmptyStyleAttributeIfNeeded(editor.dom, li);
            });
        }
        else {
            getExpandedListItemFormat(editor.formatter, name).each((liFmt) => {
                each$e(getPartiallySelectedListItems(editor.selection), (li) => removeStyles$1(editor.dom, li, liFmt, vars, null));
            });
        }
    };
    const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {
        const dom = ed.dom;
        const elementUtils = ElementUtils(ed);
        const schema = ed.schema;
        // Root level block transparents should get converted into regular text blocks
        if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {
            removeNode(ed, node, format);
            return removeResult.removed();
        }
        // Check if node is noneditable and can have the format removed from it
        if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {
            return removeResult.keep();
        }
        // Check if node matches format
        if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {
            return removeResult.keep();
        }
        // "matchName" will made sure we're dealing with an element, so cast as one
        const elm = node;
        // Applies to styling elements like strong, em, i, u, etc. so that if they have styling attributes, the attributes can be kept but the styling element is removed
        const preserveAttributes = format.preserve_attributes;
        if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {
            // Remove all attributes except for the attributes specified in preserve_attributes
            const attrsToPreserve = filter$5(dom.getAttribs(elm), (attr) => contains$2(preserveAttributes, attr.name.toLowerCase()));
            dom.removeAllAttribs(elm);
            each$e(attrsToPreserve, (attr) => dom.setAttrib(elm, attr.name, attr.value));
            // Note: If there are no attributes left, the element will be removed as normal at the end of the function
            if (attrsToPreserve.length > 0) {
                // Convert inline element to span if necessary
                return removeResult.rename('span');
            }
        }
        // Should we compare with format attribs and styles
        if (format.remove !== 'all') {
            removeStyles$1(dom, elm, format, vars, compareNode);
            // Remove attributes
            each$7(format.attributes, (value, name) => {
                const { name: attrName, value: attrValue } = processFormatAttrOrStyle(name, value, vars);
                if (format.remove_similar || isNull(attrValue) || !isElement$7(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {
                    // Keep internal classes
                    if (attrName === 'class') {
                        const currentValue = dom.getAttrib(elm, attrName);
                        if (currentValue) {
                            // Build new class value where everything is removed except the internal prefixed classes
                            let valueOut = '';
                            each$e(currentValue.split(/\s+/), (cls) => {
                                if (/mce\-\w+/.test(cls)) {
                                    valueOut += (valueOut ? ' ' : '') + cls;
                                }
                            });
                            // We got some internal classes left
                            if (valueOut) {
                                dom.setAttrib(elm, attrName, valueOut);
                                return;
                            }
                        }
                    }
                    // Remove mce prefixed attributes (must clean before short circuit operations)
                    if (MCE_ATTR_RE.test(attrName)) {
                        elm.removeAttribute('data-mce-' + attrName);
                    }
                    // keep style="list-style-type: none" on <li>s
                    if (attrName === 'style' && matchNodeNames$1(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {
                        elm.removeAttribute(attrName);
                        dom.setStyle(elm, 'list-style-type', 'none');
                        return;
                    }
                    // IE6 has a bug where the attribute doesn't get removed correctly
                    if (attrName === 'class') {
                        elm.removeAttribute('className');
                    }
                    elm.removeAttribute(attrName);
                }
            });
            // Remove classes
            each$7(format.classes, (value) => {
                value = replaceVars(value, vars);
                if (!isElement$7(compareNode) || dom.hasClass(compareNode, value)) {
                    dom.removeClass(elm, value);
                }
            });
            // Check for non internal attributes
            const attrs = dom.getAttribs(elm);
            for (let i = 0; i < attrs.length; i++) {
                const attrName = attrs[i].nodeName;
                if (!elementUtils.isAttributeInternal(attrName)) {
                    return removeResult.keep();
                }
            }
        }
        // Remove the inline child if it's empty for example <b> or <span>
        if (format.remove !== 'none') {
            removeNode(ed, elm, format);
            return removeResult.removed();
        }
        return removeResult.keep();
    };
    const findFormatRoot = (editor, container, name, vars, similar) => {
        let formatRoot;
        if (container.parentNode) {
            // Find format root
            each$e(getParents$2(editor.dom, container.parentNode).reverse(), (parent) => {
                // Find format root element
                if (!formatRoot && isElement$7(parent) && parent.id !== '_start' && parent.id !== '_end') {
                    // Is the node matching the format we are looking for
                    const format = matchNode$1(editor, parent, name, vars, similar);
                    if (format && format.split !== false) {
                        formatRoot = parent;
                    }
                }
            });
        }
        return formatRoot;
    };
    const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), (newName) => {
        // To rename a node, it needs to be a child of another node
        const fragment = editor.dom.createFragment();
        fragment.appendChild(clone);
        // If renaming we are guaranteed this is a Element, so cast
        return editor.dom.rename(clone, newName);
    }, constant(null));
    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {
        var _a, _b;
        let lastClone;
        let firstClone;
        const dom = editor.dom;
        // Format root found then clone formats and split it
        if (formatRoot) {
            const formatRootParent = formatRoot.parentNode;
            for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {
                let clone = dom.clone(parent, false);
                for (let i = 0; i < formatList.length; i++) {
                    clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);
                    if (clone === null) {
                        break;
                    }
                }
                // Build wrapper node
                if (clone) {
                    if (lastClone) {
                        clone.appendChild(lastClone);
                    }
                    if (!firstClone) {
                        firstClone = clone;
                    }
                    lastClone = clone;
                }
            }
            // Never split block elements if the format is mixed
            if (split && (!format.mixed || !dom.isBlock(formatRoot))) {
                container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;
            }
            // Wrap container in cloned formats
            if (lastClone && firstClone) {
                (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);
                firstClone.appendChild(target);
                // After splitting the nodes may match with other siblings so we need to attempt to merge them
                // Note: We can't use MergeFormats, as that'd create a circular dependency
                if (isInlineFormat(format)) {
                    mergeSiblings(editor, format, vars, lastClone);
                }
            }
        }
        return container;
    };
    const removeFormatInternal = (ed, name, vars, node, similar) => {
        const formatList = ed.formatter.get(name);
        const format = formatList[0];
        const dom = ed.dom;
        const selection = ed.selection;
        const splitToFormatRoot = (container) => {
            const formatRoot = findFormatRoot(ed, container, name, vars, similar);
            return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
        };
        // Make sure to only check for bookmarks created here (eg _start or _end)
        // as there maybe nested bookmarks
        const isRemoveBookmarkNode = (node) => isBookmarkNode$1(node) && isElement$7(node) && (node.id === '_start' || node.id === '_end');
        const removeFormatOnNode = (node) => exists(formatList, (fmt) => removeNodeFormat(ed, fmt, vars, node, node));
        // Merges the styles for each node
        const process = (node) => {
            // Grab the children first since the nodelist might be changed
            const children = from(node.childNodes);
            // Process current node
            const removed = removeFormatOnNode(node);
            // TINY-6567/TINY-7393: Include the parent if using an expanded selector format and no match was found for the current node
            const currentNodeMatches = removed || exists(formatList, (f) => matchName(dom, node, f));
            const parentNode = node.parentNode;
            if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
                removeFormatOnNode(parentNode);
            }
            // Process the children
            if (format.deep) {
                if (children.length) {
                    for (let i = 0; i < children.length; i++) {
                        process(children[i]);
                    }
                }
            }
            // Note: Assists with cleaning up any stray text decorations that may been applied when text decorations
            // and text colors were merged together from an applied format
            // Remove child span if it only contains text-decoration and a parent node also has the same text decoration.
            const textDecorations = ['underline', 'line-through', 'overline'];
            each$e(textDecorations, (decoration) => {
                if (isElement$7(node) && ed.dom.getStyle(node, 'text-decoration') === decoration &&
                    node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {
                    removeNodeFormat(ed, {
                        deep: false,
                        exact: true,
                        inline: 'span',
                        styles: {
                            textDecoration: decoration
                        }
                    }, undefined, node);
                }
            });
        };
        const unwrap = (start) => {
            const node = dom.get(start ? '_start' : '_end');
            if (node) {
                let out = node[start ? 'firstChild' : 'lastChild'];
                // If the end is placed within the start the result will be removed
                // So this checks if the out node is a bookmark node if it is it
                // checks for another more suitable node
                if (isRemoveBookmarkNode(out)) {
                    out = out[start ? 'firstChild' : 'lastChild'];
                }
                // Since dom.remove removes empty text nodes then we need to try to find a better node
                if (isText$b(out) && out.data.length === 0) {
                    out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
                }
                dom.remove(node, true);
                return out;
            }
            else {
                return null;
            }
        };
        const removeRngStyle = (rng) => {
            let startContainer;
            let endContainer;
            let expandedRng = expandRng(dom, rng, formatList, { includeTrailingSpace: rng.collapsed });
            if (format.split) {
                // Split text nodes
                expandedRng = split(expandedRng);
                startContainer = getContainer(ed, expandedRng, true);
                endContainer = getContainer(ed, expandedRng);
                if (startContainer !== endContainer) {
                    // WebKit will render the table incorrectly if we wrap a TH or TD in a SPAN
                    // so let's see if we can use the first/last child instead
                    // This will happen if you triple click a table cell and use remove formatting
                    startContainer = normalizeTableSelection(startContainer, true);
                    endContainer = normalizeTableSelection(endContainer, false);
                    // Wrap and split if nested
                    if (isChildOfInlineParent(dom, startContainer, endContainer)) {
                        const marker = Optional.from(startContainer.firstChild).getOr(startContainer);
                        splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', { 'id': '_start', 'data-mce-type': 'bookmark' }));
                        unwrap(true);
                        return;
                    }
                    // Wrap and split if nested
                    if (isChildOfInlineParent(dom, endContainer, startContainer)) {
                        const marker = Optional.from(endContainer.lastChild).getOr(endContainer);
                        splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', { 'id': '_end', 'data-mce-type': 'bookmark' }));
                        unwrap(false);
                        return;
                    }
                    // Wrap start/end nodes in span element since these might be cloned/moved
                    startContainer = wrap$1(dom, startContainer, 'span', { 'id': '_start', 'data-mce-type': 'bookmark' });
                    endContainer = wrap$1(dom, endContainer, 'span', { 'id': '_end', 'data-mce-type': 'bookmark' });
                    // Split start/end and anything in between
                    const newRng = dom.createRng();
                    newRng.setStartAfter(startContainer);
                    newRng.setEndBefore(endContainer);
                    walk$3(dom, newRng, (nodes) => {
                        each$e(nodes, (n) => {
                            if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {
                                splitToFormatRoot(n);
                            }
                        });
                    });
                    splitToFormatRoot(startContainer);
                    splitToFormatRoot(endContainer);
                    // Unwrap start/end to get real elements again
                    // Note that the return value should always be a node since it's wrapped above
                    startContainer = unwrap(true);
                    endContainer = unwrap();
                }
                else {
                    startContainer = endContainer = splitToFormatRoot(startContainer);
                }
                // Update range positions since they might have changed after the split operations
                expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
                expandedRng.startOffset = dom.nodeIndex(startContainer);
                expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
                expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;
            }
            // Remove items between start/end
            walk$3(dom, expandedRng, (nodes) => {
                each$e(nodes, process);
            });
        };
        // Handle node
        if (node) {
            if (isNode(node)) {
                const rng = dom.createRng();
                rng.setStartBefore(node);
                rng.setEndAfter(node);
                removeRngStyle(rng);
            }
            else {
                removeRngStyle(node);
            }
            fireFormatRemove(ed, name, node, vars);
            return;
        }
        if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
            // Remove formatting on the selection
            preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), 
            // Before trying to move the start of the selection, check if start element still has formatting then we are at: "<b>text|</b>text"
            // and need to move the start into the next text node
            (startNode) => isInlineFormat(format) && match$2(ed, name, vars, startNode));
            ed.nodeChanged();
        }
        else {
            removeCaretFormat(ed, name, vars, similar);
        }
        removeListStyleFormats(ed, name, vars);
        fireFormatRemove(ed, name, node, vars);
    };
    const removeFormat$1 = (ed, name, vars, node, similar) => {
        if (node || ed.selection.isEditable()) {
            removeFormatInternal(ed, name, vars, node, similar);
        }
    };
    const removeFormatOnElement = (editor, format, vars, node) => {
        return removeNodeFormatInternal(editor, format, vars, node).fold(() => Optional.some(node), (newName) => Optional.some(editor.dom.rename(node, newName)), Optional.none);
    };
    /**
     * Removes the specified format for the specified node. It will also remove the node if it doesn't have
     * any attributes if the format specifies it to do so.
     *
     * @private
     * @param {Object} format Format object with items to remove from node.
     * @param {Object} vars Name/value object with variables to apply to format.
     * @param {Node} node Node to remove the format styles on.
     * @param {Node} compareNode Optional compare node, if specified the styles will be compared to that node.
     * @return {Boolean} True/false if the node was removed or not.
     */
    const removeNodeFormat = (editor, format, vars, node, compareNode) => {
        return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, (newName) => {
            // If renaming we are guaranteed this is a Element, so cast
            editor.dom.rename(node, newName);
            return true;
        }, always);
    };

    const fontSizeAlteringFormats = ['fontsize', 'subscript', 'superscript'];
    const formatsToActOn = ['strikethrough', ...fontSizeAlteringFormats];
    const hasFormat = (formatter, el, format) => isNonNullable(formatter.matchNode(el.dom, format, {}, format === 'fontsize'));
    const isFontSizeAlteringElement = (formatter, el) => exists(fontSizeAlteringFormats, (format) => hasFormat(formatter, el, format));
    const isNormalizingFormat = (format) => contains$2(formatsToActOn, format);
    const gatherWrapperData = (isRoot, scope, hasFormat, createFormatElement, removeFormatFromElement) => {
        const parents = parents$1(scope, isRoot).filter(isElement$8);
        return findLastIndex(parents, hasFormat).map((index) => {
            const container = parents[index];
            const innerWrapper = createFormatElement(container);
            const outerWrappers = [
                ...removeFormatFromElement(shallow(container)).toArray(),
                ...bind$3(parents.slice(0, index), (wrapper) => {
                    if (hasFormat(wrapper)) {
                        return removeFormatFromElement(wrapper).toArray();
                    }
                    else {
                        return [shallow(wrapper)];
                    }
                })
            ];
            return { container, innerWrapper, outerWrappers };
        });
    };
    const wrapChildrenInInnerWrapper = (target, wrapper, hasFormat, removeFormatFromElement) => {
        each$e(children$1(target), (child) => {
            if (isElement$8(child) && hasFormat(child)) {
                if (removeFormatFromElement(child).isNone()) {
                    unwrap(child);
                }
            }
        });
        each$e(children$1(target), (child) => append$1(wrapper, child));
        prepend(target, wrapper);
    };
    const wrapInOuterWrappers = (target, wrappers) => {
        if (wrappers.length > 0) {
            const outermost = wrappers[wrappers.length - 1];
            before$4(target, outermost);
            const innerMost = foldl(wrappers.slice(0, wrappers.length - 1), (acc, wrapper) => {
                append$1(acc, wrapper);
                return wrapper;
            }, outermost);
            append$1(innerMost, target);
        }
    };
    const normalizeFontSizeElementsInternal = (domUtils, fontSizeElements, hasFormat, createFormatElement, removeFormatFromElement) => {
        const isRoot = (el) => eq(SugarElement.fromDom(domUtils.getRoot()), el) || domUtils.isBlock(el.dom);
        each$e(fontSizeElements, (fontSizeElement) => {
            gatherWrapperData(isRoot, fontSizeElement, hasFormat, createFormatElement, removeFormatFromElement).each(({ container, innerWrapper, outerWrappers }) => {
                domUtils.split(container.dom, fontSizeElement.dom);
                wrapChildrenInInnerWrapper(fontSizeElement, innerWrapper, hasFormat, removeFormatFromElement);
                wrapInOuterWrappers(fontSizeElement, outerWrappers);
            });
        });
    };
    const normalizeFontSizeElementsWithFormat = (editor, formatName, fontSizeElements) => {
        const hasFormat = (el) => isNonNullable(matchNode$1(editor, el.dom, formatName));
        const createFormatElement = (el) => {
            const newEl = SugarElement.fromTag(name(el));
            const format = matchNode$1(editor, el.dom, formatName, {});
            if (isNonNullable(format) && isApplyFormat(format)) {
                setElementFormat(editor, newEl.dom, format);
            }
            return newEl;
        };
        const removeFormatFromElement = (el) => {
            const format = matchNode$1(editor, el.dom, formatName, {});
            if (isNonNullable(format)) {
                return removeFormatOnElement(editor, format, {}, el.dom).map(SugarElement.fromDom);
            }
            else {
                return Optional.some(el);
            }
        };
        const bookmark = createBookmark$1(editor.selection.getRng());
        normalizeFontSizeElementsInternal(editor.dom, fontSizeElements, hasFormat, createFormatElement, removeFormatFromElement);
        editor.selection.setRng(resolveBookmark$2(bookmark));
    };
    const collectFontSizeElements = (formatter, wrappers) => bind$3(wrappers, (wrapper) => {
        const fontSizeDescendants = descendants$1(wrapper, (el) => isFontSizeAlteringElement(formatter, el));
        return isFontSizeAlteringElement(formatter, wrapper) ? [wrapper, ...fontSizeDescendants] : fontSizeDescendants;
    });
    const normalizeFontSizeElementsAfterApply = (editor, appliedFormat, wrappers) => {
        if (isNormalizingFormat(appliedFormat)) {
            const fontSizeElements = collectFontSizeElements(editor.formatter, wrappers);
            normalizeFontSizeElementsWithFormat(editor, 'strikethrough', fontSizeElements);
        }
    };
    const normalizeElements = (editor, elements) => {
        const fontSizeElements = filter$5(elements, (el) => isFontSizeAlteringElement(editor.formatter, el));
        normalizeFontSizeElementsWithFormat(editor, 'strikethrough', fontSizeElements);
    };

    const isHeading = (node) => ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(node.name);
    const isSummary = (node) => node.name === 'summary';

    const traverse = (root, fn) => {
        let node = root;
        while ((node = node.walk())) {
            fn(node);
        }
    };
    // Test a single node against the current filters, and add it to any match lists if necessary
    const matchNode = (nodeFilters, attributeFilters, node, matches) => {
        const name = node.name;
        // Match node filters
        for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {
            const filter = nodeFilters[ni];
            if (filter.name === name) {
                const match = matches.nodes[name];
                if (match) {
                    match.nodes.push(node);
                }
                else {
                    matches.nodes[name] = { filter, nodes: [node] };
                }
            }
        }
        // Match attribute filters
        if (node.attributes) {
            for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {
                const filter = attributeFilters[ai];
                const attrName = filter.name;
                if (attrName in node.attributes.map) {
                    const match = matches.attributes[attrName];
                    if (match) {
                        match.nodes.push(node);
                    }
                    else {
                        matches.attributes[attrName] = { filter, nodes: [node] };
                    }
                }
            }
        }
    };
    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {
        const matches = { nodes: {}, attributes: {} };
        if (node.firstChild) {
            traverse(node, (childNode) => {
                matchNode(nodeFilters, attributeFilters, childNode, matches);
            });
        }
        return matches;
    };
    // Run all necessary node filters and attribute filters, based on a match set
    const runFilters = (matches, args) => {
        const run = (matchRecord, filteringAttributes) => {
            each$d(matchRecord, (match) => {
                // in theory we don't need to copy the array, it was created purely for this filtering, but the method is exported so we can't guarantee that
                const nodes = from(match.nodes);
                each$e(match.filter.callbacks, (callback) => {
                    // very very carefully mutate the nodes array based on whether the filter still matches them
                    for (let i = nodes.length - 1; i >= 0; i--) {
                        const node = nodes[i];
                        // Remove already removed children, and nodes that no longer match the filter
                        const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;
                        if (!valueMatches || isNullable(node.parent)) {
                            nodes.splice(i, 1);
                        }
                    }
                    if (nodes.length > 0) {
                        callback(nodes, match.filter.name, args);
                    }
                });
            });
        };
        run(matches.nodes, false);
        run(matches.attributes, true);
    };
    const filter$1 = (nodeFilters, attributeFilters, node, args = {}) => {
        const matches = findMatchingNodes(nodeFilters, attributeFilters, node);
        runFilters(matches, args);
    };

    const paddEmptyNode = (settings, args, isBlock, node) => {
        const brPreferred = settings.pad_empty_with_br || args.insert;
        if (brPreferred && isBlock(node)) {
            const astNode = new AstNode('br', 1);
            if (args.insert) {
                astNode.attr('data-mce-bogus', '1');
            }
            node.empty().append(astNode);
        }
        else {
            node.empty().append(new AstNode('#text', 3)).value = nbsp;
        }
    };
    const isPaddedWithNbsp = (node) => { var _a; return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp; };
    const hasOnlyChild = (node, name) => {
        const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;
        return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;
    };
    const isPadded = (schema, node) => {
        const rule = schema.getElementRule(node.name);
        return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;
    };
    const isEmpty$2 = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, (node) => isPadded(schema, node));
    const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');
    const findClosestEditingHost = (scope) => {
        let editableNode;
        for (let node = scope; node; node = node.parent) {
            const contentEditable = node.attr('contenteditable');
            if (contentEditable === 'false') {
                break;
            }
            else if (contentEditable === 'true') {
                editableNode = node;
            }
        }
        return Optional.from(editableNode);
    };
    const getAllDescendants = (scope) => {
        const collection = [];
        for (let node = scope.firstChild; isNonNullable(node); node = node.walk()) {
            collection.push(node);
        }
        return collection;
    };

    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {
        if (schema.getSpecialElements()[node.name]) {
            node.empty().remove();
        }
        else {
            // are the children of `node` valid children of the top level parent?
            // if not, remove or unwrap them too
            const children = node.children();
            for (const childNode of children) {
                if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {
                    removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);
                }
            }
            node.unwrap();
        }
    };
    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {
        const textBlockElements = schema.getTextBlockElements();
        const nonEmptyElements = schema.getNonEmptyElements();
        const whitespaceElements = schema.getWhitespaceElements();
        const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');
        const fixed = new Set();
        const isSplittableElement = (node) => node !== rootNode && !nonSplittableElements[node.name];
        for (let ni = 0; ni < nodes.length; ni++) {
            const node = nodes[ni];
            let parent;
            let newParent;
            let tempNode;
            // Don't bother if it's detached from the tree
            if (!node.parent || fixed.has(node)) {
                continue;
            }
            // If the invalid element is a text block, and the text block is within a parent LI element
            // Then unwrap the first text block and convert other sibling text blocks to LI elements similar to Word/Open Office
            if (textBlockElements[node.name] && node.parent.name === 'li') {
                // Move sibling text blocks after LI element
                let sibling = node.next;
                while (sibling) {
                    if (textBlockElements[sibling.name]) {
                        sibling.name = 'li';
                        fixed.add(sibling);
                        node.parent.insert(sibling, node.parent);
                    }
                    else {
                        break;
                    }
                    sibling = sibling.next;
                }
                // Unwrap current text block
                node.unwrap();
                continue;
            }
            // Get list of all parent nodes until we find a valid parent to stick the child into
            const parents = [node];
            for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {
                parents.push(parent);
            }
            // Found a suitable parent
            if (parent && parents.length > 1) {
                // If the node is a valid child of the parent, then try to move it. Otherwise unwrap it
                if (!isInvalid(schema, node, parent)) {
                    // Reverse the array since it makes looping easier
                    parents.reverse();
                    // Clone the related parent and insert that after the moved node
                    newParent = parents[0].clone();
                    onCreate(newParent);
                    // Start cloning and moving children on the left side of the target node
                    let currentNode = newParent;
                    for (let i = 0; i < parents.length - 1; i++) {
                        if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {
                            tempNode = parents[i].clone();
                            onCreate(tempNode);
                            currentNode.append(tempNode);
                        }
                        else {
                            tempNode = currentNode;
                        }
                        for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {
                            const nextNode = childNode.next;
                            tempNode.append(childNode);
                            childNode = nextNode;
                        }
                        currentNode = tempNode;
                    }
                    if (!isEmpty$2(schema, nonEmptyElements, whitespaceElements, newParent)) {
                        parent.insert(newParent, parents[0], true);
                        parent.insert(node, newParent);
                    }
                    else {
                        parent.insert(node, parents[0], true);
                    }
                    // Check if the element is empty by looking through its contents, with special treatment for <p><br /></p>
                    parent = parents[0];
                    if (isEmpty$2(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {
                        parent.empty().remove();
                    }
                }
                else {
                    removeOrUnwrapInvalidNode(node, schema);
                }
            }
            else if (node.parent) {
                // If it's an LI try to find a UL/OL for it or wrap it
                if (node.name === 'li') {
                    let sibling = node.prev;
                    if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {
                        sibling.append(node);
                        continue;
                    }
                    sibling = node.next;
                    if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {
                        sibling.insert(node, sibling.firstChild, true);
                        continue;
                    }
                    const wrapper = new AstNode('ul', 1);
                    onCreate(wrapper);
                    node.wrap(wrapper);
                    continue;
                }
                // Try wrapping the element in a DIV
                if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
                    const wrapper = new AstNode('div', 1);
                    onCreate(wrapper);
                    node.wrap(wrapper);
                }
                else {
                    // We failed wrapping it, remove or unwrap it
                    removeOrUnwrapInvalidNode(node, schema);
                }
            }
        }
    };
    const hasClosest = (node, parentName) => {
        let tempNode = node;
        while (tempNode) {
            if (tempNode.name === parentName) {
                return true;
            }
            tempNode = tempNode.parent;
        }
        return false;
    };
    // The `parent` parameter of `isInvalid` function represents the closest valid parent
    // under which the `node` is intended to be moved.
    const isInvalid = (schema, node, parent = node.parent) => {
        if (!parent) {
            return false;
        }
        // Check if the node is a valid child of the parent node. If the child is
        // unknown we don't collect it since it's probably a custom element
        if (schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {
            return true;
        }
        // Anchors are a special case and cannot be nested
        if (node.name === 'a' && hasClosest(parent, 'a')) {
            return true;
        }
        // heading element is valid if it is the only one child of summary
        if (isSummary(parent) && isHeading(node)) {
            return !((parent === null || parent === void 0 ? void 0 : parent.firstChild) === node && (parent === null || parent === void 0 ? void 0 : parent.lastChild) === node);
        }
        return false;
    };

    const createRange = (sc, so, ec, eo) => {
        const rng = document.createRange();
        rng.setStart(sc, so);
        rng.setEnd(ec, eo);
        return rng;
    };
    // If you triple click a paragraph in this case:
    //   <blockquote><p>a</p></blockquote><p>b</p>
    // It would become this range in webkit:
    //   <blockquote><p>[a</p></blockquote><p>]b</p>
    // We would want it to be:
    //   <blockquote><p>[a]</p></blockquote><p>b</p>
    // Since it would otherwise produces spans out of thin air on insertContent for example.
    const normalizeBlockSelectionRange = (rng) => {
        const startPos = CaretPosition.fromRangeStart(rng);
        const endPos = CaretPosition.fromRangeEnd(rng);
        const rootNode = rng.commonAncestorContainer;
        return fromPosition(false, rootNode, endPos)
            .map((newEndPos) => {
            if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
                return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
            }
            else {
                return rng;
            }
        }).getOr(rng);
    };
    const normalize = (rng) => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);

    const explode$1 = Tools.explode;
    const create$8 = () => {
        const filters = {};
        const addFilter = (name, callback) => {
            each$e(explode$1(name), (name) => {
                if (!has$2(filters, name)) {
                    filters[name] = { name, callbacks: [] };
                }
                filters[name].callbacks.push(callback);
            });
        };
        const getFilters = () => values(filters);
        const removeFilter = (name, callback) => {
            each$e(explode$1(name), (name) => {
                if (has$2(filters, name)) {
                    if (isNonNullable(callback)) {
                        const filter = filters[name];
                        const newCallbacks = filter$5(filter.callbacks, (c) => c !== callback);
                        // If all callbacks have been removed then remove the filter reference
                        if (newCallbacks.length > 0) {
                            filter.callbacks = newCallbacks;
                        }
                        else {
                            delete filters[name];
                        }
                    }
                    else {
                        delete filters[name];
                    }
                }
            });
        };
        return {
            addFilter,
            getFilters,
            removeFilter
        };
    };

    const encodeData = (data) => data.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    const decodeData$1 = (data) => data.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');

    const removeAttrs = (node, names) => {
        each$e(names, (name) => {
            node.attr(name, null);
        });
    };
    const addFontToSpansFilter = (domParser, styles, fontSizes) => {
        domParser.addNodeFilter('font', (nodes) => {
            each$e(nodes, (node) => {
                const props = styles.parse(node.attr('style'));
                const color = node.attr('color');
                const face = node.attr('face');
                const size = node.attr('size');
                if (color) {
                    props.color = color;
                }
                if (face) {
                    props['font-family'] = face;
                }
                if (size) {
                    toInt(size).each((num) => {
                        props['font-size'] = fontSizes[num - 1];
                    });
                }
                node.name = 'span';
                node.attr('style', styles.serialize(props));
                removeAttrs(node, ['color', 'face', 'size']);
            });
        });
    };
    const addStrikeFilter = (domParser, schema, styles) => {
        domParser.addNodeFilter('strike', (nodes) => {
            const convertToSTag = schema.type !== 'html4';
            each$e(nodes, (node) => {
                if (convertToSTag) {
                    node.name = 's';
                }
                else {
                    const props = styles.parse(node.attr('style'));
                    props['text-decoration'] = 'line-through';
                    node.name = 'span';
                    node.attr('style', styles.serialize(props));
                }
            });
        });
    };
    const addFilters = (domParser, settings, schema) => {
        var _a;
        const styles = Styles();
        if (settings.convert_fonts_to_spans) {
            addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));
        }
        addStrikeFilter(domParser, schema, styles);
    };
    const register$5 = (domParser, settings, schema) => {
        if (settings.inline_styles) {
            addFilters(domParser, settings, schema);
        }
    };

    const blobUriToBlob = (url) => fetch(url)
        .then((res) => res.ok ? res.blob() : Promise.reject())
        .catch(() => Promise.reject({
        message: `Cannot convert ${url} to Blob. Resource might not exist or is inaccessible.`,
        uriType: 'blob'
    }));
    const extractBase64Data = (data) => {
        const matches = /([a-z0-9+\/=\s]+)/i.exec(data);
        return matches ? matches[1] : '';
    };
    const decodeData = (data) => {
        try {
            return decodeURIComponent(data);
        }
        catch (_a) {
            return data;
        }
    };
    const parseDataUri = (uri) => {
        const [type, ...rest] = uri.split(',');
        const data = rest.join(',');
        const matches = /data:([^/]+\/[^;]+)(;.+)?/.exec(type);
        if (matches) {
            const base64Encoded = matches[2] === ';base64';
            const decodedData = decodeData(data);
            const extractedData = base64Encoded ? extractBase64Data(decodedData) : decodedData;
            return Optional.some({
                type: matches[1],
                data: extractedData,
                base64Encoded
            });
        }
        else {
            return Optional.none();
        }
    };
    const buildBlob = (type, data, base64Encoded = true) => {
        let str = data;
        if (base64Encoded) {
            // Might throw error if data isn't proper base64
            try {
                str = atob(data);
            }
            catch (_a) {
                return Optional.none();
            }
        }
        const arr = new Uint8Array(str.length);
        for (let i = 0; i < arr.length; i++) {
            arr[i] = str.charCodeAt(i);
        }
        return Optional.some(new Blob([arr], { type }));
    };
    const dataUriToBlob = (uri) => {
        return new Promise((resolve, reject) => {
            parseDataUri(uri)
                .bind(({ type, data, base64Encoded }) => buildBlob(type, data, base64Encoded))
                .fold(() => reject('Invalid data URI'), resolve);
        });
    };
    const uriToBlob = (url) => {
        if (startsWith(url, 'blob:')) {
            return blobUriToBlob(url);
        }
        else if (startsWith(url, 'data:')) {
            return dataUriToBlob(url);
        }
        else {
            return Promise.reject('Unknown URI format');
        }
    };
    const blobToDataUri = (blob) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                resolve(reader.result);
            };
            reader.onerror = () => {
                var _a;
                reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);
            };
            reader.readAsDataURL(blob);
        });
    };

    let count$1 = 0;
    const uniqueId$1 = (prefix) => {
        return (prefix || 'blobid') + (count$1++);
    };
    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {
        return parseDataUri(dataUri).bind(({ data, type, base64Encoded }) => {
            if (base64Only && !base64Encoded) {
                return Optional.none();
            }
            else {
                const base64 = base64Encoded ? data : btoa(data);
                return generateBlobInfo(base64, type);
            }
        });
    };
    const createBlobInfo$1 = (blobCache, blob, base64) => {
        const blobInfo = blobCache.create(uniqueId$1(), blob, base64);
        blobCache.add(blobInfo);
        return blobInfo;
    };
    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {
        return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map((blob) => createBlobInfo$1(blobCache, blob, base64))));
    };
    const imageToBlobInfo = (blobCache, imageSrc) => {
        const invalidDataUri = () => Promise.reject('Invalid data URI');
        if (startsWith(imageSrc, 'blob:')) {
            const blobInfo = blobCache.getByUri(imageSrc);
            if (isNonNullable(blobInfo)) {
                return Promise.resolve(blobInfo);
            }
            else {
                return uriToBlob(imageSrc).then((blob) => {
                    return blobToDataUri(blob).then((dataUri) => {
                        return processDataUri(dataUri, false, (base64) => {
                            return Optional.some(createBlobInfo$1(blobCache, blob, base64));
                        }).getOrThunk(invalidDataUri);
                    });
                });
            }
        }
        else if (startsWith(imageSrc, 'data:')) {
            return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, (blobInfo) => Promise.resolve(blobInfo));
        }
        else {
            // Not a blob or data URI so the image isn't a local image and isn't something that can be processed
            return Promise.reject('Unknown image data format');
        }
    };

    // TINY-10350: A modification of the Regexes.link regex to specifically capture host.
    // eslint-disable-next-line max-len
    const hostCaptureRegex = /^(?:(?:(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)([A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*))(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?)$/;
    const extractHost = (url) => Optional.from(url.match(hostCaptureRegex)).bind((ms) => get$b(ms, 1)).map((h) => startsWith(h, 'www.') ? h.substring(4) : h);

    const sandboxIframe = (iframeNode, exclusions) => {
        if (Optional.from(iframeNode.attr('src')).bind(extractHost).forall((host) => !contains$2(exclusions, host))) {
            iframeNode.attr('sandbox', '');
        }
    };
    const isMimeType = (mime, type) => startsWith(mime, `${type}/`);
    const getEmbedType = (type) => {
        if (isUndefined(type)) {
            return 'iframe';
        }
        else if (isMimeType(type, 'image')) {
            return 'img';
        }
        else if (isMimeType(type, 'video')) {
            return 'video';
        }
        else if (isMimeType(type, 'audio')) {
            return 'audio';
        }
        else {
            return 'iframe';
        }
    };
    const createSafeEmbed = ({ type, src, width, height } = {}, sandboxIframes, sandboxIframesExclusions) => {
        const name = getEmbedType(type);
        const embed = new AstNode(name, 1);
        embed.attr(name === 'audio' ? { src } : { src, width, height });
        // TINY-10349: Show controls for audio and video so the replaced embed is visible in editor.
        if (name === 'audio' || name === 'video') {
            embed.attr('controls', '');
        }
        if (name === 'iframe' && sandboxIframes) {
            sandboxIframe(embed, sandboxIframesExclusions);
        }
        return embed;
    };

    const isBogusImage = (img) => isNonNullable(img.attr('data-mce-bogus'));
    const isInternalImageSource = (img) => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));
    const registerBase64ImageFilter = (parser, settings) => {
        const { blob_cache: blobCache } = settings;
        if (blobCache) {
            const processImage = (img) => {
                const inputSrc = img.attr('src');
                if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {
                    return;
                }
                dataUriToBlobInfo(blobCache, inputSrc, true).each((blobInfo) => {
                    img.attr('src', blobInfo.blobUri());
                });
            };
            parser.addAttributeFilter('src', (nodes) => each$e(nodes, processImage));
        }
    };
    const register$4 = (parser, settings) => {
        var _a, _b;
        const schema = parser.schema;
        parser.addAttributeFilter('href', (nodes) => {
            let i = nodes.length;
            const appendRel = (rel) => {
                const parts = rel.split(' ').filter((p) => p.length > 0);
                return parts.concat(['noopener']).sort().join(' ');
            };
            const addNoOpener = (rel) => {
                const newRel = rel ? Tools.trim(rel) : '';
                if (!/\b(noopener)\b/g.test(newRel)) {
                    return appendRel(newRel);
                }
                else {
                    return newRel;
                }
            };
            if (!settings.allow_unsafe_link_target) {
                while (i--) {
                    const node = nodes[i];
                    if (node.name === 'a' && node.attr('target') === '_blank') {
                        node.attr('rel', addNoOpener(node.attr('rel')));
                    }
                }
            }
        });
        // Force anchor names closed, unless the setting "allow_html_in_named_anchor" is explicitly included.
        if (!settings.allow_html_in_named_anchor) {
            parser.addAttributeFilter('id,name', (nodes) => {
                let i = nodes.length, sibling, prevSibling, parent, node;
                while (i--) {
                    node = nodes[i];
                    if (node.name === 'a' && node.firstChild && !node.attr('href')) {
                        parent = node.parent;
                        // Move children after current node
                        sibling = node.lastChild;
                        while (sibling && parent) {
                            prevSibling = sibling.prev;
                            parent.insert(sibling, node);
                            sibling = prevSibling;
                        }
                    }
                }
            });
        }
        if (settings.fix_list_elements) {
            parser.addNodeFilter('ul,ol', (nodes) => {
                let i = nodes.length, node, parentNode;
                while (i--) {
                    node = nodes[i];
                    parentNode = node.parent;
                    if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {
                        if (node.prev && node.prev.name === 'li') {
                            node.prev.append(node);
                        }
                        else {
                            const li = new AstNode('li', 1);
                            li.attr('style', 'list-style-type: none');
                            node.wrap(li);
                        }
                    }
                }
            });
        }
        const validClasses = schema.getValidClasses();
        if (settings.validate && validClasses) {
            parser.addAttributeFilter('class', (nodes) => {
                var _a;
                let i = nodes.length;
                while (i--) {
                    const node = nodes[i];
                    const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';
                    const classList = Tools.explode(clazz, ' ');
                    let classValue = '';
                    for (let ci = 0; ci < classList.length; ci++) {
                        const className = classList[ci];
                        let valid = false;
                        let validClassesMap = validClasses['*'];
                        if (validClassesMap && validClassesMap[className]) {
                            valid = true;
                        }
                        validClassesMap = validClasses[node.name];
                        if (!valid && validClassesMap && validClassesMap[className]) {
                            valid = true;
                        }
                        if (valid) {
                            if (classValue) {
                                classValue += ' ';
                            }
                            classValue += className;
                        }
                    }
                    if (!classValue.length) {
                        classValue = null;
                    }
                    node.attr('class', classValue);
                }
            });
        }
        registerBase64ImageFilter(parser, settings);
        const shouldSandboxIframes = (_a = settings.sandbox_iframes) !== null && _a !== void 0 ? _a : false;
        const sandboxIframesExclusions = unique$1((_b = settings.sandbox_iframes_exclusions) !== null && _b !== void 0 ? _b : []);
        if (settings.convert_unsafe_embeds) {
            parser.addNodeFilter('object,embed', (nodes) => each$e(nodes, (node) => {
                node.replace(createSafeEmbed({
                    type: node.attr('type'),
                    src: node.name === 'object' ? node.attr('data') : node.attr('src'),
                    width: node.attr('width'),
                    height: node.attr('height'),
                }, shouldSandboxIframes, sandboxIframesExclusions));
            }));
        }
        if (shouldSandboxIframes) {
            parser.addNodeFilter('iframe', (nodes) => each$e(nodes, (node) => sandboxIframe(node, sandboxIframesExclusions)));
        }
    };

    /*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */

    const {
      entries,
      setPrototypeOf,
      isFrozen,
      getPrototypeOf,
      getOwnPropertyDescriptor
    } = Object;
    let {
      freeze,
      seal,
      create: create$7
    } = Object; // eslint-disable-line import/no-mutable-exports
    let {
      apply,
      construct
    } = typeof Reflect !== 'undefined' && Reflect;
    if (!freeze) {
      freeze = function freeze(x) {
        return x;
      };
    }
    if (!seal) {
      seal = function seal(x) {
        return x;
      };
    }
    if (!apply) {
      apply = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    if (!construct) {
      construct = function construct(Func, args) {
        return new Func(...args);
      };
    }
    const arrayForEach = unapply(Array.prototype.forEach);
    const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
    const arrayPop = unapply(Array.prototype.pop);
    const arrayPush = unapply(Array.prototype.push);
    const arraySplice = unapply(Array.prototype.splice);
    const stringToLowerCase = unapply(String.prototype.toLowerCase);
    const stringToString = unapply(String.prototype.toString);
    const stringMatch = unapply(String.prototype.match);
    const stringReplace = unapply(String.prototype.replace);
    const stringIndexOf = unapply(String.prototype.indexOf);
    const stringTrim = unapply(String.prototype.trim);
    const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
    const regExpTest = unapply(RegExp.prototype.test);
    const typeErrorCreate = unconstruct(TypeError);
    /**
     * Creates a new function that calls the given function with a specified thisArg and arguments.
     *
     * @param func - The function to be wrapped and called.
     * @returns A new function that calls the given function with a specified thisArg and arguments.
     */
    function unapply(func) {
      return function (thisArg) {
        if (thisArg instanceof RegExp) {
          thisArg.lastIndex = 0;
        }
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return apply(func, thisArg, args);
      };
    }
    /**
     * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
     *
     * @param func - The constructor function to be wrapped and called.
     * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
     */
    function unconstruct(func) {
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return construct(func, args);
      };
    }
    /**
     * Add properties to a lookup table
     *
     * @param set - The set to which elements will be added.
     * @param array - The array containing elements to be added to the set.
     * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
     * @returns The modified set with added elements.
     */
    function addToSet(set, array) {
      let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
      if (setPrototypeOf) {
        // Make 'in' and truthy checks like Boolean(set.constructor)
        // independent of any properties defined on Object.prototype.
        // Prevent prototype setters from intercepting set as a this value.
        setPrototypeOf(set, null);
      }
      let l = array.length;
      while (l--) {
        let element = array[l];
        if (typeof element === 'string') {
          const lcElement = transformCaseFunc(element);
          if (lcElement !== element) {
            // Config presets (e.g. tags.js, attrs.js) are immutable.
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }
            element = lcElement;
          }
        }
        set[element] = true;
      }
      return set;
    }
    /**
     * Clean up an array to harden against CSPP
     *
     * @param array - The array to be cleaned.
     * @returns The cleaned version of the array
     */
    function cleanArray(array) {
      for (let index = 0; index < array.length; index++) {
        const isPropertyExist = objectHasOwnProperty(array, index);
        if (!isPropertyExist) {
          array[index] = null;
        }
      }
      return array;
    }
    /**
     * Shallow clone an object
     *
     * @param object - The object to be cloned.
     * @returns A new object that copies the original.
     */
    function clone(object) {
      const newObject = create$7(null);
      for (const [property, value] of entries(object)) {
        const isPropertyExist = objectHasOwnProperty(object, property);
        if (isPropertyExist) {
          if (Array.isArray(value)) {
            newObject[property] = cleanArray(value);
          } else if (value && typeof value === 'object' && value.constructor === Object) {
            newObject[property] = clone(value);
          } else {
            newObject[property] = value;
          }
        }
      }
      return newObject;
    }
    /**
     * This method automatically checks if the prop is function or getter and behaves accordingly.
     *
     * @param object - The object to look up the getter function in its prototype chain.
     * @param prop - The property name for which to find the getter function.
     * @returns The getter function found in the prototype chain or a fallback function.
     */
    function lookupGetter(object, prop) {
      while (object !== null) {
        const desc = getOwnPropertyDescriptor(object, prop);
        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }
          if (typeof desc.value === 'function') {
            return unapply(desc.value);
          }
        }
        object = getPrototypeOf(object);
      }
      function fallbackValue() {
        return null;
      }
      return fallbackValue;
    }

    const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
    const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
    const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
    // List of SVG elements that are disallowed by default.
    // We still need to know them so that we can do namespace
    // checks properly in case one wants to add them to
    // allow-list.
    const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
    const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
    // Similarly to SVG, we want to know all MathML elements,
    // even those that we disallow by default.
    const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
    const text = freeze(['#text']);

    const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
    const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
    const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
    const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

    // eslint-disable-next-line unicorn/better-regex
    const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
    const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
    const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
    const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
    );
    const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
    );
    const DOCTYPE_NAME = seal(/^html$/i);
    const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

    var EXPRESSIONS = /*#__PURE__*/Object.freeze({
      __proto__: null,
      ARIA_ATTR: ARIA_ATTR,
      ATTR_WHITESPACE: ATTR_WHITESPACE,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT,
      DATA_ATTR: DATA_ATTR,
      DOCTYPE_NAME: DOCTYPE_NAME,
      ERB_EXPR: ERB_EXPR,
      IS_ALLOWED_URI: IS_ALLOWED_URI,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
      MUSTACHE_EXPR: MUSTACHE_EXPR,
      TMPLIT_EXPR: TMPLIT_EXPR
    });

    /* eslint-disable @typescript-eslint/indent */
    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
    const NODE_TYPE = {
      element: 1,
      attribute: 2,
      text: 3,
      cdataSection: 4,
      entityReference: 5,
      // Deprecated
      entityNode: 6,
      // Deprecated
      progressingInstruction: 7,
      comment: 8,
      document: 9,
      documentType: 10,
      documentFragment: 11,
      notation: 12 // Deprecated
    };
    const getGlobal = function getGlobal() {
      return typeof window === 'undefined' ? null : window;
    };
    /**
     * Creates a no-op policy for internal use only.
     * Don't export this function outside this module!
     * @param trustedTypes The policy factory.
     * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
     * @return The policy created (or null, if Trusted Types
     * are not supported or creating the policy failed).
     */
    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
        return null;
      }
      // Allow the callers to control the unique policy name
      // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
      // Policy creation with duplicate names throws in Trusted Types.
      let suffix = null;
      const ATTR_NAME = 'data-tt-policy-suffix';
      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
        suffix = purifyHostElement.getAttribute(ATTR_NAME);
      }
      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML(html) {
            return html;
          },
          createScriptURL(scriptUrl) {
            return scriptUrl;
          }
        });
      } catch (_) {
        // Policy creation failed (most likely another DOMPurify script has
        // already run). Skip creating the policy, as this will only cause errors
        // if TT are enforced.
        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
        return null;
      }
    };
    const _createHooksMap = function _createHooksMap() {
      return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
      };
    };
    function createDOMPurify() {
      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
      const DOMPurify = root => createDOMPurify(root);
      DOMPurify.version = '3.2.6';
      DOMPurify.removed = [];
      if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {
        // Not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
      }
      let {
        document
      } = window;
      const originalDocument = document;
      const currentScript = originalDocument.currentScript;
      const {
        DocumentFragment,
        HTMLTemplateElement,
        Node,
        Element,
        NodeFilter,
        NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
        HTMLFormElement,
        DOMParser,
        trustedTypes
      } = window;
      const ElementPrototype = Element.prototype;
      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
      const remove = lookupGetter(ElementPrototype, 'remove');
      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
      // As per issue #47, the web-components registry is inherited by a
      // new document created via createHTMLDocument. As per the spec
      // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
      // a new empty registry is used when creating a template contents owner
      // document, so we use that as our parent document to ensure nothing
      // is inherited.
      if (typeof HTMLTemplateElement === 'function') {
        const template = document.createElement('template');
        if (template.content && template.content.ownerDocument) {
          document = template.content.ownerDocument;
        }
      }
      let trustedTypesPolicy;
      let emptyHTML = '';
      const {
        implementation,
        createNodeIterator,
        createDocumentFragment,
        getElementsByTagName
      } = document;
      const {
        importNode
      } = originalDocument;
      let hooks = _createHooksMap();
      /**
       * Expose whether this browser supports running the full DOMPurify.
       */
      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
      const {
        MUSTACHE_EXPR,
        ERB_EXPR,
        TMPLIT_EXPR,
        DATA_ATTR,
        ARIA_ATTR,
        IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE,
        CUSTOM_ELEMENT
      } = EXPRESSIONS;
      let {
        IS_ALLOWED_URI: IS_ALLOWED_URI$1
      } = EXPRESSIONS;
      /**
       * We consider the elements and attributes below to be safe. Ideally
       * don't add any new ones but feel free to remove unwanted ones.
       */
      /* allowed element names */
      let ALLOWED_TAGS = null;
      const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
      /* Allowed attribute names */
      let ALLOWED_ATTR = null;
      const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
      /*
       * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
       * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
       * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
       * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
       */
      let CUSTOM_ELEMENT_HANDLING = Object.seal(create$7(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false
        }
      }));
      /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
      let FORBID_TAGS = null;
      /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
      let FORBID_ATTR = null;
      /* Decide if ARIA attributes are okay */
      let ALLOW_ARIA_ATTR = true;
      /* Decide if custom data attributes are okay */
      let ALLOW_DATA_ATTR = true;
      /* Decide if unknown protocols are okay */
      let ALLOW_UNKNOWN_PROTOCOLS = false;
      /* Decide if self-closing tags in attributes are allowed.
       * Usually removed due to a mXSS issue in jQuery 3.0 */
      let ALLOW_SELF_CLOSE_IN_ATTR = true;
      /* Output should be safe for common template engines.
       * This means, DOMPurify removes data attributes, mustaches and ERB
       */
      let SAFE_FOR_TEMPLATES = false;
      /* Output should be safe even for XML used within HTML and alike.
       * This means, DOMPurify removes comments when containing risky content.
       */
      let SAFE_FOR_XML = true;
      /* Decide if document with <html>... should be returned */
      let WHOLE_DOCUMENT = false;
      /* Track whether config is already set on this instance of DOMPurify. */
      let SET_CONFIG = false;
      /* Decide if all elements (e.g. style, script) must be children of
       * document.body. By default, browsers might move them to document.head */
      let FORCE_BODY = false;
      /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
       * string (or a TrustedHTML object if Trusted Types are supported).
       * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
       */
      let RETURN_DOM = false;
      /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
       * string  (or a TrustedHTML object if Trusted Types are supported) */
      let RETURN_DOM_FRAGMENT = false;
      /* Try to return a Trusted Type object instead of a string, return a string in
       * case Trusted Types are not supported  */
      let RETURN_TRUSTED_TYPE = false;
      /* Output should be free from DOM clobbering attacks?
       * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
       */
      let SANITIZE_DOM = true;
      /* Achieve full DOM Clobbering protection by isolating the namespace of named
       * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
       *
       * HTML/DOM spec rules that enable DOM Clobbering:
       *   - Named Access on Window (7.3.3)
       *   - DOM Tree Accessors (3.1.5)
       *   - Form Element Parent-Child Relations (4.10.3)
       *   - Iframe srcdoc / Nested WindowProxies (4.8.5)
       *   - HTMLCollection (4.2.10.2)
       *
       * Namespace isolation is implemented by prefixing `id` and `name` attributes
       * with a constant string, i.e., `user-content-`
       */
      let SANITIZE_NAMED_PROPS = false;
      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
      /* Keep element content when removing element? */
      let KEEP_CONTENT = true;
      /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
       * of importing it into a new Document and returning a sanitized copy */
      let IN_PLACE = false;
      /* Allow usage of profiles like html, svg and mathMl */
      let USE_PROFILES = {};
      /* Tags to ignore content of when KEEP_CONTENT is true */
      let FORBID_CONTENTS = null;
      const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
      /* Tags that are safe for data: URIs */
      let DATA_URI_TAGS = null;
      const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
      /* Attributes safe for values like "javascript:" */
      let URI_SAFE_ATTRIBUTES = null;
      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
      /* Document namespace */
      let NAMESPACE = HTML_NAMESPACE;
      let IS_EMPTY_INPUT = false;
      /* Allowed XHTML+XML namespaces */
      let ALLOWED_NAMESPACES = null;
      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
      let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
      let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
      // Certain elements are allowed in both SVG and HTML
      // namespace. We need to specify them explicitly
      // so that they don't get erroneously deleted from
      // HTML namespace.
      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
      /* Parsing of strict XHTML documents */
      let PARSER_MEDIA_TYPE = null;
      const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
      let transformCaseFunc = null;
      /* Keep a reference to config to pass to hooks */
      let CONFIG = null;
      /* Ideally, do not touch anything below this line */
      /* ______________________________________________ */
      const formElement = document.createElement('form');
      const isRegexOrFunction = function isRegexOrFunction(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
      };
      /**
       * _parseConfig
       *
       * @param cfg optional config literal
       */
      // eslint-disable-next-line complexity
      const _parseConfig = function _parseConfig() {
        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        /* Shield configuration object from tampering */
        if (!cfg || typeof cfg !== 'object') {
          cfg = {};
        }
        /* Shield configuration object from prototype pollution */
        cfg = clone(cfg);
        PARSER_MEDIA_TYPE =
        // eslint-disable-next-line unicorn/prefer-includes
        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
        /* Set configuration parameters */
        ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
        FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
        USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
        RETURN_DOM = cfg.RETURN_DOM || false; // Default false
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
        FORCE_BODY = cfg.FORCE_BODY || false; // Default false
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
        IN_PLACE = cfg.IN_PLACE || false; // Default false
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        /* Parse profile info */
        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, text);
          ALLOWED_ATTR = [];
          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html$1);
            addToSet(ALLOWED_ATTR, html);
          }
          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg$1);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl$1);
            addToSet(ALLOWED_ATTR, mathMl);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        /* Merge configuration parameters */
        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
        }
        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
        }
        if (cfg.FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
        }
        /* Add #text in case KEEP_CONTENT is set to true */
        if (KEEP_CONTENT) {
          ALLOWED_TAGS['#text'] = true;
        }
        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
        }
        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ['tbody']);
          delete FORBID_TAGS.tbody;
        }
        if (cfg.TRUSTED_TYPES_POLICY) {
          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          }
          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          }
          // Overwrite existing TrustedTypes policy.
          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
          // Sign local variables required by `sanitize`.
          emptyHTML = trustedTypesPolicy.createHTML('');
        } else {
          // Uninitialized policy, attempt to initialize the internal dompurify policy.
          if (trustedTypesPolicy === undefined) {
            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
          }
          // If creating the internal policy succeeded sign internal variables.
          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
            emptyHTML = trustedTypesPolicy.createHTML('');
          }
        }
        // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.
        if (freeze) {
          freeze(cfg);
        }
        CONFIG = cfg;
      };
      /* Keep track of all possible SVG and MathML tags
       * so that we can perform the namespace checks
       * correctly. */
      const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
      const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
      /**
       * @param element a DOM element whose namespace is being checked
       * @returns Return false if the element has a
       *  namespace that a spec-compliant parser would never
       *  return. Return true otherwise.
       */
      const _checkValidNamespace = function _checkValidNamespace(element) {
        let parent = getParentNode(element);
        // In JSDOM, if we're inside shadow DOM, then parentNode
        // can be null. We just simulate parent in this case.
        if (!parent || !parent.tagName) {
          parent = {
            namespaceURI: NAMESPACE,
            tagName: 'template'
          };
        }
        const tagName = stringToLowerCase(element.tagName);
        const parentTagName = stringToLowerCase(parent.tagName);
        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
          return false;
        }
        if (element.namespaceURI === SVG_NAMESPACE) {
          // The only way to switch from HTML namespace to SVG
          // is via <svg>. If it happens via any other tag, then
          // it should be killed.
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'svg';
          }
          // The only way to switch from MathML to SVG is via`
          // svg if parent is either <annotation-xml> or MathML
          // text integration points.
          if (parent.namespaceURI === MATHML_NAMESPACE) {
            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          }
          // We only allow elements that are defined in SVG
          // spec. All others are disallowed in SVG namespace.
          return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
          // The only way to switch from HTML namespace to MathML
          // is via <math>. If it happens via any other tag, then
          // it should be killed.
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'math';
          }
          // The only way to switch from SVG to MathML is via
          // <math> and HTML integration points
          if (parent.namespaceURI === SVG_NAMESPACE) {
            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
          }
          // We only allow elements that are defined in MathML
          // spec. All others are disallowed in MathML namespace.
          return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
          // The only way to switch from SVG to HTML is via
          // HTML integration points, and from MathML to HTML
          // is via MathML text integration points
          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          // We disallow tags that are specific for MathML
          // or SVG and should never appear in HTML namespace
          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        // For XHTML and XML documents that support custom namespaces
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
          return true;
        }
        // The code should never reach this place (this means
        // that the element somehow got namespace that is not
        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
        // Return false just in case.
        return false;
      };
      /**
       * _forceRemove
       *
       * @param node a DOM node
       */
      const _forceRemove = function _forceRemove(node) {
        arrayPush(DOMPurify.removed, {
          element: node
        });
        try {
          // eslint-disable-next-line unicorn/prefer-dom-node-remove
          getParentNode(node).removeChild(node);
        } catch (_) {
          remove(node);
        }
      };
      /**
       * _removeAttribute
       *
       * @param name an Attribute name
       * @param element a DOM node
       */
      const _removeAttribute = function _removeAttribute(name, element) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: element.getAttributeNode(name),
            from: element
          });
        } catch (_) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: element
          });
        }
        element.removeAttribute(name);
        // We void attribute values for unremovable "is" attributes
        if (name === 'is') {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(element);
            } catch (_) {}
          } else {
            try {
              element.setAttribute(name, '');
            } catch (_) {}
          }
        }
      };
      /**
       * _initDocument
       *
       * @param dirty - a string of dirty markup
       * @return a DOM, filled with the dirty markup
       */
      const _initDocument = function _initDocument(dirty) {
        /* Create a HTML document */
        let doc = null;
        let leadingWhitespace = null;
        if (FORCE_BODY) {
          dirty = '<remove></remove>' + dirty;
        } else {
          /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
          const matches = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches && matches[0];
        }
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
          // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
        }
        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        /*
         * Use the DOMParser API by default, fallback later if needs be
         * DOMParser not work for svg when has multiple root element.
         */
        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
          } catch (_) {}
        }
        /* Use createHTMLDocument in case DOMParser is not available */
        if (!doc || !doc.documentElement) {
          doc = implementation.createDocument(NAMESPACE, 'template', null);
          try {
            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
          } catch (_) {
            // Syntax error if dirtyPayload is invalid xml
          }
        }
        const body = doc.body || doc.documentElement;
        if (dirty && leadingWhitespace) {
          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        /* Work on whole document or just its body */
        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
        }
        return WHOLE_DOCUMENT ? doc.documentElement : body;
      };
      /**
       * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
       *
       * @param root The root element or node to start traversing on.
       * @return The created NodeIterator
       */
      const _createNodeIterator = function _createNodeIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
      };
      /**
       * _isClobbered
       *
       * @param element element to check for clobbering attacks
       * @return true if clobbered, false if safe
       */
      const _isClobbered = function _isClobbered(element) {
        return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
      };
      /**
       * Checks whether the given object is a DOM node.
       *
       * @param value object to check whether it's a DOM node
       * @return true is object is a DOM node
       */
      const _isNode = function _isNode(value) {
        return typeof Node === 'function' && value instanceof Node;
      };
      function _executeHooks(hooks, currentNode, data) {
        arrayForEach(hooks, hook => {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      }
      /**
       * _sanitizeElements
       *
       * @protect nodeName
       * @protect textContent
       * @protect removeChild
       * @param currentNode to check for permission to exist
       * @return true if node was killed, false if left alive
       */
      const _sanitizeElements = function _sanitizeElements(currentNode) {
        let content = null;
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
        /* Check if element is clobbered or can clobber */
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Now let's check the element's type and name */
        const tagName = transformCaseFunc(currentNode.nodeName);
        /* Execute a hook if present */
        _executeHooks(hooks.uponSanitizeElement, currentNode, {
          tagName,
          allowedTags: ALLOWED_TAGS
        });
        /* Detect mXSS attempts abusing namespace confusion */
        if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove any occurrence of processing instructions */
        if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove any kind of possibly harmful comments */
        if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove element if anything forbids its presence */
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          /* Check if we have a custom element to handle */
          if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
              return false;
            }
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
              return false;
            }
          }
          /* Keep content except for bad-listed elements */
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            const parentNode = getParentNode(currentNode) || currentNode.parentNode;
            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
            if (childNodes && parentNode) {
              const childCount = childNodes.length;
              for (let i = childCount - 1; i >= 0; --i) {
                const childClone = cloneNode(childNodes[i], true);
                childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                parentNode.insertBefore(childClone, getNextSibling(currentNode));
              }
            }
          }
          _forceRemove(currentNode);
          return true;
        }
        /* Check whether element has a valid namespace */
        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Make sure that older browsers don't get fallback-tag mXSS */
        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Sanitize element content to be template-safe */
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
          /* Get the element's text content */
          content = currentNode.textContent;
          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
            content = stringReplace(content, expr, ' ');
          });
          if (currentNode.textContent !== content) {
            arrayPush(DOMPurify.removed, {
              element: currentNode.cloneNode()
            });
            currentNode.textContent = content;
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeElements, currentNode, null);
        return false;
      };
      /**
       * _isValidAttribute
       *
       * @param lcTag Lowercase tag name of containing element.
       * @param lcName Lowercase attribute name.
       * @param value Attribute value.
       * @return Returns true if `value` is valid, otherwise false.
       */
      // eslint-disable-next-line complexity
      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        /* Make sure attribute cannot clobber */
        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
          return false;
        }
        /* Allow valid data-* attributes: At least one character after "-"
            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
            We don't need to check the value; it's always URI safe. */
        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
          // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
            return false;
          }
          /* Check value is safe. First, is attr inert? If so, is safe */
        } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
          return false;
        } else ;
        return true;
      };
      /**
       * _isBasicCustomElement
       * checks if at least one dash is included in tagName, and it's not the first char
       * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
       *
       * @param tagName name of the tag of the node to sanitize
       * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
       */
      const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
        return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
      };
      /**
       * _sanitizeAttributes
       *
       * @protect attributes
       * @protect nodeName
       * @protect removeAttribute
       * @protect setAttribute
       *
       * @param currentNode to sanitize
       */
      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
        const {
          attributes
        } = currentNode;
        /* Check if we have attributes; if not we might have a text node */
        if (!attributes || _isClobbered(currentNode)) {
          return;
        }
        const hookEvent = {
          attrName: '',
          attrValue: '',
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR,
          forceKeepAttr: undefined
        };
        let l = attributes.length;
        /* Go backwards over all attributes; safely remove bad ones */
        while (l--) {
          const attr = attributes[l];
          const {
            name,
            namespaceURI,
            value: attrValue
          } = attr;
          const lcName = transformCaseFunc(name);
          const initValue = attrValue;
          let value = name === 'value' ? initValue : stringTrim(initValue);
          /* Execute a hook if present */
          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
          _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
          value = hookEvent.attrValue;
          /* Full DOM Clobbering protection via namespace isolation,
           * Prefix id and name attributes with `user-content-`
           */
          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
            // Remove the attribute with this value
            _removeAttribute(name, currentNode);
            // Prefix the value and later re-create the attribute with the sanitized value
            value = SANITIZE_NAMED_PROPS_PREFIX + value;
          }
          /* Work around a security issue with comments inside attributes */
          if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Did the hooks approve of the attribute? */
          if (hookEvent.forceKeepAttr) {
            continue;
          }
          /* Did the hooks approve of the attribute? */
          if (!hookEvent.keepAttr) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Work around a security issue in jQuery 3.0 */
          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Sanitize attribute content to be template-safe */
          if (SAFE_FOR_TEMPLATES) {
            arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
              value = stringReplace(value, expr, ' ');
            });
          }
          /* Is `value` valid for this attribute? */
          const lcTag = transformCaseFunc(currentNode.nodeName);
          if (!_isValidAttribute(lcTag, lcName, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Handle attributes that require Trusted Types */
          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
            if (namespaceURI) ; else {
              switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                case 'TrustedHTML':
                  {
                    value = trustedTypesPolicy.createHTML(value);
                    break;
                  }
                case 'TrustedScriptURL':
                  {
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                  }
              }
            }
          }
          /* Handle invalid data-* attribute set by try-catching it */
          if (value !== initValue) {
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
                currentNode.setAttribute(name, value);
              }
              if (_isClobbered(currentNode)) {
                _forceRemove(currentNode);
              } else {
                arrayPop(DOMPurify.removed);
              }
            } catch (_) {
              _removeAttribute(name, currentNode);
            }
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
      };
      /**
       * _sanitizeShadowDOM
       *
       * @param fragment to iterate over recursively
       */
      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        let shadowNode = null;
        const shadowIterator = _createNodeIterator(fragment);
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
        while (shadowNode = shadowIterator.nextNode()) {
          /* Execute a hook if present */
          _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
          /* Sanitize tags and elements */
          _sanitizeElements(shadowNode);
          /* Check attributes next */
          _sanitizeAttributes(shadowNode);
          /* Deep shadow DOM detected */
          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(shadowNode.content);
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
      };
      // eslint-disable-next-line complexity
      DOMPurify.sanitize = function (dirty) {
        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let body = null;
        let importedNode = null;
        let currentNode = null;
        let returnNode = null;
        /* Make sure we have a string to sanitize.
          DO NOT return early, as this will return the wrong type if
          the user has requested a DOM object rather than a string */
        IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
          dirty = '<!-->';
        }
        /* Stringify, in case dirty is an object */
        if (typeof dirty !== 'string' && !_isNode(dirty)) {
          if (typeof dirty.toString === 'function') {
            dirty = dirty.toString();
            if (typeof dirty !== 'string') {
              throw typeErrorCreate('dirty is not a string, aborting');
            }
          } else {
            throw typeErrorCreate('toString is not a function');
          }
        }
        /* Return dirty HTML if DOMPurify cannot run */
        if (!DOMPurify.isSupported) {
          return dirty;
        }
        /* Assign config vars */
        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        /* Clean up removed elements */
        DOMPurify.removed = [];
        /* Check if dirty is correctly typed for IN_PLACE */
        if (typeof dirty === 'string') {
          IN_PLACE = false;
        }
        if (IN_PLACE) {
          /* Do some early pre-sanitization to avoid unsafe root nodes */
          if (dirty.nodeName) {
            const tagName = transformCaseFunc(dirty.nodeName);
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
            }
          }
        } else if (dirty instanceof Node) {
          /* If dirty is a DOM element, append to an empty document to avoid
             elements being stripped by the parser */
          body = _initDocument('<!---->');
          importedNode = body.ownerDocument.importNode(dirty, true);
          if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
            /* Node is already a body, use as is */
            body = importedNode;
          } else if (importedNode.nodeName === 'HTML') {
            body = importedNode;
          } else {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            body.appendChild(importedNode);
          }
        } else {
          /* Exit directly if we have nothing to do */
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
          // eslint-disable-next-line unicorn/prefer-includes
          dirty.indexOf('<') === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          /* Initialize the document to work on */
          body = _initDocument(dirty);
          /* Check we have a DOM node from the data */
          if (!body) {
            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
          }
        }
        /* Remove first element node (ours) if FORCE_BODY is set */
        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        /* Get node iterator */
        const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
        /* Now start iterating over the created document */
        while (currentNode = nodeIterator.nextNode()) {
          /* Sanitize tags and elements */
          _sanitizeElements(currentNode);
          /* Check attributes next */
          _sanitizeAttributes(currentNode);
          /* Shadow DOM detected, sanitize it */
          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
        }
        /* If we sanitized `dirty` in-place, return it. */
        if (IN_PLACE) {
          return dirty;
        }
        /* Return sanitized string or DOM */
        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);
            while (body.firstChild) {
              // eslint-disable-next-line unicorn/prefer-dom-node-append
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }
          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
            /*
              AdoptNode() is not used because internal state is not reset
              (e.g. the past names map of a HTMLFormElement), this is safe
              in theory but we would rather not risk another attack vector.
              The state that is cloned by importNode() is explicitly defined
              by the specs.
            */
            returnNode = importNode.call(originalDocument, returnNode, true);
          }
          return returnNode;
        }
        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        /* Serialize doctype if allowed */
        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
        }
        /* Sanitize final string template-safe */
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
            serializedHTML = stringReplace(serializedHTML, expr, ' ');
          });
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      DOMPurify.setConfig = function () {
        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _parseConfig(cfg);
        SET_CONFIG = true;
      };
      DOMPurify.clearConfig = function () {
        CONFIG = null;
        SET_CONFIG = false;
      };
      DOMPurify.isValidAttribute = function (tag, attr, value) {
        /* Initialize shared config vars if necessary. */
        if (!CONFIG) {
          _parseConfig({});
        }
        const lcTag = transformCaseFunc(tag);
        const lcName = transformCaseFunc(attr);
        return _isValidAttribute(lcTag, lcName, value);
      };
      DOMPurify.addHook = function (entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') {
          return;
        }
        arrayPush(hooks[entryPoint], hookFunction);
      };
      DOMPurify.removeHook = function (entryPoint, hookFunction) {
        if (hookFunction !== undefined) {
          const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
          return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];
        }
        return arrayPop(hooks[entryPoint]);
      };
      DOMPurify.removeHooks = function (entryPoint) {
        hooks[entryPoint] = [];
      };
      DOMPurify.removeAllHooks = function () {
        hooks = _createHooksMap();
      };
      return DOMPurify;
    }
    var purify = createDOMPurify();

    /**
     * This class handles parsing, modification and serialization of URI/URL strings.
     * @class tinymce.util.URI
     */
    const each$6 = Tools.each, trim = Tools.trim;
    const queryParts = [
        'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host',
        'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
    ];
    const DEFAULT_PORTS = {
        ftp: 21,
        http: 80,
        https: 443,
        mailto: 25
    };
    const safeSvgDataUrlElements = ['img', 'video'];
    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {
        if (isNonNullable(allowSvgDataUrls)) {
            return !allowSvgDataUrls;
        }
        else {
            // Only allow SVGs by default on images/videos since the browser won't execute scripts on those elements
            return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;
        }
    };
    const decodeUri = (encodedUri) => {
        try {
            // Might throw malformed URI sequence
            return decodeURIComponent(encodedUri);
        }
        catch (_a) {
            // Fallback to non UTF-8 decoder
            return unescape(encodedUri);
        }
    };
    const isInvalidUri = (settings, uri, tagName) => {
        // remove all whitespaces from decoded uri to prevent impact on regex matching
        const decodedUri = decodeUri(uri).replace(/\s/g, '');
        if (settings.allow_script_urls) {
            return false;
            // Ensure we don't have a javascript URI, as that is not safe since it allows arbitrary JavaScript execution
        }
        else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {
            return true;
        }
        else if (settings.allow_html_data_urls) {
            return false;
        }
        else if (/^data:image\//i.test(decodedUri)) {
            return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(decodedUri);
        }
        else {
            return /^data:/i.test(decodedUri);
        }
    };
    class URI {
        static parseDataUri(uri) {
            let type;
            const uriComponents = decodeURIComponent(uri).split(',');
            const matches = /data:([^;]+)/.exec(uriComponents[0]);
            if (matches) {
                type = matches[1];
            }
            return {
                type,
                data: uriComponents[1]
            };
        }
        /**
         * Check to see if a URI is safe to use in the Document Object Model (DOM). This will return
         * true if the URI can be used in the DOM without potentially triggering a security issue.
         *
         * @method isDomSafe
         * @static
         * @param {String} uri The URI to be validated.
         * @param {Object} context An optional HTML tag name where the element is being used.
         * @param {Object} options An optional set of options to use when determining if the URI is safe.
         * @return {Boolean} True if the URI is safe, otherwise false.
         */
        static isDomSafe(uri, context, options = {}) {
            if (options.allow_script_urls) {
                return true;
            }
            else {
                const decodedUri = Entities.decode(uri).replace(/[\s\u0000-\u001F]+/g, '');
                return !isInvalidUri(options, decodedUri, context);
            }
        }
        static getDocumentBaseUrl(loc) {
            var _a;
            let baseUrl;
            // Pass applewebdata:// and other non web protocols though
            if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {
                baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';
            }
            else {
                baseUrl = loc.protocol + '//' + loc.host + loc.pathname;
            }
            if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
                baseUrl = baseUrl.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
                if (!/[\/\\]$/.test(baseUrl)) {
                    baseUrl += '/';
                }
            }
            return baseUrl;
        }
        /**
         * Constructs a new URI instance.
         *
         * @constructor
         * @method URI
         * @param {String} url URI string to parse.
         * @param {Object} settings Optional settings object.
         */
        constructor(url, settings = {}) {
            this.path = '';
            this.directory = '';
            url = trim(url);
            this.settings = settings;
            const baseUri = settings.base_uri;
            const self = this;
            // Strange app protocol that isn't http/https or local anchor
            // For example: mailto,skype,tel etc.
            if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
                self.source = url;
                return;
            }
            const isProtocolRelative = url.indexOf('//') === 0;
            // Absolute path with no host, fake host and protocol
            if (url.indexOf('/') === 0 && !isProtocolRelative) {
                url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;
            }
            // Relative path http:// or protocol relative //path
            if (!/^[\w\-]*:?\/\//.test(url)) {
                const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;
                if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {
                    url = '//mce_host' + self.toAbsPath(baseUrl, url);
                }
                else {
                    const match = /([^#?]*)([#?]?.*)/.exec(url);
                    if (match) {
                        url = ((baseUri && baseUri.protocol) || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];
                    }
                }
            }
            // Parse URL (Credits goes to Steave, http://blog.stevenlevithan.com/archives/parseuri)
            url = url.replace(/@@/g, '(mce_at)'); // Zope 3 workaround, they use @@something
            const urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
            if (urlMatch) {
                each$6(queryParts, (v, i) => {
                    let part = urlMatch[i];
                    // Zope 3 workaround, they use @@something
                    if (part) {
                        part = part.replace(/\(mce_at\)/g, '@@');
                    }
                    self[v] = part;
                });
            }
            if (baseUri) {
                if (!self.protocol) {
                    self.protocol = baseUri.protocol;
                }
                if (!self.userInfo) {
                    self.userInfo = baseUri.userInfo;
                }
                if (!self.port && self.host === 'mce_host') {
                    self.port = baseUri.port;
                }
                if (!self.host || self.host === 'mce_host') {
                    self.host = baseUri.host;
                }
                self.source = '';
            }
            if (isProtocolRelative) {
                self.protocol = '';
            }
        }
        /**
         * Sets the internal path part of the URI.
         *
         * @method setPath
         * @param {String} path Path string to set.
         */
        setPath(path) {
            const pathMatch = /^(.*?)\/?(\w+)?$/.exec(path);
            // Update path parts
            if (pathMatch) {
                this.path = pathMatch[0];
                this.directory = pathMatch[1];
                this.file = pathMatch[2];
            }
            // Rebuild source
            this.source = '';
            this.getURI();
        }
        /**
         * Converts the specified URI into a relative URI based on the current URI instance location.
         *
         * @method toRelative
         * @param {String} uri URI to convert into a relative path/URI.
         * @return {String} Relative URI from the point specified in the current URI instance.
         * @example
         * // Converts an absolute URL to an relative URL url will be somedir/somefile.htm
         * const url = new tinymce.util.URI('http://www.site.com/dir/').toRelative('http://www.site.com/dir/somedir/somefile.htm');
         */
        toRelative(uri) {
            if (uri === './') {
                return uri;
            }
            const relativeUri = new URI(uri, { base_uri: this });
            // Not on same domain/port or protocol
            if ((relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host) || this.port !== relativeUri.port ||
                (this.protocol !== relativeUri.protocol && relativeUri.protocol !== '')) {
                return relativeUri.getURI();
            }
            const tu = this.getURI(), uu = relativeUri.getURI();
            // Allow usage of the base_uri when relative_urls = true
            if (tu === uu || (tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu)) {
                return tu;
            }
            let output = this.toRelPath(this.path, relativeUri.path);
            // Add query
            if (relativeUri.query) {
                output += '?' + relativeUri.query;
            }
            // Add anchor
            if (relativeUri.anchor) {
                output += '#' + relativeUri.anchor;
            }
            return output;
        }
        /**
         * Converts the specified URI into a absolute URI based on the current URI instance location.
         *
         * @method toAbsolute
         * @param {String} uri URI to convert into a relative path/URI.
         * @param {Boolean} noHost No host and protocol prefix.
         * @return {String} Absolute URI from the point specified in the current URI instance.
         * @example
         * // Converts an relative URL to an absolute URL url will be http://www.site.com/dir/somedir/somefile.htm
         * const url = new tinymce.util.URI('http://www.site.com/dir/').toAbsolute('somedir/somefile.htm');
         */
        toAbsolute(uri, noHost) {
            const absoluteUri = new URI(uri, { base_uri: this });
            return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
        }
        /**
         * Determine whether the given URI has the same origin as this URI.  Based on RFC-6454.
         * Supports default ports for protocols listed in DEFAULT_PORTS.  Unsupported protocols will fail safe: they
         * won't match, if the port specifications differ.
         *
         * @method isSameOrigin
         * @param {tinymce.util.URI} uri Uri instance to compare.
         * @returns {Boolean} True if the origins are the same.
         */
        isSameOrigin(uri) {
            // eslint-disable-next-line eqeqeq
            if (this.host == uri.host && this.protocol == uri.protocol) {
                // eslint-disable-next-line eqeqeq
                if (this.port == uri.port) {
                    return true;
                }
                const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;
                // eslint-disable-next-line eqeqeq
                if (defaultPort && ((this.port || defaultPort) == (uri.port || defaultPort))) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Converts a absolute path into a relative path.
         *
         * @method toRelPath
         * @param {String} base Base point to convert the path from.
         * @param {String} path Absolute path to convert into a relative path.
         */
        toRelPath(base, path) {
            let breakPoint = 0, out = '', i, l;
            // Split the paths
            const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');
            const items = path.split('/');
            if (normalizedBase.length >= items.length) {
                for (i = 0, l = normalizedBase.length; i < l; i++) {
                    if (i >= items.length || normalizedBase[i] !== items[i]) {
                        breakPoint = i + 1;
                        break;
                    }
                }
            }
            if (normalizedBase.length < items.length) {
                for (i = 0, l = items.length; i < l; i++) {
                    if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
                        breakPoint = i + 1;
                        break;
                    }
                }
            }
            if (breakPoint === 1) {
                return path;
            }
            for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {
                out += '../';
            }
            for (i = breakPoint - 1, l = items.length; i < l; i++) {
                if (i !== breakPoint - 1) {
                    out += '/' + items[i];
                }
                else {
                    out += items[i];
                }
            }
            return out;
        }
        /**
         * Converts a relative path into a absolute path.
         *
         * @method toAbsPath
         * @param {String} base Base point to convert the path from.
         * @param {String} path Relative path to convert into an absolute path.
         */
        toAbsPath(base, path) {
            let nb = 0;
            // Split paths
            const tr = /\/$/.test(path) ? '/' : '';
            const normalizedBase = base.split('/');
            const normalizedPath = path.split('/');
            // Remove empty chunks
            const baseParts = [];
            each$6(normalizedBase, (k) => {
                if (k) {
                    baseParts.push(k);
                }
            });
            // Merge relURLParts chunks
            const pathParts = [];
            for (let i = normalizedPath.length - 1; i >= 0; i--) {
                // Ignore empty or .
                if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {
                    continue;
                }
                // Is parent
                if (normalizedPath[i] === '..') {
                    nb++;
                    continue;
                }
                // Move up
                if (nb > 0) {
                    nb--;
                    continue;
                }
                pathParts.push(normalizedPath[i]);
            }
            const i = baseParts.length - nb;
            // If /a/b/c or /
            let outPath;
            if (i <= 0) {
                outPath = reverse(pathParts).join('/');
            }
            else {
                outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');
            }
            // Add front / if it's needed
            if (outPath.indexOf('/') !== 0) {
                outPath = '/' + outPath;
            }
            // Add trailing / if it's needed
            if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {
                outPath += tr;
            }
            return outPath;
        }
        /**
         * Returns the full URI of the internal structure.
         *
         * @method getURI
         * @param {Boolean} noProtoHost Optional no host and protocol part. Defaults to false.
         */
        getURI(noProtoHost = false) {
            let s;
            // Rebuild source
            if (!this.source || noProtoHost) {
                s = '';
                if (!noProtoHost) {
                    if (this.protocol) {
                        s += this.protocol + '://';
                    }
                    else {
                        s += '//';
                    }
                    if (this.userInfo) {
                        s += this.userInfo + '@';
                    }
                    if (this.host) {
                        s += this.host;
                    }
                    if (this.port) {
                        s += ':' + this.port;
                    }
                }
                if (this.path) {
                    s += this.path;
                }
                if (this.query) {
                    s += '?' + this.query;
                }
                if (this.anchor) {
                    s += '#' + this.anchor;
                }
                this.source = s;
            }
            return this.source;
        }
    }

    // A list of attributes that should be filtered further based on the parser settings
    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');
    const internalElementAttr = 'data-mce-type';
    let uid = 0;
    const processNode = (node, settings, schema, scope, evt) => {
        var _a, _b, _c, _d;
        const validate = settings.validate;
        const specialElements = schema.getSpecialElements();
        if (node.nodeType === COMMENT) {
            // Pad conditional comments if they aren't allowed
            if (!settings.allow_conditional_comments && /^\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {
                node.nodeValue = ' ' + node.nodeValue;
            }
            if (settings.sanitize && settings.allow_html_in_comments && isString(node.nodeValue)) {
                node.nodeValue = encodeData(node.nodeValue);
            }
        }
        const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();
        if (scope !== 'html' && schema.isValid(scope)) {
            if (isNonNullable(evt)) {
                evt.allowedTags[lcTagName] = true;
            }
            return;
        }
        // Just leave non-elements such as text and comments up to dompurify
        if (node.nodeType !== ELEMENT || lcTagName === 'body') {
            return;
        }
        // Construct the sugar element wrapper
        const element = SugarElement.fromDom(node);
        // Determine if we're dealing with an internal attribute
        const isInternalElement = has$1(element, internalElementAttr);
        // Cleanup bogus elements
        const bogus = get$9(element, 'data-mce-bogus');
        if (!isInternalElement && isString(bogus)) {
            if (bogus === 'all') {
                remove$8(element);
            }
            else {
                unwrap(element);
            }
            return;
        }
        // Determine if the schema allows the element and either add it or remove it
        const rule = schema.getElementRule(lcTagName);
        if (validate && !rule) {
            // If a special element is invalid, then remove the entire element instead of unwrapping
            if (has$2(specialElements, lcTagName)) {
                remove$8(element);
            }
            else {
                unwrap(element);
            }
            return;
        }
        else {
            if (isNonNullable(evt)) {
                evt.allowedTags[lcTagName] = true;
            }
        }
        // Validate the element using the attribute rules
        if (validate && rule && !isInternalElement) {
            // Fix the attributes for the element, unwrapping it if we have to
            each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], (attr) => {
                set$4(element, attr.name, attr.value === '{$uid}' ? `mce_${uid++}` : attr.value);
            });
            each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], (attr) => {
                if (!has$1(element, attr.name)) {
                    set$4(element, attr.name, attr.value === '{$uid}' ? `mce_${uid++}` : attr.value);
                }
            });
            // If none of the required attributes were found then remove
            if (rule.attributesRequired && !exists(rule.attributesRequired, (attr) => has$1(element, attr))) {
                unwrap(element);
                return;
            }
            // If there are no attributes then remove
            if (rule.removeEmptyAttrs && hasNone(element)) {
                unwrap(element);
                return;
            }
            // Change the node name if the schema says to
            if (rule.outputName && rule.outputName !== lcTagName) {
                mutate(element, rule.outputName);
            }
        }
    };
    const processAttr = (ele, settings, schema, scope, evt) => {
        const tagName = ele.tagName.toLowerCase();
        const { attrName, attrValue } = evt;
        evt.keepAttr = shouldKeepAttribute(settings, schema, scope, tagName, attrName, attrValue);
        if (evt.keepAttr) {
            evt.allowedAttributes[attrName] = true;
            if (isBooleanAttribute(attrName, schema)) {
                evt.attrValue = attrName;
            }
            // We need to tell DOMPurify to forcibly keep the attribute if it's an SVG data URI and svg data URIs are allowed
            if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {
                evt.forceKeepAttr = true;
            }
            // For internal elements always keep the attribute if the attribute name is id, class or style
        }
        else if (isRequiredAttributeOfInternalElement(ele, attrName)) {
            evt.forceKeepAttr = true;
        }
    };
    const shouldKeepAttribute = (settings, schema, scope, tagName, attrName, attrValue) => {
        // All attributes within non HTML namespaces elements are considered valid
        if (scope !== 'html' && !isNonHtmlElementRootName(tagName)) {
            return true;
        }
        return !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) &&
            (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));
    };
    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');
    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();
    const filterAttributes = (ele, settings, schema, scope) => {
        const { attributes } = ele;
        for (let i = attributes.length - 1; i >= 0; i--) {
            const attr = attributes[i];
            const attrName = attr.name;
            const attrValue = attr.value;
            if (!shouldKeepAttribute(settings, schema, scope, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {
                ele.removeAttribute(attrName);
            }
            else if (isBooleanAttribute(attrName, schema)) {
                ele.setAttribute(attrName, attrName);
            }
        }
    };
    const setupPurify = (settings, schema, namespaceTracker) => {
        const purify$1 = purify();
        // We use this to add new tags to the allow-list as we parse, if we notice that a tag has been banned but it's still in the schema
        purify$1.addHook('uponSanitizeElement', (ele, evt) => {
            processNode(ele, settings, schema, namespaceTracker.track(ele), evt);
        });
        // Let's do the same thing for attributes
        purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {
            processAttr(ele, settings, schema, namespaceTracker.current(), evt);
        });
        return purify$1;
    };
    const getPurifyConfig = (settings, mimeType) => {
        const basePurifyConfig = {
            IN_PLACE: true,
            ALLOW_UNKNOWN_PROTOCOLS: true,
            // Deliberately ban all tags and attributes by default, and then un-ban them on demand in hooks
            // #comment and #cdata-section are always allowed as they aren't controlled via the schema
            // body is also allowed due to the DOMPurify checking the root node before sanitizing
            ALLOWED_TAGS: ['#comment', '#cdata-section', 'body'],
            ALLOWED_ATTR: []
        };
        const config = { ...basePurifyConfig };
        // Set the relevant parser mimetype
        config.PARSER_MEDIA_TYPE = mimeType;
        // Allow any URI when allowing script urls
        if (settings.allow_script_urls) {
            config.ALLOWED_URI_REGEXP = /.*/;
            // Allow anything except javascript (or similar) URIs if all html data urls are allowed
        }
        else if (settings.allow_html_data_urls) {
            config.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i;
        }
        return config;
    };
    const sanitizeSvgElement = (ele) => {
        // xlink:href used to be the way to do links in SVG 1.x https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xlink:href
        const xlinkAttrs = ['type', 'href', 'role', 'arcrole', 'title', 'show', 'actuate', 'label', 'from', 'to'].map((name) => `xlink:${name}`);
        const config = {
            IN_PLACE: true,
            USE_PROFILES: {
                html: true,
                svg: true,
                svgFilters: true
            },
            ALLOWED_ATTR: xlinkAttrs
        };
        purify().sanitize(ele, config);
    };
    const sanitizeMathmlElement = (node, settings) => {
        const config = {
            IN_PLACE: true,
            USE_PROFILES: {
                mathMl: true
            },
        };
        const purify$1 = purify();
        const allowedEncodings = settings.allow_mathml_annotation_encodings;
        const hasAllowedEncodings = isArray$1(allowedEncodings) && allowedEncodings.length > 0;
        const hasValidEncoding = (el) => {
            const encoding = el.getAttribute('encoding');
            return hasAllowedEncodings && isString(encoding) && contains$2(allowedEncodings, encoding);
        };
        const isValidElementOpt = (node, lcTagName) => {
            if (hasAllowedEncodings && lcTagName === 'semantics') {
                return Optional.some(true);
            }
            else if (lcTagName === 'annotation') {
                return Optional.some(isElement$7(node) && hasValidEncoding(node));
            }
            else if (isArray$1(settings.extended_mathml_elements)) {
                if (settings.extended_mathml_elements.includes(lcTagName)) {
                    return Optional.from(true);
                }
                else {
                    return Optional.none();
                }
            }
            else {
                return Optional.none();
            }
        };
        purify$1.addHook('uponSanitizeElement', (node, evt) => {
            var _a;
            // We know the node is an element as we have
            // passed an element to the purify.sanitize function below
            const lcTagName = (_a = evt.tagName) !== null && _a !== void 0 ? _a : node.nodeName.toLowerCase();
            const keepElementOpt = isValidElementOpt(node, lcTagName);
            keepElementOpt.each((keepElement) => {
                evt.allowedTags[lcTagName] = keepElement;
                if (!keepElement && settings.sanitize) {
                    if (isElement$7(node)) {
                        node.remove();
                    }
                }
            });
        });
        purify$1.addHook('uponSanitizeAttribute', (_node, event) => {
            if (isArray$1(settings.extended_mathml_attributes)) {
                const keepAttribute = settings.extended_mathml_attributes.includes(event.attrName);
                if (keepAttribute) {
                    event.forceKeepAttr = true;
                }
            }
        });
        purify$1.sanitize(node, config);
    };
    const mkSanitizeNamespaceElement = (settings) => (ele) => {
        const namespaceType = toScopeType(ele);
        if (namespaceType === 'svg') {
            sanitizeSvgElement(ele);
        }
        else if (namespaceType === 'math') {
            sanitizeMathmlElement(ele, settings);
        }
        else {
            throw new Error('Not a namespace element');
        }
    };
    const getSanitizer = (settings, schema) => {
        const namespaceTracker = createNamespaceTracker();
        if (settings.sanitize) {
            const purify = setupPurify(settings, schema, namespaceTracker);
            const sanitizeHtmlElement = (body, mimeType) => {
                purify.sanitize(body, getPurifyConfig(settings, mimeType));
                purify.removed = [];
                namespaceTracker.reset();
            };
            return {
                sanitizeHtmlElement,
                sanitizeNamespaceElement: mkSanitizeNamespaceElement(settings)
            };
        }
        else {
            const sanitizeHtmlElement = (body, _mimeType) => {
                // eslint-disable-next-line no-bitwise
                const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
                let node;
                while ((node = nodeIterator.nextNode())) {
                    const currentScope = namespaceTracker.track(node);
                    processNode(node, settings, schema, currentScope);
                    if (isElement$7(node)) {
                        filterAttributes(node, settings, schema, currentScope);
                    }
                }
                namespaceTracker.reset();
            };
            const sanitizeNamespaceElement = noop;
            return {
                sanitizeHtmlElement,
                sanitizeNamespaceElement
            };
        }
    };

    /**
     * @summary
     * This class parses HTML code into a DOM like structure of nodes it will remove redundant whitespace and make
     * sure that the node tree is valid according to the specified schema.
     * So for example: `<p>a<p>b</p>c</p>` will become `<p>a</p><p>b</p><p>c</p>`.
     *
     * @example
     * const parser = tinymce.html.DomParser({ validate: true }, schema);
     * const rootNode = parser.parse('<h1>content</h1>');
     *
     * @class tinymce.html.DomParser
     * @version 3.4
     */
    const extraBlockLikeElements = ['script', 'style', 'template', 'param'];
    const makeMap = Tools.makeMap, extend$1 = Tools.extend;
    const transferChildren = (parent, nativeParent, specialElements, nsSanitizer, decodeComments) => {
        const parentName = parent.name;
        // Exclude the special elements where the content is RCDATA as their content needs to be parsed instead of being left as plain text
        // See: https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
        const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea' && parentName !== 'noscript';
        const childNodes = nativeParent.childNodes;
        for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {
            const nativeChild = childNodes[ni];
            const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);
            if (isElement$7(nativeChild)) {
                const attributes = nativeChild.attributes;
                for (let ai = 0, al = attributes.length; ai < al; ai++) {
                    const attr = attributes[ai];
                    child.attr(attr.name, attr.value);
                }
                if (isNonHtmlElementRootName(child.name)) {
                    nsSanitizer(nativeChild);
                    child.value = nativeChild.innerHTML;
                }
            }
            else if (isText$b(nativeChild)) {
                child.value = nativeChild.data;
                if (isSpecial) {
                    child.raw = true;
                }
            }
            else if (isComment(nativeChild)) {
                child.value = decodeComments ? decodeData$1(nativeChild.data) : nativeChild.data;
            }
            else if (isCData(nativeChild) || isPi(nativeChild)) {
                child.value = nativeChild.data;
            }
            if (isTemplate(nativeChild)) {
                const content = AstNode.create('#text');
                content.value = nativeChild.innerHTML;
                content.raw = true;
                child.append(content);
            }
            else if (!isNonHtmlElementRootName(child.name)) {
                transferChildren(child, nativeChild, specialElements, nsSanitizer, decodeComments);
            }
            parent.append(child);
        }
    };
    const walkTree = (root, preprocessors, postprocessors) => {
        const traverseOrder = [];
        for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {
            const tempNode = node;
            each$e(preprocessors, (preprocess) => preprocess(tempNode));
            if (isNullable(tempNode.parent) && tempNode !== root) {
                // The node has been detached, so rewind a little and don't add it to our traversal
                node = lastNode;
            }
            else {
                traverseOrder.push(tempNode);
            }
        }
        for (let i = traverseOrder.length - 1; i >= 0; i--) {
            const node = traverseOrder[i];
            each$e(postprocessors, (postprocess) => postprocess(node));
        }
    };
    // All the dom operations we want to perform, regardless of whether we're trying to properly validate things
    // e.g. removing excess whitespace
    // e.g. removing empty nodes (or padding them with <br>)
    //
    // Returns [ preprocess, postprocess ]
    const whitespaceCleaner = (root, schema, settings, args) => {
        const validate = settings.validate;
        const nonEmptyElements = schema.getNonEmptyElements();
        const whitespaceElements = schema.getWhitespaceElements();
        const blockElements = extend$1(makeMap(extraBlockLikeElements), schema.getBlockElements());
        const textRootBlockElements = getTextRootBlockElements(schema);
        const allWhiteSpaceRegExp = /[ \t\r\n]+/g;
        const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
        const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
        const hasWhitespaceParent = (node) => {
            let tempNode = node.parent;
            while (isNonNullable(tempNode)) {
                if (tempNode.name in whitespaceElements) {
                    return true;
                }
                else {
                    tempNode = tempNode.parent;
                }
            }
            return false;
        };
        const isTextRootBlockEmpty = (node) => {
            let tempNode = node;
            while (isNonNullable(tempNode)) {
                if (tempNode.name in textRootBlockElements) {
                    return isEmpty$2(schema, nonEmptyElements, whitespaceElements, tempNode);
                }
                else {
                    tempNode = tempNode.parent;
                }
            }
            return false;
        };
        const isBlock = (node) => node.name in blockElements || isTransparentAstBlock(schema, node) || (isNonHtmlElementRootName(node.name) && node.parent === root);
        const isAtEdgeOfBlock = (node, start) => {
            const neighbour = start ? node.prev : node.next;
            if (isNonNullable(neighbour) || isNullable(node.parent)) {
                return false;
            }
            // Make sure our parent is actually a block, and also make sure it isn't a temporary "context" element
            // that we're probably going to unwrap as soon as we insert this content into the editor
            return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);
        };
        const preprocess = (node) => {
            var _a;
            if (node.type === 3) {
                // Remove leading whitespace here, so that all whitespace in nodes to the left of us has already been fixed
                if (!hasWhitespaceParent(node)) {
                    let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
                    text = text.replace(allWhiteSpaceRegExp, ' ');
                    if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {
                        text = text.replace(startWhiteSpaceRegExp, '');
                    }
                    if (text.length === 0) {
                        node.remove();
                    }
                    else if (text === ' ' && node.prev && node.prev.type === COMMENT && node.next && node.next.type === COMMENT) {
                        node.remove();
                    }
                    else {
                        node.value = text;
                    }
                }
            }
        };
        const postprocess = (node) => {
            var _a;
            if (node.type === 1) {
                // Check for empty nodes here, because children will have been processed and (if necessary) emptied / removed already
                const elementRule = schema.getElementRule(node.name);
                if (validate && elementRule) {
                    const isNodeEmpty = isEmpty$2(schema, nonEmptyElements, whitespaceElements, node);
                    if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {
                        paddEmptyNode(settings, args, isBlock, node);
                    }
                    else if (elementRule.removeEmpty && isNodeEmpty) {
                        if (isBlock(node)) {
                            node.remove();
                        }
                        else {
                            node.unwrap();
                        }
                    }
                    else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {
                        paddEmptyNode(settings, args, isBlock, node);
                    }
                }
            }
            else if (node.type === 3) {
                // Removing trailing whitespace here, so that all whitespace in nodes to the right of us has already been fixed
                if (!hasWhitespaceParent(node)) {
                    let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
                    if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {
                        text = text.replace(endWhiteSpaceRegExp, '');
                    }
                    if (text.length === 0) {
                        node.remove();
                    }
                    else {
                        node.value = text;
                    }
                }
            }
        };
        return [preprocess, postprocess];
    };
    const getRootBlockName = (settings, args) => {
        var _a;
        const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;
        if (name === false) {
            return '';
        }
        else if (name === true) {
            return 'p';
        }
        else {
            return name;
        }
    };
    const DomParser = (settings = {}, schema = Schema()) => {
        const nodeFilterRegistry = create$8();
        const attributeFilterRegistry = create$8();
        // Apply setting defaults
        const defaultedSettings = {
            validate: true,
            root_name: 'body',
            sanitize: true,
            allow_html_in_comments: false,
            ...settings
        };
        const parser = new DOMParser();
        const sanitizer = getSanitizer(defaultedSettings, schema);
        const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {
            const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';
            // Determine the root element to wrap the HTML in when parsing. If we're dealing with a
            // special element then we need to wrap it so the internal content is handled appropriately.
            const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());
            const content = isSpecialRoot ? `<${rootName}>${html}</${rootName}>` : html;
            const makeWrap = () => {
                if (format === 'xhtml') {
                    // If parsing XHTML then the content must contain the xmlns declaration, see https://www.w3.org/TR/xhtml1/normative.html#strict
                    return `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${content}</body></html>`;
                }
                else if (/^[\s]*<head/i.test(html) || /^[\s]*<html/i.test(html) || /^[\s]*<!DOCTYPE/i.test(html)) {
                    return `<html>${content}</html>`;
                }
                else {
                    return `<body>${content}</body>`;
                }
            };
            const body = parser.parseFromString(makeWrap(), mimeType).body;
            sanitizer.sanitizeHtmlElement(body, mimeType);
            return isSpecialRoot ? body.firstChild : body;
        };
        /**
         * Adds a node filter function to the parser, the parser will collect the specified nodes by name
         * and then execute the callback once it has finished parsing the document.
         *
         * @method addNodeFilter
         * @param {String} name Comma separated list of nodes to collect.
         * @param {Function} callback Callback function to execute once it has collected nodes.
         * @example
         * parser.addNodeFilter('p,h1', (nodes, name) => {
         *   for (var i = 0; i < nodes.length; i++) {
         *     console.log(nodes[i].name);
         *   }
         * });
         */
        const addNodeFilter = nodeFilterRegistry.addFilter;
        const getNodeFilters = nodeFilterRegistry.getFilters;
        /**
         * Removes a node filter function or removes all filter functions from the parser for the node names provided.
         *
         * @method removeNodeFilter
         * @param {String} name Comma separated list of node names to remove filters for.
         * @param {Function} callback Optional callback function to only remove a specific callback.
         * @example
         * // Remove a single filter
         * parser.removeNodeFilter('p,h1', someCallback);
         *
         * // Remove all filters
         * parser.removeNodeFilter('p,h1');
         */
        const removeNodeFilter = nodeFilterRegistry.removeFilter;
        /**
         * Adds an attribute filter function to the parser, the parser will collect nodes that has the specified attributes
         * and then execute the callback once it has finished parsing the document.
         *
         * @method addAttributeFilter
         * @param {String} name Comma separated list of attributes to collect.
         * @param {Function} callback Callback function to execute once it has collected nodes.
         * @example
         * parser.addAttributeFilter('src,href', (nodes, name) => {
         *   for (let i = 0; i < nodes.length; i++) {
         *     console.log(nodes[i].name);
         *   }
         * });
         */
        const addAttributeFilter = attributeFilterRegistry.addFilter;
        const getAttributeFilters = attributeFilterRegistry.getFilters;
        /**
         * Removes an attribute filter function or removes all filter functions from the parser for the attribute names provided.
         *
         * @method removeAttributeFilter
         * @param {String} name Comma separated list of attribute names to remove filters for.
         * @param {Function} callback Optional callback function to only remove a specific callback.
         * @example
         * // Remove a single filter
         * parser.removeAttributeFilter('src,href', someCallback);
         *
         * // Remove all filters
         * parser.removeAttributeFilter('src,href');
         */
        const removeAttributeFilter = attributeFilterRegistry.removeFilter;
        const findInvalidChildren = (node, invalidChildren) => {
            if (isInvalid(schema, node)) {
                invalidChildren.push(node);
            }
        };
        const isWrappableNode = (blockElements, node) => {
            const isInternalElement = isString(node.attr(internalElementAttr));
            const isInlineElement = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node)) && !isNonHtmlElementRootName(node.name);
            return node.type === 3 || (isInlineElement && !isInternalElement);
        };
        const addRootBlocks = (rootNode, rootBlockName) => {
            const blockElements = extend$1(makeMap(extraBlockLikeElements), schema.getBlockElements());
            const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
            const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
            let node = rootNode.firstChild, rootBlockNode = null;
            // Removes whitespace at beginning and end of block so:
            // <p> x </p> -> <p>x</p>
            const trim = (rootBlock) => {
                var _a, _b;
                if (rootBlock) {
                    node = rootBlock.firstChild;
                    if (node && node.type === 3) {
                        node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');
                    }
                    node = rootBlock.lastChild;
                    if (node && node.type === 3) {
                        node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');
                    }
                }
            };
            // Check if rootBlock is valid within rootNode for example if P is valid in H1 if H1 is the contentEditable root
            if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
                return;
            }
            while (node) {
                const next = node.next;
                if (isWrappableNode(blockElements, node)) {
                    if (!rootBlockNode) {
                        // Create a new root block element
                        rootBlockNode = new AstNode(rootBlockName, 1);
                        rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);
                        rootNode.insert(rootBlockNode, node);
                        rootBlockNode.append(node);
                    }
                    else {
                        rootBlockNode.append(node);
                    }
                }
                else {
                    trim(rootBlockNode);
                    rootBlockNode = null;
                }
                node = next;
            }
            trim(rootBlockNode);
        };
        /**
         * Parses the specified HTML string into a DOM like node tree and returns the result.
         *
         * @method parse
         * @param {String} html Html string to sax parse.
         * @param {Object} args Optional args object that gets passed to all filter functions.
         * @return {tinymce.html.Node} Root node containing the tree.
         * @example
         * const rootNode = tinymce.html.DomParser({...}).parse('<b>text</b>');
         */
        const parse = (html, args = {}) => {
            var _a;
            const validate = defaultedSettings.validate;
            const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;
            // Parse and sanitize the content
            const element = parseAndSanitizeWithContext(html, rootName, args.format);
            updateChildren(schema, element);
            // Create the AST representation
            const rootNode = new AstNode(rootName, 11);
            transferChildren(rootNode, element, schema.getSpecialElements(), sanitizer.sanitizeNamespaceElement, defaultedSettings.sanitize && defaultedSettings.allow_html_in_comments);
            // This next line is needed to fix a memory leak in chrome and firefox.
            // For more information see TINY-9186
            element.innerHTML = '';
            // Set up whitespace fixes
            const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);
            // Find the invalid children in the tree
            const invalidChildren = [];
            const invalidFinder = validate ? (node) => findInvalidChildren(node, invalidChildren) : noop;
            // Set up attribute and node matching
            const matches = { nodes: {}, attributes: {} };
            const matchFinder = (node) => matchNode(getNodeFilters(), getAttributeFilters(), node, matches);
            // Walk the dom, apply all of the above things
            walkTree(rootNode, [whitespacePre, matchFinder], [whitespacePost, invalidFinder]);
            // Because we collected invalid children while walking backwards, we need to reverse the list before operating on them
            invalidChildren.reverse();
            // Fix invalid children or report invalid children in a contextual parsing
            if (validate && invalidChildren.length > 0) {
                if (args.context) {
                    args.invalid = true;
                }
                else {
                    cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);
                }
            }
            // Wrap nodes in the root into block elements if the root is body
            const rootBlockName = getRootBlockName(defaultedSettings, args);
            if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {
                addRootBlocks(rootNode, rootBlockName);
            }
            // Run filters only when the contents is valid
            if (!args.invalid) {
                runFilters(matches, args);
            }
            return rootNode;
        };
        const exports = {
            schema,
            addAttributeFilter,
            getAttributeFilters,
            removeAttributeFilter,
            addNodeFilter,
            getNodeFilters,
            removeNodeFilter,
            parse
        };
        register$4(exports, defaultedSettings);
        register$5(exports, defaultedSettings, schema);
        return exports;
    };

    const isTreeNode = (content) => content instanceof AstNode;

    const serializeContent = (content) => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;
    const withSerializedContent = (content, fireEvent, parserSettings) => {
        const serializedContent = serializeContent(content);
        const eventArgs = fireEvent(serializedContent);
        if (eventArgs.isDefaultPrevented()) {
            return eventArgs;
        }
        else if (isTreeNode(content)) {
            // Restore the content type back to being an AstNode. If the content has changed we need to
            // re-parse the new content, otherwise we can return the input.
            if (eventArgs.content !== serializedContent) {
                const rootNode = DomParser({ validate: false, forced_root_block: false, ...parserSettings }).parse(eventArgs.content, { context: content.name });
                return { ...eventArgs, content: rootNode };
            }
            else {
                return { ...eventArgs, content };
            }
        }
        else {
            return eventArgs;
        }
    };
    const makeParserSettings = (editor) => ({
        sanitize: shouldSanitizeXss(editor),
        sandbox_iframes: shouldSandboxIframes(editor),
        sandbox_iframes_exclusions: getSandboxIframesExclusions(editor)
    });
    const preProcessGetContent = (editor, args) => {
        if (args.no_events) {
            return Result.value(args);
        }
        else {
            const eventArgs = fireBeforeGetContent(editor, args);
            if (eventArgs.isDefaultPrevented()) {
                return Result.error(fireGetContent(editor, { content: '', ...eventArgs }).content);
            }
            else {
                return Result.value(eventArgs);
            }
        }
    };
    const postProcessGetContent = (editor, content, args) => {
        if (args.no_events) {
            return content;
        }
        else {
            const processedEventArgs = withSerializedContent(content, (content) => fireGetContent(editor, { ...args, content }), makeParserSettings(editor));
            return processedEventArgs.content;
        }
    };
    const preProcessSetContent = (editor, args) => {
        if (args.no_events) {
            return Result.value(args);
        }
        else {
            const processedEventArgs = withSerializedContent(args.content, (content) => fireBeforeSetContent(editor, { ...args, content }), makeParserSettings(editor));
            if (processedEventArgs.isDefaultPrevented()) {
                fireSetContent(editor, processedEventArgs);
                return Result.error(undefined);
            }
            else {
                return Result.value(processedEventArgs);
            }
        }
    };
    const postProcessSetContent = (editor, content, args) => {
        if (!args.no_events) {
            fireSetContent(editor, { ...args, content });
        }
    };

    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' +
        'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' +
        'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' +
        'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' +
        'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' +
        'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists,' +
        'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format').split(',');
    // const deprecatedOptions: string[] = ('').split(',');
    const deprecatedOptions = [];
    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,template,textcolor,rtc'.split(',');
    const deprecatedPlugins = [
        {
            name: 'export',
            replacedWith: 'Export to PDF'
        },
    ];
    const getMatchingOptions = (options, searchingFor) => {
        const settingNames = filter$5(searchingFor, (setting) => has$2(options, setting));
        return sort(settingNames);
    };
    const getRemovedOptions = (options) => {
        const settingNames = getMatchingOptions(options, removedOptions);
        // Forced root block is a special case whereby only the empty/false value is deprecated
        const forcedRootBlock = options.forced_root_block;
        // Note: This cast is required for old configurations as forced root block used to allow a boolean
        if (forcedRootBlock === false || forcedRootBlock === '') {
            settingNames.push('forced_root_block (false only)');
        }
        return sort(settingNames);
    };
    const getDeprecatedOptions = (options) => getMatchingOptions(options, deprecatedOptions);
    const getMatchingPlugins = (options, searchingFor) => {
        const plugins = Tools.makeMap(options.plugins, ' ');
        const hasPlugin = (plugin) => has$2(plugins, plugin);
        const pluginNames = filter$5(searchingFor, hasPlugin);
        return sort(pluginNames);
    };
    const getRemovedPlugins = (options) => getMatchingPlugins(options, removedPlugins);
    const getDeprecatedPlugins = (options) => getMatchingPlugins(options, deprecatedPlugins.map((entry) => entry.name));
    const logRemovedWarnings = (rawOptions, normalizedOptions) => {
        // Note: Ensure we use the original user settings, not the final when logging
        const removedOptions = getRemovedOptions(rawOptions);
        const removedPlugins = getRemovedPlugins(normalizedOptions);
        const hasRemovedPlugins = removedPlugins.length > 0;
        const hasRemovedOptions = removedOptions.length > 0;
        const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';
        if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {
            const listJoiner = '\n- ';
            const themesMessage = isLegacyMobileTheme ? `\n\nThemes:${listJoiner}mobile` : '';
            const pluginsMessage = hasRemovedPlugins ? `\n\nPlugins:${listJoiner}${removedPlugins.join(listJoiner)}` : '';
            const optionsMessage = hasRemovedOptions ? `\n\nOptions:${listJoiner}${removedOptions.join(listJoiner)}` : '';
            // eslint-disable-next-line no-console
            console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 8.0. These features will no longer work and should be removed from the TinyMCE configuration. ' +
                'See https://www.tiny.cloud/docs/tinymce/8/migration-from-7x/ for more information.' +
                themesMessage +
                pluginsMessage +
                optionsMessage);
        }
    };
    const getPluginDescription = (name) => find$2(deprecatedPlugins, (entry) => entry.name === name).fold(() => name, (entry) => {
        if (entry.replacedWith) {
            return `${name}, replaced by ${entry.replacedWith}`;
        }
        else {
            return name;
        }
    });
    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {
        // Note: Ensure we use the original user settings, not the final when logging
        const deprecatedOptions = getDeprecatedOptions(rawOptions);
        const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);
        const hasDeprecatedPlugins = deprecatedPlugins.length > 0;
        const hasDeprecatedOptions = deprecatedOptions.length > 0;
        if (hasDeprecatedPlugins || hasDeprecatedOptions) {
            const listJoiner = '\n- ';
            const pluginsMessage = hasDeprecatedPlugins ? `\n\nPlugins:${listJoiner}${deprecatedPlugins.map(getPluginDescription).join(listJoiner)}` : '';
            const optionsMessage = hasDeprecatedOptions ? `\n\nOptions:${listJoiner}${deprecatedOptions.join(listJoiner)}` : '';
            // eslint-disable-next-line no-console
            console.warn('The following deprecated features are currently enabled but will be removed soon.' +
                pluginsMessage +
                optionsMessage);
        }
    };
    const logWarnings = (rawOptions, normalizedOptions) => {
        logRemovedWarnings(rawOptions, normalizedOptions);
        logDeprecatedWarnings(rawOptions, normalizedOptions);
    };
    const deprecatedFeatures = {
        fire: 'The "fire" event api has been deprecated and will be removed in TinyMCE 9. Use "dispatch" instead.',
        selectionSetContent: 'The "editor.selection.setContent" method has been deprecated and will be removed in TinyMCE 9. Use "editor.insertContent" instead.'
    };
    const logFeatureDeprecationWarning = (feature) => {
        // eslint-disable-next-line no-console
        console.warn(deprecatedFeatures[feature], new Error().stack);
    };

    const removeEmpty = (text) => {
        if (text.dom.length === 0) {
            remove$8(text);
            return Optional.none();
        }
        else {
            return Optional.some(text);
        }
    };
    const walkPastBookmark = (node, start) => node.filter((elm) => BookmarkManager.isBookmarkNode(elm.dom))
        .bind(start ? nextSibling : prevSibling);
    const merge = (outer, inner, rng, start, schema) => {
        const outerElm = outer.dom;
        const innerElm = inner.dom;
        const oldLength = start ? outerElm.length : innerElm.length;
        if (start) {
            mergeTextNodes(outerElm, innerElm, schema, false, !start);
            rng.setStart(innerElm, oldLength);
        }
        else {
            mergeTextNodes(innerElm, outerElm, schema, false, !start);
            rng.setEnd(innerElm, oldLength);
        }
    };
    const normalizeTextIfRequired = (inner, start, schema) => {
        parent(inner).each((root) => {
            const text = inner.dom;
            if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {
                normalizeWhitespaceAfter(text, 0, schema);
            }
            else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length), schema)) {
                normalizeWhitespaceBefore(text, text.length, schema);
            }
        });
    };
    const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {
        outerNode.bind((outer) => {
            // Normalize the text outside the inserted content
            const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;
            normalizer(outer.dom, start ? outer.dom.length : 0, schema);
            // Merge the inserted content with other text nodes
            return innerNode.filter(isText$c).map((inner) => merge(outer, inner, rng, start, schema));
        }).orThunk(() => {
            // Note: Attempt to leave the inserted/inner content as is and only adjust if absolutely required
            const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$c);
            return innerTextNode.map((inner) => normalizeTextIfRequired(inner, start, schema));
        });
    };
    const rngSetContent = (rng, fragment, schema) => {
        const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);
        const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);
        rng.deleteContents();
        rng.insertNode(fragment);
        const prevText = firstChild.bind(prevSibling).filter(isText$c).bind(removeEmpty);
        const nextText = lastChild.bind(nextSibling).filter(isText$c).bind(removeEmpty);
        // Join and normalize text
        mergeAndNormalizeText(prevText, firstChild, rng, true, schema);
        mergeAndNormalizeText(nextText, lastChild, rng, false, schema);
        rng.collapse(false);
    };
    const setupArgs$3 = (args, content) => ({
        format: 'html',
        ...args,
        set: true,
        selection: true,
        content
    });
    const cleanContent = (editor, args) => {
        if (args.format !== 'raw') {
            // Find which context to parse the content in
            const rng = editor.selection.getRng();
            const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);
            const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};
            const node = editor.parser.parse(args.content, { forced_root_block: false, ...contextArgs, ...args });
            return HtmlSerializer({ validate: false }, editor.schema).serialize(node);
        }
        else {
            return args.content;
        }
    };
    const setContentInternal$1 = (editor, content, args = {}) => {
        const defaultedArgs = setupArgs$3(args, content);
        preProcessSetContent(editor, defaultedArgs).each((updatedArgs) => {
            // Sanitize the content
            const cleanedContent = cleanContent(editor, updatedArgs);
            const rng = editor.selection.getRng();
            rngSetContent(rng, rng.createContextualFragment(cleanedContent), editor.schema);
            editor.selection.setRng(rng);
            scrollRangeIntoView(editor, rng);
            postProcessSetContent(editor, cleanedContent, updatedArgs);
        });
    };
    const setContentExternal = (editor, content, args = {}) => {
        logFeatureDeprecationWarning('selectionSetContent');
        setContentInternal$1(editor, content, args);
    };

    /**
     * Handles inserts of lists into the editor instance.
     *
     * @class tinymce.InsertList
     * @private
     */
    const hasOnlyOneChild$1 = (node) => {
        return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;
    };
    const isPaddingNode = (node) => {
        return node.name === 'br' || node.value === nbsp;
    };
    const isPaddedEmptyBlock = (schema, node) => {
        const blockElements = schema.getBlockElements();
        return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);
    };
    const isEmptyFragmentElement = (schema, node) => {
        const nonEmptyElements = schema.getNonEmptyElements();
        return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
    };
    const isListFragment = (schema, fragment) => {
        let firstChild = fragment.firstChild;
        let lastChild = fragment.lastChild;
        // Skip meta since it's likely <meta><ul>..</ul>
        if (firstChild && firstChild.name === 'meta') {
            firstChild = firstChild.next;
        }
        // Skip mce_marker since it's likely <ul>..</ul><span id="mce_marker"></span>
        if (lastChild && lastChild.attr('id') === 'mce_marker') {
            lastChild = lastChild.prev;
        }
        // Skip last child if it's an empty block
        if (isEmptyFragmentElement(schema, lastChild)) {
            lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;
        }
        if (!firstChild || firstChild !== lastChild) {
            return false;
        }
        return firstChild.name === 'ul' || firstChild.name === 'ol';
    };
    const cleanupDomFragment = (domFragment) => {
        var _a, _b;
        const firstChild = domFragment.firstChild;
        const lastChild = domFragment.lastChild;
        // TODO: remove the meta tag from paste logic
        if (firstChild && firstChild.nodeName === 'META') {
            (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);
        }
        if (lastChild && lastChild.id === 'mce_marker') {
            (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);
        }
        return domFragment;
    };
    const toDomFragment = (dom, serializer, fragment) => {
        const html = serializer.serialize(fragment);
        const domFragment = dom.createFragment(html);
        return cleanupDomFragment(domFragment);
    };
    const listItems = (elm) => {
        var _a;
        return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], (child) => {
            return child.nodeName === 'LI';
        });
    };
    const isPadding = (node) => {
        return node.data === nbsp || isBr$7(node);
    };
    const isListItemPadded = (node) => {
        return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);
    };
    const isEmptyOrPadded = (elm) => {
        return !elm.firstChild || isListItemPadded(elm);
    };
    const trimListItems = (elms) => {
        return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
    };
    const getParentLi = (dom, node) => {
        const parentBlock = dom.getParent(node, dom.isBlock);
        return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;
    };
    const isParentBlockLi = (dom, node) => {
        return !!getParentLi(dom, node);
    };
    const getSplit = (parentNode, rng) => {
        const beforeRng = rng.cloneRange();
        const afterRng = rng.cloneRange();
        beforeRng.setStartBefore(parentNode);
        afterRng.setEndAfter(parentNode);
        return [
            beforeRng.cloneContents(),
            afterRng.cloneContents()
        ];
    };
    const findFirstIn = (node, rootNode) => {
        const caretPos = CaretPosition.before(node);
        const caretWalker = CaretWalker(rootNode);
        const newCaretPos = caretWalker.next(caretPos);
        return newCaretPos ? newCaretPos.toRange() : null;
    };
    const findLastOf = (node, rootNode) => {
        const caretPos = CaretPosition.after(node);
        const caretWalker = CaretWalker(rootNode);
        const newCaretPos = caretWalker.prev(caretPos);
        return newCaretPos ? newCaretPos.toRange() : null;
    };
    const insertMiddle = (target, elms, rootNode, rng) => {
        const parts = getSplit(target, rng);
        const parentElm = target.parentNode;
        if (parentElm) {
            parentElm.insertBefore(parts[0], target);
            Tools.each(elms, (li) => {
                parentElm.insertBefore(li, target);
            });
            parentElm.insertBefore(parts[1], target);
            parentElm.removeChild(target);
        }
        return findLastOf(elms[elms.length - 1], rootNode);
    };
    const insertBefore$2 = (target, elms, rootNode) => {
        const parentElm = target.parentNode;
        if (parentElm) {
            Tools.each(elms, (elm) => {
                parentElm.insertBefore(elm, target);
            });
        }
        return findFirstIn(target, rootNode);
    };
    const insertAfter$2 = (target, elms, rootNode, dom) => {
        dom.insertAfter(elms.reverse(), target);
        return findLastOf(elms[0], rootNode);
    };
    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {
        const domFragment = toDomFragment(dom, serializer, fragment);
        const liTarget = getParentLi(dom, rng.startContainer);
        const liElms = trimListItems(listItems(domFragment.firstChild));
        const BEGINNING = 1, END = 2;
        const rootNode = dom.getRoot();
        const isAt = (location) => {
            const caretPos = CaretPosition.fromRangeStart(rng);
            const caretWalker = CaretWalker(dom.getRoot());
            const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
            const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();
            return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;
        };
        if (!liTarget) {
            return null;
        }
        else if (isAt(BEGINNING)) {
            return insertBefore$2(liTarget, liElms, rootNode);
        }
        else if (isAt(END)) {
            return insertAfter$2(liTarget, liElms, rootNode, dom);
        }
        else {
            return insertMiddle(liTarget, liElms, rootNode, rng);
        }
    };

    const mergeableWrappedElements = ['pre'];
    const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {
        var _a;
        const firstNode = fragment.firstChild;
        const lastNode = fragment.lastChild;
        const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;
        const isPastingSingleElement = firstNode === last;
        const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);
        if (isPastingSingleElement && isWrappedElement) {
            const isContentEditable = firstNode.attr('contenteditable') !== 'false';
            const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;
            const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);
            return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;
        }
        else {
            return false;
        }
    };
    const isTableCell = isTableCell$3;
    const isTableCellContentSelected = (dom, rng, cell) => {
        if (isNonNullable(cell)) {
            const endCell = dom.getParent(rng.endContainer, isTableCell);
            return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);
        }
        else {
            return false;
        }
    };
    const isEditableEmptyBlock = (dom, node) => {
        if (dom.isBlock(node) && dom.isEditable(node)) {
            const childNodes = node.childNodes;
            return (childNodes.length === 1 && isBr$7(childNodes[0])) || childNodes.length === 0;
        }
        else {
            return false;
        }
    };
    const validInsertion = (editor, value, parentNode) => {
        var _a;
        // Should never insert content into bogus elements, since these can
        // be resize handles or similar
        if (parentNode.getAttribute('data-mce-bogus') === 'all') {
            (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);
        }
        else {
            if (isEditableEmptyBlock(editor.dom, parentNode)) {
                editor.dom.setHTML(parentNode, value);
            }
            else {
                setContentInternal$1(editor, value, { no_events: true });
            }
        }
    };
    const trimBrsFromTableCell = (dom, elm, schema) => {
        Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each((el) => trimBlockTrailingBr(el, schema));
    };
    // Remove children nodes that are exactly the same as a parent node - name, attributes, styles
    const reduceInlineTextElements = (editor, merge) => {
        const textInlineElements = editor.schema.getTextInlineElements();
        const dom = editor.dom;
        if (merge) {
            const root = editor.getBody();
            const elementUtils = ElementUtils(editor);
            const fragmentSelector = '*[data-mce-fragment]';
            const fragments = dom.select(fragmentSelector);
            Tools.each(fragments, (node) => {
                const isInline = (currentNode) => isNonNullable(textInlineElements[currentNode.nodeName.toLowerCase()]);
                const hasOneChild = (currentNode) => currentNode.childNodes.length === 1;
                const hasNoNonInheritableStyles = (currentNode) => !(hasNonInheritableStyles(dom, currentNode) || hasConditionalNonInheritableStyles(dom, currentNode));
                if (hasNoNonInheritableStyles(node) && isInline(node) && hasOneChild(node)) {
                    const styles = getStyleProps(dom, node);
                    const isOverridden = (oldStyles, newStyles) => forall(oldStyles, (style) => contains$2(newStyles, style));
                    const overriddenByAllChildren = (childNode) => hasOneChild(node) && dom.is(childNode, fragmentSelector) && isInline(childNode) &&
                        (childNode.nodeName === node.nodeName && isOverridden(styles, getStyleProps(dom, childNode)) || overriddenByAllChildren(childNode.children[0]));
                    const identicalToParent = (parentNode) => isNonNullable(parentNode) && parentNode !== root
                        && (elementUtils.compare(node, parentNode) || identicalToParent(parentNode.parentElement));
                    const conflictWithInsertedParent = (parentNode) => isNonNullable(parentNode) && parentNode !== root
                        && dom.is(parentNode, fragmentSelector) && (hasStyleConflict(dom, node, parentNode) || conflictWithInsertedParent(parentNode.parentElement));
                    if (overriddenByAllChildren(node.children[0]) || (identicalToParent(node.parentElement) && !conflictWithInsertedParent(node.parentElement))) {
                        dom.remove(node, true);
                    }
                }
            });
            normalizeElements(editor, fromDom$1(fragments));
        }
    };
    const markFragmentElements = (fragment) => {
        let node = fragment;
        while ((node = node.walk())) {
            if (node.type === 1) {
                node.attr('data-mce-fragment', '1');
            }
        }
    };
    const unmarkFragmentElements = (elm) => {
        Tools.each(elm.getElementsByTagName('*'), (elm) => {
            elm.removeAttribute('data-mce-fragment');
        });
    };
    const isPartOfFragment = (node) => {
        return !!node.getAttribute('data-mce-fragment');
    };
    const canHaveChildren = (editor, node) => {
        return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];
    };
    const moveSelectionToMarker = (editor, marker) => {
        var _a, _b, _c;
        let nextRng;
        const dom = editor.dom;
        const selection = editor.selection;
        if (!marker) {
            return;
        }
        selection.scrollIntoView(marker);
        // If marker is in cE=false then move selection to that element instead
        const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);
        if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {
            dom.remove(marker);
            selection.select(parentEditableElm);
            return;
        }
        // Move selection before marker and remove it
        let rng = dom.createRng();
        // If previous sibling is a text node set the selection to the end of that node
        const node = marker.previousSibling;
        if (isText$b(node)) {
            rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
            const node2 = marker.nextSibling;
            if (isText$b(node2)) {
                node.appendData(node2.data);
                (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);
            }
        }
        else {
            // If the previous sibling isn't a text node or doesn't exist set the selection before the marker node
            rng.setStartBefore(marker);
            rng.setEndBefore(marker);
        }
        const findNextCaretRng = (rng) => {
            let caretPos = CaretPosition.fromRangeStart(rng);
            const caretWalker = CaretWalker(editor.getBody());
            caretPos = caretWalker.next(caretPos);
            return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();
        };
        // Remove the marker node and set the new range
        const parentBlock = dom.getParent(marker, dom.isBlock);
        dom.remove(marker);
        if (parentBlock && dom.isEmpty(parentBlock)) {
            const isCell = isTableCell(parentBlock);
            empty(SugarElement.fromDom(parentBlock));
            rng.setStart(parentBlock, 0);
            rng.setEnd(parentBlock, 0);
            if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
                rng = nextRng;
                dom.remove(parentBlock);
            }
            else {
                // TINY-9860: If parentBlock is a table cell, add a br without 'data-mce-bogus' attribute.
                dom.add(parentBlock, dom.create('br', isCell ? {} : { 'data-mce-bogus': '1' }));
            }
        }
        selection.setRng(rng);
    };
    const deleteSelectedContent = (editor) => {
        const dom = editor.dom;
        // Fix for #2595 seems that delete removes one extra character on
        // WebKit for some odd reason if you double click select a word
        const rng = normalize(editor.selection.getRng());
        editor.selection.setRng(rng);
        // TINY-1044: Selecting all content in a single table cell will cause the entire table to be deleted
        // when using the native delete command. As such we need to manually delete the cell content instead
        const startCell = dom.getParent(rng.startContainer, isTableCell);
        if (isTableCellContentSelected(dom, rng, startCell)) {
            deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
            // TINY-9193: If the selection is over the whole text node in an element then Firefox incorrectly moves the caret to the previous line
            // TINY-11953: If the selection is over the whole anchor node, then Chrome incorrectly removes parent node alongside with it's child - anchor
        }
        else if (isSelectionOverWholeAnchor(rng) || isSelectionOverWholeTextNode(rng)) {
            rng.deleteContents();
        }
        else {
            editor.getDoc().execCommand('Delete', false);
        }
    };
    const findMarkerNode = (scope) => {
        for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {
            if (markerNode.attr('id') === 'mce_marker') {
                return Optional.some(markerNode);
            }
        }
        return Optional.none();
    };
    const notHeadingsInSummary = (dom, node, fragment) => {
        var _a;
        return exists(fragment.children(), isHeading) && ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName) === 'SUMMARY';
    };
    const insertHtmlAtCaret = (editor, value, details) => {
        var _a;
        const selection = editor.selection;
        const dom = editor.dom;
        // Setup parser and serializer
        const parser = editor.parser;
        const merge = details.merge;
        const serializer = HtmlSerializer({
            validate: true
        }, editor.schema);
        const bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
        // TINY-10305: Remove all user-input zwsp to avoid impacting caret removal from content.
        if (!details.preserve_zwsp) {
            value = trim$2(value);
        }
        // Add caret at end of contents if it's missing
        if (value.indexOf('{$caret}') === -1) {
            value += '{$caret}';
        }
        // Replace the caret marker with a span bookmark element
        value = value.replace(/\{\$caret\}/, bookmarkHtml);
        // If selection is at <body>|<p></p> then move it into <body><p>|</p>
        let rng = selection.getRng();
        const caretElement = rng.startContainer;
        const body = editor.getBody();
        if (caretElement === body && selection.isCollapsed()) {
            if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {
                rng = dom.createRng();
                rng.setStart(body.firstChild, 0);
                rng.setEnd(body.firstChild, 0);
                selection.setRng(rng);
            }
        }
        // Insert node maker where we will insert the new HTML and get it's parent
        if (!selection.isCollapsed()) {
            deleteSelectedContent(editor);
        }
        const parentNode = selection.getNode();
        // Parse the fragment within the context of the parent node
        const parserArgs = { context: parentNode.nodeName.toLowerCase(), data: details.data, insert: true };
        const fragment = parser.parse(value, parserArgs);
        // Custom handling of lists
        if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {
            rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);
            if (rng) {
                selection.setRng(rng);
            }
            return value;
        }
        if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {
            (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();
        }
        markFragmentElements(fragment);
        // Move the caret to a more suitable location
        let node = fragment.lastChild;
        if (node && node.attr('id') === 'mce_marker') {
            const marker = node;
            for (node = node.prev; node; node = node.walk(true)) {
                if (node.name === 'table') {
                    break;
                }
                if (node.type === 3 || !dom.isBlock(node.name)) {
                    if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {
                        node.parent.insert(marker, node, node.name === 'br');
                    }
                    break;
                }
            }
        }
        editor._selectionOverrides.showBlockCaretContainer(parentNode);
        // If parser says valid we can insert the contents into that parent
        if (!parserArgs.invalid && !notHeadingsInSummary(dom, parentNode, fragment)) {
            value = serializer.serialize(fragment);
            validInsertion(editor, value, parentNode);
        }
        else {
            // If the fragment was invalid within that context then we need
            // to parse and process the parent it's inserted into
            // Insert bookmark node and get the parent
            setContentInternal$1(editor, bookmarkHtml);
            let parentNode = selection.getNode();
            let tempNode;
            const rootNode = editor.getBody();
            // Opera will return the document node when selection is in root
            if (isDocument$1(parentNode)) {
                parentNode = tempNode = rootNode;
            }
            else {
                tempNode = parentNode;
            }
            // Find the ancestor just before the root element
            while (tempNode && tempNode !== rootNode) {
                parentNode = tempNode;
                tempNode = tempNode.parentNode;
            }
            // Get the outer/inner HTML depending on if we are in the root and parser and serialize that
            value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
            const root = parser.parse(value);
            const markerNode = findMarkerNode(root);
            const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);
            markerNode.each((marker) => marker.replace(fragment));
            const fragmentNodes = getAllDescendants(fragment);
            fragment.unwrap();
            const invalidChildren = filter$5(fragmentNodes, (node) => isInvalid(editor.schema, node));
            cleanInvalidNodes(invalidChildren, editor.schema, editingHost);
            filter$1(parser.getNodeFilters(), parser.getAttributeFilters(), root);
            value = serializer.serialize(root);
            // Set the inner/outer HTML depending on if we are in the root or not
            if (parentNode === rootNode) {
                dom.setHTML(rootNode, value);
            }
            else {
                dom.setOuterHTML(parentNode, value);
            }
        }
        reduceInlineTextElements(editor, merge);
        moveSelectionToMarker(editor, dom.get('mce_marker'));
        unmarkFragmentElements(editor.getBody());
        trimBrsFromTableCell(dom, selection.getStart(), editor.schema);
        updateCaret(editor.schema, editor.getBody(), selection.getStart());
        return value;
    };

    const moveSelection = (editor) => {
        if (hasFocus(editor)) {
            firstPositionIn(editor.getBody()).each((pos) => {
                const node = pos.getNode();
                const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
                editor.selection.setRng(caretPos.toRange());
            });
        }
    };
    const setEditorHtml = (editor, html, noSelection) => {
        editor.dom.setHTML(editor.getBody(), html);
        if (noSelection !== true) {
            moveSelection(editor);
        }
    };
    const setContentString = (editor, body, content, args) => {
        // TINY-10305: Remove all user-input zwsp to avoid impacting caret removal from content.
        content = trim$2(content);
        // Padd empty content in Gecko and Safari. Commands will otherwise fail on the content
        // It will also be impossible to place the caret in the editor unless there is a BR element present
        if (content.length === 0 || /^\s+$/.test(content)) {
            const padd = '<br data-mce-bogus="1">';
            // Todo: There is a lot more root elements that need special padding
            // so separate this and add all of them at some point.
            if (body.nodeName === 'TABLE') {
                content = '<tr><td>' + padd + '</td></tr>';
            }
            else if (/^(UL|OL)$/.test(body.nodeName)) {
                content = '<li>' + padd + '</li>';
            }
            const forcedRootBlockName = getForcedRootBlock(editor);
            // Check if forcedRootBlock is a valid child of the body
            if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
                content = padd;
                content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);
            }
            else if (!content) {
                content = padd;
            }
            setEditorHtml(editor, content, args.no_selection);
            return { content, html: content };
        }
        else {
            if (args.format !== 'raw') {
                content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, { isRootContent: true, insert: true }));
            }
            const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);
            setEditorHtml(editor, trimmedHtml, args.no_selection);
            return { content: trimmedHtml, html: trimmedHtml };
        }
    };
    const setContentTree = (editor, body, content, args) => {
        filter$1(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
        const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);
        // TINY-10305: Remove all user-input zwsp to avoid impacting caret removal from content.
        const trimmedHtml = trim$2(isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html));
        setEditorHtml(editor, trimmedHtml, args.no_selection);
        return { content, html: trimmedHtml };
    };
    const setContentInternal = (editor, content, args) => {
        return Optional.from(editor.getBody()).map((body) => {
            if (isTreeNode(content)) {
                return setContentTree(editor, body, content, args);
            }
            else {
                return setContentString(editor, body, content, args);
            }
        }).getOr({ content, html: isTreeNode(args.content) ? '' : args.content });
    };

    const postProcessHooks = {};
    const isPre = matchNodeNames$1(['pre']);
    const addPostProcessHook = (name, hook) => {
        const hooks = postProcessHooks[name];
        if (!hooks) {
            postProcessHooks[name] = [];
        }
        postProcessHooks[name].push(hook);
    };
    const postProcess$1 = (name, editor) => {
        if (has$2(postProcessHooks, name)) {
            each$e(postProcessHooks[name], (hook) => {
                hook(editor);
            });
        }
    };
    addPostProcessHook('pre', (editor) => {
        const rng = editor.selection.getRng();
        const hasPreSibling = (blocks) => (pre) => {
            const prev = pre.previousSibling;
            return isPre(prev) && contains$2(blocks, prev);
        };
        const joinPre = (pre1, pre2) => {
            const sPre2 = SugarElement.fromDom(pre2);
            const doc = documentOrOwner(sPre2).dom;
            remove$8(sPre2);
            append(SugarElement.fromDom(pre1), [
                SugarElement.fromTag('br', doc),
                SugarElement.fromTag('br', doc),
                ...children$1(sPre2)
            ]);
        };
        if (!rng.collapsed) {
            const blocks = editor.selection.getSelectedBlocks();
            const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));
            each$e(preBlocks, (pre) => {
                joinPre(pre.previousSibling, pre);
            });
        }
    });

    const each$5 = Tools.each;
    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {
        const processTextDecorationsAndColor = (n) => {
            if (isHTMLElement(n) && isElement$7(n.parentNode) && dom.isEditable(n)) {
                const parentTextDecoration = getTextDecoration(dom, n.parentNode);
                if (dom.getStyle(n, 'color') && parentTextDecoration) {
                    dom.setStyle(n, 'text-decoration', parentTextDecoration);
                }
                else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {
                    dom.setStyle(n, 'text-decoration', null);
                }
            }
        };
        // Colored nodes should be underlined so that the color of the underline matches the text color.
        if (format.styles && (format.styles.color || format.styles.textDecoration)) {
            Tools.walk(node, processTextDecorationsAndColor, 'childNodes');
            processTextDecorationsAndColor(node);
        }
    };
    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {
        // nodes with font-size should have their own background color as well to fit the line-height (see TINY-882)
        if (format.styles && format.styles.backgroundColor) {
            const hasFontSize = hasStyle(dom, 'fontSize');
            processChildElements(node, (elm) => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));
        }
    };
    const mergeSubSup = (dom, format, vars, node) => {
        // Remove font size on all descendants of a sub/sup and remove the inverse elements
        if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {
            const hasFontSize = hasStyle(dom, 'fontSize');
            processChildElements(node, (elm) => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'fontSize', ''));
            const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), dom.isEditable);
            dom.remove(inverseTagDescendants, true);
        }
    };
    const mergeWithChildren = (editor, formatList, vars, node) => {
        // Remove/merge children
        // Note: RemoveFormat.removeFormat will not remove formatting from noneditable nodes
        each$5(formatList, (format) => {
            // Merge all children of similar type will move styles from child to parent
            // this: <span style="color:red"><b><span style="color:red; font-size:10px">text</span></b></span>
            // will become: <span style="color:red"><b><span style="font-size:10px">text</span></b></span>
            if (isInlineFormat(format)) {
                each$5(editor.dom.select(format.inline, node), (child) => {
                    if (isElementNode(child)) {
                        removeNodeFormat(editor, format, vars, child, format.exact ? child : null);
                    }
                });
            }
            clearChildStyles(editor.dom, format, node);
        });
    };
    const mergeWithParents = (editor, format, name, vars, node) => {
        // Remove format if direct parent already has the same format
        // Note: RemoveFormat.removeFormat will not remove formatting from noneditable nodes
        const parentNode = node.parentNode;
        if (matchNode$1(editor, parentNode, name, vars)) {
            if (removeNodeFormat(editor, format, vars, node)) {
                return;
            }
        }
        // Remove format if any ancestor already has the same format
        if (format.merge_with_parents && parentNode) {
            editor.dom.getParent(parentNode, (parent) => {
                if (matchNode$1(editor, parent, name, vars)) {
                    removeNodeFormat(editor, format, vars, node);
                    return true;
                }
                else {
                    return false;
                }
            });
        }
    };

    const each$4 = Tools.each;
    const canFormatBR = (editor, format, node, parentName) => {
        // TINY-6483: Can format 'br' if it is contained in a valid empty block and an inline format is being applied
        if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {
            const validBRParentElements = getTextRootBlockElements(editor.schema);
            // If a caret node is present, the format should apply to that, not the br (applicable to collapsed selections)
            const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), (sibling) => isCaretNode(sibling.dom));
            return hasNonNullableKey(validBRParentElements, parentName) && isEmptyNode(editor.schema, node.parentNode, { skipBogus: false, includeZwsp: true }) && !hasCaretNodeSibling;
        }
        else {
            return false;
        }
    };
    const applyFormatAction = (ed, name, vars, node) => {
        const formatList = ed.formatter.get(name);
        const format = formatList[0];
        const isCollapsed = !node && ed.selection.isCollapsed();
        const dom = ed.dom;
        const selection = ed.selection;
        const applyNodeStyle = (formatList, node) => {
            let found = false;
            // Look for matching formats
            each$4(formatList, (format) => {
                if (!isSelectorFormat(format)) {
                    return false;
                }
                // Check if the node is nonediatble and if the format can override noneditable node
                if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {
                    return true;
                }
                // Check collapsed state if it exists
                if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {
                    return true;
                }
                if (dom.is(node, format.selector) && !isCaretNode(node)) {
                    setElementFormat(ed, node, format, vars, node);
                    found = true;
                    return false;
                }
                return true;
            });
            return found;
        };
        const createWrapElement = (wrapName) => {
            if (isString(wrapName)) {
                const wrapElm = dom.create(wrapName);
                setElementFormat(ed, wrapElm, format, vars, node);
                return wrapElm;
            }
            else {
                return null;
            }
        };
        const applyRngStyle = (dom, rng, nodeSpecific) => {
            const newWrappers = [];
            let contentEditable = true;
            // Setup wrapper element
            const wrapName = format.inline || format.block;
            const wrapElm = createWrapElement(wrapName);
            const isMatchingWrappingBlock = (node) => isWrappingBlockFormat(format) && matchNode$1(ed, node, name, vars);
            const canRenameBlock = (node, parentName, isEditableDescendant) => {
                const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) &&
                    isTextBlock$2(ed.schema, node) &&
                    isValid(ed, parentName, wrapName);
                return isEditableDescendant && isValidBlockFormatForNode;
            };
            const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {
                const nodeName = node.nodeName.toLowerCase();
                const isValidWrapNode = isValid(ed, wrapName, nodeName) &&
                    isValid(ed, parentName, wrapName);
                // If it is not node specific, it means that it was not passed into 'formatter.apply` and is within the editor selection
                const isZwsp$1 = !nodeSpecific && isText$b(node) && isZwsp(node.data);
                const isCaret = isCaretNode(node);
                const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);
                return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp$1 && !isCaret && isCorrectFormatForNode;
            };
            walk$3(dom, rng, (nodes) => {
                let currentWrapElm;
                /**
                 * Process a list of nodes wrap them.
                 */
                const process = (node) => {
                    let hasContentEditableState = false;
                    let lastContentEditable = contentEditable;
                    let isWrappableNoneditableElm = false;
                    const parentNode = node.parentNode;
                    const parentName = parentNode.nodeName.toLowerCase();
                    // Node has a contentEditable value
                    const contentEditableValue = dom.getContentEditable(node);
                    if (isNonNullable(contentEditableValue)) {
                        lastContentEditable = contentEditable;
                        contentEditable = contentEditableValue === 'true';
                        // Unless the noneditable element is wrappable, we don't want to wrap the container, only it's editable children
                        hasContentEditableState = true;
                        isWrappableNoneditableElm = isWrappableNoneditable(ed, node);
                    }
                    const isEditableDescendant = contentEditable && !hasContentEditableState;
                    // Stop wrapping on br elements except when valid
                    if (isBr$7(node) && !canFormatBR(ed, format, node, parentName)) {
                        currentWrapElm = null;
                        // Remove any br elements when we wrap things
                        if (isBlockFormat(format)) {
                            dom.remove(node);
                        }
                        return;
                    }
                    if (isMatchingWrappingBlock(node)) {
                        currentWrapElm = null;
                        return;
                    }
                    if (canRenameBlock(node, parentName, isEditableDescendant)) {
                        const elm = dom.rename(node, wrapName);
                        setElementFormat(ed, elm, format, vars, node);
                        newWrappers.push(elm);
                        currentWrapElm = null;
                        return;
                    }
                    if (isSelectorFormat(format)) {
                        let found = applyNodeStyle(formatList, node);
                        // TINY-6567/TINY-7393: Include the parent if using an expanded selector format and no match was found for the current node
                        if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
                            found = applyNodeStyle(formatList, parentNode);
                        }
                        // Continue processing if a selector match wasn't found and a inline element is defined
                        if (!isInlineFormat(format) || found) {
                            currentWrapElm = null;
                            return;
                        }
                    }
                    if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {
                        // Start wrapping
                        if (!currentWrapElm) {
                            // Wrap the node
                            currentWrapElm = dom.clone(wrapElm, false);
                            parentNode.insertBefore(currentWrapElm, node);
                            newWrappers.push(currentWrapElm);
                        }
                        // Wrappable noneditable element has been handled so go back to previous state
                        if (isWrappableNoneditableElm && hasContentEditableState) {
                            contentEditable = lastContentEditable;
                        }
                        currentWrapElm.appendChild(node);
                    }
                    else {
                        // Start a new wrapper for possible children
                        currentWrapElm = null;
                        each$e(from(node.childNodes), process);
                        if (hasContentEditableState) {
                            contentEditable = lastContentEditable; // Restore last contentEditable state from stack
                        }
                        // End the last wrapper
                        currentWrapElm = null;
                    }
                };
                each$e(nodes, process);
            });
            // Apply formats to links as well to get the color of the underline to change as well
            if (format.links === true) {
                each$e(newWrappers, (wrapper) => {
                    const process = (target) => {
                        if (target.nodeName === 'A') {
                            setElementFormat(ed, target, format, vars, node);
                        }
                        each$e(from(target.childNodes), process);
                    };
                    process(wrapper);
                });
            }
            normalizeFontSizeElementsAfterApply(ed, name, fromDom$1(newWrappers));
            // Cleanup
            each$e(newWrappers, (node) => {
                const getChildCount = (node) => {
                    let count = 0;
                    each$e(node.childNodes, (node) => {
                        if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {
                            count++;
                        }
                    });
                    return count;
                };
                const mergeStyles = (node) => {
                    // Check if a child was found and of the same type as the current node
                    const childElement = find$2(node.childNodes, isElementNode$1)
                        .filter((child) => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));
                    return childElement.map((child) => {
                        const clone = dom.clone(child, false);
                        setElementFormat(ed, clone, format, vars, node);
                        dom.replace(clone, node, true);
                        dom.remove(child, true);
                        return clone;
                    }).getOr(node);
                };
                const childCount = getChildCount(node);
                // Remove empty nodes but only if there is multiple wrappers and they are not block
                // elements so never remove single <h1></h1> since that would remove the
                // current empty block element where the caret is at
                if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {
                    dom.remove(node, true);
                    return;
                }
                if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {
                    // Merges the current node with it's children of similar type to reduce the number of elements
                    if (!format.exact && childCount === 1) {
                        node = mergeStyles(node);
                    }
                    mergeWithChildren(ed, formatList, vars, node);
                    mergeWithParents(ed, format, name, vars, node);
                    mergeBackgroundColorAndFontSize(dom, format, vars, node);
                    mergeTextDecorationsAndColor(dom, format, vars, node);
                    mergeSubSup(dom, format, vars, node);
                    mergeSiblings(ed, format, vars, node);
                }
            });
        };
        // TODO: TINY-9142: Remove this to make nested noneditable formatting work
        const targetNode = isNode(node) ? node : selection.getNode();
        if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {
            // node variable is used by other functions above in the same scope so need to set it here
            node = targetNode;
            applyNodeStyle(formatList, node);
            fireFormatApply(ed, name, node, vars);
            return;
        }
        if (format) {
            if (node) {
                if (isNode(node)) {
                    if (!applyNodeStyle(formatList, node)) {
                        const rng = dom.createRng();
                        rng.setStartBefore(node);
                        rng.setEndAfter(node);
                        applyRngStyle(dom, expandRng(dom, rng, formatList), true);
                    }
                }
                else {
                    applyRngStyle(dom, node, true);
                }
            }
            else {
                if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
                    // Apply formatting to selection
                    selection.setRng(normalize(selection.getRng()));
                    preserveSelection(ed, () => {
                        runOnRanges(ed, (selectionRng, fake) => {
                            const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);
                            applyRngStyle(dom, expandedRng, false);
                        });
                    }, always);
                    ed.nodeChanged();
                }
                else {
                    applyCaretFormat(ed, name, vars);
                }
                getExpandedListItemFormat(ed.formatter, name).each((liFmt) => {
                    each$e(getFullySelectedListItems(ed.selection), (li) => applyStyles(dom, li, liFmt, vars));
                });
            }
            postProcess$1(name, ed);
        }
        fireFormatApply(ed, name, node, vars);
    };
    const applyFormat$1 = (editor, name, vars, node) => {
        if (node || editor.selection.isEditable()) {
            applyFormatAction(editor, name, vars, node);
        }
    };

    const hasVars = (value) => has$2(value, 'vars');
    const setup$A = (registeredFormatListeners, editor) => {
        registeredFormatListeners.set({});
        editor.on('NodeChange', (e) => {
            updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());
        });
        editor.on('FormatApply FormatRemove', (e) => {
            const element = Optional.from(e.node)
                .map((nodeOrRange) => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer)
                .bind((node) => isElement$7(node) ? Optional.some(node) : Optional.from(node.parentElement))
                .getOrThunk(() => fallbackElement(editor));
            updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());
        });
    };
    const fallbackElement = (editor) => editor.selection.getStart();
    const matchingNode = (editor, parents, format, similar, vars) => {
        const isMatchingNode = (node) => {
            const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);
            return !isUndefined(matchingFormat);
        };
        const isUnableToMatch = (node) => {
            if (matchesUnInheritedFormatSelector(editor, node, format)) {
                return true;
            }
            else {
                if (!similar) {
                    // If we want to find an exact match, then finding a similar match halfway up the parents tree is bad
                    return isNonNullable(editor.formatter.matchNode(node, format, vars, true));
                }
                else {
                    return false;
                }
            }
        };
        return findUntil$1(parents, isMatchingNode, isUnableToMatch);
    };
    const getParents = (editor, elm) => {
        const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);
        return filter$5(getParents$2(editor.dom, element), (node) => isElement$7(node) && !isBogus$1(node));
    };
    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {
        // Ignore bogus nodes like the <a> tag created by moveStart()
        const parents = getParents(editor, elm);
        each$d(registeredCallbacks, (data, format) => {
            const runIfChanged = (spec) => {
                const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);
                const isSet = match.isSome();
                if (spec.state.get() !== isSet) {
                    spec.state.set(isSet);
                    const node = match.getOr(elm);
                    if (hasVars(spec)) {
                        spec.callback(isSet, { node, format, parents });
                    }
                    else {
                        each$e(spec.callbacks, (callback) => callback(isSet, { node, format, parents }));
                    }
                }
            };
            each$e([data.withSimilar, data.withoutSimilar], runIfChanged);
            each$e(data.withVars, runIfChanged);
        });
    };
    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
        const formatChangeItems = registeredFormatListeners.get();
        each$e(formats.split(','), (format) => {
            const group = get$a(formatChangeItems, format).getOrThunk(() => {
                const base = {
                    withSimilar: {
                        state: Cell(false),
                        similar: true,
                        callbacks: []
                    },
                    withoutSimilar: {
                        state: Cell(false),
                        similar: false,
                        callbacks: []
                    },
                    withVars: []
                };
                formatChangeItems[format] = base;
                return base;
            });
            const getCurrent = () => {
                const parents = getParents(editor);
                return matchingNode(editor, parents, format, similar, vars).isSome();
            };
            if (isUndefined(vars)) {
                const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;
                toAppendTo.callbacks.push(callback);
                if (toAppendTo.callbacks.length === 1) {
                    toAppendTo.state.set(getCurrent());
                }
            }
            else {
                group.withVars.push({
                    state: Cell(getCurrent()),
                    similar,
                    vars,
                    callback
                });
            }
        });
        registeredFormatListeners.set(formatChangeItems);
    };
    const removeListeners = (registeredFormatListeners, formats, callback) => {
        const formatChangeItems = registeredFormatListeners.get();
        each$e(formats.split(','), (format) => get$a(formatChangeItems, format).each((group) => {
            formatChangeItems[format] = {
                withSimilar: {
                    ...group.withSimilar,
                    callbacks: filter$5(group.withSimilar.callbacks, (cb) => cb !== callback),
                },
                withoutSimilar: {
                    ...group.withoutSimilar,
                    callbacks: filter$5(group.withoutSimilar.callbacks, (cb) => cb !== callback),
                },
                withVars: filter$5(group.withVars, (item) => item.callback !== callback),
            };
        }));
        registeredFormatListeners.set(formatChangeItems);
    };
    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
        addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);
        return {
            unbind: () => removeListeners(registeredFormatListeners, formats, callback)
        };
    };

    const toggle = (editor, name, vars, node) => {
        const fmt = editor.formatter.get(name);
        if (fmt) {
            if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {
                removeFormat$1(editor, name, vars, node);
            }
            else {
                applyFormat$1(editor, name, vars, node);
            }
        }
    };

    const tableModel = (element, width, rows) => ({
        element,
        width,
        rows
    });
    const tableRow = (element, cells) => ({
        element,
        cells
    });
    const cellPosition = (x, y) => ({
        x,
        y
    });
    const getSpan = (td, key) => {
        return getOpt(td, key).bind(toInt).getOr(1);
    };
    const fillout = (table, x, y, tr, td) => {
        const rowspan = getSpan(td, 'rowspan');
        const colspan = getSpan(td, 'colspan');
        const rows = table.rows;
        for (let y2 = y; y2 < y + rowspan; y2++) {
            if (!rows[y2]) {
                rows[y2] = tableRow(deep(tr), []);
            }
            for (let x2 = x; x2 < x + colspan; x2++) {
                const cells = rows[y2].cells;
                // not filler td:s are purposely not cloned so that we can
                // find cells in the model by element object references
                cells[x2] = y2 === y && x2 === x ? td : shallow(td);
            }
        }
    };
    const cellExists = (table, x, y) => {
        const rows = table.rows;
        const cells = rows[y] ? rows[y].cells : [];
        return !!cells[x];
    };
    const skipCellsX = (table, x, y) => {
        while (cellExists(table, x, y)) {
            x++;
        }
        return x;
    };
    const getWidth = (rows) => {
        return foldl(rows, (acc, row) => {
            return row.cells.length > acc ? row.cells.length : acc;
        }, 0);
    };
    const findElementPos = (table, element) => {
        const rows = table.rows;
        for (let y = 0; y < rows.length; y++) {
            const cells = rows[y].cells;
            for (let x = 0; x < cells.length; x++) {
                if (eq(cells[x], element)) {
                    return Optional.some(cellPosition(x, y));
                }
            }
        }
        return Optional.none();
    };
    const extractRows = (table, sx, sy, ex, ey) => {
        const newRows = [];
        const rows = table.rows;
        for (let y = sy; y <= ey; y++) {
            const cells = rows[y].cells;
            const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
            newRows.push(tableRow(rows[y].element, slice));
        }
        return newRows;
    };
    const subTable = (table, startPos, endPos) => {
        const sx = startPos.x, sy = startPos.y;
        const ex = endPos.x, ey = endPos.y;
        const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);
        return tableModel(table.element, getWidth(newRows), newRows);
    };
    const createDomTable = (table, rows) => {
        const tableElement = shallow(table.element);
        const tableBody = SugarElement.fromTag('tbody');
        append(tableBody, rows);
        append$1(tableElement, tableBody);
        return tableElement;
    };
    const modelRowsToDomRows = (table) => {
        return map$3(table.rows, (row) => {
            const cells = map$3(row.cells, (cell) => {
                const td = deep(cell);
                remove$9(td, 'colspan');
                remove$9(td, 'rowspan');
                return td;
            });
            const tr = shallow(row.element);
            append(tr, cells);
            return tr;
        });
    };
    const fromDom = (tableElm) => {
        const table = tableModel(shallow(tableElm), 0, []);
        each$e(descendants(tableElm, 'tr'), (tr, y) => {
            each$e(descendants(tr, 'td,th'), (td, x) => {
                fillout(table, skipCellsX(table, x, y), y, tr, td);
            });
        });
        return tableModel(table.element, getWidth(table.rows), table.rows);
    };
    const toDom = (table) => {
        return createDomTable(table, modelRowsToDomRows(table));
    };
    const subsection = (table, startElement, endElement) => {
        return findElementPos(table, startElement).bind((startPos) => {
            return findElementPos(table, endElement).map((endPos) => {
                return subTable(table, startPos, endPos);
            });
        });
    };

    const findParentListContainer = (parents) => find$2(parents, (elm) => name(elm) === 'ul' || name(elm) === 'ol');
    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, (elm) => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), (_li) => findParentListContainer(parents).map((listCont) => {
        const listElm = SugarElement.fromTag(name(listCont));
        // Retain any list-style* styles when generating the new fragment
        const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));
        setAll(listElm, listStyles);
        return [
            SugarElement.fromTag('li'),
            listElm
        ];
    }).getOr([]));
    const wrap = (innerElm, elms) => {
        const wrapped = foldl(elms, (acc, elm) => {
            append$1(elm, acc);
            return elm;
        }, innerElm);
        return elms.length > 0 ? fromElements([wrapped]) : wrapped;
    };
    const directListWrappers = (commonAnchorContainer) => {
        if (isListItem$2(commonAnchorContainer)) {
            return parent(commonAnchorContainer).filter(isList$1).fold(constant([]), (listElm) => [commonAnchorContainer, listElm]);
        }
        else {
            return isList$1(commonAnchorContainer) ? [commonAnchorContainer] : [];
        }
    };
    const getWrapElements = (rootNode, rng, schema) => {
        const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);
        const parents = parentsAndSelf(commonAnchorContainer, rootNode);
        const wrapElements = filter$5(parents, (el) => schema.isWrapper(name(el)));
        const listWrappers = getFullySelectedListWrappers(parents, rng);
        const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
        return map$3(allWrappers, shallow);
    };
    const emptyFragment = () => fromElements([]);
    const getFragmentFromRange = (rootNode, rng, schema) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng, schema));
    const getParentTable = (rootElm, cell) => ancestor$4(cell, 'table', curry(eq, rootElm));
    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind((tableElm) => {
        const firstCell = selectedTableCells[0];
        const lastCell = selectedTableCells[selectedTableCells.length - 1];
        const fullTableModel = fromDom(tableElm);
        return subsection(fullTableModel, firstCell, lastCell).map((sectionedTableModel) => fromElements([toDom(sectionedTableModel)]));
    }).getOrThunk(emptyFragment);
    const getSelectionFragment = (rootNode, ranges, schema) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0], schema);
    const read$3 = (rootNode, ranges, schema) => {
        const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
        return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges, schema);
    };

    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));
    const getInnerText = (bin) => {
        return trim$2(bin.innerText);
    };
    const getContextNodeName = (parentBlockOpt) => parentBlockOpt.map((block) => block.nodeName).getOr('div').toLowerCase();
    const getTextContent = (editor) => Optional.from(editor.selection.getRng()).map((rng) => {
        var _a;
        const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));
        const body = editor.getBody();
        const contextNodeName = getContextNodeName(parentBlockOpt);
        const rangeContentClone = SugarElement.fromDom(rng.cloneContents());
        cleanupBogusElements(rangeContentClone);
        cleanupInputNames(rangeContentClone);
        const bin = editor.dom.add(body, contextNodeName, {
            'data-mce-bogus': 'all',
            'style': 'overflow: hidden; opacity: 0;'
        }, rangeContentClone.dom);
        const text = getInnerText(bin);
        // textContent will not strip leading/trailing spaces since it doesn't consider how it'll render
        const nonRenderedText = trim$2((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');
        editor.dom.remove(bin);
        if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {
            // If the bin contains a trailing/leading space, then we need to inspect the parent block to see if we should include the spaces
            const parentBlock = parentBlockOpt.getOr(body);
            const parentBlockText = getInnerText(parentBlock);
            const textIndex = parentBlockText.indexOf(text);
            if (textIndex === -1) {
                return text;
            }
            else {
                const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);
                const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);
                return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');
            }
        }
        else {
            return text;
        }
    }).getOr('');
    const getSerializedContent = (editor, args) => {
        const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');
        const sel = editor.selection.getSel();
        const ranges = processRanges(editor, getRanges(sel));
        const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema).dom : rng.cloneContents();
        if (fragment) {
            tmpElm.appendChild(fragment);
        }
        return editor.selection.serializer.serialize(tmpElm, args);
    };
    const extractSelectedContent = (editor, args) => {
        if (args.format === 'text') {
            return getTextContent(editor);
        }
        else {
            const content = getSerializedContent(editor, args);
            if (args.format === 'tree') {
                return content;
            }
            else {
                return editor.selection.isCollapsed() ? '' : content;
            }
        }
    };
    const setupArgs$2 = (args, format) => ({
        ...args,
        format,
        get: true,
        selection: true,
        getInner: true
    });
    const getSelectedContentInternal = (editor, format, args = {}) => {
        const defaultedArgs = setupArgs$2(args, format);
        return preProcessGetContent(editor, defaultedArgs).fold(identity, (updatedArgs) => {
            const content = extractSelectedContent(editor, updatedArgs);
            return postProcessGetContent(editor, content, updatedArgs);
        });
    };

    /**
     * JS Implementation of the O(ND) Difference Algorithm by Eugene W. Myers.
     *
     * @class tinymce.undo.Diff
     * @private
     */
    const KEEP = 0, INSERT = 1, DELETE = 2;
    const diff = (left, right) => {
        const size = left.length + right.length + 2;
        const vDown = new Array(size);
        const vUp = new Array(size);
        const snake = (start, end, diag) => {
            return {
                start,
                end,
                diag
            };
        };
        const buildScript = (start1, end1, start2, end2, script) => {
            const middle = getMiddleSnake(start1, end1, start2, end2);
            if (middle === null || middle.start === end1 && middle.diag === end1 - end2 ||
                middle.end === start1 && middle.diag === start1 - start2) {
                let i = start1;
                let j = start2;
                while (i < end1 || j < end2) {
                    if (i < end1 && j < end2 && left[i] === right[j]) {
                        script.push([KEEP, left[i]]);
                        ++i;
                        ++j;
                    }
                    else {
                        if (end1 - start1 > end2 - start2) {
                            script.push([DELETE, left[i]]);
                            ++i;
                        }
                        else {
                            script.push([INSERT, right[j]]);
                            ++j;
                        }
                    }
                }
            }
            else {
                buildScript(start1, middle.start, start2, middle.start - middle.diag, script);
                for (let i2 = middle.start; i2 < middle.end; ++i2) {
                    script.push([KEEP, left[i2]]);
                }
                buildScript(middle.end, end1, middle.end - middle.diag, end2, script);
            }
        };
        const buildSnake = (start, diag, end1, end2) => {
            let end = start;
            while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {
                ++end;
            }
            return snake(start, end, diag);
        };
        const getMiddleSnake = (start1, end1, start2, end2) => {
            // Myers Algorithm
            // Initialisations
            const m = end1 - start1;
            const n = end2 - start2;
            if (m === 0 || n === 0) {
                return null;
            }
            const delta = m - n;
            const sum = n + m;
            const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
            vDown[1 + offset] = start1;
            vUp[1 + offset] = end1 + 1;
            let d, k, i, x, y;
            for (d = 0; d <= offset; ++d) {
                // Down
                for (k = -d; k <= d; k += 2) {
                    // First step
                    i = k + offset;
                    if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {
                        vDown[i] = vDown[i + 1];
                    }
                    else {
                        vDown[i] = vDown[i - 1] + 1;
                    }
                    x = vDown[i];
                    y = x - start1 + start2 - k;
                    while (x < end1 && y < end2 && left[x] === right[y]) {
                        vDown[i] = ++x;
                        ++y;
                    }
                    // Second step
                    if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
                        if (vUp[i - delta] <= vDown[i]) {
                            return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
                        }
                    }
                }
                // Up
                for (k = delta - d; k <= delta + d; k += 2) {
                    // First step
                    i = k + offset - delta;
                    if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {
                        vUp[i] = vUp[i + 1] - 1;
                    }
                    else {
                        vUp[i] = vUp[i - 1];
                    }
                    x = vUp[i] - 1;
                    y = x - start1 + start2 - k;
                    while (x >= start1 && y >= start2 && left[x] === right[y]) {
                        vUp[i] = x--;
                        y--;
                    }
                    // Second step
                    if (delta % 2 === 0 && -d <= k && k <= d) {
                        if (vUp[i] <= vDown[i + delta]) {
                            return buildSnake(vUp[i], k + start1 - start2, end1, end2);
                        }
                    }
                }
            }
            return null;
        };
        const script = [];
        buildScript(0, left.length, 0, right.length, script);
        return script;
    };

    /**
     * This module reads and applies html fragments from/to dom nodes.
     *
     * @class tinymce.undo.Fragments
     * @private
     */
    const getOuterHtml = (elm) => {
        if (isElement$7(elm)) {
            return elm.outerHTML;
        }
        else if (isText$b(elm)) {
            return Entities.encodeRaw(elm.data, false);
        }
        else if (isComment(elm)) {
            return '<!--' + elm.data + '-->';
        }
        return '';
    };
    const createFragment = (html) => {
        let node;
        const container = document.createElement('div');
        const frag = document.createDocumentFragment();
        if (html) {
            container.innerHTML = html;
        }
        while ((node = container.firstChild)) {
            frag.appendChild(node);
        }
        return frag;
    };
    const insertAt = (elm, html, index) => {
        const fragment = createFragment(html);
        if (elm.hasChildNodes() && index < elm.childNodes.length) {
            const target = elm.childNodes[index];
            elm.insertBefore(fragment, target);
        }
        else {
            elm.appendChild(fragment);
        }
    };
    const removeAt = (elm, index) => {
        if (elm.hasChildNodes() && index < elm.childNodes.length) {
            const target = elm.childNodes[index];
            elm.removeChild(target);
        }
    };
    const applyDiff = (diff, elm) => {
        let index = 0;
        each$e(diff, (action) => {
            if (action[0] === KEEP) {
                index++;
            }
            else if (action[0] === INSERT) {
                insertAt(elm, action[1], index);
                index++;
            }
            else if (action[0] === DELETE) {
                removeAt(elm, index);
            }
        });
    };
    const read$2 = (elm, trimZwsp) => filter$5(map$3(from(elm.childNodes), trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml), (item) => {
        return item.length > 0;
    });
    const write = (fragments, elm) => {
        const currentFragments = map$3(from(elm.childNodes), getOuterHtml);
        applyDiff(diff(currentFragments, fragments), elm);
        return elm;
    };

    // We need to create a temporary document instead of using the global document since
    // innerHTML on a detached element will still make http requests to the images
    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));
    const hasIframes = (body) => body.querySelector('iframe') !== null;
    const createFragmentedLevel = (fragments) => {
        return {
            type: 'fragmented',
            fragments,
            content: '',
            bookmark: null,
            beforeBookmark: null
        };
    };
    const createCompleteLevel = (content) => {
        return {
            type: 'complete',
            fragments: null,
            content,
            bookmark: null,
            beforeBookmark: null
        };
    };
    const createFromEditor = (editor) => {
        const tempAttrs = editor.serializer.getTempAttrs();
        const body = trim$1(editor.getBody(), tempAttrs);
        return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$2(body.innerHTML));
    };
    const applyToEditor = (editor, level, before) => {
        const bookmark = before ? level.beforeBookmark : level.bookmark;
        if (level.type === 'fragmented') {
            write(level.fragments, editor.getBody());
        }
        else {
            editor.setContent(level.content, {
                format: 'raw',
                // If we have a path bookmark, we need to check if the bookmark location was a fake caret.
                // If the bookmark was not a fake caret, then we need to ensure that setContent does not move the selection
                // as this can create a new fake caret - particularly if the first element in the body is contenteditable=false.
                // The creation of this new fake caret will cause our path offset to be off by one when restoring the original selection.
                no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true
            });
        }
        if (bookmark) {
            editor.selection.moveToBookmark(bookmark);
            editor.selection.scrollIntoView();
        }
    };
    const getLevelContent = (level) => {
        return level.type === 'fragmented' ? level.fragments.join('') : level.content;
    };
    const getCleanLevelContent = (level) => {
        const elm = SugarElement.fromTag('body', lazyTempDocument());
        set$3(elm, getLevelContent(level));
        each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);
        return get$8(elm);
    };
    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);
    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);
    // Most of the time the contents is equal so it's faster to first check that using strings then fallback to a cleaned dom comparison
    const isEq$1 = (level1, level2) => {
        if (!level1 || !level2) {
            return false;
        }
        else if (hasEqualContent(level1, level2)) {
            return true;
        }
        else {
            return hasEqualCleanedContent(level1, level2);
        }
    };

    const isUnlocked = (locks) => locks.get() === 0;

    const setTyping = (undoManager, typing, locks) => {
        if (isUnlocked(locks)) {
            undoManager.typing = typing;
        }
    };
    const endTyping = (undoManager, locks) => {
        if (undoManager.typing) {
            setTyping(undoManager, false, locks);
            undoManager.add();
        }
    };
    const endTypingLevelIgnoreLocks = (undoManager) => {
        if (undoManager.typing) {
            undoManager.typing = false;
            undoManager.add();
        }
    };

    const beforeChange$1 = (editor, locks, beforeBookmark) => {
        if (isUnlocked(locks)) {
            beforeBookmark.set(getUndoBookmark(editor.selection));
        }
    };
    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {
        const currentLevel = createFromEditor(editor);
        const newLevel = Tools.extend(level || {}, currentLevel);
        if (!isUnlocked(locks) || editor.removed) {
            return null;
        }
        const lastLevel = undoManager.data[index.get()];
        if (editor.dispatch('BeforeAddUndo', { level: newLevel, lastLevel, originalEvent: event }).isDefaultPrevented()) {
            return null;
        }
        // Add undo level if needed
        if (lastLevel && isEq$1(lastLevel, newLevel)) {
            return null;
        }
        // Set before bookmark on previous level
        if (undoManager.data[index.get()]) {
            beforeBookmark.get().each((bm) => {
                undoManager.data[index.get()].beforeBookmark = bm;
            });
        }
        // Time to compress
        const customUndoRedoLevels = getCustomUndoRedoLevels(editor);
        if (customUndoRedoLevels) {
            if (undoManager.data.length > customUndoRedoLevels) {
                for (let i = 0; i < undoManager.data.length - 1; i++) {
                    undoManager.data[i] = undoManager.data[i + 1];
                }
                undoManager.data.length--;
                index.set(undoManager.data.length);
            }
        }
        // Get a non intrusive normalized bookmark
        newLevel.bookmark = getUndoBookmark(editor.selection);
        // Crop array if needed
        if (index.get() < undoManager.data.length - 1) {
            undoManager.data.length = index.get() + 1;
        }
        undoManager.data.push(newLevel);
        index.set(undoManager.data.length - 1);
        const args = { level: newLevel, lastLevel, originalEvent: event };
        if (index.get() > 0) {
            editor.setDirty(true);
            editor.dispatch('AddUndo', args);
            editor.dispatch('change', args);
        }
        else {
            editor.dispatch('AddUndo', args);
        }
        return newLevel;
    };
    const clear$1 = (editor, undoManager, index) => {
        undoManager.data = [];
        index.set(0);
        undoManager.typing = false;
        editor.dispatch('ClearUndos');
    };
    const extra$1 = (editor, undoManager, index, callback1, callback2) => {
        if (undoManager.transact(callback1)) {
            const bookmark = undoManager.data[index.get()].bookmark;
            const lastLevel = undoManager.data[index.get() - 1];
            applyToEditor(editor, lastLevel, true);
            if (undoManager.transact(callback2)) {
                undoManager.data[index.get() - 1].beforeBookmark = bookmark;
            }
        }
    };
    const redo$1 = (editor, index, data) => {
        let level;
        if (index.get() < data.length - 1) {
            index.set(index.get() + 1);
            level = data[index.get()];
            applyToEditor(editor, level, false);
            editor.setDirty(true);
            editor.dispatch('Redo', { level });
        }
        return level;
    };
    const undo$1 = (editor, undoManager, locks, index) => {
        let level;
        if (undoManager.typing) {
            undoManager.add();
            undoManager.typing = false;
            setTyping(undoManager, false, locks);
        }
        if (index.get() > 0) {
            index.set(index.get() - 1);
            level = undoManager.data[index.get()];
            applyToEditor(editor, level, true);
            editor.setDirty(true);
            editor.dispatch('Undo', { level });
        }
        return level;
    };
    const reset$1 = (undoManager) => {
        undoManager.clear();
        undoManager.add();
    };
    const hasUndo$1 = (editor, undoManager, index) => 
    // Has undo levels or typing and content isn't the same as the initial level
    index.get() > 0 || (undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]));
    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;
    const transact$1 = (undoManager, locks, callback) => {
        endTyping(undoManager, locks);
        undoManager.beforeChange();
        undoManager.ignore(callback);
        return undoManager.add();
    };
    const ignore$1 = (locks, callback) => {
        try {
            locks.set(locks.get() + 1);
            callback();
        }
        finally {
            locks.set(locks.get() - 1);
        }
    };

    const addVisualInternal = (editor, elm) => {
        const dom = editor.dom;
        const scope = isNonNullable(elm) ? elm : editor.getBody();
        each$e(dom.select('table,a', scope), (matchedElm) => {
            switch (matchedElm.nodeName) {
                case 'TABLE':
                    const cls = getVisualAidsTableClass(editor);
                    const value = dom.getAttrib(matchedElm, 'border');
                    if ((!value || value === '0') && editor.hasVisual) {
                        dom.addClass(matchedElm, cls);
                    }
                    else {
                        dom.removeClass(matchedElm, cls);
                    }
                    break;
                case 'A':
                    if (!dom.getAttrib(matchedElm, 'href')) {
                        const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;
                        const cls = getVisualAidsAnchorClass(editor);
                        if (value && editor.hasVisual) {
                            dom.addClass(matchedElm, cls);
                        }
                        else {
                            dom.removeClass(matchedElm, cls);
                        }
                    }
                    break;
            }
        });
        editor.dispatch('VisualAid', { element: elm, hasVisual: editor.hasVisual });
    };

    const makePlainAdaptor = (editor) => ({
        init: {
            bindEvents: noop
        },
        undoManager: {
            beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),
            add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),
            undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),
            redo: (index, data) => redo$1(editor, index, data),
            clear: (undoManager, index) => clear$1(editor, undoManager, index),
            reset: (undoManager) => reset$1(undoManager),
            hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),
            hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),
            transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),
            ignore: (locks, callback) => ignore$1(locks, callback),
            extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)
        },
        formatter: {
            match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),
            matchAll: (names, vars) => matchAll(editor, names, vars),
            matchNode: (node, name, vars, similar) => matchNode$1(editor, node, name, vars, similar),
            canApply: (name) => canApply(editor, name),
            closest: (names) => closest(editor, names),
            apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),
            remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),
            toggle: (name, vars, node) => toggle(editor, name, vars, node),
            formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)
        },
        editor: {
            getContent: (args) => getContentInternal(editor, args),
            setContent: (content, args) => setContentInternal(editor, content, args),
            insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),
            addVisual: (elm) => addVisualInternal(editor, elm)
        },
        selection: {
            getContent: (format, args) => getSelectedContentInternal(editor, format, args)
        },
        autocompleter: {
            addDecoration: noop, // This was never fully implemented in RTC
            removeDecoration: noop, // This was never fully implemented in RTC
        },
        raw: {
            getModel: () => Optional.none()
        }
    });
    const makeRtcAdaptor = (rtcEditor) => {
        const defaultVars = (vars) => isObject(vars) ? vars : {};
        const { init, undoManager, formatter, editor, selection, autocompleter, raw } = rtcEditor;
        return {
            init: {
                bindEvents: init.bindEvents
            },
            undoManager: {
                beforeChange: undoManager.beforeChange,
                add: undoManager.add,
                undo: undoManager.undo,
                redo: undoManager.redo,
                clear: undoManager.clear,
                reset: undoManager.reset,
                hasUndo: undoManager.hasUndo,
                hasRedo: undoManager.hasRedo,
                transact: (_undoManager, _locks, fn) => undoManager.transact(fn),
                ignore: (_locks, callback) => undoManager.ignore(callback),
                extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)
            },
            formatter: {
                match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),
                matchAll: formatter.matchAll,
                matchNode: formatter.matchNode,
                canApply: (name) => formatter.canApply(name),
                closest: (names) => formatter.closest(names),
                apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),
                remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),
                toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),
                formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)
            },
            editor: {
                getContent: (args) => editor.getContent(args),
                setContent: (content, args) => {
                    return { content: editor.setContent(content, args), html: '' };
                },
                insertContent: (content, _details) => {
                    editor.insertContent(content);
                    return '';
                },
                addVisual: editor.addVisual
            },
            selection: {
                getContent: (_format, args) => selection.getContent(args)
            },
            autocompleter: {
                addDecoration: autocompleter.addDecoration,
                removeDecoration: autocompleter.removeDecoration
            },
            raw: {
                getModel: () => Optional.some(raw.getRawModel())
            }
        };
    };
    const makeNoopAdaptor = () => {
        // Cast as any since this will never match the implementations
        const nul = constant(null);
        const empty = constant('');
        return {
            init: {
                bindEvents: noop
            },
            undoManager: {
                beforeChange: noop,
                add: nul,
                undo: nul,
                redo: nul,
                clear: noop,
                reset: noop,
                hasUndo: never,
                hasRedo: never,
                transact: nul,
                ignore: noop,
                extra: noop
            },
            formatter: {
                match: never,
                matchAll: constant([]),
                matchNode: constant(undefined),
                canApply: never,
                closest: empty,
                apply: noop,
                remove: noop,
                toggle: noop,
                formatChanged: constant({ unbind: noop })
            },
            editor: {
                getContent: empty,
                setContent: constant({ content: '', html: '' }),
                insertContent: constant(''),
                addVisual: noop
            },
            selection: {
                getContent: empty
            },
            autocompleter: {
                addDecoration: noop,
                removeDecoration: noop
            },
            raw: {
                getModel: constant(Optional.none())
            }
        };
    };
    const isRtc = (editor) => has$2(editor.plugins, 'rtc');
    const getRtcSetup = (editor) => get$a(editor.plugins, 'rtc').bind((rtcPlugin) => 
    // This might not exist if the stub plugin is loaded on cloud
    Optional.from(rtcPlugin.setup));
    const setup$z = (editor) => {
        const editorCast = editor;
        return getRtcSetup(editor).fold(() => {
            editorCast.rtcInstance = makePlainAdaptor(editor);
            return Optional.none();
        }, (setup) => {
            // We need to provide a noop adaptor while initializing since any call by the theme or plugins to say undoManager.hasUndo would throw errors
            editorCast.rtcInstance = makeNoopAdaptor();
            return Optional.some(() => setup().then((rtcEditor) => {
                editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
                return rtcEditor.rtc.isRemote;
            }));
        });
    };
    const getRtcInstanceWithFallback = (editor) => 
    // Calls to editor.getContent/editor.setContent should still work even if the rtcInstance is not yet available
    editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
    const getRtcInstanceWithError = (editor) => {
        const rtcInstance = editor.rtcInstance;
        if (!rtcInstance) {
            throw new Error('Failed to get RTC instance not yet initialized.');
        }
        else {
            return rtcInstance;
        }
    };
    /** In theory these could all be inlined but having them here makes it clear what is overridden */
    const beforeChange = (editor, locks, beforeBookmark) => {
        getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);
    };
    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);
    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);
    const clear = (editor, undoManager, index) => {
        getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
    };
    const reset = (editor, undoManager) => {
        getRtcInstanceWithError(editor).undoManager.reset(undoManager);
    };
    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);
    const ignore = (editor, locks, callback) => {
        getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
    };
    const extra = (editor, undoManager, index, callback1, callback2) => {
        getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);
    };
    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);
    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);
    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);
    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);
    const applyFormat = (editor, name, vars, node) => {
        getRtcInstanceWithError(editor).formatter.apply(name, vars, node);
    };
    const removeFormat = (editor, name, vars, node, similar) => {
        getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);
    };
    const toggleFormat = (editor, name, vars, node) => {
        getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);
    };
    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);
    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);
    const setContent$1 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);
    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);
    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);
    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);
    const bindEvents = (editor) => getRtcInstanceWithError(editor).init.bindEvents();

    const getContent$1 = (editor, args = {}) => {
        const format = args.format ? args.format : 'html';
        return getSelectedContent(editor, format, args);
    };

    const deleteFromCallbackMap = (callbackMap, selector, callback) => {
        if (has$2(callbackMap, selector)) {
            const newCallbacks = filter$5(callbackMap[selector], (cb) => cb !== callback);
            if (newCallbacks.length === 0) {
                delete callbackMap[selector];
            }
            else {
                callbackMap[selector] = newCallbacks;
            }
        }
    };
    var SelectorChanged = (dom, editor) => {
        let selectorChangedData;
        let currentSelectors;
        const findMatchingNode = (selector, nodes) => find$2(nodes, (node) => dom.is(node, selector));
        const getParents = (elem) => dom.getParents(elem, undefined, dom.getRoot());
        const setup = () => {
            selectorChangedData = {};
            currentSelectors = {};
            editor.on('NodeChange', (e) => {
                const node = e.element;
                const parents = getParents(node);
                const matchedSelectors = {};
                // Check for new matching selectors
                each$d(selectorChangedData, (callbacks, selector) => {
                    findMatchingNode(selector, parents).each((node) => {
                        if (!currentSelectors[selector]) {
                            // Execute callbacks
                            each$e(callbacks, (callback) => {
                                callback(true, { node, selector, parents });
                            });
                            currentSelectors[selector] = callbacks;
                        }
                        matchedSelectors[selector] = callbacks;
                    });
                });
                // Check if current selectors still match
                each$d(currentSelectors, (callbacks, selector) => {
                    if (!matchedSelectors[selector]) {
                        delete currentSelectors[selector];
                        each$e(callbacks, (callback) => {
                            callback(false, { node, selector, parents });
                        });
                    }
                });
            });
        };
        return {
            selectorChangedWithUnbind: (selector, callback) => {
                if (!selectorChangedData) {
                    setup();
                }
                // Add selector listeners
                if (!selectorChangedData[selector]) {
                    selectorChangedData[selector] = [];
                }
                selectorChangedData[selector].push(callback);
                // Setup the initial state if selected already
                findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {
                    currentSelectors[selector] = selectorChangedData[selector];
                });
                return {
                    unbind: () => {
                        deleteFromCallbackMap(selectorChangedData, selector, callback);
                        deleteFromCallbackMap(currentSelectors, selector, callback);
                    }
                };
            }
        };
    };

    /**
     * This class handles text and control selection it's an crossbrowser utility class.
     * Consult the TinyMCE API Documentation for more details and examples on how to use this class.
     *
     * @class tinymce.dom.Selection
     * @example
     * // Getting the currently selected node for the active editor
     * alert(tinymce.activeEditor.selection.getNode().nodeName);
     */
    const isAttachedToDom = (node) => {
        return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));
    };
    const isValidRange = (rng) => {
        if (!rng) {
            return false;
        }
        else {
            return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
        }
    };
    /**
     * Constructs a new selection instance.
     *
     * @constructor
     * @method Selection
     * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.
     * @param {Window} win Window to bind the selection object to.
     * @param {tinymce.dom.Serializer} serializer DOM serialization class to use for getContent.
     * @param {tinymce.Editor} editor Editor instance of the selection.
     */
    const EditorSelection = (dom, win, serializer, editor) => {
        let selectedRange;
        let explicitRange;
        const { selectorChangedWithUnbind } = SelectorChanged(dom, editor);
        /**
         * Move the selection cursor range to the specified node and offset.
         * If there is no node specified it will move it to the first suitable location within the body.
         *
         * @method setCursorLocation
         * @param {Node} node Optional node to put the cursor in.
         * @param {Number} offset Optional offset from the start of the node to put the cursor at.
         */
        const setCursorLocation = (node, offset) => {
            const rng = dom.createRng();
            if (isNonNullable(node) && isNonNullable(offset)) {
                rng.setStart(node, offset);
                rng.setEnd(node, offset);
                setRng(rng);
                collapse(false);
            }
            else {
                moveEndPoint(dom, rng, editor.getBody(), true);
                setRng(rng);
            }
        };
        /**
         * Returns the selected contents using the DOM serializer passed in to this class.
         *
         * @method getContent
         * @param {Object} args Optional settings class with for example output format text or html.
         * @return {String} Selected contents in for example HTML format.
         * @example
         * // Alerts the currently selected contents
         * alert(tinymce.activeEditor.selection.getContent());
         *
         * // Alerts the currently selected contents as plain text
         * alert(tinymce.activeEditor.selection.getContent({ format: 'text' }));
         */
        const getContent = (args) => getContent$1(editor, args);
        /**
         * This method has been deprecated. Use "editor.insertContent" instead.
         *
         * Sets the current selection to the specified content. If any contents is selected it will be replaced
         * with the contents passed in to this function. If there is no selection the contents will be inserted
         * where the caret is placed in the editor/page.
         *
         * @method setContent
         * @param {String} content HTML contents to set could also be other formats depending on settings.
         * @param {Object} args Optional settings object with for example data format.
         * @example
         * // Inserts some HTML contents at the current selection
         * tinymce.activeEditor.selection.setContent('<strong>Some contents</strong>');
         */
        const setContent = (content, args) => setContentExternal(editor, content, args);
        /**
         * Returns the start element of a selection range. If the start is in a text
         * node the parent element will be returned.
         *
         * @method getStart
         * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
         * @return {Element} Start element of selection range.
         */
        const getStart$1 = (real) => getStart(editor.getBody(), getRng$1(), real);
        /**
         * Returns the end element of a selection range. If the end is in a text
         * node the parent element will be returned.
         *
         * @method getEnd
         * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
         * @return {Element} End element of selection range.
         */
        const getEnd$1 = (real) => getEnd(editor.getBody(), getRng$1(), real);
        /**
         * Returns a bookmark location for the current selection. This bookmark object
         * can then be used to restore the selection after some content modification to the document.
         *
         * @method getBookmark
         * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
         * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
         * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
         * @example
         * // Stores a bookmark of the current selection
         * const bm = tinymce.activeEditor.selection.getBookmark();
         *
         * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
         *
         * // Restore the selection bookmark
         * tinymce.activeEditor.selection.moveToBookmark(bm);
         */
        const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);
        /**
         * Restores the selection to the specified bookmark.
         *
         * @method moveToBookmark
         * @param {Object} bookmark Bookmark to restore selection from.
         * @example
         * // Stores a bookmark of the current selection
         * const bm = tinymce.activeEditor.selection.getBookmark();
         *
         * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
         *
         * // Restore the selection bookmark
         * tinymce.activeEditor.selection.moveToBookmark(bm);
         */
        const moveToBookmark = (bookmark) => bookmarkManager.moveToBookmark(bookmark);
        /**
         * Selects the specified element. This will place the start and end of the selection range around the element.
         *
         * @method select
         * @param {Element} node HTML DOM element to select.
         * @param {Boolean} content Optional bool state if the contents should be selected or not on non IE browser.
         * @return {Element} Selected element the same element as the one that got passed in.
         * @example
         * // Select the first paragraph in the active editor
         * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select('p')[0]);
         */
        const select$1 = (node, content) => {
            select(dom, node, content).each(setRng);
            return node;
        };
        /**
         * Returns true/false if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.
         *
         * @method isCollapsed
         * @return {Boolean} true/false state if the selection range is collapsed or not.
         * Collapsed means if it's a caret or a larger selection.
         */
        const isCollapsed = () => {
            const rng = getRng$1(), sel = getSel();
            if (!rng || rng.item) {
                return false;
            }
            if (rng.compareEndPoints) {
                return rng.compareEndPoints('StartToEnd', rng) === 0;
            }
            return !sel || rng.collapsed;
        };
        /**
         * Checks if the current selections start and end containers are editable within their parents contexts.
         *
         * @method isEditable
         * @return {Boolean} Will be true if the selection is editable and false if it's not editable.
         */
        const isEditable = () => {
            if (editor.mode.isReadOnly()) {
                return false;
            }
            const rng = getRng$1();
            const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected="1"]');
            if (fakeSelectedElements.length > 0) {
                return forall(fakeSelectedElements, (el) => dom.isEditable(el.parentElement));
            }
            else {
                return isEditableRange(dom, rng);
            }
        };
        /**
         * Collapse the selection to start or end of range.
         *
         * @method collapse
         * @param {Boolean} toStart Optional boolean state if to collapse to end or not. Defaults to false.
         */
        const collapse = (toStart) => {
            const rng = getRng$1();
            rng.collapse(!!toStart);
            setRng(rng);
        };
        /**
         * Returns the browsers internal selection object.
         *
         * @method getSel
         * @return {Selection} Internal browser selection object.
         */
        const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;
        /**
         * Returns the browsers internal range object.
         *
         * @method getRng
         * @return {Range} Internal browser range object.
         * @see http://www.quirksmode.org/dom/range_intro.html
         * @see http://www.dotvoid.com/2001/03/using-the-range-object-in-mozilla/
         */
        const getRng$1 = () => {
            let rng;
            const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {
                try {
                    return sourceRange.compareBoundaryPoints(how, destinationRange);
                }
                catch (_a) {
                    // Gecko throws wrong document exception if the range points
                    // to nodes that where removed from the dom #6690
                    // Browsers should mutate existing DOMRange instances so that they always point
                    // to something in the document this is not the case in Gecko works fine in IE/WebKit/Blink
                    // For performance reasons just return -1
                    return -1;
                }
            };
            const doc = win.document;
            if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
                const bookmark = getRng(editor);
                if (bookmark.isSome()) {
                    return bookmark.map((r) => processRanges(editor, [r])[0]).getOr(doc.createRange());
                }
            }
            try {
                const selection = getSel();
                if (selection && !isRestrictedNode(selection.anchorNode)) {
                    if (selection.rangeCount > 0) {
                        rng = selection.getRangeAt(0);
                    }
                    else {
                        rng = doc.createRange();
                    }
                    rng = processRanges(editor, [rng])[0];
                }
            }
            catch (_a) {
                // IE throws unspecified error here if TinyMCE is placed in a frame/iframe
            }
            // No range found then create an empty one
            // This can occur when the editor is placed in a hidden container element on Gecko
            if (!rng) {
                rng = doc.createRange();
            }
            // If range is at start of document then move it to start of body
            if (isDocument$1(rng.startContainer) && rng.collapsed) {
                const elm = dom.getRoot();
                rng.setStart(elm, 0);
                rng.setEnd(elm, 0);
            }
            if (selectedRange && explicitRange) {
                if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 &&
                    tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
                    // Safari, Opera and Chrome only ever select text which causes the range to change.
                    // This lets us use the originally set range if the selection hasn't been changed by the user.
                    rng = explicitRange;
                }
                else {
                    selectedRange = null;
                    explicitRange = null;
                }
            }
            return rng;
        };
        /**
         * Changes the selection to the specified DOM range.
         *
         * @method setRng
         * @param {Range} rng Range to select.
         * @param {Boolean} forward Optional boolean if the selection is forwards or backwards.
         */
        const setRng = (rng, forward) => {
            if (!isValidRange(rng)) {
                return;
            }
            const sel = getSel();
            const evt = editor.dispatch('SetSelectionRange', { range: rng, forward });
            rng = evt.range;
            if (sel) {
                explicitRange = rng;
                try {
                    sel.removeAllRanges();
                    sel.addRange(rng);
                }
                catch (_a) {
                    // IE might throw errors here if the editor is within a hidden container and selection is changed
                }
                // Forward is set to false and we have an extend function
                if (forward === false && sel.extend) {
                    sel.collapse(rng.endContainer, rng.endOffset);
                    sel.extend(rng.startContainer, rng.startOffset);
                }
                // adding range isn't always successful so we need to check range count otherwise an exception can occur
                selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
            }
            // WebKit edge case selecting images works better using setBaseAndExtent when the image is floated
            if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {
                if (rng.endOffset - rng.startOffset < 2) {
                    if (rng.startContainer.hasChildNodes()) {
                        const node = rng.startContainer.childNodes[rng.startOffset];
                        if (node && node.nodeName === 'IMG') {
                            sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
                            // Since the setBaseAndExtent is fixed in more recent Blink versions we
                            // need to detect if it's doing the wrong thing and falling back to the
                            // crazy incorrect behavior api call since that seems to be the only way
                            // to get it to work on Safari WebKit as of 2017-02-23
                            if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                                sel.setBaseAndExtent(node, 0, node, 1);
                            }
                        }
                    }
                }
            }
            editor.dispatch('AfterSetSelectionRange', { range: rng, forward });
        };
        /**
         * Sets the current selection to the specified DOM element.
         *
         * @method setNode
         * @param {Element} elm Element to set as the contents of the selection.
         * @return {Element} Returns the element that got passed in.
         * @example
         * // Inserts a DOM node at current selection/caret location
         * tinymce.activeEditor.selection.setNode(tinymce.activeEditor.dom.create('img', { src: 'some.gif', title: 'some title' }));
         */
        const setNode = (elm) => {
            setContentInternal$1(editor, dom.getOuterHTML(elm));
            return elm;
        };
        /**
         * Returns the currently selected element or the common ancestor element for both start and end of the selection.
         *
         * @method getNode
         * @return {Element} Currently selected element or common ancestor element.
         * @example
         * // Alerts the currently selected elements node name
         * alert(tinymce.activeEditor.selection.getNode().nodeName);
         */
        const getNode$1 = () => getNode(editor.getBody(), getRng$1());
        const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);
        const isForward = () => {
            const sel = getSel();
            const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
            const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
            // No support for selection direction then always return true
            if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {
                return true;
            }
            const anchorRange = dom.createRng();
            const focusRange = dom.createRng();
            try {
                anchorRange.setStart(anchorNode, sel.anchorOffset);
                anchorRange.collapse(true);
                focusRange.setStart(focusNode, sel.focusOffset);
                focusRange.collapse(true);
            }
            catch (_a) {
                // Safari can generate an invalid selection and error. Silently handle it and default to forward.
                // See https://bugs.webkit.org/show_bug.cgi?id=230594.
                return true;
            }
            return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
        };
        const normalize = () => {
            const rng = getRng$1();
            const sel = getSel();
            if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {
                const normRng = normalize$2(dom, rng);
                normRng.each((normRng) => {
                    setRng(normRng, isForward());
                });
                return normRng.getOr(rng);
            }
            return rng;
        };
        /**
         * Executes callback when the current selection starts/stops matching the specified selector. The current
         * state will be passed to the callback as it's first argument.
         *
         * @method selectorChanged
         * @param {String} selector CSS selector to check for.
         * @param {Function} callback Callback with state and args when the selector is matches or not.
         */
        // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
        const selectorChanged = (selector, callback) => {
            selectorChangedWithUnbind(selector, callback);
            return exports;
        };
        const getScrollContainer = () => {
            let scrollContainer;
            let node = dom.getRoot();
            while (node && node.nodeName !== 'BODY') {
                if (node.scrollHeight > node.clientHeight) {
                    scrollContainer = node;
                    break;
                }
                node = node.parentNode;
            }
            return scrollContainer;
        };
        const scrollIntoView = (elm, alignToTop) => {
            if (isNonNullable(elm)) {
                scrollElementIntoView(editor, elm, alignToTop);
            }
            else {
                scrollRangeIntoView(editor, getRng$1(), alignToTop);
            }
        };
        const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));
        const getBoundingClientRect = () => {
            const rng = getRng$1();
            return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
        };
        const destroy = () => {
            win = selectedRange = explicitRange = null;
            controlSelection.destroy();
        };
        /**
         * Expands the selection range to contain the entire word when the selection is collapsed within the word.
         *
         * @method expand
         * @param {Object} options Optional options provided to the expansion. Defaults to { type: 'word' }
         */
        const expand = (options = { type: 'word' }) => setRng(RangeUtils(dom).expand(getRng$1(), options));
        const exports = {
            dom,
            win,
            serializer,
            editor,
            expand,
            collapse,
            setCursorLocation,
            getContent,
            setContent,
            getBookmark,
            moveToBookmark,
            select: select$1,
            isCollapsed,
            isEditable,
            isForward,
            setNode,
            getNode: getNode$1,
            getSel,
            setRng,
            getRng: getRng$1,
            getStart: getStart$1,
            getEnd: getEnd$1,
            getSelectedBlocks: getSelectedBlocks$1,
            normalize,
            selectorChanged,
            selectorChangedWithUnbind,
            getScrollContainer,
            scrollIntoView,
            placeCaretAt,
            getBoundingClientRect,
            destroy
        };
        const bookmarkManager = BookmarkManager(exports);
        const controlSelection = ControlSelection(exports, editor);
        exports.bookmarkManager = bookmarkManager;
        exports.controlSelection = controlSelection;
        return exports;
    };

    const addNodeFilter = (settings, htmlParser, schema) => {
        htmlParser.addNodeFilter('br', (nodes, _, args) => {
            const blockElements = Tools.extend({}, schema.getBlockElements());
            const nonEmptyElements = schema.getNonEmptyElements();
            const whitespaceElements = schema.getWhitespaceElements();
            // Remove brs from body element as well
            blockElements.body = 1;
            const isBlock = (node) => node.name in blockElements || isTransparentAstBlock(schema, node);
            // Must loop forwards since it will otherwise remove all brs in <p>a<br><br><br></p>
            for (let i = 0, l = nodes.length; i < l; i++) {
                let node = nodes[i];
                let parent = node.parent;
                if (parent && isBlock(parent) && node === parent.lastChild) {
                    // Loop all nodes to the left of the current node and check for other BR elements
                    // excluding bookmarks since they are invisible
                    let prev = node.prev;
                    while (prev) {
                        const prevName = prev.name;
                        // Ignore bookmarks
                        if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {
                            // Found another br it's a <br><br> structure then don't remove anything
                            if (prevName === 'br') {
                                node = null;
                            }
                            break;
                        }
                        prev = prev.prev;
                    }
                    if (node) {
                        node.remove();
                        // Is the parent to be considered empty after we removed the BR
                        if (isEmpty$2(schema, nonEmptyElements, whitespaceElements, parent)) {
                            const elementRule = schema.getElementRule(parent.name);
                            // Remove or padd the element depending on schema rule
                            if (elementRule) {
                                if (elementRule.removeEmpty) {
                                    parent.remove();
                                }
                                else if (elementRule.paddEmpty) {
                                    paddEmptyNode(settings, args, isBlock, parent);
                                }
                            }
                        }
                    }
                }
                else {
                    // Replaces BR elements inside inline elements like <p><b><i><br></i></b></p>
                    // so they become <p><b><i>&nbsp;</i></b></p>
                    let lastParent = node;
                    while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {
                        lastParent = parent;
                        if (blockElements[parent.name]) {
                            break;
                        }
                        parent = parent.parent;
                    }
                    if (lastParent === parent) {
                        const textNode = new AstNode('#text', 3);
                        textNode.value = nbsp;
                        node.replace(textNode);
                    }
                }
            }
        });
    };

    const register$3 = (htmlParser, settings, dom) => {
        // Convert tabindex back to elements when serializing contents
        htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                node.attr('tabindex', node.attr('data-mce-tabindex'));
                node.attr(name, null);
            }
        });
        // Convert move data-mce-src, data-mce-href and data-mce-style into nodes or process them if needed
        htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {
            const internalName = 'data-mce-' + name;
            const urlConverter = settings.url_converter;
            const urlConverterScope = settings.url_converter_scope;
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                let value = node.attr(internalName);
                if (value !== undefined) {
                    // Set external name to internal value and remove internal
                    node.attr(name, value.length > 0 ? value : null);
                    node.attr(internalName, null);
                }
                else {
                    // No internal attribute found then convert the value we have in the DOM
                    value = node.attr(name);
                    if (name === 'style') {
                        value = dom.serializeStyle(dom.parseStyle(value), node.name);
                    }
                    else if (urlConverter) {
                        value = urlConverter.call(urlConverterScope, value, name, node.name);
                    }
                    node.attr(name, value.length > 0 ? value : null);
                }
            }
        });
        // Remove internal classes mceItem<..> or mceSelected
        htmlParser.addAttributeFilter('class', (nodes) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                let value = node.attr('class');
                if (value) {
                    value = value.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, '');
                    node.attr('class', value.length > 0 ? value : null);
                }
            }
        });
        // Remove bookmark elements
        htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {
                    // We maybe dealing with a "filled" bookmark. If so just remove the node, otherwise unwrap it
                    const hasChildren = Optional.from(node.firstChild).exists((firstChild) => { var _a; return !isZwsp((_a = firstChild.value) !== null && _a !== void 0 ? _a : ''); });
                    if (hasChildren) {
                        node.unwrap();
                    }
                    else {
                        node.remove();
                    }
                }
            }
        });
        // Force script into CDATA sections and remove the mce- prefix also add comments around styles
        htmlParser.addNodeFilter('script,style', (nodes, name) => {
            var _a;
            const trim = (value) => {
                /* jshint maxlen:255 */
                /* eslint max-len:0 */
                return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n')
                    .replace(/^[\r\n]*|[\r\n]*$/g, '')
                    .replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, '')
                    .replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, '');
            };
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                const firstChild = node.firstChild;
                const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';
                if (name === 'script') {
                    // Remove mce- prefix from script elements and remove default type since the user specified
                    // a script element without type attribute
                    const type = node.attr('type');
                    if (type) {
                        node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\-/, ''));
                    }
                    if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {
                        firstChild.value = '// <![CDATA[\n' + trim(value) + '\n// ]]>';
                    }
                }
                else {
                    if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {
                        firstChild.value = '<!--\n' + trim(value) + '\n-->';
                    }
                }
            }
        });
        // Convert comments to cdata and handle protected comments
        htmlParser.addNodeFilter('#comment', (nodes) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                const value = node.value;
                if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {
                    node.name = '#cdata';
                    node.type = 4;
                    node.value = dom.decode(value.replace(/^\[CDATA\[|\]\]$/g, ''));
                }
                else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {
                    node.name = '#text';
                    node.type = 3;
                    node.raw = true;
                    node.value = unescape(value).substr(14);
                }
            }
        });
        htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                if (node.type === 7) {
                    node.remove();
                }
                else if (node.type === 1) {
                    if (name === 'input' && !node.attr('type')) {
                        node.attr('type', 'text');
                    }
                }
            }
        });
        htmlParser.addAttributeFilter('data-mce-type', (nodes) => {
            each$e(nodes, (node) => {
                if (node.attr('data-mce-type') === 'format-caret') {
                    if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
                        node.remove();
                    }
                    else {
                        node.unwrap();
                    }
                }
            });
        });
        // Remove internal data attributes
        htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' +
            'data-mce-selected,data-mce-expando,data-mce-block,' +
            'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {
            let i = nodes.length;
            while (i--) {
                nodes[i].attr(name, null);
            }
        });
        // Remove <br> at end of block elements Gecko and WebKit injects BR elements to
        // make it possible to place the caret inside empty blocks. This logic tries to remove
        // these elements and keep br elements that where intended to be there intact
        if (settings.remove_trailing_brs) {
            addNodeFilter(settings, htmlParser, htmlParser.schema);
        }
    };
    /**
     * IE 11 has a fantastic bug where it will produce two trailing BR elements to iframe bodies when
     * the iframe is hidden by display: none on a parent container. The DOM is actually out of sync
     * with innerHTML in this case. It's like IE adds shadow DOM BR elements that appears on innerHTML
     * but not as the lastChild of the body. So this fix simply removes the last two
     * BR elements at the end of the document.
     *
     * Example of what happens: <body>text</body> becomes <body>text<br><br></body>
     */
    const trimTrailingBr = (rootNode) => {
        const isBr = (node) => {
            return (node === null || node === void 0 ? void 0 : node.name) === 'br';
        };
        const brNode1 = rootNode.lastChild;
        if (isBr(brNode1)) {
            const brNode2 = brNode1.prev;
            if (isBr(brNode2)) {
                brNode1.remove();
                brNode2.remove();
            }
        }
    };

    const preProcess$1 = (editor, node, args) => {
        let oldDoc;
        const dom = editor.dom;
        let clonedNode = node.cloneNode(true);
        // Nodes needs to be attached to something in WebKit/Opera
        // This fix will make DOM ranges and make Sizzle happy!
        const impl = document.implementation;
        if (impl.createHTMLDocument) {
            // Create an empty HTML document
            const doc = impl.createHTMLDocument('');
            // Add the element or it's children if it's a body element to the new document
            Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], (node) => {
                doc.body.appendChild(doc.importNode(node, true));
            });
            // Grab first child or body element for serialization
            if (clonedNode.nodeName !== 'BODY') {
                // We cast to a Element here, as this will be the cloned node imported and appended above
                clonedNode = doc.body.firstChild;
            }
            else {
                clonedNode = doc.body;
            }
            // set the new document in DOMUtils so createElement etc works
            oldDoc = dom.doc;
            dom.doc = doc;
        }
        firePreProcess(editor, { ...args, node: clonedNode });
        if (oldDoc) {
            dom.doc = oldDoc;
        }
        return clonedNode;
    };
    const shouldFireEvent = (editor, args) => {
        return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;
    };
    const process$1 = (editor, node, args) => {
        return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;
    };

    const addTempAttr = (htmlParser, tempAttrs, name) => {
        if (Tools.inArray(tempAttrs, name) === -1) {
            htmlParser.addAttributeFilter(name, (nodes, name) => {
                let i = nodes.length;
                while (i--) {
                    nodes[i].attr(name, null);
                }
            });
            tempAttrs.push(name);
        }
    };
    const postProcess = (editor, args, content) => {
        if (!args.no_events && editor) {
            const outArgs = firePostProcess(editor, { ...args, content });
            return outArgs.content;
        }
        else {
            return content;
        }
    };
    const getHtmlFromNode = (dom, node, args) => {
        // TODO: Investigate if using `innerHTML` is correct as DomSerializerPreProcess definitely returns a Node
        const html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));
        return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);
    };
    const parseHtml = (htmlParser, html, args) => {
        const parserArgs = args.selection ? { forced_root_block: false, ...args } : args;
        const rootNode = htmlParser.parse(html, parserArgs);
        trimTrailingBr(rootNode);
        return rootNode;
    };
    const serializeNode = (settings, schema, node) => {
        const htmlSerializer = HtmlSerializer(settings, schema);
        return htmlSerializer.serialize(node);
    };
    const toHtml = (editor, settings, schema, rootNode, args) => {
        const content = serializeNode(settings, schema, rootNode);
        return postProcess(editor, args, content);
    };
    const DomSerializerImpl = (settings, editor) => {
        const tempAttrs = ['data-mce-selected'];
        const defaultedSettings = {
            entity_encoding: 'named',
            remove_trailing_brs: true,
            pad_empty_with_br: false,
            ...settings
        };
        const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;
        const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);
        const htmlParser = DomParser(defaultedSettings, schema);
        register$3(htmlParser, defaultedSettings, dom);
        const serialize = (node, parserArgs = {}) => {
            const args = { format: 'html', ...parserArgs };
            const targetNode = process$1(editor, node, args);
            const html = getHtmlFromNode(dom, targetNode, args);
            const rootNode = parseHtml(htmlParser, html, args);
            return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);
        };
        return {
            schema,
            addNodeFilter: htmlParser.addNodeFilter,
            addAttributeFilter: htmlParser.addAttributeFilter,
            serialize: serialize,
            addRules: schema.addValidElements,
            setRules: schema.setValidElements,
            addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
            getTempAttrs: constant(tempAttrs),
            getNodeFilters: htmlParser.getNodeFilters,
            getAttributeFilters: htmlParser.getAttributeFilters,
            removeNodeFilter: htmlParser.removeNodeFilter,
            removeAttributeFilter: htmlParser.removeAttributeFilter
        };
    };

    /**
     * This class is used to serialize DOM trees into a string. Consult the TinyMCE API Documentation for
     * more details and examples on how to use this class.
     *
     * @class tinymce.dom.Serializer
     */
    const DomSerializer = (settings, editor) => {
        const domSerializer = DomSerializerImpl(settings, editor);
        // Return public methods
        return {
            /**
             * Schema instance that was used to when the Serializer was constructed.
             *
             * @field {tinymce.html.Schema} schema
             */
            schema: domSerializer.schema,
            /**
             * Adds a node filter function to the parser used by the serializer, the parser will collect the specified nodes by name
             * and then execute the callback once it has finished parsing the document.
             *
             * @method addNodeFilter
             * @param {String} name Comma separated list of nodes to collect.
             * @param {Function} callback Callback function to execute once it has collected nodes.
             * @example
             * serializer.addNodeFilter('p,h1', (nodes, name) => {
             *   for (let i = 0; i < nodes.length; i++) {
             *     console.log(nodes[i].name);
             *   }
             * });
             */
            addNodeFilter: domSerializer.addNodeFilter,
            /**
             * Adds an attribute filter function to the parser used by the serializer, the parser will
             * collect nodes that has the specified attributes
             * and then execute the callback once it has finished parsing the document.
             *
             * @method addAttributeFilter
             * @param {String} name Comma separated list of attributes to collect.
             * @param {Function} callback Callback function to execute once it has collected nodes.
             * @example
             * serializer.addAttributeFilter('src,href', (nodes, name) => {
             *   for (let i = 0; i < nodes.length; i++) {
             *     console.log(nodes[i].name);
             *   }
             * });
             */
            addAttributeFilter: domSerializer.addAttributeFilter,
            /**
             * Serializes the specified browser DOM node into a HTML string.
             *
             * @method serialize
             * @param {DOMNode} node DOM node to serialize.
             * @param {Object} args Arguments option that gets passed to event handlers.
             */
            serialize: domSerializer.serialize,
            /**
             * Adds valid elements rules to the serializers schema instance this enables you to specify things
             * like what elements should be outputted and what attributes specific elements might have.
             * Consult the TinyMCE Documentation for more details on this format.
             *
             * @method addRules
             * @param {String} rules Valid elements rules string to add to schema.
             */
            addRules: domSerializer.addRules,
            /**
             * Sets the valid elements rules to the serializers schema instance this enables you to specify things
             * like what elements should be outputted and what attributes specific elements might have.
             * Consult the TinyMCE Documentation for more details on this format.
             *
             * @method setRules
             * @param {String} rules Valid elements rules string.
             */
            setRules: domSerializer.setRules,
            /**
             * Adds a temporary internal attribute these attributes will get removed on undo and
             * when getting contents out of the editor.
             *
             * @method addTempAttr
             * @param {String} name string
             */
            addTempAttr: domSerializer.addTempAttr,
            /**
             * Returns an array of all added temp attrs names.
             *
             * @method getTempAttrs
             * @return {String[]} Array with attribute names.
             */
            getTempAttrs: domSerializer.getTempAttrs,
            getNodeFilters: domSerializer.getNodeFilters,
            getAttributeFilters: domSerializer.getAttributeFilters,
            /**
             * Removes a node filter function or removes all filter functions from the parser used by the serializer for the node names provided.
             *
             * @method removeNodeFilter
             * @param {String} name Comma separated list of node names to remove filters for.
             * @param {Function} callback Optional callback function to only remove a specific callback.
             * @example
             * // Remove a single filter
             * serializer.removeNodeFilter('p,h1', someCallback);
             *
             * // Remove all filters
             * serializer.removeNodeFilter('p,h1');
             */
            removeNodeFilter: domSerializer.removeNodeFilter,
            /**
             * Removes an attribute filter function or removes all filter functions from the parser used by the serializer for the attribute names provided.
             *
             * @method removeAttributeFilter
             * @param {String} name Comma separated list of attribute names to remove filters for.
             * @param {Function} callback Optional callback function to only remove a specific callback.
             * @example
             * // Remove a single filter
             * serializer.removeAttributeFilter('src,href', someCallback);
             *
             * // Remove all filters
             * serializer.removeAttributeFilter('src,href');
             */
            removeAttributeFilter: domSerializer.removeAttributeFilter
        };
    };

    const defaultFormat$1 = 'html';
    const setupArgs$1 = (args, format) => ({
        ...args,
        format,
        get: true,
        getInner: true
    });
    const getContent = (editor, args = {}) => {
        const format = args.format ? args.format : defaultFormat$1;
        const defaultedArgs = setupArgs$1(args, format);
        return preProcessGetContent(editor, defaultedArgs).fold(identity, (updatedArgs) => {
            const content = getContent$2(editor, updatedArgs);
            return postProcessGetContent(editor, content, updatedArgs);
        });
    };

    const defaultFormat = 'html';
    const setupArgs = (args, content) => ({
        format: defaultFormat,
        ...args,
        set: true,
        content
    });
    const setContent = (editor, content, args = {}) => {
        const defaultedArgs = setupArgs(args, content);
        preProcessSetContent(editor, defaultedArgs).each((updatedArgs) => {
            const result = setContent$1(editor, updatedArgs.content, updatedArgs);
            postProcessSetContent(editor, result.html, updatedArgs);
        });
    };

    const DOM$b = DOMUtils.DOM;
    const restoreOriginalStyles = (editor) => {
        DOM$b.setStyle(editor.id, 'display', editor.orgDisplay);
    };
    const safeDestroy = (x) => Optional.from(x).each((x) => x.destroy());
    const clearDomReferences = (editor) => {
        const ed = editor;
        ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;
        ed.bodyElement = ed.contentDocument = ed.contentWindow = null;
        ed.iframeElement = ed.targetElm = null;
        const selection = editor.selection;
        if (selection) {
            const dom = selection.dom;
            ed.selection = selection.win = selection.dom = dom.doc = null;
        }
    };
    const restoreForm = (editor) => {
        const form = editor.formElement;
        if (form) {
            if (form._mceOldSubmit) {
                form.submit = form._mceOldSubmit;
                delete form._mceOldSubmit;
            }
            DOM$b.unbind(form, 'submit reset', editor.formEventDelegate);
        }
    };
    const remove$1 = (editor) => {
        if (!editor.removed) {
            const { _selectionOverrides, editorUpload } = editor;
            const body = editor.getBody();
            const element = editor.getElement();
            if (body) {
                editor.save({ is_removing: true });
            }
            editor.removed = true;
            editor.unbindAllNativeEvents();
            // Remove any hidden input
            if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {
                DOM$b.remove(element.nextSibling);
            }
            fireRemove(editor);
            editor.editorManager.remove(editor);
            if (!editor.inline && body) {
                restoreOriginalStyles(editor);
            }
            fireDetach(editor);
            DOM$b.remove(editor.getContainer());
            safeDestroy(_selectionOverrides);
            safeDestroy(editorUpload);
            editor.destroy();
        }
    };
    const destroy = (editor, automatic) => {
        const { selection, dom } = editor;
        if (editor.destroyed) {
            return;
        }
        // If user manually calls destroy and not remove
        // Users seems to have logic that calls destroy instead of remove
        if (!automatic && !editor.removed) {
            editor.remove();
            return;
        }
        if (!automatic) {
            editor.editorManager.off('beforeunload', editor._beforeUnload);
            // Manual destroy
            if (editor.theme && editor.theme.destroy) {
                editor.theme.destroy();
            }
            safeDestroy(selection);
            safeDestroy(dom);
        }
        restoreForm(editor);
        clearDomReferences(editor);
        editor.destroyed = true;
    };

    const CreateIconManager = () => {
        const lookup = {};
        const add = (id, iconPack) => {
            lookup[id] = iconPack;
        };
        const get = (id) => {
            if (lookup[id]) {
                return lookup[id];
            }
            else {
                return { icons: {} };
            }
        };
        const has = (id) => has$2(lookup, id);
        return {
            add,
            get,
            has
        };
    };
    const IconManager = CreateIconManager();

    const ModelManager = AddOnManager.ModelManager;

    const getProp = (propName, elm) => {
        const rawElm = elm.dom;
        return rawElm[propName];
    };
    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);
    const getClientWidth = curry(getProp, 'clientWidth');
    const getClientHeight = curry(getProp, 'clientHeight');
    const getMarginTop = curry(getComputedSizeProp, 'margin-top');
    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');
    const getBoundingClientRect = (elm) => elm.dom.getBoundingClientRect();
    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {
        const clientWidth = getClientWidth(bodyElm);
        const clientHeight = getClientHeight(bodyElm);
        return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
    };
    const transpose = (inline, elm, clientX, clientY) => {
        const clientRect = getBoundingClientRect(elm);
        const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;
        const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;
        const x = clientX - deltaX;
        const y = clientY - deltaY;
        return { x, y };
    };
    // Checks if the specified coordinate is within the visual content area excluding the scrollbars
    const isXYInContentArea = (editor, clientX, clientY) => {
        const bodyElm = SugarElement.fromDom(editor.getBody());
        const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
        const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
        return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
    };
    const fromDomSafe = (node) => Optional.from(node).map(SugarElement.fromDom);
    const isEditorAttachedToDom = (editor) => {
        const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
        return fromDomSafe(rawContainer).map(inBody).getOr(false);
    };

    var NotificationManagerImpl = () => {
        const unimplemented = () => {
            throw new Error('Theme did not provide a NotificationManager implementation.');
        };
        return {
            open: unimplemented,
            close: unimplemented,
            getArgs: unimplemented
        };
    };

    /**
     * This class handles the creation of TinyMCE's notifications.
     *
     * @class tinymce.NotificationManager
     * @example
     * // Opens a new notification of type "error" with text "An error occurred."
     * tinymce.activeEditor.notificationManager.open({
     *   text: 'An error occurred.',
     *   type: 'error'
     * });
     */
    const NotificationManager = (editor) => {
        const notifications = [];
        const getImplementation = () => {
            const theme = editor.theme;
            return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
        };
        const getTopNotification = () => {
            return Optional.from(notifications[0]);
        };
        const isEqual = (a, b) => {
            return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
        };
        const reposition = () => {
            getTopNotification().each((notification) => {
                notification.reposition();
            });
        };
        const addNotification = (notification) => {
            notifications.push(notification);
        };
        const closeNotification = (notification) => {
            findIndex$2(notifications, (otherNotification) => {
                return otherNotification === notification;
            }).each((index) => {
                // Mutate here since third party might have stored away the window array
                // TODO: Consider breaking this api
                notifications.splice(index, 1);
            });
        };
        const open = (spec, fireEvent = true) => {
            // Never open notification if editor has been removed.
            if (editor.removed || !isEditorAttachedToDom(editor)) {
                return {};
            }
            // fire event to allow notification spec to be mutated before display
            if (fireEvent) {
                editor.dispatch('BeforeOpenNotification', { notification: spec });
            }
            return find$2(notifications, (notification) => {
                return isEqual(getImplementation().getArgs(notification), spec);
            }).getOrThunk(() => {
                editor.editorManager.setActive(editor);
                const notification = getImplementation().open(spec, () => {
                    closeNotification(notification);
                }, () => hasEditorOrUiFocus(editor));
                addNotification(notification);
                reposition();
                // Ensure notification is not passed by reference to prevent mutation
                editor.dispatch('OpenNotification', { notification: { ...notification } });
                return notification;
            });
        };
        const close = () => {
            getTopNotification().each((notification) => {
                getImplementation().close(notification);
                closeNotification(notification);
                reposition();
            });
        };
        const getNotifications = constant(notifications);
        const registerEvents = (editor) => {
            editor.on('SkinLoaded', () => {
                const serviceMessage = getServiceMessage(editor);
                if (serviceMessage) {
                    // Ensure we pass false for fireEvent so that service message cannot be altered.
                    open({
                        text: serviceMessage,
                        type: 'warning',
                        timeout: 0
                    }, false);
                }
                // Ensure the notifications are repositioned once the skin has loaded, as otherwise
                // any notifications rendered before then may have wrapped and been in the wrong place
                reposition();
            });
            // NodeChange is needed for inline mode and autoresize as the positioning is done
            // from the bottom up, which changes when the content in the editor changes.
            editor.on('show ResizeEditor ResizeWindow NodeChange ToggleView FullscreenStateChanged', () => {
                requestAnimationFrame(reposition);
            });
            editor.on('remove', () => {
                each$e(notifications.slice(), (notification) => {
                    getImplementation().close(notification);
                });
            });
            editor.on('keydown', (e) => {
                var _a;
                // TODO: TINY-11429 Remove this once we remove the use of keycodes
                const isF12 = ((_a = e.key) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'f12' || e.keyCode === 123;
                if (e.altKey && isF12) {
                    e.preventDefault();
                    getTopNotification()
                        .map((notificationApi) => SugarElement.fromDom(notificationApi.getEl()))
                        .each((elm) => focus$1(elm));
                }
            });
        };
        registerEvents(editor);
        return {
            /**
             * Opens a new notification.
             *
             * @method open
             * @param {Object} args A <code>name: value</code> collection containing settings such as: <code>timeout</code>, <code>type</code>, and message (<code>text</code>).
             * <br /><br />
             * For information on the available settings, see: <a href="https://www.tiny.cloud/docs/tinymce/8/creating-custom-notifications/">Create custom notifications</a>.
             */
            open,
            /**
             * Closes the top most notification.
             *
             * @method close
             */
            close,
            /**
             * Returns the currently opened notification objects.
             *
             * @method getNotifications
             * @return {Array} Array of the currently opened notifications.
             */
            getNotifications
        };
    };

    const PluginManager = AddOnManager.PluginManager;

    const ThemeManager = AddOnManager.ThemeManager;

    var WindowManagerImpl = () => {
        const unimplemented = () => {
            throw new Error('Theme did not provide a WindowManager implementation.');
        };
        return {
            open: unimplemented,
            openUrl: unimplemented,
            alert: unimplemented,
            confirm: unimplemented,
            close: unimplemented
        };
    };

    const WindowManager = (editor) => {
        let dialogs = [];
        const getImplementation = () => {
            const theme = editor.theme;
            return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
        };
        const funcBind = (scope, f) => {
            return (...args) => {
                return f ? f.apply(scope, args) : undefined;
            };
        };
        const fireOpenEvent = (dialog) => {
            editor.dispatch('OpenWindow', {
                dialog
            });
        };
        const fireCloseEvent = (dialog) => {
            editor.dispatch('CloseWindow', {
                dialog
            });
        };
        const addDialog = (dialog, triggerElement) => {
            dialogs.push({ instanceApi: dialog, triggerElement });
            fireOpenEvent(dialog);
        };
        const closeDialog = (dialog) => {
            fireCloseEvent(dialog);
            const dialogTriggerElement = findMap(dialogs, ({ instanceApi, triggerElement }) => instanceApi === dialog ? triggerElement : Optional.none());
            dialogs = filter$5(dialogs, ({ instanceApi }) => instanceApi !== dialog);
            // Move focus back to editor when the last window is closed
            if (dialogs.length === 0) {
                editor.focus();
            }
            else {
                // Move focus to the element that was active before the dialog was opened
                dialogTriggerElement.filter(inBody).each(focus$1);
            }
        };
        const getTopDialog = () => {
            return Optional.from(dialogs[dialogs.length - 1]);
        };
        const storeSelectionAndOpenDialog = (openDialog) => {
            editor.editorManager.setActive(editor);
            store(editor);
            const activeEl = active();
            editor.ui.show();
            const dialog = openDialog();
            addDialog(dialog, activeEl);
            return dialog;
        };
        const open = (args, params) => {
            return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));
        };
        const openUrl = (args) => {
            return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));
        };
        const restoreFocus = (activeEl) => {
            if (dialogs.length !== 0) {
                // If there are some dialogs, the confirm/alert was probably triggered from the dialog
                // Move focus to the element that was active before the confirm/alert was opened
                activeEl.each((el) => focus$1(el));
            }
        };
        const alert = (message, callback, scope) => {
            const activeEl = active();
            const windowManagerImpl = getImplementation();
            windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, () => {
                restoreFocus(activeEl);
                callback === null || callback === void 0 ? void 0 : callback();
            }));
        };
        const confirm = (message, callback, scope) => {
            const activeEl = active();
            const windowManagerImpl = getImplementation();
            windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, (state) => {
                restoreFocus(activeEl);
                callback === null || callback === void 0 ? void 0 : callback(state);
            }));
        };
        const close = () => {
            getTopDialog().each(({ instanceApi: dialog }) => {
                getImplementation().close(dialog);
                closeDialog(dialog);
            });
        };
        editor.on('remove', () => {
            each$e(dialogs, ({ instanceApi: dialog }) => {
                getImplementation().close(dialog);
            });
        });
        return {
            /**
             * Opens a new window.
             *
             * @method open
             * @param {Object} config For information on the available options, see: <a href="https://www.tiny.cloud/docs/tinymce/8/dialog-configuration/#options">Dialog - Configuration options</a>.
             * @param {Object} params (Optional) For information on the available options, see: <a href="https://www.tiny.cloud/docs/tinymce/8/dialog-configuration/#configuration-parameters">Dialog - Configuration parameters</a>.
             * @returns {WindowManager.DialogInstanceApi} A new dialog instance.
             */
            open,
            /**
             * Opens a new window for the specified url.
             *
             * @method openUrl
             * @param {Object} config For information on the available options, see: <a href="https://www.tiny.cloud/docs/tinymce/8/urldialog/#configuration">URL dialog - Configuration</a>.
             * @returns {WindowManager.UrlDialogInstanceApi} A new URL dialog instance.
             */
            openUrl,
            /**
             * Creates an alert dialog. Do not use the blocking behavior of this
             * native version. Use the callback method instead; then it can be extended.
             *
             * @method alert
             * @param {String} message Text to display in the new alert dialog.
             * @param {Function} callback (Optional) Callback function to be executed after the user has selected ok.
             * @param {Object} scope (Optional) Scope to execute the callback in.
             * @example
             * // Displays an alert box using the active editors window manager instance
             * tinymce.activeEditor.windowManager.alert('Hello world!');
             */
            alert,
            /**
             * Creates an alert dialog. Do not use the blocking behavior of this
             * native version. Use the callback method instead; then it can be extended.
             *
             * @method confirm
             * @param {String} message Text to display in the new confirm dialog.
             * @param {Function} callback (Optional) Callback function to be executed after the user has selected ok or cancel.
             * @param {Object} scope (Optional) Scope to execute the callback in.
             * @example
             * // Displays a confirm box and an alert message will be displayed depending on what you choose in the confirm
             * tinymce.activeEditor.windowManager.confirm('Do you want to do something?', (state) => {
             *   const message = state ? 'Ok' : 'Cancel';
             *   tinymce.activeEditor.windowManager.alert(message);
             * });
             */
            confirm,
            /**
             * Closes the top most window.
             *
             * @method close
             */
            close
        };
    };

    const displayNotification$1 = (editor, message) => {
        editor.notificationManager.open({
            type: 'error',
            text: message
        });
    };
    const displayError = (editor, message) => {
        if (editor._skinLoaded) {
            displayNotification$1(editor, message);
        }
        else {
            editor.on('SkinLoaded', () => {
                displayNotification$1(editor, message);
            });
        }
    };
    const uploadError = (editor, message) => {
        displayError(editor, I18n.translate(['Failed to upload image: {0}', message]));
    };
    const logError = (editor, errorType, msg) => {
        fireError(editor, errorType, { message: msg });
        // eslint-disable-next-line no-console
        console.error(msg);
    };
    const createLoadError = (type, url, name) => name ?
        `Failed to load ${type}: ${name} from url ${url}` :
        `Failed to load ${type} url: ${url}`;
    const pluginLoadError = (editor, url, name) => {
        logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));
    };
    const iconsLoadError = (editor, url, name) => {
        logError(editor, 'IconsLoadError', createLoadError('icons', url, name));
    };
    const languageLoadError = (editor, url, name) => {
        logError(editor, 'LanguageLoadError', createLoadError('language', url, name));
    };
    const themeLoadError = (editor, url, name) => {
        logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));
    };
    const modelLoadError = (editor, url, name) => {
        logError(editor, 'ModelLoadError', createLoadError('model', url, name));
    };
    const licenseKeyManagerLoadError = (editor, url) => {
        logError(editor, 'LicenseKeyManagerLoadError', createLoadError('license key manager', url));
    };
    const pluginInitError = (editor, name, err) => {
        const message = I18n.translate(['Failed to initialize plugin: {0}', name]);
        fireError(editor, 'PluginLoadError', { message });
        initError(message, err);
        displayError(editor, message);
    };
    const initError = (message, ...x) => {
        const console = window.console;
        if (console) { // Skip test env
            if (console.error) {
                console.error(message, ...x);
            }
            else {
                console.log(message, ...x);
            }
        }
    };

    // Map to track which editors have already been processed and disabled
    const processedEditors = new WeakMap();
    const forceDisable = (editor) => {
        // Check if we've already disabled the editor
        if (processedEditors.has(editor)) {
            return;
        }
        // Mark this editor as processed
        processedEditors.set(editor, true);
        const switchModeListener = () => {
            editor.on('SwitchMode', (e) => {
                const { mode } = e;
                if (mode !== 'readonly') {
                    editor.mode.set('readonly');
                }
            });
        };
        const disabledStateChangeListener = () => {
            editor.on('DisabledStateChange', (e) => {
                const { state } = e;
                if (!state) {
                    e.preventDefault();
                }
            }, true);
        };
        if (editor.initialized) {
            // Set readonly before setting disabled as disabling editor prevents mode from being changed
            if (!editor.removed) {
                editor.mode.set('readonly');
            }
            editor.options.set('disabled', true);
        }
        else {
            editor.on('init', () => {
                // Set readonly before setting disabled as disabling editor prevents mode from being changed
                if (!editor.removed) {
                    editor.mode.set('readonly');
                }
                editor.options.set('disabled', true);
            });
        }
        disabledStateChangeListener();
        switchModeListener();
    };

    /* eslint-disable no-console */
    const displayNotification = (editor, messageData) => {
        const { type, message } = messageData;
        editor.notificationManager.open({
            type,
            text: message
        });
    };
    const getConsoleFn = (type) => {
        switch (type) {
            case 'error':
                return console.error;
            case 'info':
                return console.info;
            case 'warn':
                return console.warn;
            case 'log':
            default:
                return console.log;
        }
    };
    const displayConsoleMessage = (messageData) => {
        const consoleFn = getConsoleFn(messageData.type);
        consoleFn(messageData.message);
    };
    const reportMessage = (editor, message) => {
        const { console, editor: editorUi } = message;
        if (isNonNullable(editorUi)) {
            if (editor._skinLoaded) {
                displayNotification(editor, editorUi);
            }
            else {
                editor.on('SkinLoaded', () => {
                    displayNotification(editor, editorUi);
                });
            }
        }
        if (isNonNullable(console)) {
            displayConsoleMessage(console);
        }
    };

    const DOCS_URL = 'https://www.tiny.cloud/docs/tinymce/latest/license-key/';
    const DOCS_URL_MESSAGE = `Read more: ${DOCS_URL}`;
    const PROVIDE_LICENSE_KEY_MESSAGE = `Make sure to provide a valid license key or add license_key: 'gpl' to the init config to agree to the open source license terms.`;
    const reportNoKeyError = (editor) => {
        const baseMessage = 'The editor is disabled because a TinyMCE license key has not been provided.';
        reportMessage(editor, {
            console: {
                type: 'error',
                message: [
                    `${baseMessage}`,
                    PROVIDE_LICENSE_KEY_MESSAGE,
                    DOCS_URL_MESSAGE
                ].join(' ')
            },
            editor: {
                type: 'warning',
                message: `${baseMessage}`
            }
        });
    };
    const reportLoadError = (editor, onlineStatus) => {
        const key = `${onlineStatus === 'online' ? 'API' : 'license'} key`;
        const baseMessage = `The editor is disabled because the TinyMCE ${key} could not be validated.`;
        reportMessage(editor, {
            console: {
                type: 'error',
                message: [
                    `${baseMessage}`,
                    `The TinyMCE Commercial License Key Manager plugin is required for the provided ${key} to be validated but could not be loaded.`,
                    DOCS_URL_MESSAGE
                ].join(' ')
            },
            editor: {
                type: 'warning',
                message: `${baseMessage}`
            }
        });
    };
    const reportInvalidPlugin = (editor, pluginCode) => {
        const baseMessage = `The "${pluginCode}" plugin requires a valid TinyMCE license key.`;
        reportMessage(editor, {
            console: {
                type: 'error',
                message: [
                    `${baseMessage}`,
                    DOCS_URL_MESSAGE
                ].join(' ')
            }
        });
    };

    const PLUGIN_CODE$1 = 'licensekeymanager';
    const getOnlineStatus = (editor) => {
        const hasApiKey = isString(getApiKey(editor));
        return hasApiKey ? 'online' : 'offline';
    };
    const getLicenseKeyType = (editor) => {
        var _a;
        const licenseKey = (_a = getLicenseKey(editor)) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (licenseKey === 'gpl') {
            return 'gpl';
        }
        else if (isNullable(licenseKey)) {
            return 'no_key';
        }
        else {
            return 'non_gpl';
        }
    };
    const determineStrategy = (editor) => {
        const onlineStatus = getOnlineStatus(editor);
        const licenseKeyType = getLicenseKeyType(editor);
        const forcePlugin = (new Set(getPlugins(editor))).has(PLUGIN_CODE$1);
        if (licenseKeyType !== 'gpl' || onlineStatus === 'online' || forcePlugin) {
            return {
                type: 'use_plugin',
                onlineStatus,
                licenseKeyType,
                forcePlugin
            };
        }
        else {
            return {
                type: 'use_gpl',
                onlineStatus,
                licenseKeyType,
                forcePlugin
            };
        }
    };

    const NoLicenseKeyManager = (editor) => ({
        validate: (data) => {
            const { plugin } = data;
            const hasPlugin = isString(plugin);
            // Premium plugins are not allowed
            if (hasPlugin) {
                reportInvalidPlugin(editor, plugin);
            }
            return Promise.resolve(false);
        },
    });
    const GplLicenseKeyManager = (editor) => ({
        validate: (data) => {
            const { plugin } = data;
            const hasPlugin = isString(plugin);
            // Premium plugins are not allowed if 'gpl' is given as the license_key
            if (hasPlugin) {
                reportInvalidPlugin(editor, plugin);
            }
            return Promise.resolve(!hasPlugin);
        },
    });
    const ADDON_KEY = 'manager';
    const PLUGIN_CODE = PLUGIN_CODE$1;
    const setup$y = () => {
        const addOnManager = AddOnManager();
        const add = (addOn) => {
            addOnManager.add(ADDON_KEY, addOn);
        };
        const load = (editor, suffix) => {
            const strategy = determineStrategy(editor);
            if (strategy.type === 'use_plugin') {
                const url = `plugins/${PLUGIN_CODE}/plugin${suffix}.js`;
                addOnManager.load(ADDON_KEY, url).catch(() => {
                    licenseKeyManagerLoadError(editor, url);
                });
            }
        };
        const init = (editor) => {
            const setLicenseKeyManager = (licenseKeyManager) => {
                Object.defineProperty(editor, 'licenseKeyManager', {
                    value: licenseKeyManager,
                    writable: false,
                    configurable: false,
                    enumerable: true,
                });
            };
            const strategy = determineStrategy(editor);
            const LicenseKeyManager = addOnManager.get(ADDON_KEY);
            // Use plugin if it is already loaded as it can handle all license key types
            if (isNonNullable(LicenseKeyManager)) {
                const licenseKeyManagerApi = LicenseKeyManager(editor, addOnManager.urls[ADDON_KEY]);
                setLicenseKeyManager(licenseKeyManagerApi);
            }
            else {
                switch (strategy.type) {
                    case 'use_gpl': {
                        setLicenseKeyManager(GplLicenseKeyManager(editor));
                        break;
                    }
                    case 'use_plugin': {
                        // We know the plugin hasn't loaded and it is required
                        forceDisable(editor);
                        setLicenseKeyManager(NoLicenseKeyManager(editor));
                        if (strategy.onlineStatus === 'offline' && strategy.licenseKeyType === 'no_key') {
                            reportNoKeyError(editor);
                        }
                        else {
                            reportLoadError(editor, strategy.onlineStatus);
                        }
                        break;
                    }
                }
            }
            // Validation of the license key is done asynchronously and does
            // not block initialization of the editor
            // The validate function is expected to set the editor to the correct
            // state depending on if the license key is valid or not
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            editor.licenseKeyManager.validate({});
        };
        return {
            load,
            add,
            init
        };
    };
    const LicenseKeyManagerLoader = setup$y();

    const removeFakeSelection = (editor) => {
        Optional.from(editor.selection.getNode()).each((elm) => {
            elm.removeAttribute('data-mce-selected');
        });
    };
    const setEditorCommandState = (editor, cmd, state) => {
        try {
            // execCommand needs a string for the value, so convert the boolean to a string
            // See: https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#Parameters
            editor.getDoc().execCommand(cmd, false, String(state));
        }
        catch (_a) {
            // Ignore
        }
    };
    const setCommonEditorCommands = (editor, state) => {
        setEditorCommandState(editor, 'StyleWithCSS', state);
        setEditorCommandState(editor, 'enableInlineTableEditing', state);
        setEditorCommandState(editor, 'enableObjectResizing', state);
    };
    const restoreFakeSelection = (editor) => {
        editor.selection.setRng(editor.selection.getRng());
    };
    // Not quite sugar Class.toggle, it's more of a Class.set
    const toggleClass = (elm, cls, state) => {
        if (has(elm, cls) && !state) {
            remove$4(elm, cls);
        }
        else if (state) {
            add$2(elm, cls);
        }
    };
    const disableEditor = (editor) => {
        const body = SugarElement.fromDom(editor.getBody());
        toggleClass(body, 'mce-content-readonly', true);
        editor.selection.controlSelection.hideResizeRect();
        editor._selectionOverrides.hideFakeCaret();
        removeFakeSelection(editor);
    };
    const enableEditor = (editor) => {
        const body = SugarElement.fromDom(editor.getBody());
        toggleClass(body, 'mce-content-readonly', false);
        if (editor.hasEditableRoot()) {
            set(body, true);
        }
        setCommonEditorCommands(editor, false);
        if (hasEditorOrUiFocus(editor)) {
            editor.focus();
        }
        restoreFakeSelection(editor);
        editor.nodeChanged();
    };

    const isDisabled = (editor) => isDisabled$1(editor);
    const internalContentEditableAttr = 'data-mce-contenteditable';
    const switchOffContentEditableTrue = (elm) => {
        each$e(descendants(elm, '*[contenteditable="true"]'), (elm) => {
            set$4(elm, internalContentEditableAttr, 'true');
            set(elm, false);
        });
    };
    const switchOnContentEditableTrue = (elm) => {
        each$e(descendants(elm, `*[${internalContentEditableAttr}="true"]`), (elm) => {
            remove$9(elm, internalContentEditableAttr);
            set(elm, true);
        });
    };
    const toggleDisabled = (editor, state) => {
        const body = SugarElement.fromDom(editor.getBody());
        if (state) {
            disableEditor(editor);
            set(body, false);
            switchOffContentEditableTrue(body);
        }
        else {
            switchOnContentEditableTrue(body);
            enableEditor(editor);
        }
    };
    const registerDisabledContentFilters = (editor) => {
        if (editor.serializer) {
            registerFilters(editor);
        }
        else {
            editor.on('PreInit', () => {
                registerFilters(editor);
            });
        }
    };
    const registerFilters = (editor) => {
        editor.parser.addAttributeFilter('contenteditable', (nodes) => {
            if (isDisabled(editor)) {
                each$e(nodes, (node) => {
                    node.attr(internalContentEditableAttr, node.attr('contenteditable'));
                    node.attr('contenteditable', 'false');
                });
            }
        });
        editor.serializer.addAttributeFilter(internalContentEditableAttr, (nodes) => {
            if (isDisabled(editor)) {
                each$e(nodes, (node) => {
                    node.attr('contenteditable', node.attr(internalContentEditableAttr));
                });
            }
        });
        editor.serializer.addTempAttr(internalContentEditableAttr);
    };
    const isClickEvent = (e) => e.type === 'click';
    const allowedEvents = ['copy'];
    const isAllowedEventInDisabledMode = (e) => contains$2(allowedEvents, e.type);
    const getAnchorHrefOpt = (editor, elm) => {
        const isRoot = (elm) => eq(elm, SugarElement.fromDom(editor.getBody()));
        return closest$3(elm, 'a', isRoot).bind((a) => getOpt(a, 'href'));
    };
    const processDisabledEvents = (editor, e) => {
        /*
          If an event is a click event on or within an anchor, and the CMD/CTRL key is
          not held, then we want to prevent default behaviour and either:
            a) scroll to the relevant bookmark
            b) open the link using default browser behaviour
        */
        if (isClickEvent(e) && !VK.metaKeyPressed(e)) {
            const elm = SugarElement.fromDom(e.target);
            getAnchorHrefOpt(editor, elm).each((href) => {
                e.preventDefault();
                if (/^#/.test(href)) {
                    const targetEl = editor.dom.select(`${href},[name="${removeLeading(href, '#')}"]`);
                    if (targetEl.length) {
                        editor.selection.scrollIntoView(targetEl[0], true);
                    }
                }
                else {
                    window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');
                }
            });
        }
        else if (isAllowedEventInDisabledMode(e)) {
            editor.dispatch(e.type, e);
        }
    };
    const registerDisabledModeEventHandlers = (editor) => {
        editor.on('ShowCaret ObjectSelected', (e) => {
            if (isDisabled(editor)) {
                e.preventDefault();
            }
        });
        // Preprend to the handlers as this should be the first to fire
        editor.on('DisabledStateChange', (e) => {
            if (!e.isDefaultPrevented()) {
                toggleDisabled(editor, e.state);
            }
        });
    };
    const registerEventsAndFilters$1 = (editor) => {
        registerDisabledContentFilters(editor);
        registerDisabledModeEventHandlers(editor);
    };

    const isContentCssSkinName = (url) => /^[a-z0-9\-]+$/i.test(url);
    const toContentSkinResourceName = (url) => 'content/' + url + '/content.css';
    const isBundledCssSkinName = (url) => tinymce.Resource.has(toContentSkinResourceName(url));
    const getContentCssUrls = (editor) => {
        return transformToUrls(editor, getContentCss(editor));
    };
    const getFontCssUrls = (editor) => {
        return transformToUrls(editor, getFontCss(editor));
    };
    const transformToUrls = (editor, cssLinks) => {
        const skinUrl = editor.editorManager.baseURL + '/skins/content';
        const suffix = editor.editorManager.suffix;
        const contentCssFile = `content${suffix}.css`;
        return map$3(cssLinks, (url) => {
            if (isBundledCssSkinName(url)) {
                return url;
            }
            else if (isContentCssSkinName(url) && !editor.inline) {
                return `${skinUrl}/${url}/${contentCssFile}`;
            }
            else {
                return editor.documentBaseURI.toAbsolute(url);
            }
        });
    };
    const appendContentCssFromSettings = (editor) => {
        editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));
    };

    /**
     * Finds images with data uris or blob uris. If data uris are found it will convert them into blob uris.
     *
     * @private
     * @class tinymce.file.ImageScanner
     */
    const getAllImages = (elm) => {
        return elm ? from(elm.getElementsByTagName('img')) : [];
    };
    const ImageScanner = (uploadStatus, blobCache) => {
        const cachedPromises = {};
        const findAll = (elm, predicate = always) => {
            const images = filter$5(getAllImages(elm), (img) => {
                const src = img.src;
                if (img.hasAttribute('data-mce-bogus')) {
                    return false;
                }
                if (img.hasAttribute('data-mce-placeholder')) {
                    return false;
                }
                if (!src || src === Env.transparentSrc) {
                    return false;
                }
                if (startsWith(src, 'blob:')) {
                    return !uploadStatus.isUploaded(src) && predicate(img);
                }
                if (startsWith(src, 'data:')) {
                    return predicate(img);
                }
                return false;
            });
            const promises = map$3(images, (img) => {
                const imageSrc = img.src;
                if (has$2(cachedPromises, imageSrc)) {
                    // Since the cached promise will return the cached image
                    // We need to wrap it and resolve with the actual image
                    return cachedPromises[imageSrc].then((imageInfo) => {
                        if (isString(imageInfo)) { // error apparently
                            return imageInfo;
                        }
                        else {
                            return {
                                image: img,
                                blobInfo: imageInfo.blobInfo
                            };
                        }
                    });
                }
                else {
                    const newPromise = imageToBlobInfo(blobCache, imageSrc)
                        .then((blobInfo) => {
                        delete cachedPromises[imageSrc];
                        return { image: img, blobInfo };
                    }).catch((error) => {
                        delete cachedPromises[imageSrc];
                        return error;
                    });
                    cachedPromises[imageSrc] = newPromise;
                    return newPromise;
                }
            });
            return Promise.all(promises);
        };
        return {
            findAll
        };
    };

    /**
     * Holds the current status of a blob uri, if it's pending or uploaded and what the result urls was.
     *
     * @private
     * @class tinymce.file.UploadStatus
     */
    const UploadStatus = () => {
        const PENDING = 1, UPLOADED = 2;
        let blobUriStatuses = {};
        const createStatus = (status, resultUri) => {
            return {
                status,
                resultUri
            };
        };
        const hasBlobUri = (blobUri) => {
            return blobUri in blobUriStatuses;
        };
        const getResultUri = (blobUri) => {
            const result = blobUriStatuses[blobUri];
            return result ? result.resultUri : null;
        };
        const isPending = (blobUri) => {
            return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
        };
        const isUploaded = (blobUri) => {
            return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
        };
        const markPending = (blobUri) => {
            blobUriStatuses[blobUri] = createStatus(PENDING, null);
        };
        const markUploaded = (blobUri, resultUri) => {
            blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
        };
        const removeFailed = (blobUri) => {
            delete blobUriStatuses[blobUri];
        };
        const destroy = () => {
            blobUriStatuses = {};
        };
        return {
            hasBlobUri,
            getResultUri,
            isPending,
            isUploaded,
            markPending,
            markUploaded,
            removeFailed,
            destroy
        };
    };

    /**
     * Generates unique ids.
     *
     * @class tinymce.util.Uuid
     * @private
     */
    let count = 0;
    const seed = () => {
        const rnd = () => {
            return Math.round(random() * 0xFFFFFFFF).toString(36);
        };
        const now = new Date().getTime();
        return 's' + now.toString(36) + rnd() + rnd() + rnd();
    };
    const uuid = (prefix) => {
        return prefix + (count++) + seed();
    };

    const BlobCache = () => {
        let cache = [];
        const mimeToExt = (mime) => {
            const mimes = {
                'image/jpeg': 'jpg',
                'image/jpg': 'jpg',
                'image/gif': 'gif',
                'image/png': 'png',
                'image/apng': 'apng',
                'image/avif': 'avif',
                'image/svg+xml': 'svg',
                'image/webp': 'webp',
                'image/bmp': 'bmp',
                'image/tiff': 'tiff'
            };
            return mimes[mime.toLowerCase()] || 'dat';
        };
        const create = (o, blob, base64, name, filename) => {
            if (isString(o)) {
                const id = o;
                return toBlobInfo({
                    id,
                    name,
                    filename,
                    blob: blob,
                    base64: base64
                });
            }
            else if (isObject(o)) {
                return toBlobInfo(o);
            }
            else {
                throw new Error('Unknown input type');
            }
        };
        const toBlobInfo = (o) => {
            if (!o.blob || !o.base64) {
                throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');
            }
            const id = o.id || uuid('blobid');
            const name = o.name || id;
            const blob = o.blob;
            return {
                id: constant(id),
                name: constant(name),
                filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),
                blob: constant(blob),
                base64: constant(o.base64),
                blobUri: constant(o.blobUri || URL.createObjectURL(blob)),
                uri: constant(o.uri)
            };
        };
        const add = (blobInfo) => {
            if (!get(blobInfo.id())) {
                cache.push(blobInfo);
            }
        };
        const findFirst = (predicate) => find$2(cache, predicate).getOrUndefined();
        const get = (id) => findFirst((cachedBlobInfo) => cachedBlobInfo.id() === id);
        const getByUri = (blobUri) => findFirst((blobInfo) => blobInfo.blobUri() === blobUri);
        const getByData = (base64, type) => findFirst((blobInfo) => blobInfo.base64() === base64 && blobInfo.blob().type === type);
        const removeByUri = (blobUri) => {
            cache = filter$5(cache, (blobInfo) => {
                if (blobInfo.blobUri() === blobUri) {
                    URL.revokeObjectURL(blobInfo.blobUri());
                    return false;
                }
                return true;
            });
        };
        const destroy = () => {
            each$e(cache, (cachedBlobInfo) => {
                URL.revokeObjectURL(cachedBlobInfo.blobUri());
            });
            cache = [];
        };
        return {
            create,
            add,
            get,
            getByUri,
            getByData,
            findFirst,
            removeByUri,
            destroy
        };
    };

    const Uploader = (uploadStatus, settings) => {
        const pendingPromises = {};
        const pathJoin = (path1, path2) => {
            if (path1) {
                return path1.replace(/\/$/, '') + '/' + path2.replace(/^\//, '');
            }
            return path2;
        };
        const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {
            const xhr = new XMLHttpRequest();
            xhr.open('POST', settings.url);
            xhr.withCredentials = settings.credentials;
            xhr.upload.onprogress = (e) => {
                progress(e.loaded / e.total * 100);
            };
            xhr.onerror = () => {
                failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);
            };
            xhr.onload = () => {
                if (xhr.status < 200 || xhr.status >= 300) {
                    failure('HTTP Error: ' + xhr.status);
                    return;
                }
                const json = JSON.parse(xhr.responseText);
                if (!json || !isString(json.location)) {
                    failure('Invalid JSON: ' + xhr.responseText);
                    return;
                }
                success(pathJoin(settings.basePath, json.location));
            };
            const formData = new FormData();
            formData.append('file', blobInfo.blob(), blobInfo.filename());
            xhr.send(formData);
        });
        const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;
        const noUpload = () => new Promise((resolve) => {
            resolve([]);
        });
        const handlerSuccess = (blobInfo, url) => ({
            url,
            blobInfo,
            status: true
        });
        const handlerFailure = (blobInfo, error) => ({
            url: '',
            blobInfo,
            status: false,
            error
        });
        const resolvePending = (blobUri, result) => {
            Tools.each(pendingPromises[blobUri], (resolve) => {
                resolve(result);
            });
            delete pendingPromises[blobUri];
        };
        const uploadBlobInfo = (blobInfo, handler, openNotification) => {
            uploadStatus.markPending(blobInfo.blobUri());
            return new Promise((resolve) => {
                let notification;
                let progress;
                try {
                    const closeNotification = () => {
                        if (notification) {
                            notification.close();
                            progress = noop; // Once it's closed it's closed
                        }
                    };
                    const success = (url) => {
                        closeNotification();
                        uploadStatus.markUploaded(blobInfo.blobUri(), url);
                        resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
                        resolve(handlerSuccess(blobInfo, url));
                    };
                    const failure = (error) => {
                        closeNotification();
                        uploadStatus.removeFailed(blobInfo.blobUri());
                        resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));
                        resolve(handlerFailure(blobInfo, error));
                    };
                    progress = (percent) => {
                        if (percent < 0 || percent > 100) {
                            return;
                        }
                        Optional.from(notification)
                            .orThunk(() => Optional.from(openNotification).map(apply$1))
                            .each((n) => {
                            notification = n;
                            n.progressBar.value(percent);
                        });
                    };
                    handler(blobInfo, progress).then(success, (err) => {
                        failure(isString(err) ? { message: err } : err);
                    });
                }
                catch (ex) {
                    resolve(handlerFailure(blobInfo, ex));
                }
            });
        };
        const isDefaultHandler = (handler) => handler === defaultHandler;
        const pendingUploadBlobInfo = (blobInfo) => {
            const blobUri = blobInfo.blobUri();
            return new Promise((resolve) => {
                pendingPromises[blobUri] = pendingPromises[blobUri] || [];
                pendingPromises[blobUri].push(resolve);
            });
        };
        const uploadBlobs = (blobInfos, openNotification) => {
            blobInfos = Tools.grep(blobInfos, (blobInfo) => !uploadStatus.isUploaded(blobInfo.blobUri()));
            return Promise.all(Tools.map(blobInfos, (blobInfo) => uploadStatus.isPending(blobInfo.blobUri()) ?
                pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));
        };
        const upload = (blobInfos, openNotification) => (!settings.url && isDefaultHandler(uploadHandler)) ? noUpload() : uploadBlobs(blobInfos, openNotification);
        return {
            upload
        };
    };

    const openNotification = (editor) => () => editor.notificationManager.open({
        text: editor.translate('Image uploading...'),
        type: 'info',
        timeout: -1,
        progressBar: true
    });
    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {
        url: getImageUploadUrl(editor),
        basePath: getImageUploadBasePath(editor),
        credentials: getImagesUploadCredentials(editor),
        handler: getImagesUploadHandler(editor)
    });
    /**
     * This class handles uploading images to a back-end server.
     *
     * @class tinymce.util.ImageUploader
     */
    const ImageUploader = (editor) => {
        const uploadStatus = UploadStatus();
        const uploader = createUploader(editor, uploadStatus);
        return {
            /**
             * Uploads images to the configured image upload URL (`images_upload_url`) or passes the images to the defined image upload handler function (`images_upload_handler`).
             *
             * @method upload
             * @param {Array} blobInfos  A BlobInfo array containing the image data to upload. A BlobInfo can be created by calling `editor.editorUpload.blobCache.create()`.
             * @param {Boolean} showNotification (Optional) When set to true, a notification with a progress bar will be shown during image uploads.
             */
            upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined)
        };
    };

    const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);
    const addPaddingToEmpty = (editor) => (element) => {
        if (isEmptyForPadding(editor, element)) {
            append$1(element, SugarElement.fromHtml('<br data-mce-bogus="1" />'));
        }
    };
    const EditorUpload = (editor) => {
        const blobCache = BlobCache();
        let uploader, imageScanner;
        const uploadStatus = UploadStatus();
        const urlFilters = [];
        const aliveGuard = (callback) => {
            return (result) => {
                if (editor.selection) {
                    return callback(result);
                }
                return [];
            };
        };
        const cacheInvalidator = (url) => url + (url.indexOf('?') === -1 ? '?' : '&') + (new Date()).getTime();
        // Replaces strings without regexps to avoid FF regexp to big issue
        const replaceString = (content, search, replace) => {
            let index = 0;
            do {
                index = content.indexOf(search, index);
                if (index !== -1) {
                    content = content.substring(0, index) + replace + content.substr(index + search.length);
                    index += replace.length - search.length + 1;
                }
            } while (index !== -1);
            return content;
        };
        const replaceImageUrl = (content, targetUrl, replacementUrl) => {
            const replacementString = `src="${replacementUrl}"${replacementUrl === Env.transparentSrc ? ' data-mce-placeholder="1"' : ''}`;
            content = replaceString(content, `src="${targetUrl}"`, replacementString);
            content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
            return content;
        };
        const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {
            each$e(editor.undoManager.data, (level) => {
                if (level.type === 'fragmented') {
                    level.fragments = map$3(level.fragments, (fragment) => replaceImageUrl(fragment, targetUrl, replacementUrl));
                }
                else {
                    level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
                }
            });
        };
        const replaceImageUriInView = (image, resultUri) => {
            const src = editor.convertURL(resultUri, 'src');
            replaceUrlInUndoStack(image.src, resultUri);
            setAll$1(SugarElement.fromDom(image), {
                'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
                'data-mce-src': src
            });
        };
        const uploadImages = () => {
            if (!uploader) {
                uploader = createUploader(editor, uploadStatus);
            }
            return scanForImages().then(aliveGuard((imageInfos) => {
                const blobInfos = map$3(imageInfos, (imageInfo) => imageInfo.blobInfo);
                return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard((result) => {
                    const imagesToRemove = [];
                    let shouldDispatchChange = false;
                    const filteredResult = map$3(result, (uploadInfo, index) => {
                        const { blobInfo, image } = imageInfos[index];
                        let removed = false;
                        if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
                            if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {
                                shouldDispatchChange = true;
                            }
                            blobCache.removeByUri(image.src);
                            if (isRtc(editor)) ;
                            else {
                                replaceImageUriInView(image, uploadInfo.url);
                            }
                        }
                        else if (uploadInfo.error) {
                            if (uploadInfo.error.remove) {
                                replaceUrlInUndoStack(image.src, Env.transparentSrc);
                                imagesToRemove.push(image);
                                removed = true;
                            }
                            uploadError(editor, uploadInfo.error.message);
                        }
                        return {
                            element: image,
                            status: uploadInfo.status,
                            uploadUri: uploadInfo.url,
                            blobInfo,
                            removed
                        };
                    });
                    if (imagesToRemove.length > 0 && !isRtc(editor)) {
                        editor.undoManager.transact(() => {
                            each$e(fromDom$1(imagesToRemove), (sugarElement) => {
                                const parentOpt = parent(sugarElement);
                                remove$8(sugarElement);
                                // This needs a more editor-wide fix, see issue TINY-9802. Short version: Removing the image resulted in empty <p> elements, which confused the editor.
                                parentOpt.each(addPaddingToEmpty(editor));
                                blobCache.removeByUri(sugarElement.dom.src);
                            });
                        });
                    }
                    else if (shouldDispatchChange) {
                        editor.undoManager.dispatchChange();
                    }
                    return filteredResult;
                }));
            }));
        };
        const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);
        const isValidDataUriImage = (imgElm) => forall(urlFilters, (filter) => filter(imgElm));
        const addFilter = (filter) => {
            urlFilters.push(filter);
        };
        const scanForImages = () => {
            if (!imageScanner) {
                imageScanner = ImageScanner(uploadStatus, blobCache);
            }
            return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard((result) => {
                const filteredResult = filter$5(result, (resultItem) => {
                    // ImageScanner internally converts images that it finds, but it may fail to do so if image source is inaccessible.
                    // In such case resultItem will contain appropriate text error message, instead of image data.
                    if (isString(resultItem)) {
                        displayError(editor, resultItem);
                        return false;
                    }
                    else if (resultItem.uriType === 'blob') {
                        return false;
                    }
                    else {
                        return true;
                    }
                });
                if (isRtc(editor)) ;
                else {
                    each$e(filteredResult, (resultItem) => {
                        replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
                        resultItem.image.src = resultItem.blobInfo.blobUri();
                        resultItem.image.removeAttribute('data-mce-src');
                    });
                }
                return filteredResult;
            }));
        };
        const destroy = () => {
            blobCache.destroy();
            uploadStatus.destroy();
            imageScanner = uploader = null;
        };
        const replaceBlobUris = (content) => {
            return content.replace(/src="(blob:[^"]+)"/g, (match, blobUri) => {
                const resultUri = uploadStatus.getResultUri(blobUri);
                if (resultUri) {
                    return 'src="' + resultUri + '"';
                }
                let blobInfo = blobCache.getByUri(blobUri);
                if (!blobInfo) {
                    blobInfo = foldl(editor.editorManager.get(), (result, editor) => {
                        return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);
                    }, undefined);
                }
                if (blobInfo) {
                    const blob = blobInfo.blob();
                    return 'src="data:' + blob.type + ';base64,' + blobInfo.base64() + '"';
                }
                return match;
            });
        };
        editor.on('SetContent', () => {
            if (isAutomaticUploadsEnabled(editor)) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                uploadImagesAuto();
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                scanForImages();
            }
        });
        editor.on('RawSaveContent', (e) => {
            e.content = replaceBlobUris(e.content);
        });
        editor.on('GetContent', (e) => {
            if (e.source_view || e.format === 'raw' || e.format === 'tree') {
                return;
            }
            e.content = replaceBlobUris(e.content);
        });
        editor.on('PostRender', () => {
            editor.parser.addNodeFilter('img', (images) => {
                each$e(images, (img) => {
                    const src = img.attr('src');
                    if (!src || blobCache.getByUri(src)) {
                        return;
                    }
                    const resultUri = uploadStatus.getResultUri(src);
                    if (resultUri) {
                        img.attr('src', resultUri);
                    }
                });
            });
        });
        return {
            blobCache,
            addFilter,
            uploadImages,
            uploadImagesAuto,
            scanForImages,
            destroy
        };
    };

    const get$1 = (editor) => {
        const dom = editor.dom;
        const schemaType = editor.schema.type;
        const formats = {
            valigntop: [
                { selector: 'td,th', styles: { verticalAlign: 'top' } }
            ],
            valignmiddle: [
                { selector: 'td,th', styles: { verticalAlign: 'middle' } }
            ],
            valignbottom: [
                { selector: 'td,th', styles: { verticalAlign: 'bottom' } }
            ],
            alignleft: [
                {
                    selector: 'figure.image',
                    collapsed: false,
                    classes: 'align-left',
                    ceFalseOverride: true,
                    preview: 'font-family font-size'
                },
                {
                    selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
                    styles: {
                        textAlign: 'left'
                    },
                    inherit: false,
                    preview: false
                },
                {
                    selector: 'img,audio,video',
                    collapsed: false,
                    styles: {
                        float: 'left',
                    },
                    preview: 'font-family font-size'
                },
                {
                    selector: '.mce-placeholder',
                    styles: {
                        float: 'left',
                    },
                    ceFalseOverride: true
                },
                {
                    selector: 'table',
                    collapsed: false,
                    styles: {
                        marginLeft: '0px',
                        marginRight: 'auto',
                    },
                    onformat: (table) => {
                        // Remove conflicting float style
                        dom.setStyle(table, 'float', null);
                    },
                    preview: 'font-family font-size'
                },
                {
                    selector: '.mce-preview-object,[data-ephox-embed-iri]',
                    ceFalseOverride: true,
                    styles: {
                        float: 'left'
                    }
                }
            ],
            aligncenter: [
                {
                    selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
                    styles: {
                        textAlign: 'center'
                    },
                    inherit: false,
                    preview: 'font-family font-size'
                },
                {
                    selector: 'figure.image',
                    collapsed: false,
                    classes: 'align-center',
                    ceFalseOverride: true,
                    preview: 'font-family font-size'
                },
                {
                    selector: 'img,audio,video',
                    collapsed: false,
                    styles: {
                        display: 'block',
                        marginLeft: 'auto',
                        marginRight: 'auto'
                    },
                    preview: false
                },
                {
                    selector: '.mce-placeholder',
                    styles: {
                        display: 'block',
                        marginLeft: 'auto',
                        marginRight: 'auto',
                    },
                    ceFalseOverride: true
                },
                {
                    selector: 'table',
                    collapsed: false,
                    styles: {
                        marginLeft: 'auto',
                        marginRight: 'auto'
                    },
                    preview: 'font-family font-size'
                },
                {
                    selector: '.mce-preview-object',
                    ceFalseOverride: true,
                    styles: {
                        display: 'table', // Needs to be `table` to properly render while editing
                        marginLeft: 'auto',
                        marginRight: 'auto'
                    },
                    preview: false
                },
                {
                    selector: '[data-ephox-embed-iri]',
                    ceFalseOverride: true,
                    styles: {
                        marginLeft: 'auto',
                        marginRight: 'auto'
                    },
                    preview: false
                }
            ],
            alignright: [
                {
                    selector: 'figure.image',
                    collapsed: false,
                    classes: 'align-right',
                    ceFalseOverride: true,
                    preview: 'font-family font-size'
                },
                {
                    selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
                    styles: {
                        textAlign: 'right'
                    },
                    inherit: false,
                    preview: 'font-family font-size'
                },
                {
                    selector: 'img,audio,video',
                    collapsed: false,
                    styles: {
                        float: 'right'
                    },
                    preview: 'font-family font-size'
                },
                {
                    selector: '.mce-placeholder',
                    styles: {
                        float: 'right'
                    },
                    ceFalseOverride: true
                },
                {
                    selector: 'table',
                    collapsed: false,
                    styles: {
                        marginRight: '0px',
                        marginLeft: 'auto',
                    },
                    onformat: (table) => {
                        // Remove conflicting float style
                        dom.setStyle(table, 'float', null);
                    },
                    preview: 'font-family font-size'
                },
                {
                    selector: '.mce-preview-object,[data-ephox-embed-iri]',
                    ceFalseOverride: true,
                    styles: {
                        float: 'right'
                    },
                    preview: false
                }
            ],
            alignjustify: [
                {
                    selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
                    styles: {
                        textAlign: 'justify'
                    },
                    inherit: false,
                    preview: 'font-family font-size'
                }
            ],
            bold: [
                { inline: 'strong', remove: 'all', preserve_attributes: ['class', 'style'] },
                { inline: 'span', styles: { fontWeight: 'bold' } },
                { inline: 'b', remove: 'all', preserve_attributes: ['class', 'style'] }
            ],
            italic: [
                { inline: 'em', remove: 'all', preserve_attributes: ['class', 'style'] },
                { inline: 'span', styles: { fontStyle: 'italic' } },
                { inline: 'i', remove: 'all', preserve_attributes: ['class', 'style'] }
            ],
            underline: [
                { inline: 'span', styles: { textDecoration: 'underline' }, exact: true },
                { inline: 'u', remove: 'all', preserve_attributes: ['class', 'style'] }
            ],
            strikethrough: (() => {
                const span = { inline: 'span', styles: { textDecoration: 'line-through' }, exact: true };
                const strike = { inline: 'strike', remove: 'all', preserve_attributes: ['class', 'style'] };
                const s = { inline: 's', remove: 'all', preserve_attributes: ['class', 'style'] };
                return schemaType !== 'html4' ? [s, span, strike] : [span, s, strike];
            })(),
            forecolor: { inline: 'span', styles: { color: '%value' }, links: true, remove_similar: true, clear_child_styles: true },
            hilitecolor: { inline: 'span', styles: { backgroundColor: '%value' }, links: true, remove_similar: true, clear_child_styles: true },
            fontname: { inline: 'span', toggle: false, styles: { fontFamily: '%value' }, clear_child_styles: true },
            fontsize: { inline: 'span', toggle: false, styles: { fontSize: '%value' }, clear_child_styles: true },
            lineheight: { selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div', styles: { lineHeight: '%value' } },
            fontsize_class: { inline: 'span', attributes: { class: '%value' } },
            blockquote: { block: 'blockquote', wrapper: true, remove: 'all' },
            subscript: { inline: 'sub' },
            superscript: { inline: 'sup' },
            code: { inline: 'code' },
            samp: { inline: 'samp' },
            link: {
                inline: 'a', selector: 'a', remove: 'all', split: true, deep: true,
                onmatch: (node, _fmt, _itemName) => {
                    return isElement$7(node) && node.hasAttribute('href');
                },
                onformat: (elm, _fmt, vars) => {
                    Tools.each(vars, (value, key) => {
                        dom.setAttrib(elm, key, value);
                    });
                }
            },
            lang: {
                inline: 'span',
                clear_child_styles: true,
                remove_similar: true,
                attributes: {
                    'lang': '%value',
                    'data-mce-lang': (vars) => { var _a; return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null; }
                }
            },
            removeformat: [
                {
                    selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',
                    remove: 'all',
                    split: true,
                    expand: false,
                    block_expand: true,
                    deep: true
                },
                { selector: 'span', attributes: ['style', 'class'], remove: 'empty', split: true, expand: false, deep: true },
                { selector: '*', attributes: ['style', 'class'], split: false, expand: false, deep: true }
            ]
        };
        Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd'.split(/\s/), (name) => {
            formats[name] = { block: name, remove: 'all' };
        });
        return formats;
    };

    const genericBase = {
        remove_similar: true,
        inherit: false
    };
    const cellBase = {
        selector: 'td,th',
        ...genericBase
    };
    const cellFormats = {
        tablecellbackgroundcolor: {
            styles: { backgroundColor: '%value' },
            ...cellBase
        },
        tablecellverticalalign: {
            styles: {
                'vertical-align': '%value'
            },
            ...cellBase
        },
        tablecellbordercolor: {
            styles: { borderColor: '%value' },
            ...cellBase
        },
        tablecellclass: {
            classes: ['%value'],
            ...cellBase
        },
        tableclass: {
            selector: 'table',
            classes: ['%value'],
            ...genericBase
        },
        tablecellborderstyle: {
            styles: { borderStyle: '%value' },
            ...cellBase
        },
        tablecellborderwidth: {
            styles: { borderWidth: '%value' },
            ...cellBase
        }
    };
    const get = constant(cellFormats);

    const FormatRegistry = (editor) => {
        const formats = {};
        const get$2 = (name) => isNonNullable(name) ? formats[name] : formats;
        const has = (name) => has$2(formats, name);
        const register = (name, format) => {
            if (name) {
                if (!isString(name)) {
                    each$d(name, (format, name) => {
                        register(name, format);
                    });
                }
                else {
                    // Force format into array and add it to internal collection
                    if (!isArray$1(format)) {
                        format = [format];
                    }
                    each$e(format, (format) => {
                        // Set deep to false by default on selector formats this to avoid removing
                        // alignment on images inside paragraphs when alignment is changed on paragraphs
                        if (isUndefined(format.deep)) {
                            format.deep = !isSelectorFormat(format);
                        }
                        // Default to true
                        if (isUndefined(format.split)) {
                            format.split = !isSelectorFormat(format) || isInlineFormat(format);
                        }
                        // Default to true
                        if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {
                            format.remove = 'none';
                        }
                        // Mark format as a mixed format inline + block level
                        if (isSelectorFormat(format) && isInlineFormat(format)) {
                            format.mixed = true;
                            format.block_expand = true;
                        }
                        // Split classes if needed
                        if (isString(format.classes)) {
                            format.classes = format.classes.split(/\s+/);
                        }
                    });
                    formats[name] = format;
                }
            }
        };
        const unregister = (name) => {
            if (name && formats[name]) {
                delete formats[name];
            }
            return formats;
        };
        register(get$1(editor));
        register(get());
        register(getFormats(editor));
        return {
            get: get$2,
            has,
            register,
            unregister
        };
    };

    const each$3 = Tools.each;
    const dom = DOMUtils.DOM;
    const isPreviewItem = (item) => isNonNullable(item) && isObject(item);
    const parsedSelectorToHtml = (ancestry, editor) => {
        const schema = editor && editor.schema || Schema({});
        const decorate = (elm, item) => {
            if (item.classes.length > 0) {
                dom.addClass(elm, item.classes.join(' '));
            }
            dom.setAttribs(elm, item.attrs);
        };
        const createElement = (sItem) => {
            const item = isString(sItem) ? {
                name: sItem,
                classes: [],
                attrs: {}
            } : sItem;
            const elm = dom.create(item.name);
            decorate(elm, item);
            return elm;
        };
        const getRequiredParent = (elm, candidate) => {
            const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());
            const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;
            if (parentsRequired && parentsRequired.length) {
                return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];
            }
            else {
                return false;
            }
        };
        const wrapInHtml = (elm, ancestors, siblings) => {
            let parentCandidate;
            const ancestor = ancestors[0];
            const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;
            const parentRequired = getRequiredParent(elm, ancestorName);
            if (parentRequired) {
                if (ancestorName === parentRequired) {
                    parentCandidate = ancestor;
                    ancestors = ancestors.slice(1);
                }
                else {
                    parentCandidate = parentRequired;
                }
            }
            else if (ancestor) {
                parentCandidate = ancestor;
                ancestors = ancestors.slice(1);
            }
            else if (!siblings) {
                return elm;
            }
            // if no more ancestry, wrap in generic div
            const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');
            parent.appendChild(elm);
            if (siblings) {
                Tools.each(siblings, (sibling) => {
                    const siblingElm = createElement(sibling);
                    parent.insertBefore(siblingElm, elm);
                });
            }
            const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;
            return wrapInHtml(parent, ancestors, parentSiblings);
        };
        const fragment = dom.create('div');
        if (ancestry.length > 0) {
            const item = ancestry[0];
            const elm = createElement(item);
            const siblings = isPreviewItem(item) ? item.siblings : undefined;
            fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));
        }
        return fragment;
    };
    const parseSelectorItem = (item) => {
        item = Tools.trim(item);
        let tagName = 'div';
        const obj = {
            name: tagName,
            classes: [],
            attrs: {},
            selector: item
        };
        if (item !== '*') {
            // matching IDs, CLASSes, ATTRIBUTES and PSEUDOs
            tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, ($0, $1, $2, $3, $4) => {
                switch ($1) {
                    case '#':
                        obj.attrs.id = $2;
                        break;
                    case '.':
                        obj.classes.push($2);
                        break;
                    case ':':
                        if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {
                            obj.attrs[$2] = $2;
                        }
                        break;
                }
                // attribute matched
                if ($3 === '[') {
                    const m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
                    if (m) {
                        obj.attrs[m[1]] = m[2];
                    }
                }
                return '';
            });
        }
        obj.name = tagName || 'div';
        return obj;
    };
    const parseSelector = (selector) => {
        if (!isString(selector)) {
            return [];
        }
        // take into account only first one
        selector = selector.split(/\s*,\s*/)[0];
        // tighten
        selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, '$1');
        // split either on > or on space, but not the one inside brackets
        return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), (item) => {
            // process each sibling selector separately
            const siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
            const obj = siblings.pop(); // the last one is our real target
            if (siblings.length) {
                obj.siblings = siblings;
            }
            return obj;
        }).reverse();
    };
    const getCssText = (editor, format) => {
        let previewCss = '';
        let previewStyles = getPreviewStyles(editor);
        // No preview forced
        if (previewStyles === '') {
            return '';
        }
        // Removes any variables since these can't be previewed
        const removeVars = (val) => {
            return isString(val) ? val.replace(/%(\w+)/g, '') : '';
        };
        const getComputedStyle = (name, elm) => {
            return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);
        };
        // Create block/inline element to use for preview
        if (isString(format)) {
            const formats = editor.formatter.get(format);
            if (!formats) {
                return '';
            }
            format = formats[0];
        }
        // Format specific preview override
        // TODO: This should probably be further reduced by the previewStyles option
        if ('preview' in format) {
            const preview = format.preview;
            if (preview === false) {
                return '';
            }
            else {
                previewStyles = preview || previewStyles;
            }
        }
        let name = format.block || format.inline || 'span';
        let previewFrag;
        const items = parseSelector(format.selector);
        if (items.length > 0) {
            if (!items[0].name) { // e.g. something like ul > .someClass was provided
                items[0].name = name;
            }
            name = format.selector;
            previewFrag = parsedSelectorToHtml(items, editor);
        }
        else {
            previewFrag = parsedSelectorToHtml([name], editor);
        }
        const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;
        // Add format styles to preview element
        each$3(format.styles, (value, name) => {
            const newValue = removeVars(value);
            if (newValue) {
                dom.setStyle(previewElm, name, newValue);
            }
        });
        // Add attributes to preview element
        each$3(format.attributes, (value, name) => {
            const newValue = removeVars(value);
            if (newValue) {
                dom.setAttrib(previewElm, name, newValue);
            }
        });
        // Add classes to preview element
        each$3(format.classes, (value) => {
            const newValue = removeVars(value);
            if (!dom.hasClass(previewElm, newValue)) {
                dom.addClass(previewElm, newValue);
            }
        });
        editor.dispatch('PreviewFormats');
        // Add the previewElm outside the visual area
        dom.setStyles(previewFrag, { position: 'absolute', left: -0xFFFF });
        editor.getBody().appendChild(previewFrag);
        // Get parent container font size so we can compute px values out of em/% for older IE:s
        const rawParentFontSize = getComputedStyle('fontSize');
        const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;
        each$3(previewStyles.split(' '), (name) => {
            let value = getComputedStyle(name, previewElm);
            // If background is transparent then check if the body has a background color we can use
            if (name === 'background-color' && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value)) {
                value = getComputedStyle(name);
                // Ignore white since it's the default color, not the nicest fix
                // TODO: Fix this by detecting runtime style
                if (rgbaToHexString(value).toLowerCase() === '#ffffff') {
                    return;
                }
            }
            if (name === 'color') {
                // Ignore black since it's the default color, not the nicest fix
                // TODO: Fix this by detecting runtime style
                if (rgbaToHexString(value).toLowerCase() === '#000000') {
                    return;
                }
            }
            // Old IE won't calculate the font size so we need to do that manually
            if (name === 'font-size') {
                if (/em|%$/.test(value)) {
                    if (parentFontSize === 0) {
                        return;
                    }
                    // Convert font size from em/% to px
                    const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);
                    value = (numValue * parentFontSize) + 'px';
                }
            }
            if (name === 'border' && value) {
                previewCss += 'padding:0 2px;';
            }
            previewCss += name + ':' + value + ';';
        });
        editor.dispatch('AfterPreviewFormats');
        // previewCss += 'line-height:normal';
        dom.remove(previewFrag);
        return previewCss;
    };

    const setup$x = (editor) => {
        // Add some inline shortcuts
        editor.addShortcut('meta+b', '', 'Bold');
        editor.addShortcut('meta+i', '', 'Italic');
        editor.addShortcut('meta+u', '', 'Underline');
        // BlockFormat shortcuts keys
        for (let i = 1; i <= 6; i++) {
            editor.addShortcut('access+' + i, '', ['FormatBlock', false, 'h' + i]);
        }
        editor.addShortcut('access+7', '', ['FormatBlock', false, 'p']);
        editor.addShortcut('access+8', '', ['FormatBlock', false, 'div']);
        editor.addShortcut('access+9', '', ['FormatBlock', false, 'address']);
    };

    const Formatter = (editor) => {
        const formats = FormatRegistry(editor);
        const formatChangeState = Cell({});
        setup$x(editor);
        setup$B(editor);
        if (!isRtc(editor)) {
            setup$A(formatChangeState, editor);
        }
        return {
            /**
             * Returns the format by name or all formats if no name is specified.
             *
             * @method get
             * @param {String} name Optional name to retrieve by.
             * @return {Array/Object} Array/Object with all registered formats or a specific format.
             */
            get: formats.get,
            /**
             * Returns true or false if a format is registered for the specified name.
             *
             * @method has
             * @param {String} name Format name to check if a format exists.
             * @return {Boolean} True/False if a format for the specified name exists.
             */
            has: formats.has,
            /**
             * Registers a specific format by name.
             *
             * @method register
             * @param {Object/String} name Name of the format for example "bold".
             * @param {Object/Array} format Optional format object or array of format variants
             * can only be omitted if the first arg is an object.
             */
            register: formats.register,
            /**
             * Unregister a specific format by name.
             *
             * @method unregister
             * @param {String} name Name of the format for example "bold".
             */
            unregister: formats.unregister,
            /**
             * Applies the specified format to the current selection or specified node.
             *
             * @method apply
             * @param {String} name Name of format to apply.
             * @param {Object} vars Optional list of variables to replace within format before applying it.
             * @param {Node} node Optional node to apply the format to defaults to current selection.
             */
            apply: (name, vars, node) => {
                applyFormat(editor, name, vars, node);
            },
            /**
             * Removes the specified format from the current selection or specified node.
             *
             * @method remove
             * @param {String} name Name of format to remove.
             * @param {Object} vars Optional list of variables to replace within format before removing it.
             * @param {Node/Range} node Optional node or DOM range to remove the format from defaults to current selection.
             */
            remove: (name, vars, node, similar) => {
                removeFormat(editor, name, vars, node, similar);
            },
            /**
             * Toggles the specified format on/off.
             *
             * @method toggle
             * @param {String} name Name of format to apply/remove.
             * @param {Object} vars Optional list of variables to replace within format before applying/removing it.
             * @param {Node} node Optional node to apply the format to or remove from. Defaults to current selection.
             */
            toggle: (name, vars, node) => {
                toggleFormat(editor, name, vars, node);
            },
            /**
             * Matches the current selection or specified node against the specified format name.
             *
             * @method match
             * @param {String} name Name of format to match.
             * @param {Object} vars Optional list of variables to replace before checking it.
             * @param {Node} node Optional node to check.
             * @param {Boolean} similar Optional argument to specify that similar formats should be checked instead of only exact formats.
             * @return {Boolean} true/false if the specified selection/node matches the format.
             */
            match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),
            /**
             * Finds the closest matching format from a set of formats for the current selection.
             *
             * @method closest
             * @param {Array} names Format names to check for.
             * @return {String} The closest matching format name or null.
             */
            closest: (names) => closestFormat(editor, names),
            /**
             * Matches the current selection against the array of formats and returns a new array with matching formats.
             *
             * @method matchAll
             * @param {Array} names Name of format to match.
             * @param {Object} vars Optional list of variables to replace before checking it.
             * @return {Array} Array with matched formats.
             */
            matchAll: (names, vars) => matchAllFormats(editor, names, vars),
            /**
             * Return true/false if the specified node has the specified format.
             *
             * @method matchNode
             * @param {Node} node Node to check the format on.
             * @param {String} name Format name to check.
             * @param {Object} vars Optional list of variables to replace before checking it.
             * @param {Boolean} similar Match format that has similar properties.
             * @return {Object} Returns the format object it matches or undefined if it doesn't match.
             */
            matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),
            /**
             * Returns true/false if the specified format can be applied to the current selection or not. It
             * will currently only check the state for selector formats, it returns true on all other format types.
             *
             * @method canApply
             * @param {String} name Name of format to check.
             * @return {Boolean} true/false if the specified format can be applied to the current selection/node.
             */
            canApply: (name) => canApplyFormat(editor, name),
            /**
             * Executes the specified callback when the current selection matches the formats or not.
             *
             * @method formatChanged
             * @param {String} formats Comma separated list of formats to check for.
             * @param {Function} callback Callback with state and args when the format is changed/toggled on/off.
             * @param {Boolean} similar True/false state if the match should handle similar or exact formats.
             * @param {Object} vars Restrict the format being watched to only match if the variables applied are equal to vars.
             */
            formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),
            /**
             * Returns a preview css text for the specified format.
             *
             * @method getCssText
             * @param {String/Object} format Format to generate preview css text for.
             * @return {String} Css text for the specified format.
             * @example
             * const cssText1 = editor.formatter.getCssText('bold');
             * const cssText2 = editor.formatter.getCssText({ inline: 'b' });
             */
            getCssText: curry(getCssText, editor)
        };
    };

    // Avoid adding non-typing undo levels for commands that could cause duplicate undo levels to be created
    // or do not alter the editor content or selection in any way
    const shouldIgnoreCommand = (cmd) => {
        switch (cmd.toLowerCase()) {
            case 'undo':
            case 'redo':
            case 'mcefocus':
                return true;
            default:
                return false;
        }
    };
    const registerEvents = (editor, undoManager, locks) => {
        const isFirstTypedCharacter = Cell(false);
        const addNonTypingUndoLevel = (e) => {
            setTyping(undoManager, false, locks);
            undoManager.add({}, e);
        };
        // Add initial undo level when the editor is initialized
        editor.on('init', () => {
            undoManager.add();
        });
        // Get position before an execCommand is processed
        editor.on('BeforeExecCommand', (e) => {
            const cmd = e.command;
            if (!shouldIgnoreCommand(cmd)) {
                endTyping(undoManager, locks);
                undoManager.beforeChange();
            }
        });
        // Add undo level after an execCommand call was made
        editor.on('ExecCommand', (e) => {
            const cmd = e.command;
            if (!shouldIgnoreCommand(cmd)) {
                addNonTypingUndoLevel(e);
            }
        });
        editor.on('ObjectResizeStart cut', () => {
            undoManager.beforeChange();
        });
        editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);
        editor.on('dragend', addNonTypingUndoLevel);
        editor.on('keyup', (e) => {
            const keyCode = e.keyCode;
            // If key is prevented then don't add undo level
            // This would happen on keyboard shortcuts for example
            if (e.isDefaultPrevented()) {
                return;
            }
            const isMeta = Env.os.isMacOS() && e.key === 'Meta';
            if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode === 45 || e.ctrlKey || isMeta) {
                addNonTypingUndoLevel();
                editor.nodeChanged();
            }
            if (keyCode === 46 || keyCode === 8) {
                editor.nodeChanged();
            }
            // Fire a TypingUndo event on the first character entered
            if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {
                if (!editor.isDirty()) {
                    editor.setDirty(true);
                }
                editor.dispatch('TypingUndo');
                isFirstTypedCharacter.set(false);
                editor.nodeChanged();
            }
        });
        editor.on('keydown', (e) => {
            const keyCode = e.keyCode;
            // If key is prevented then don't add undo level
            // This would happen on keyboard shortcuts for example
            if (e.isDefaultPrevented()) {
                return;
            }
            // Is character position keys left,right,up,down,home,end,pgdown,pgup,enter
            if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode === 45) {
                if (undoManager.typing) {
                    addNonTypingUndoLevel(e);
                }
                return;
            }
            // If key isn't Ctrl+Alt/AltGr
            const modKey = (e.ctrlKey && !e.altKey) || e.metaKey;
            if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
                undoManager.beforeChange();
                setTyping(undoManager, true, locks);
                undoManager.add({}, e);
                isFirstTypedCharacter.set(true);
                return;
            }
            const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;
            if (hasOnlyMetaOrCtrlModifier) {
                undoManager.beforeChange();
            }
        });
        editor.on('mousedown', (e) => {
            if (undoManager.typing) {
                addNonTypingUndoLevel(e);
            }
        });
        // Special inputType, currently only Chrome implements this: https://www.w3.org/TR/input-events-2/#x5.1.2-attributes
        const isInsertReplacementText = (event) => event.inputType === 'insertReplacementText';
        // Safari just shows inputType `insertText` but with data set to null so we can use that
        const isInsertTextDataNull = (event) => event.inputType === 'insertText' && event.data === null;
        const isInsertFromPasteOrDrop = (event) => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';
        // For detecting when user has replaced text using the browser built-in spell checker or paste/drop events
        editor.on('input', (e) => {
            if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {
                addNonTypingUndoLevel(e);
            }
        });
        editor.on('AddUndo Undo Redo ClearUndos', (e) => {
            if (!e.isDefaultPrevented()) {
                editor.nodeChanged();
            }
        });
    };
    const addKeyboardShortcuts = (editor) => {
        editor.addShortcut('meta+z', '', 'Undo');
        editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');
    };

    /**
     * This class handles the undo/redo history levels for the editor. Since the built-in undo/redo has major drawbacks a custom one was needed.
     *
     * @class tinymce.UndoManager
     */
    const UndoManager = (editor) => {
        const beforeBookmark = value$1();
        const locks = Cell(0);
        const index = Cell(0);
        /* eslint consistent-this:0 */
        const undoManager = {
            data: [], // Gets mutated both internally and externally by plugins like remark, not documented
            /**
             * State if the user is currently typing or not. This will add a typing operation into one undo
             * level instead of one new level for each keystroke.
             *
             * @field {Boolean} typing
             */
            typing: false,
            /**
             * Stores away a bookmark to be used when performing an undo action so that the selection is before
             * the change has been made.
             *
             * @method beforeChange
             */
            beforeChange: () => {
                beforeChange(editor, locks, beforeBookmark);
            },
            /**
             * Adds a new undo level/snapshot to the undo list.
             *
             * @method add
             * @param {Object} level Optional undo level object to add.
             * @param {DOMEvent} event Optional event responsible for the creation of the undo level.
             * @return {Object} Undo level that got added or null if a level wasn't needed.
             */
            add: (level, event) => {
                return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
            },
            /**
             * Dispatch a change event with current editor status as level and current undoManager layer as lastLevel
             *
             * @method dispatchChange
             */
            dispatchChange: () => {
                editor.setDirty(true);
                const level = createFromEditor(editor);
                level.bookmark = getUndoBookmark(editor.selection);
                editor.dispatch('change', {
                    level,
                    lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()
                });
            },
            /**
             * Undoes the last action.
             *
             * @method undo
             * @return {Object} Undo level or null if no undo was performed.
             */
            undo: () => {
                return undo(editor, undoManager, locks, index);
            },
            /**
             * Redoes the last action.
             *
             * @method redo
             * @return {Object} Redo level or null if no redo was performed.
             */
            redo: () => {
                return redo(editor, index, undoManager.data);
            },
            /**
             * Removes all undo levels.
             *
             * @method clear
             */
            clear: () => {
                clear(editor, undoManager, index);
            },
            /**
             * Resets the undo manager levels by clearing all levels and then adding an initial level.
             *
             * @method reset
             */
            reset: () => {
                reset(editor, undoManager);
            },
            /**
             * Returns true/false if the undo manager has any undo levels.
             *
             * @method hasUndo
             * @return {Boolean} true/false if the undo manager has any undo levels.
             */
            hasUndo: () => {
                return hasUndo(editor, undoManager, index);
            },
            /**
             * Returns true/false if the undo manager has any redo levels.
             *
             * @method hasRedo
             * @return {Boolean} true/false if the undo manager has any redo levels.
             */
            hasRedo: () => {
                return hasRedo(editor, undoManager, index);
            },
            /**
             * Executes the specified mutator function as an undo transaction. The selection
             * before the modification will be stored to the undo stack and if the DOM changes
             * it will add a new undo level. Any logic within the translation that adds undo levels will
             * be ignored. So a translation can include calls to execCommand or editor.insertContent.
             *
             * @method transact
             * @param {Function} callback Function that gets executed and has dom manipulation logic in it.
             * @return {Object} Undo level that got added or null it a level wasn't needed.
             */
            transact: (callback) => {
                return transact(editor, undoManager, locks, callback);
            },
            /**
             * Executes the specified mutator function as an undo transaction. But without adding an undo level.
             * Any logic within the translation that adds undo levels will be ignored. So a translation can
             * include calls to execCommand or editor.insertContent.
             *
             * @method ignore
             * @param {Function} callback Function that gets executed and has dom manipulation logic in it.
             */
            ignore: (callback) => {
                ignore(editor, locks, callback);
            },
            /**
             * Adds an extra "hidden" undo level by first applying the first mutation and store that to the undo stack
             * then roll back that change and do the second mutation on top of the stack. This will produce an extra
             * undo level that the user doesn't see until they undo.
             *
             * @method extra
             * @param {Function} callback1 Function that does mutation but gets stored as a "hidden" extra undo level.
             * @param {Function} callback2 Function that does mutation but gets displayed to the user.
             */
            extra: (callback1, callback2) => {
                extra(editor, undoManager, index, callback1, callback2);
            }
        };
        if (!isRtc(editor)) {
            registerEvents(editor, undoManager, locks);
        }
        addKeyboardShortcuts(editor);
        return undoManager;
    };

    const nonTypingKeycodes = [
        // tab, esc, home, end
        9, 27, VK.HOME, VK.END,
        // pause, capslock, print screen, numlock, scroll lock
        19, 20, 44, 144, 145,
        // page up/down, insert
        33, 34, 45,
        // alt, shift, ctrl
        16, 17, 18,
        // meta/windows key
        91, 92, 93,
        // direction
        VK.DOWN, VK.UP, VK.LEFT, VK.RIGHT
    ].concat(
    // Meta key on firefox is different
    Env.browser.isFirefox() ? [224] : []);
    const placeholderAttr = 'data-mce-placeholder';
    const isKeyboardEvent = (e) => e.type === 'keydown' || e.type === 'keyup';
    const isDeleteEvent = (e) => {
        const keyCode = e.keyCode;
        return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
    };
    const isNonTypingKeyboardEvent = (e) => {
        if (isKeyboardEvent(e)) {
            const keyCode = e.keyCode;
            // Ctrl/Meta/Alt key pressed, F1-12 or non typing keycode
            return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));
        }
        else {
            return false;
        }
    };
    const isTypingKeyboardEvent = (e) => 
    // 229 === Unidentified, so since we don't know what it is treat it as a non typing event on keyup but as a typing event on keydown
    // Android will generally always send a 229 keycode since it uses an IME to input text
    isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);
    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {
        if (dom.isEmpty(rootElm, undefined, { skipBogus: false, includeZwsp: true })) {
            // Ensure the node matches the forced_root_block setting, as the content could be an empty list, etc...
            // and also check that the content isn't indented
            const firstElement = rootElm.firstElementChild;
            if (!firstElement) {
                return true;
            }
            else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {
                return false;
            }
            else {
                return forcedRootBlock === firstElement.nodeName.toLowerCase();
            }
        }
        else {
            return false;
        }
    };
    const setup$w = (editor) => {
        var _a;
        const dom = editor.dom;
        const rootBlock = getForcedRootBlock(editor);
        const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';
        const updatePlaceholder = (e, initial) => {
            if (isNonTypingKeyboardEvent(e)) {
                return;
            }
            // Check to see if we should show the placeholder
            const body = editor.getBody();
            const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);
            // Update the attribute as required
            const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';
            if (isPlaceholderShown !== showPlaceholder || initial) {
                dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
                firePlaceholderToggle(editor, showPlaceholder);
                // Swap the key listener state
                editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);
                editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);
            }
        };
        if (isNotEmpty(placeholder)) {
            editor.on('init', (e) => {
                // Setup the initial state
                updatePlaceholder(e, true);
                editor.on('change SetContent ExecCommand', updatePlaceholder);
                // TINY-4828: Update the placeholder after pasting content. This needs to use a timeout as
                // the browser doesn't update the dom until after the paste event has fired
                editor.on('paste', (e) => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));
            });
        }
    };

    const matchNodeName = (name) => (node) => isNonNullable(node) && node.nodeName.toLowerCase() === name;
    const matchNodeNames = (regex) => (node) => isNonNullable(node) && regex.test(node.nodeName);
    const isTextNode$1 = (node) => isNonNullable(node) && node.nodeType === 3;
    const isElement$1 = (node) => isNonNullable(node) && node.nodeType === 1;
    const isListNode = matchNodeNames(/^(OL|UL|DL)$/);
    const isOlUlNode = matchNodeNames(/^(OL|UL)$/);
    const isListItemNode = matchNodeNames(/^(LI|DT|DD)$/);
    const isDlItemNode = matchNodeNames(/^(DT|DD)$/);
    const isBr$1 = matchNodeName('br');
    const isFirstChild$1 = (node) => { var _a; return ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === node; };
    const isTextBlock = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getTextBlockElements();
    const isBlock = (node, blockElements) => isNonNullable(node) && node.nodeName in blockElements;
    const isVoid = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getVoidElements();
    const isBogusBr = (dom, node) => {
        if (!isBr$1(node)) {
            return false;
        }
        return dom.isBlock(node.nextSibling) && !isBr$1(node.previousSibling);
    };
    const isEmpty$1 = (dom, elm, keepBookmarks) => {
        const empty = dom.isEmpty(elm);
        if (keepBookmarks && dom.select('span[data-mce-type=bookmark]', elm).length > 0) {
            return false;
        }
        return empty;
    };
    const isChildOfBody = (dom, elm) => dom.isChildOf(elm, dom.getRoot());

    const getNormalizedPoint = (container, offset) => {
        if (isTextNode$1(container)) {
            return { container, offset };
        }
        const node = RangeUtils.getNode(container, offset);
        if (isTextNode$1(node)) {
            return {
                container: node,
                offset: offset >= container.childNodes.length ? node.data.length : 0
            };
        }
        else if (node.previousSibling && isTextNode$1(node.previousSibling)) {
            return {
                container: node.previousSibling,
                offset: node.previousSibling.data.length
            };
        }
        else if (node.nextSibling && isTextNode$1(node.nextSibling)) {
            return {
                container: node.nextSibling,
                offset: 0
            };
        }
        return { container, offset };
    };
    const normalizeRange = (rng) => {
        const outRng = rng.cloneRange();
        const rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);
        outRng.setStart(rangeStart.container, rangeStart.offset);
        const rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);
        outRng.setEnd(rangeEnd.container, rangeEnd.offset);
        return outRng;
    };

    const DOM$a = DOMUtils.DOM;
    /**
     * Returns a range bookmark. This will convert indexed bookmarks into temporary span elements with
     * index 0 so that they can be restored properly after the DOM has been modified. Text bookmarks will not have spans
     * added to them since they can be restored after a dom operation.
     *
     * So this: <p><b>|</b><b>|</b></p>
     * becomes: <p><b><span data-mce-type="bookmark">|</span></b><b data-mce-type="bookmark">|</span></b></p>
     *
     */
    const createBookmark = (rng) => {
        const bookmark = {};
        const setupEndPoint = (start) => {
            let container = rng[start ? 'startContainer' : 'endContainer'];
            let offset = rng[start ? 'startOffset' : 'endOffset'];
            if (isElement$1(container)) {
                const offsetNode = DOM$a.create('span', { 'data-mce-type': 'bookmark' });
                if (container.hasChildNodes()) {
                    offset = Math.min(offset, container.childNodes.length - 1);
                    if (start) {
                        container.insertBefore(offsetNode, container.childNodes[offset]);
                    }
                    else {
                        DOM$a.insertAfter(offsetNode, container.childNodes[offset]);
                    }
                }
                else {
                    container.appendChild(offsetNode);
                }
                container = offsetNode;
                offset = 0;
            }
            bookmark[start ? 'startContainer' : 'endContainer'] = container;
            bookmark[start ? 'startOffset' : 'endOffset'] = offset;
        };
        setupEndPoint(true);
        if (!rng.collapsed) {
            setupEndPoint();
        }
        return bookmark;
    };
    const resolveBookmark$1 = (bookmark) => {
        const restoreEndPoint = (start) => {
            const nodeIndex = (container) => {
                var _a;
                let node = (_a = container.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild;
                let idx = 0;
                while (node) {
                    if (node === container) {
                        return idx;
                    }
                    // Skip data-mce-type=bookmark nodes
                    if (!isElement$1(node) || node.getAttribute('data-mce-type') !== 'bookmark') {
                        idx++;
                    }
                    node = node.nextSibling;
                }
                return -1;
            };
            let container = bookmark[start ? 'startContainer' : 'endContainer'];
            let offset = bookmark[start ? 'startOffset' : 'endOffset'];
            if (!container) {
                return;
            }
            if (isElement$1(container) && container.parentNode) {
                const node = container;
                offset = nodeIndex(container);
                container = container.parentNode;
                DOM$a.remove(node);
                if (!container.hasChildNodes() && DOM$a.isBlock(container)) {
                    container.appendChild(DOM$a.create('br'));
                }
            }
            bookmark[start ? 'startContainer' : 'endContainer'] = container;
            bookmark[start ? 'startOffset' : 'endOffset'] = offset;
        };
        restoreEndPoint(true);
        restoreEndPoint();
        const rng = DOM$a.createRng();
        rng.setStart(bookmark.startContainer, bookmark.startOffset);
        if (bookmark.endContainer) {
            rng.setEnd(bookmark.endContainer, bookmark.endOffset);
        }
        return normalizeRange(rng);
    };

    const DOM$9 = DOMUtils.DOM;
    const normalizeList = (dom, list) => {
        const parentNode = list.parentElement;
        // Move UL/OL to previous LI if it's the only child of a LI
        if (parentNode && parentNode.nodeName === 'LI' && parentNode.firstChild === list) {
            const sibling = parentNode.previousSibling;
            if (sibling && sibling.nodeName === 'LI') {
                sibling.appendChild(list);
                if (isEmpty$1(dom, parentNode)) {
                    DOM$9.remove(parentNode);
                }
            }
            else {
                DOM$9.setStyle(parentNode, 'listStyleType', 'none');
            }
        }
        // Append OL/UL to previous LI if it's in a parent OL/UL i.e. old HTML4
        if (isListNode(parentNode)) {
            const sibling = parentNode.previousSibling;
            if (sibling && sibling.nodeName === 'LI') {
                sibling.appendChild(list);
            }
        }
    };
    const normalizeLists = (dom, element) => {
        const lists = Tools.grep(dom.select('ol,ul', element));
        Tools.each(lists, (list) => {
            normalizeList(dom, list);
        });
    };

    const listNames = ['OL', 'UL', 'DL'];
    const listSelector = listNames.join(',');
    const getParentList = (editor, node) => {
        const selectionStart = node || editor.selection.getStart(true);
        return editor.dom.getParent(selectionStart, listSelector, getClosestListHost(editor, selectionStart));
    };
    const isParentListSelected = (parentList, selectedBlocks) => isNonNullable(parentList) && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;
    const findSubLists = (parentList) => filter$5(parentList.querySelectorAll(listSelector), isListNode);
    const getSelectedSubLists = (editor) => {
        const parentList = getParentList(editor);
        const selectedBlocks = editor.selection.getSelectedBlocks();
        if (isParentListSelected(parentList, selectedBlocks)) {
            return findSubLists(parentList);
        }
        else {
            return filter$5(selectedBlocks, (elm) => {
                return isListNode(elm) && parentList !== elm;
            });
        }
    };
    const findParentListItemsNodes = (editor, elms) => {
        const listItemsElms = Tools.map(elms, (elm) => {
            const parentLi = editor.dom.getParent(elm, 'li,dd,dt', getClosestListHost(editor, elm));
            return parentLi ? parentLi : elm;
        });
        return unique$1(listItemsElms);
    };
    const getSelectedListItems = (editor) => {
        const selectedBlocks = editor.selection.getSelectedBlocks();
        return filter$5(findParentListItemsNodes(editor, selectedBlocks), isListItemNode);
    };
    const getSelectedDlItems = (editor) => filter$5(getSelectedListItems(editor), isDlItemNode);
    const getClosestEditingHost = (editor, elm) => {
        const parentTableCell = editor.dom.getParents(elm, 'TD,TH');
        return parentTableCell.length > 0 ? parentTableCell[0] : editor.getBody();
    };
    const isListHost = (schema, node) => !isListNode(node) && !isListItemNode(node) && exists(listNames, (listName) => schema.isValidChild(node.nodeName, listName));
    const getClosestListHost = (editor, elm) => {
        const parentBlocks = editor.dom.getParents(elm, editor.dom.isBlock);
        const isNotForcedRootBlock = (elm) => elm.nodeName.toLowerCase() !== getForcedRootBlock(editor);
        const parentBlock = find$2(parentBlocks, (elm) => isNotForcedRootBlock(elm) && isListHost(editor.schema, elm));
        return parentBlock.getOr(editor.getBody());
    };
    const isListInsideAnLiWithFirstAndLastNotListElement = (list) => parent(list).exists((parent) => isListItemNode(parent.dom)
        && firstChild(parent).exists((firstChild) => !isListNode(firstChild.dom))
        && lastChild(parent).exists((lastChild) => !isListNode(lastChild.dom)));
    const findLastParentListNode = (editor, elm) => {
        const parentLists = editor.dom.getParents(elm, 'ol,ul', getClosestListHost(editor, elm));
        return last$2(parentLists);
    };
    const getSelectedLists = (editor) => {
        const firstList = findLastParentListNode(editor, editor.selection.getStart());
        const subsequentLists = filter$5(editor.selection.getSelectedBlocks(), isOlUlNode);
        return firstList.toArray().concat(subsequentLists);
    };
    const getParentLists = (editor) => {
        const elm = editor.selection.getStart();
        return editor.dom.getParents(elm, 'ol,ul', getClosestListHost(editor, elm));
    };
    const getSelectedListRoots = (editor) => {
        const selectedLists = getSelectedLists(editor);
        const parentLists = getParentLists(editor);
        return find$2(parentLists, (p) => isListInsideAnLiWithFirstAndLastNotListElement(SugarElement.fromDom(p))).fold(() => getUniqueListRoots(editor, selectedLists), (l) => [l]);
    };
    const getUniqueListRoots = (editor, lists) => {
        const listRoots = map$3(lists, (list) => findLastParentListNode(editor, list).getOr(list));
        return unique$1(listRoots);
    };

    const isCustomList = (list) => /\btox\-/.test(list.className);
    // Advlist/core/ListUtils.ts - Duplicated in Advlist plugin
    const isWithinNonEditable = (editor, element) => element !== null && !editor.dom.isEditable(element);
    const selectionIsWithinNonEditableList = (editor) => {
        const parentList = getParentList(editor);
        return isWithinNonEditable(editor, parentList) || !editor.selection.isEditable();
    };
    const isWithinNonEditableList$1 = (editor, element) => {
        const parentList = editor.dom.getParent(element, 'ol,ul,dl');
        return isWithinNonEditable(editor, parentList) || !editor.selection.isEditable();
    };

    const fireListEvent = (editor, action, element) => editor.dispatch('ListMutation', { action, element });

    const createTextBlock$1 = (editor, contentNode, attrs = {}) => {
        const dom = editor.dom;
        const blockElements = editor.schema.getBlockElements();
        const fragment = dom.createFragment();
        const blockName = getForcedRootBlock(editor);
        const blockAttrs = getForcedRootBlockAttrs(editor);
        let node;
        let textBlock;
        let hasContentNode = false;
        textBlock = dom.create(blockName, {
            ...blockAttrs,
            ...(attrs.style ? { style: attrs.style } : {})
        });
        if (!isBlock(contentNode.firstChild, blockElements)) {
            fragment.appendChild(textBlock);
        }
        while ((node = contentNode.firstChild)) {
            const nodeName = node.nodeName;
            if (!hasContentNode && (nodeName !== 'SPAN' || node.getAttribute('data-mce-type') !== 'bookmark')) {
                hasContentNode = true;
            }
            if (isBlock(node, blockElements)) {
                fragment.appendChild(node);
                textBlock = null;
            }
            else {
                if (!textBlock) {
                    textBlock = dom.create(blockName, blockAttrs);
                    fragment.appendChild(textBlock);
                }
                textBlock.appendChild(node);
            }
        }
        // BR is needed in empty blocks
        if (!hasContentNode && textBlock) {
            textBlock.appendChild(dom.create('br', { 'data-mce-bogus': '1' }));
        }
        return fragment;
    };

    const isList = (el) => is$1(el, 'OL,UL');
    const isListItem$1 = (el) => is$1(el, 'LI');
    const hasFirstChildList = (el) => firstChild(el).exists(isList);
    const hasLastChildList = (el) => lastChild(el).exists(isList);
    const canIncreaseDepthOfList = (editor, amount) => {
        return getListMaxDepth(editor).map((max) => max >= amount).getOr(true);
    };

    const isEntryList = (entry) => 'listAttributes' in entry;
    const isEntryComment = (entry) => 'isComment' in entry;
    const isEntryFragment = (entry) => 'isFragment' in entry;
    const isIndented = (entry) => entry.depth > 0;
    const isSelected = (entry) => entry.isSelected;
    const cloneItemContent = (li) => {
        const children = children$1(li);
        const content = hasLastChildList(li) ? children.slice(0, -1) : children;
        return map$3(content, deep);
    };
    const createEntry = (li, depth, isSelected) => parent(li).filter(isElement$8).map((list) => ({
        depth,
        dirty: false,
        isSelected,
        content: cloneItemContent(li),
        itemAttributes: clone$4(li),
        listAttributes: clone$4(list),
        listType: name(list),
        isInPreviousLi: false
    }));

    const joinSegment = (parent, child) => {
        append$1(parent.item, child.list);
    };
    const joinSegments = (segments) => {
        for (let i = 1; i < segments.length; i++) {
            joinSegment(segments[i - 1], segments[i]);
        }
    };
    const appendSegments = (head$1, tail) => {
        lift2(last$2(head$1), head(tail), joinSegment);
    };
    const createSegment = (scope, listType) => {
        const segment = {
            list: SugarElement.fromTag(listType, scope),
            item: SugarElement.fromTag('li', scope)
        };
        append$1(segment.list, segment.item);
        return segment;
    };
    const createSegments = (scope, entry, size) => {
        const segments = [];
        for (let i = 0; i < size; i++) {
            segments.push(createSegment(scope, isEntryList(entry) ? entry.listType : entry.parentListType));
        }
        return segments;
    };
    const populateSegments = (segments, entry) => {
        for (let i = 0; i < segments.length - 1; i++) {
            set$2(segments[i].item, 'list-style-type', 'none');
        }
        last$2(segments).each((segment) => {
            if (isEntryList(entry)) {
                setAll$1(segment.list, entry.listAttributes);
                setAll$1(segment.item, entry.itemAttributes);
            }
            append(segment.item, entry.content);
        });
    };
    const normalizeSegment = (segment, entry) => {
        if (name(segment.list) !== entry.listType) {
            segment.list = mutate(segment.list, entry.listType);
        }
        setAll$1(segment.list, entry.listAttributes);
    };
    const createItem = (scope, attr, content) => {
        const item = SugarElement.fromTag('li', scope);
        setAll$1(item, attr);
        append(item, content);
        return item;
    };
    const appendItem = (segment, item) => {
        append$1(segment.list, item);
        segment.item = item;
    };
    const writeShallow = (scope, cast, entry) => {
        const newCast = cast.slice(0, entry.depth);
        last$2(newCast).each((segment) => {
            if (isEntryList(entry)) {
                const item = createItem(scope, entry.itemAttributes, entry.content);
                appendItem(segment, item);
                normalizeSegment(segment, entry);
            }
            else if (isEntryFragment(entry)) {
                append(segment.item, entry.content);
            }
            else {
                const item = SugarElement.fromHtml(`<!--${entry.content}-->`);
                append$1(segment.list, item);
            }
        });
        return newCast;
    };
    const writeDeep = (scope, cast, entry) => {
        const segments = createSegments(scope, entry, entry.depth - cast.length);
        joinSegments(segments);
        populateSegments(segments, entry);
        appendSegments(cast, segments);
        return cast.concat(segments);
    };
    const composeList = (scope, entries) => {
        let firstCommentEntryOpt = Optional.none();
        const cast = foldl(entries, (cast, entry, i) => {
            if (!isEntryComment(entry)) {
                return entry.depth > cast.length ? writeDeep(scope, cast, entry) : writeShallow(scope, cast, entry);
            }
            else {
                // this is needed becuase if the first element of the list is a comment we would not have the data to create the new list
                if (i === 0) {
                    firstCommentEntryOpt = Optional.some(entry);
                    return cast;
                }
                return writeShallow(scope, cast, entry);
            }
        }, []);
        firstCommentEntryOpt.each((firstCommentEntry) => {
            const item = SugarElement.fromHtml(`<!--${firstCommentEntry.content}-->`);
            head(cast).each((fistCast) => {
                prepend(fistCast.list, item);
            });
        });
        return head(cast).map((segment) => segment.list);
    };

    const indentEntry = (editor, indentation, entry) => {
        switch (indentation) {
            case "Indent" /* Indentation.Indent */:
                if (canIncreaseDepthOfList(editor, entry.depth)) {
                    entry.depth++;
                }
                else {
                    return;
                }
                break;
            case "Outdent" /* Indentation.Outdent */:
                entry.depth--;
                break;
            case "Flatten" /* Indentation.Flatten */:
                entry.depth = 0;
        }
        entry.dirty = true;
    };

    const cloneListProperties = (target, source) => {
        if (isEntryList(target) && isEntryList(source)) {
            target.listType = source.listType;
            target.listAttributes = { ...source.listAttributes };
        }
    };
    const cleanListProperties = (entry) => {
        // Remove the start attribute if generating a new list
        entry.listAttributes = filter$4(entry.listAttributes, (_value, key) => key !== 'start');
    };
    // Closest entry above/below in the same list
    const closestSiblingEntry = (entries, start) => {
        const depth = entries[start].depth;
        // Ignore dirty items as they've been moved and won't have the right list data yet
        const matches = (entry) => entry.depth === depth && !entry.dirty;
        const until = (entry) => entry.depth < depth;
        // Check in reverse to see if there's an entry as the same depth before the current entry
        // but if not, then try to walk forwards as well
        return findUntil$1(reverse(entries.slice(0, start)), matches, until)
            .orThunk(() => findUntil$1(entries.slice(start + 1), matches, until));
    };
    const normalizeEntries = (entries) => {
        each$e(entries, (entry, i) => {
            closestSiblingEntry(entries, i).fold(() => {
                if (entry.dirty && isEntryList(entry)) {
                    cleanListProperties(entry);
                }
            }, (matchingEntry) => cloneListProperties(entry, matchingEntry));
        });
        return entries;
    };

    const parseSingleItem = (depth, itemSelection, selectionState, item) => {
        var _a;
        if (isComment$1(item)) {
            return [{
                    depth: depth + 1,
                    content: (_a = item.dom.nodeValue) !== null && _a !== void 0 ? _a : '',
                    dirty: false,
                    isSelected: false,
                    isComment: true
                }];
        }
        itemSelection.each((selection) => {
            if (eq(selection.start, item)) {
                selectionState.set(true);
            }
        });
        const currentItemEntry = createEntry(item, depth, selectionState.get());
        // Update selectionState (end)
        itemSelection.each((selection) => {
            if (eq(selection.end, item)) {
                selectionState.set(false);
            }
        });
        const childListEntries = lastChild(item)
            .filter(isList)
            .map((list) => parseList(depth, itemSelection, selectionState, list))
            .getOr([]);
        return currentItemEntry.toArray().concat(childListEntries);
    };
    const parseItem = (depth, itemSelection, selectionState, item) => firstChild(item).filter(isList).fold(() => parseSingleItem(depth, itemSelection, selectionState, item), (list) => {
        const parsedSiblings = foldl(children$1(item), (acc, liChild, i) => {
            if (i === 0) {
                return acc;
            }
            else {
                if (isListItem$1(liChild)) {
                    return acc.concat(parseSingleItem(depth, itemSelection, selectionState, liChild));
                }
                else {
                    const fragment = {
                        isFragment: true,
                        depth,
                        content: [liChild],
                        isSelected: false,
                        dirty: false,
                        parentListType: name(list)
                    };
                    return acc.concat(fragment);
                }
            }
        }, []);
        return parseList(depth, itemSelection, selectionState, list).concat(parsedSiblings);
    });
    const parseList = (depth, itemSelection, selectionState, list) => bind$3(children$1(list), (element) => {
        const parser = isList(element) ? parseList : parseItem;
        const newDepth = depth + 1;
        return parser(newDepth, itemSelection, selectionState, element);
    });
    const parseLists = (lists, itemSelection) => {
        const selectionState = Cell(false);
        const initialDepth = 0;
        return map$3(lists, (list) => ({
            sourceList: list,
            entries: parseList(initialDepth, itemSelection, selectionState, list)
        }));
    };

    const outdentedComposer = (editor, entries) => {
        const normalizedEntries = normalizeEntries(entries);
        return map$3(normalizedEntries, (entry) => {
            const content = !isEntryComment(entry)
                ? fromElements(entry.content)
                : fromElements([SugarElement.fromHtml(`<!--${entry.content}-->`)]);
            const listItemAttrs = isEntryList(entry) ? entry.itemAttributes : {};
            return SugarElement.fromDom(createTextBlock$1(editor, content.dom, listItemAttrs));
        });
    };
    const indentedComposer = (editor, entries) => {
        const normalizedEntries = normalizeEntries(entries);
        return composeList(editor.contentDocument, normalizedEntries).toArray();
    };
    const composeEntries = (editor, entries) => bind$3(groupBy(entries, isIndented), (entries) => {
        const groupIsIndented = head(entries).exists(isIndented);
        return groupIsIndented ? indentedComposer(editor, entries) : outdentedComposer(editor, entries);
    });
    const indentSelectedEntries = (editor, entries, indentation) => {
        each$e(filter$5(entries, isSelected), (entry) => indentEntry(editor, indentation, entry));
    };
    const getItemSelection = (editor) => {
        const selectedListItems = map$3(getSelectedListItems(editor), SugarElement.fromDom);
        return lift2(find$2(selectedListItems, not(hasFirstChildList)), find$2(reverse(selectedListItems), not(hasFirstChildList)), (start, end) => ({ start, end }));
    };
    const listIndentation = (editor, lists, indentation) => {
        const entrySets = parseLists(lists, getItemSelection(editor));
        each$e(entrySets, (entrySet) => {
            indentSelectedEntries(editor, entrySet.entries, indentation);
            const composedLists = composeEntries(editor, entrySet.entries);
            each$e(composedLists, (composedList) => {
                fireListEvent(editor, indentation === "Indent" /* Indentation.Indent */ ? "IndentList" /* ListAction.IndentList */ : "OutdentList" /* ListAction.OutdentList */, composedList.dom);
            });
            before$3(entrySet.sourceList, composedLists);
            remove$8(entrySet.sourceList);
        });
    };
    const canIndent$1 = (editor) => getListMaxDepth(editor).forall((max) => {
        const blocks = editor.selection.getSelectedBlocks();
        return exists(blocks, (element) => {
            return closest$3(SugarElement.fromDom(element), 'li').forall((sugarElement) => ancestors(sugarElement, 'ol,ul').length <= max);
        });
    });

    const DOM$8 = DOMUtils.DOM;
    const splitList = (editor, list, li) => {
        const removeAndKeepBookmarks = (targetNode) => {
            const parent = targetNode.parentNode;
            if (parent) {
                Tools.each(bookmarks, (node) => {
                    parent.insertBefore(node, li.parentNode);
                });
            }
            DOM$8.remove(targetNode);
        };
        const bookmarks = DOM$8.select('span[data-mce-type="bookmark"]', list);
        const newBlock = createTextBlock$1(editor, li);
        const tmpRng = DOM$8.createRng();
        tmpRng.setStartAfter(li);
        tmpRng.setEndAfter(list);
        const fragment = tmpRng.extractContents();
        for (let node = fragment.firstChild; node; node = node.firstChild) {
            if (node.nodeName === 'LI' && editor.dom.isEmpty(node)) {
                DOM$8.remove(node);
                break;
            }
        }
        if (!editor.dom.isEmpty(fragment)) {
            DOM$8.insertAfter(fragment, list);
        }
        DOM$8.insertAfter(newBlock, list);
        const parent = li.parentElement;
        if (parent && isEmpty$1(editor.dom, parent)) {
            removeAndKeepBookmarks(parent);
        }
        DOM$8.remove(li);
        if (isEmpty$1(editor.dom, list)) {
            DOM$8.remove(list);
        }
    };

    const isDescriptionDetail = isTag('dd');
    const isDescriptionTerm = isTag('dt');
    const outdentDlItem = (editor, item) => {
        if (isDescriptionDetail(item)) {
            mutate(item, 'dt');
        }
        else if (isDescriptionTerm(item)) {
            parentElement(item).each((dl) => splitList(editor, dl.dom, item.dom));
        }
    };
    const indentDlItem = (item) => {
        if (isDescriptionTerm(item)) {
            mutate(item, 'dd');
        }
    };
    const dlIndentation = (editor, indentation, dlItems) => {
        if (indentation === "Indent" /* Indentation.Indent */) {
            each$e(dlItems, indentDlItem);
        }
        else {
            each$e(dlItems, (item) => outdentDlItem(editor, item));
        }
    };

    const selectionIndentation = (editor, indentation) => {
        const lists = fromDom$1(getSelectedListRoots(editor));
        const dlItems = fromDom$1(getSelectedDlItems(editor));
        let isHandled = false;
        if (lists.length || dlItems.length) {
            const bookmark = editor.selection.getBookmark();
            listIndentation(editor, lists, indentation);
            dlIndentation(editor, indentation, dlItems);
            editor.selection.moveToBookmark(bookmark);
            editor.selection.setRng(normalizeRange(editor.selection.getRng()));
            editor.nodeChanged();
            isHandled = true;
        }
        return isHandled;
    };
    const handleIndentation = (editor, indentation) => !selectionIsWithinNonEditableList(editor) && selectionIndentation(editor, indentation);
    const indentListSelection = (editor) => handleIndentation(editor, "Indent" /* Indentation.Indent */);
    const outdentListSelection = (editor) => handleIndentation(editor, "Outdent" /* Indentation.Outdent */);
    const flattenListSelection = (editor) => handleIndentation(editor, "Flatten" /* Indentation.Flatten */);

    const listToggleActionFromListName = (listName) => {
        switch (listName) {
            case 'UL': return "ToggleUlList" /* ListAction.ToggleUlList */;
            case 'OL': return "ToggleOlList" /* ListAction.ToggleOlList */;
            case 'DL': return "ToggleDLList" /* ListAction.ToggleDLList */;
        }
    };

    const updateListStyle = (dom, el, detail) => {
        const type = detail['list-style-type'] ? detail['list-style-type'] : null;
        dom.setStyle(el, 'list-style-type', type);
    };
    const setAttribs = (elm, attrs) => {
        Tools.each(attrs, (value, key) => {
            elm.setAttribute(key, value);
        });
    };
    const updateListAttrs = (dom, el, detail) => {
        setAttribs(el, detail['list-attributes']);
        Tools.each(dom.select('li', el), (li) => {
            setAttribs(li, detail['list-item-attributes']);
        });
    };
    const updateListWithDetails = (dom, el, detail) => {
        updateListStyle(dom, el, detail);
        updateListAttrs(dom, el, detail);
    };
    const removeStyles = (dom, element, styles) => {
        Tools.each(styles, (style) => dom.setStyle(element, style, ''));
    };
    const isInline$1 = (editor, node) => isNonNullable(node) && !isBlock(node, editor.schema.getBlockElements());
    const getEndPointNode = (editor, rng, start, root) => {
        let container = rng[start ? 'startContainer' : 'endContainer'];
        const offset = rng[start ? 'startOffset' : 'endOffset'];
        // Resolve node index
        if (isElement$1(container)) {
            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
        }
        if (!start && isBr$1(container.nextSibling)) {
            container = container.nextSibling;
        }
        const findBlockAncestor = (node) => {
            while (!editor.dom.isBlock(node) && node.parentNode && root !== node) {
                node = node.parentNode;
            }
            return node;
        };
        // The reason why the next two if statements exist is because when the root node is a table cell (possibly some other node types)
        // then the highest we can go up the dom hierarchy is one level below the table cell.
        // So what happens when we have a bunch of inline nodes and text nodes in the table cell
        // and when the selection is collapsed inside one of the inline nodes then only that inline node (or text node) will be included
        // in the created list because that would be one level below td node and the other inline nodes won't be included.
        // So the fix proposed is to traverse left when looking for start node (and traverse right when looking for end node)
        // and keep traversing as long as we have an inline or text node (same for traversing right).
        // This way we end up including all the inline elements in the created list.
        // For more info look at #TINY-6853
        const findBetterContainer = (container, forward) => {
            var _a;
            const walker = new DomTreeWalker(container, findBlockAncestor(container));
            const dir = forward ? 'next' : 'prev';
            let node;
            while ((node = walker[dir]())) {
                if (!(isVoid(editor, node) || isZwsp$2(node.textContent) || ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) === 0)) {
                    return Optional.some(node);
                }
            }
            return Optional.none();
        };
        // Traverse left to include inline/text nodes
        if (start && isTextNode$1(container)) {
            if (isZwsp$2(container.textContent)) {
                container = findBetterContainer(container, false).getOr(container);
            }
            else {
                if (container.parentNode !== null && isInline$1(editor, container.parentNode)) {
                    container = container.parentNode;
                }
                while (container.previousSibling !== null && (isInline$1(editor, container.previousSibling) || isTextNode$1(container.previousSibling))) {
                    container = container.previousSibling;
                }
            }
        }
        // Traverse right to include inline/text nodes
        if (!start && isTextNode$1(container)) {
            if (isZwsp$2(container.textContent)) {
                container = findBetterContainer(container, true).getOr(container);
            }
            else {
                if (container.parentNode !== null && isInline$1(editor, container.parentNode)) {
                    container = container.parentNode;
                }
                while (container.nextSibling !== null && (isInline$1(editor, container.nextSibling) || isTextNode$1(container.nextSibling))) {
                    container = container.nextSibling;
                }
            }
        }
        while (container.parentNode !== root) {
            const parent = container.parentNode;
            if (isTextBlock(editor, container)) {
                return container;
            }
            if (/^(TD|TH)$/.test(parent.nodeName)) {
                return container;
            }
            container = parent;
        }
        return container;
    };
    const getSelectedTextBlocks = (editor, rng, root) => {
        const textBlocks = [];
        const dom = editor.dom;
        const startNode = getEndPointNode(editor, rng, true, root);
        const endNode = getEndPointNode(editor, rng, false, root);
        let block;
        const siblings = [];
        for (let node = startNode; node; node = node.nextSibling) {
            siblings.push(node);
            if (node === endNode) {
                break;
            }
        }
        Tools.each(siblings, (node) => {
            var _a;
            if (isTextBlock(editor, node)) {
                textBlocks.push(node);
                block = null;
                return;
            }
            if (dom.isBlock(node) || isBr$1(node)) {
                if (isBr$1(node)) {
                    dom.remove(node);
                }
                block = null;
                return;
            }
            const nextSibling = node.nextSibling;
            if (BookmarkManager.isBookmarkNode(node)) {
                if (isListNode(nextSibling) || isTextBlock(editor, nextSibling) || (!nextSibling && node.parentNode === root)) {
                    block = null;
                    return;
                }
            }
            if (!block) {
                block = dom.create('p');
                (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(block, node);
                textBlocks.push(block);
            }
            block.appendChild(node);
        });
        return textBlocks;
    };
    const hasCompatibleStyle = (dom, sib, detail) => {
        const sibStyle = dom.getStyle(sib, 'list-style-type');
        let detailStyle = detail ? detail['list-style-type'] : '';
        detailStyle = detailStyle === null ? '' : detailStyle;
        return sibStyle === detailStyle;
    };
    /*
      Find the first element we would transform into a li-element if given no constraints.
      If the common ancestor is higher up than that provide it as the starting-point for the search for the root instead of the first selected element.
      This helps avoid issues with divs that should become li-elements are detected as the root when they should not be.
    */
    const getRootSearchStart = (editor, range) => {
        const start = editor.selection.getStart(true);
        const startPoint = getEndPointNode(editor, range, true, editor.getBody());
        if (ancestor$2(SugarElement.fromDom(startPoint), SugarElement.fromDom(range.commonAncestorContainer))) {
            return range.commonAncestorContainer;
        }
        else {
            return start;
        }
    };
    const applyList = (editor, listName, detail) => {
        const rng = editor.selection.getRng();
        let listItemName = 'LI';
        const root = getClosestListHost(editor, getRootSearchStart(editor, rng));
        const dom = editor.dom;
        if (dom.getContentEditable(editor.selection.getNode()) === 'false') {
            return;
        }
        listName = listName.toUpperCase();
        if (listName === 'DL') {
            listItemName = 'DT';
        }
        const bookmark = createBookmark(rng);
        const selectedTextBlocks = filter$5(getSelectedTextBlocks(editor, rng, root), editor.dom.isEditable);
        Tools.each(selectedTextBlocks, (block) => {
            let listBlock;
            const sibling = block.previousSibling;
            const parent = block.parentNode;
            if (!isListItemNode(parent)) {
                if (sibling && isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {
                    listBlock = sibling;
                    block = dom.rename(block, listItemName);
                    sibling.appendChild(block);
                }
                else {
                    listBlock = dom.create(listName);
                    parent.insertBefore(listBlock, block);
                    listBlock.appendChild(block);
                    block = dom.rename(block, listItemName);
                }
                removeStyles(dom, block, [
                    'margin', 'margin-right', 'margin-bottom', 'margin-left', 'margin-top',
                    'padding', 'padding-right', 'padding-bottom', 'padding-left', 'padding-top'
                ]);
                updateListWithDetails(dom, listBlock, detail);
                mergeWithAdjacentLists(editor.dom, listBlock);
            }
        });
        editor.selection.setRng(resolveBookmark$1(bookmark));
    };
    const isValidLists = (list1, list2) => {
        return isListNode(list1) && list1.nodeName === (list2 === null || list2 === void 0 ? void 0 : list2.nodeName);
    };
    const hasSameListStyle = (dom, list1, list2) => {
        const targetStyle = dom.getStyle(list1, 'list-style-type', true);
        const style = dom.getStyle(list2, 'list-style-type', true);
        return targetStyle === style;
    };
    const hasSameClasses = (elm1, elm2) => {
        return elm1.className === elm2.className;
    };
    const shouldMerge = (dom, list1, list2) => {
        return isValidLists(list1, list2) &&
            // Note: isValidLists will ensure list1 and list2 are a HTMLElement. Unfortunately TypeScript doesn't
            // support type guards on multiple variables. See https://github.com/microsoft/TypeScript/issues/26916
            hasSameListStyle(dom, list1, list2) &&
            hasSameClasses(list1, list2);
    };
    const mergeWithAdjacentLists = (dom, listBlock) => {
        let node;
        let sibling = listBlock.nextSibling;
        if (shouldMerge(dom, listBlock, sibling)) {
            const liSibling = sibling;
            while ((node = liSibling.firstChild)) {
                listBlock.appendChild(node);
            }
            dom.remove(liSibling);
        }
        sibling = listBlock.previousSibling;
        if (shouldMerge(dom, listBlock, sibling)) {
            const liSibling = sibling;
            while ((node = liSibling.lastChild)) {
                listBlock.insertBefore(node, listBlock.firstChild);
            }
            dom.remove(liSibling);
        }
    };
    const updateList$1 = (editor, list, listName, detail) => {
        if (list.nodeName !== listName) {
            const newList = editor.dom.rename(list, listName);
            updateListWithDetails(editor.dom, newList, detail);
            fireListEvent(editor, listToggleActionFromListName(listName), newList);
        }
        else {
            updateListWithDetails(editor.dom, list, detail);
            fireListEvent(editor, listToggleActionFromListName(listName), list);
        }
    };
    const updateCustomList = (editor, list, listName, detail) => {
        list.classList.forEach((cls, _, classList) => {
            if (cls.startsWith('tox-')) {
                classList.remove(cls);
                if (classList.length === 0) {
                    list.removeAttribute('class');
                }
            }
        });
        if (list.nodeName !== listName) {
            const newList = editor.dom.rename(list, listName);
            updateListWithDetails(editor.dom, newList, detail);
            fireListEvent(editor, listToggleActionFromListName(listName), newList);
        }
        else {
            updateListWithDetails(editor.dom, list, detail);
            fireListEvent(editor, listToggleActionFromListName(listName), list);
        }
    };
    const toggleMultipleLists = (editor, parentList, lists, listName, detail) => {
        const parentIsList = isListNode(parentList);
        if (parentIsList && parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {
            flattenListSelection(editor);
        }
        else {
            applyList(editor, listName, detail);
            const bookmark = createBookmark(editor.selection.getRng());
            const allLists = parentIsList ? [parentList, ...lists] : lists;
            const updateFunction = (parentIsList && isCustomList(parentList)) ? updateCustomList : updateList$1;
            Tools.each(allLists, (elm) => {
                updateFunction(editor, elm, listName, detail);
            });
            editor.selection.setRng(resolveBookmark$1(bookmark));
        }
    };
    const hasListStyleDetail = (detail) => {
        return 'list-style-type' in detail;
    };
    const toggleSingleList = (editor, parentList, listName, detail) => {
        if (parentList === editor.getBody()) {
            return;
        }
        if (parentList) {
            if (parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {
                flattenListSelection(editor);
            }
            else {
                const bookmark = createBookmark(editor.selection.getRng());
                if (isCustomList(parentList)) {
                    parentList.classList.forEach((cls, _, classList) => {
                        if (cls.startsWith('tox-')) {
                            classList.remove(cls);
                            if (classList.length === 0) {
                                parentList.removeAttribute('class');
                            }
                        }
                    });
                }
                updateListWithDetails(editor.dom, parentList, detail);
                const newList = editor.dom.rename(parentList, listName);
                mergeWithAdjacentLists(editor.dom, newList);
                editor.selection.setRng(resolveBookmark$1(bookmark));
                applyList(editor, listName, detail);
                fireListEvent(editor, listToggleActionFromListName(listName), newList);
            }
        }
        else {
            applyList(editor, listName, detail);
            fireListEvent(editor, listToggleActionFromListName(listName), parentList);
        }
    };
    const toggleList = (editor, listName, _detail) => {
        const parentList = getParentList(editor);
        if (isWithinNonEditableList$1(editor, parentList)) {
            return;
        }
        const selectedSubLists = getSelectedSubLists(editor);
        const detail = isObject(_detail) ? _detail : {};
        if (selectedSubLists.length > 0) {
            toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);
        }
        else {
            toggleSingleList(editor, parentList, listName, detail);
        }
    };

    const findNextCaretContainer = (editor, rng, isForward, root) => {
        let node = rng.startContainer;
        const offset = rng.startOffset;
        if (isTextNode$1(node) && (isForward ? offset < node.data.length : offset > 0)) {
            return node;
        }
        const nonEmptyBlocks = editor.schema.getNonEmptyElements();
        if (isElement$1(node)) {
            node = RangeUtils.getNode(node, offset);
        }
        const walker = new DomTreeWalker(node, root);
        // Delete at <li>|<br></li> then jump over the bogus br
        if (isForward) {
            if (isBogusBr(editor.dom, node)) {
                walker.next();
            }
        }
        const walkFn = isForward ? walker.next.bind(walker) : walker.prev2.bind(walker);
        while ((node = walkFn())) {
            if (node.nodeName === 'LI' && !node.hasChildNodes()) {
                return node;
            }
            if (nonEmptyBlocks[node.nodeName]) {
                return node;
            }
            if (isTextNode$1(node) && node.data.length > 0) {
                return node;
            }
        }
        return null;
    };
    const hasOnlyOneBlockChild = (dom, elm) => {
        const childNodes = elm.childNodes;
        return childNodes.length === 1 && !isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);
    };
    const isUnwrappable = (node) => Optional.from(node)
        .map(SugarElement.fromDom)
        .filter(isHTMLElement$1)
        .exists((el) => isEditable$2(el) && !contains$2(['details'], name(el)));
    const unwrapSingleBlockChild = (dom, elm) => {
        if (hasOnlyOneBlockChild(dom, elm) && isUnwrappable(elm.firstChild)) {
            dom.remove(elm.firstChild, true);
        }
    };
    const moveChildren = (dom, fromElm, toElm) => {
        let node;
        const targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;
        unwrapSingleBlockChild(dom, fromElm);
        if (!isEmpty$1(dom, fromElm, true)) {
            while ((node = fromElm.firstChild)) {
                targetElm.appendChild(node);
            }
        }
    };
    const mergeLiElements = (dom, fromElm, toElm) => {
        let listNode;
        const ul = fromElm.parentNode;
        if (!isChildOfBody(dom, fromElm) || !isChildOfBody(dom, toElm)) {
            return;
        }
        if (isListNode(toElm.lastChild)) {
            listNode = toElm.lastChild;
        }
        if (ul === toElm.lastChild) {
            if (isBr$1(ul.previousSibling)) {
                dom.remove(ul.previousSibling);
            }
        }
        const node = toElm.lastChild;
        if (node && isBr$1(node) && fromElm.hasChildNodes()) {
            dom.remove(node);
        }
        if (isEmpty$1(dom, toElm, true)) {
            empty(SugarElement.fromDom(toElm));
        }
        moveChildren(dom, fromElm, toElm);
        if (listNode) {
            toElm.appendChild(listNode);
        }
        const contains$1 = contains(SugarElement.fromDom(toElm), SugarElement.fromDom(fromElm));
        const nestedLists = contains$1 ? dom.getParents(fromElm, isListNode, toElm) : [];
        dom.remove(fromElm);
        each$e(nestedLists, (list) => {
            if (isEmpty$1(dom, list) && list !== dom.getRoot()) {
                dom.remove(list);
            }
        });
    };
    const mergeIntoEmptyLi = (editor, fromLi, toLi) => {
        empty(SugarElement.fromDom(toLi));
        mergeLiElements(editor.dom, fromLi, toLi);
        editor.selection.setCursorLocation(toLi, 0);
    };
    const mergeForward = (editor, rng, fromLi, toLi) => {
        const dom = editor.dom;
        if (dom.isEmpty(toLi)) {
            mergeIntoEmptyLi(editor, fromLi, toLi);
        }
        else {
            const bookmark = createBookmark(rng);
            mergeLiElements(dom, fromLi, toLi);
            editor.selection.setRng(resolveBookmark$1(bookmark));
        }
    };
    const mergeBackward = (editor, rng, fromLi, toLi) => {
        const bookmark = createBookmark(rng);
        mergeLiElements(editor.dom, fromLi, toLi);
        const resolvedBookmark = resolveBookmark$1(bookmark);
        editor.selection.setRng(resolvedBookmark);
    };
    const backspaceDeleteFromListToListCaret = (editor, isForward) => {
        const dom = editor.dom, selection = editor.selection;
        const selectionStartElm = selection.getStart();
        const root = getClosestEditingHost(editor, selectionStartElm);
        const li = dom.getParent(selection.getStart(), 'LI', root);
        if (li) {
            const ul = li.parentElement;
            if (ul === editor.getBody() && isEmpty$1(dom, ul)) {
                return true;
            }
            const rng = normalizeRange(selection.getRng());
            const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);
            const willMergeParentIntoChild = otherLi && (isForward ? dom.isChildOf(li, otherLi) : dom.isChildOf(otherLi, li));
            if (otherLi && otherLi !== li && !willMergeParentIntoChild) {
                editor.undoManager.transact(() => {
                    if (isForward) {
                        mergeForward(editor, rng, otherLi, li);
                    }
                    else {
                        if (isFirstChild$1(li)) {
                            outdentListSelection(editor);
                        }
                        else {
                            mergeBackward(editor, rng, li, otherLi);
                        }
                    }
                });
                return true;
            }
            else if (willMergeParentIntoChild && !isForward && otherLi !== li) {
                const commonAncestorParent = rng.commonAncestorContainer.parentElement;
                if (!commonAncestorParent || dom.isChildOf(otherLi, commonAncestorParent)) {
                    return false;
                }
                editor.undoManager.transact(() => {
                    const bookmark = createBookmark(rng);
                    moveChildren(dom, commonAncestorParent, otherLi);
                    commonAncestorParent.remove();
                    const resolvedBookmark = resolveBookmark$1(bookmark);
                    editor.selection.setRng(resolvedBookmark);
                });
                return true;
            }
            else if (!otherLi) {
                if (!isForward && rng.startOffset === 0 && rng.endOffset === 0) {
                    editor.undoManager.transact(() => {
                        flattenListSelection(editor);
                    });
                    return true;
                }
            }
        }
        return false;
    };
    const removeBlock = (dom, block, root) => {
        const parentBlock = dom.getParent(block.parentNode, dom.isBlock, root);
        dom.remove(block);
        if (parentBlock && dom.isEmpty(parentBlock)) {
            dom.remove(parentBlock);
        }
    };
    const backspaceDeleteIntoListCaret = (editor, isForward) => {
        const dom = editor.dom;
        const selectionStartElm = editor.selection.getStart();
        const root = getClosestEditingHost(editor, selectionStartElm);
        const block = dom.getParent(selectionStartElm, dom.isBlock, root);
        if (block && dom.isEmpty(block, undefined, { checkRootAsContent: true })) {
            const rng = normalizeRange(editor.selection.getRng());
            const nextCaretContainer = findNextCaretContainer(editor, rng, isForward, root);
            const otherLi = dom.getParent(nextCaretContainer, 'LI', root);
            if (nextCaretContainer && otherLi) {
                const findValidElement = (element) => contains$2(['td', 'th', 'caption'], name(element));
                const findRoot = (node) => node.dom === root;
                const otherLiCell = closest$4(SugarElement.fromDom(otherLi), findValidElement, findRoot);
                const caretCell = closest$4(SugarElement.fromDom(rng.startContainer), findValidElement, findRoot);
                if (!equals(otherLiCell, caretCell, eq)) {
                    return false;
                }
                editor.undoManager.transact(() => {
                    const parentNode = otherLi.parentNode;
                    removeBlock(dom, block, root);
                    mergeWithAdjacentLists(dom, parentNode);
                    editor.selection.select(nextCaretContainer, true);
                    editor.selection.collapse(isForward);
                });
                return true;
            }
        }
        return false;
    };
    const backspaceDeleteCaret$1 = (editor, isForward) => {
        return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);
    };
    const hasListSelection = (editor) => {
        const selectionStartElm = editor.selection.getStart();
        const root = getClosestEditingHost(editor, selectionStartElm);
        const startListParent = editor.dom.getParent(selectionStartElm, 'LI,DT,DD', root);
        return isNonNullable(startListParent) || getSelectedListItems(editor).length > 0;
    };
    const backspaceDeleteRange$1 = (editor) => {
        if (hasListSelection(editor)) {
            editor.undoManager.transact(() => {
                // Some delete actions may prevent the input event from being fired. If we do not detect it, we fire it ourselves.
                let shouldFireInput = true;
                const inputHandler = () => shouldFireInput = false;
                editor.on('input', inputHandler);
                editor.execCommand('Delete');
                editor.off('input', inputHandler);
                if (shouldFireInput) {
                    editor.dispatch('input');
                }
                normalizeLists(editor.dom, editor.getBody());
            });
            return true;
        }
        return false;
    };
    const backspaceDelete$c = (editor, isForward) => {
        const selection = editor.selection;
        return !isWithinNonEditableList$1(editor, selection.getNode()) && (selection.isCollapsed() ?
            backspaceDeleteCaret$1(editor, isForward) : backspaceDeleteRange$1(editor));
    };

    const blockPosition = (block, position) => ({
        block,
        position
    });
    const blockBoundary = (from, to) => ({
        from,
        to
    });
    const getBlockPosition = (rootNode, pos) => {
        const rootElm = SugarElement.fromDom(rootNode);
        const containerElm = SugarElement.fromDom(pos.container());
        return getParentBlock$2(rootElm, containerElm).map((block) => blockPosition(block, pos));
    };
    const isNotAncestorial = (blockBoundary) => !(contains(blockBoundary.to.block, blockBoundary.from.block) || contains(blockBoundary.from.block, blockBoundary.to.block));
    const isDifferentBlocks = (blockBoundary) => !eq(blockBoundary.from.block, blockBoundary.to.block);
    const getClosestHost = (root, scope) => {
        const isRoot = (node) => eq(node, root);
        const isHost = (node) => isTableCell$2(node) || isContentEditableTrue$3(node.dom);
        return closest$4(scope, isHost, isRoot).filter(isElement$8).getOr(root);
    };
    const hasSameHost = (rootNode, blockBoundary) => {
        const root = SugarElement.fromDom(rootNode);
        return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));
    };
    const isEditable$1 = (blockBoundary) => isContentEditableFalse$a(blockBoundary.from.block.dom) === false && isContentEditableFalse$a(blockBoundary.to.block.dom) === false;
    const hasValidBlocks = (blockBoundary) => {
        const isValidBlock = (block) => isTextBlock$3(block) || hasBlockAttr(block.dom) || isListItem$2(block);
        return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);
    };
    const skipLastBr = (schema, rootNode, forward, blockPosition) => {
        if (isBr$7(blockPosition.position.getNode()) && !isEmpty$4(schema, blockPosition.block)) {
            return positionIn(false, blockPosition.block.dom).bind((lastPositionInBlock) => {
                if (lastPositionInBlock.isEqual(blockPosition.position)) {
                    return fromPosition(forward, rootNode, lastPositionInBlock).bind((to) => getBlockPosition(rootNode, to));
                }
                else {
                    return Optional.some(blockPosition);
                }
            }).getOr(blockPosition);
        }
        else {
            return blockPosition;
        }
    };
    const readFromRange = (schema, rootNode, forward, rng) => {
        const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
        const toBlockPos = fromBlockPos.bind((blockPos) => fromPosition(forward, rootNode, blockPos.position).bind((to) => getBlockPosition(rootNode, to).map((blockPos) => skipLastBr(schema, rootNode, forward, blockPos))));
        return lift2(fromBlockPos, toBlockPos, blockBoundary).filter((blockBoundary) => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary) && isNotAncestorial(blockBoundary));
    };
    const read$1 = (schema, rootNode, forward, rng) => rng.collapsed ? readFromRange(schema, rootNode, forward, rng) : Optional.none();

    const getChildrenUntilBlockBoundary = (block, schema) => {
        const children = children$1(block);
        return findIndex$2(children, (el) => schema.isBlock(name(el))).fold(constant(children), (index) => children.slice(0, index));
    };
    const extractChildren = (block, schema) => {
        const children = getChildrenUntilBlockBoundary(block, schema);
        each$e(children, remove$8);
        return children;
    };
    const removeEmptyRoot = (schema, rootNode, block) => {
        const parents = parentsAndSelf(block, rootNode);
        return find$2(parents.reverse(), (element) => isEmpty$4(schema, element)).each(remove$8);
    };
    const isEmptyBefore = (schema, el) => filter$5(prevSiblings(el), (el) => !isEmpty$4(schema, el)).length === 0;
    const nestedBlockMerge = (rootNode, fromBlock, toBlock, schema, insertionPoint) => {
        if (isEmpty$4(schema, toBlock)) {
            fillWithPaddingBr(toBlock);
            return firstPositionIn(toBlock.dom);
        }
        if (isEmptyBefore(schema, insertionPoint) && isEmpty$4(schema, fromBlock)) {
            before$4(insertionPoint, SugarElement.fromTag('br'));
        }
        const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));
        each$e(extractChildren(fromBlock, schema), (child) => {
            before$4(insertionPoint, child);
        });
        removeEmptyRoot(schema, rootNode, fromBlock);
        return position;
    };
    const isInline = (schema, node) => schema.isInline(name(node));
    const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema) => {
        if (isEmpty$4(schema, toBlock)) {
            if (isEmpty$4(schema, fromBlock)) {
                const getInlineToBlockDescendants = (el) => {
                    const helper = (node, elements) => firstChild(node).fold(() => elements, (child) => isInline(schema, child) ? helper(child, elements.concat(shallow(child))) : elements);
                    return helper(el, []);
                };
                const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {
                    wrap$2(element, descendant);
                    return descendant;
                }, createPaddingBr());
                empty(fromBlock);
                append$1(fromBlock, newFromBlockDescendants);
            }
            remove$8(toBlock);
            return firstPositionIn(fromBlock.dom);
        }
        const position = lastPositionIn(toBlock.dom);
        each$e(extractChildren(fromBlock, schema), (child) => {
            append$1(toBlock, child);
        });
        removeEmptyRoot(schema, rootNode, fromBlock);
        return position;
    };
    const findInsertionPoint = (toBlock, block) => {
        const parentsAndSelf$1 = parentsAndSelf(block, toBlock);
        return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
    };
    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();
    const trimBr = (first, block) => {
        positionIn(first, block.dom)
            .bind((position) => Optional.from(position.getNode()))
            .map(SugarElement.fromDom)
            .filter(isBr$6)
            .each(remove$8);
    };
    const mergeBlockInto = (rootNode, fromBlock, toBlock, schema) => {
        trimBr(true, fromBlock);
        trimBr(false, toBlock);
        return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema), curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema));
    };
    const mergeBlocks = (rootNode, forward, block1, block2, schema) => forward ? mergeBlockInto(rootNode, block2, block1, schema) : mergeBlockInto(rootNode, block1, block2, schema);

    const backspaceDelete$b = (editor, forward) => {
        const rootNode = SugarElement.fromDom(editor.getBody());
        const position = read$1(editor.schema, rootNode.dom, forward, editor.selection.getRng())
            .map((blockBoundary) => () => {
            mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block, editor.schema)
                .each((pos) => {
                editor.selection.setRng(pos.toRange());
            });
        });
        return position;
    };

    const deleteRangeMergeBlocks = (rootNode, selection, schema) => {
        const rng = selection.getRng();
        return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {
            if (!eq(block1, block2)) {
                return Optional.some(() => {
                    rng.deleteContents();
                    mergeBlocks(rootNode, true, block1, block2, schema).each((pos) => {
                        selection.setRng(pos.toRange());
                    });
                });
            }
            else {
                return Optional.none();
            }
        }).getOr(Optional.none());
    };
    const isRawNodeInTable = (root, rawNode) => {
        const node = SugarElement.fromDom(rawNode);
        const isRoot = curry(eq, root);
        return ancestor$5(node, isTableCell$2, isRoot).isSome();
    };
    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
    const isEverythingSelected = (root, rng) => {
        const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();
        const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();
        return !isSelectionInTable(root, rng) && noPrevious && noNext;
    };
    const emptyEditor = (editor) => {
        return Optional.some(() => {
            editor.setContent('');
            editor.selection.setCursorLocation();
        });
    };
    const deleteRange$3 = (editor) => {
        const rootNode = SugarElement.fromDom(editor.getBody());
        const rng = editor.selection.getRng();
        return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);
    };
    const backspaceDelete$a = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$3(editor);

    const showCaret = (direction, editor, node, before, scrollIntoView) => 
    // TODO: Figure out a better way to handle this dependency
    Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));
    const getNodeRange = (node) => {
        const rng = node.ownerDocument.createRange();
        rng.selectNode(node);
        return rng;
    };
    const selectNode = (editor, node) => {
        const e = editor.dispatch('BeforeObjectSelected', { target: node });
        if (e.isDefaultPrevented()) {
            return Optional.none();
        }
        return Optional.some(getNodeRange(node));
    };
    const renderCaretAtRange = (editor, range, scrollIntoView) => {
        const normalizedRange = normalizeRange$2(1, editor.getBody(), range);
        const caretPosition = CaretPosition.fromRangeStart(normalizedRange);
        const caretPositionNode = caretPosition.getNode();
        if (isInlineFakeCaretTarget(caretPositionNode)) {
            return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
        }
        const caretPositionBeforeNode = caretPosition.getNode(true);
        if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {
            return showCaret(1, editor, caretPositionBeforeNode, false, false);
        }
        // TODO: Should render caret before/after depending on where you click on the page forces after now
        const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());
        if (isInlineFakeCaretTarget(ceRoot)) {
            return showCaret(1, editor, ceRoot, false, scrollIntoView);
        }
        return Optional.none();
    };
    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;

    const isBeforeBoundary = (pos) => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
    const isAfterBoundary = (pos) => isAfterContentEditableFalse(pos) || isAfterMedia(pos);
    const trimEmptyTextNode = (dom, node) => {
        if (isText$b(node) && node.data.length === 0) {
            dom.remove(node);
        }
    };
    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {
        showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each((caretRange) => {
            // Delete the selected content
            if (range.collapsed) {
                const deleteRange = range.cloneRange();
                if (forward) {
                    deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);
                }
                else {
                    deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);
                }
                deleteRange.deleteContents();
            }
            else {
                range.deleteContents();
            }
            editor.selection.setRng(caretRange);
        });
        trimEmptyTextNode(editor.dom, node);
    };
    // If the caret position is next to a fake caret target element (eg cef/media) after a delete operation, then ensure a caret is added
    // eg. <span cE=false>a|b -> <span cE=false>|bc
    // Note: We also need to handle the actual deletion, as some browsers (eg IE) move the selection to the opposite side of the cef element
    const deleteBoundaryText = (editor, forward) => {
        const range = editor.selection.getRng();
        if (!isText$b(range.commonAncestorContainer)) {
            return Optional.none();
        }
        const direction = forward ? 1 /* HDirection.Forwards */ : -1 /* HDirection.Backwards */;
        const caretWalker = CaretWalker(editor.getBody());
        const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);
        const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
        // Get the next caret position. ie where it'll be after the delete
        const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
        const nextCaretPosition = getNextPosFn(caretPosition);
        const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;
        if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {
            return Optional.none();
        }
        else if (isBeforeFn(normalizedNextCaretPosition)) {
            return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));
        }
        // Peek ahead and see if the next element is a cef/media element
        const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);
        if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
            if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {
                return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));
            }
        }
        return Optional.none();
    };
    const backspaceDelete$9 = (editor, forward) => deleteBoundaryText(editor, forward);

    const getEdgeCefPosition = (editor, atStart) => {
        const root = editor.getBody();
        return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) :
            lastPositionIn(root).filter(isAfterContentEditableFalse);
    };
    const isCefAtEdgeSelected = (editor) => {
        const rng = editor.selection.getRng();
        return !rng.collapsed
            && (getEdgeCefPosition(editor, true).exists((pos) => pos.isEqual(CaretPosition.fromRangeStart(rng)))
                || getEdgeCefPosition(editor, false).exists((pos) => pos.isEqual(CaretPosition.fromRangeEnd(rng))));
    };

    const isCompoundElement = (node) => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$2(SugarElement.fromDom(node)));
    const DeleteAction = Adt.generate([
        { remove: ['element'] },
        { moveToElement: ['element'] },
        { moveToPosition: ['position'] }
    ]);
    const isAtContentEditableBlockCaret = (forward, from) => {
        const elm = from.getNode(!forward);
        const caretLocation = forward ? 'after' : 'before';
        return isElement$7(elm) && elm.getAttribute('data-mce-caret') === caretLocation;
    };
    const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {
        const inSameBlock = (elm) => schema.isInline(elm.nodeName.toLowerCase()) && !isInSameBlock(from, to, root);
        return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);
    };
    const deleteEmptyBlockOrMoveToCef = (schema, root, forward, from, to) => {
        // TODO: TINY-8865 - This may not be safe to cast as Node below and alternative solutions need to be looked into
        const toCefElm = to.getNode(!forward);
        return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map((blockElm) => isEmpty$4(schema, blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));
    };
    const findCefPosition = (root, forward, from, schema) => fromPosition(forward, root, from).bind((to) => {
        if (isCompoundElement(to.getNode())) {
            return Optional.none();
        }
        else if (isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)) {
            return Optional.none();
        }
        else if (forward && isContentEditableFalse$a(to.getNode())) {
            return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);
        }
        else if (!forward && isContentEditableFalse$a(to.getNode(true))) {
            return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);
        }
        else if (forward && isAfterContentEditableFalse(from)) {
            return Optional.some(DeleteAction.moveToPosition(to));
        }
        else if (!forward && isBeforeContentEditableFalse(from)) {
            return Optional.some(DeleteAction.moveToPosition(to));
        }
        else {
            return Optional.none();
        }
    });
    const getContentEditableBlockAction = (forward, elm) => {
        if (isNullable(elm)) {
            return Optional.none();
        }
        else if (forward && isContentEditableFalse$a(elm.nextSibling)) {
            return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
        }
        else if (!forward && isContentEditableFalse$a(elm.previousSibling)) {
            return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
        }
        else {
            return Optional.none();
        }
    };
    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold((elm) => Optional.some(DeleteAction.remove(elm)), (elm) => Optional.some(DeleteAction.moveToElement(elm)), (to) => {
        if (isInSameBlock(from, to, root)) {
            return Optional.none();
        }
        else {
            return Optional.some(DeleteAction.moveToPosition(to));
        }
    });
    const getContentEditableAction = (root, forward, from, schema) => {
        if (isAtContentEditableBlockCaret(forward, from)) {
            return getContentEditableBlockAction(forward, from.getNode(!forward))
                .orThunk(() => findCefPosition(root, forward, from, schema));
        }
        else {
            return findCefPosition(root, forward, from, schema).bind((deleteAction) => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));
        }
    };
    const read = (root, forward, rng, schema) => {
        const normalizedRange = normalizeRange$2(forward ? 1 : -1, root, rng);
        const from = CaretPosition.fromRangeStart(normalizedRange);
        const rootElement = SugarElement.fromDom(root);
        // TODO: TINY-8865 - This may not be safe to cast as Node below and alternative solutions need to be looked into
        if (!forward && isAfterContentEditableFalse(from)) {
            return Optional.some(DeleteAction.remove(from.getNode(true)));
        }
        else if (forward && isBeforeContentEditableFalse(from)) {
            return Optional.some(DeleteAction.remove(from.getNode()));
        }
        else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from, schema)) {
            return findPreviousBr(rootElement, from, schema).map((br) => DeleteAction.remove(br.getNode()));
        }
        else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from, schema)) {
            return findNextBr(rootElement, from, schema).map((br) => DeleteAction.remove(br.getNode()));
        }
        else {
            return getContentEditableAction(root, forward, from, schema);
        }
    };

    const deleteElement$1 = (editor, forward) => (element) => {
        editor._selectionOverrides.hideFakeCaret();
        deleteElement$2(editor, forward, SugarElement.fromDom(element));
        return true;
    };
    const moveToElement = (editor, forward) => (element) => {
        const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
        editor.selection.setRng(pos.toRange());
        return true;
    };
    const moveToPosition = (editor) => (pos) => {
        editor.selection.setRng(pos.toRange());
        return true;
    };
    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));
    const backspaceDeleteCaret = (editor, forward) => {
        const selectedNode = editor.selection.getNode(); // is the parent node if cursor before/after cef
        // Cases:
        // 1. CEF selectedNode -> return true
        // 2. CET selectedNode -> try to delete, return true if possible else false
        // 3. CET ancestor -> try to delete, return true if possible else false
        // 4. no CET/CEF ancestor -> try to delete, return true if possible else false
        // 5. CEF ancestor -> return true
        return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$a).fold(() => read(editor.getBody(), forward, editor.selection.getRng(), editor.schema).map((deleteAction) => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));
    };
    const deleteOffscreenSelection = (rootElement) => {
        each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$8);
    };
    const backspaceDeleteRange = (editor, forward) => {
        const selectedNode = editor.selection.getNode(); // is the cef node if cef is selected
        // Cases:
        // 1. Table cell -> return false, as this is handled by `TableDelete` instead
        // 2. CEF selectedNode
        //    a. no ancestor CET/CEF || CET ancestor -> run delete code and return true
        //    b. CEF ancestor -> return true
        // 3. non-CEF selectedNode -> return false
        if (isContentEditableFalse$a(selectedNode) && !isTableCell$3(selectedNode)) {
            const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$a);
            return hasCefAncestor.fold(() => Optional.some(() => {
                deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
                deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));
                paddEmptyBody(editor);
            }), () => Optional.some(noop));
        }
        if (isCefAtEdgeSelected(editor)) {
            return Optional.some(() => {
                deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));
            });
        }
        return Optional.none();
    };
    const paddEmptyElement = (editor) => {
        const dom = editor.dom, selection = editor.selection;
        const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());
        if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {
            const br = dom.create('br', { 'data-mce-bogus': '1' });
            dom.setHTML(ceRoot, '');
            ceRoot.appendChild(br);
            selection.setRng(CaretPosition.before(br).toRange());
        }
        return true;
    };
    const backspaceDelete$8 = (editor, forward) => {
        if (editor.selection.isCollapsed()) {
            return backspaceDeleteCaret(editor, forward);
        }
        else {
            return backspaceDeleteRange(editor, forward);
        }
    };

    const isTextEndpoint = (endpoint) => endpoint.hasOwnProperty('text');
    const isElementEndpoint = (endpoint) => endpoint.hasOwnProperty('marker');
    const getBookmark = (range, createMarker) => {
        const getEndpoint = (container, offset) => {
            if (isText$b(container)) {
                return { text: container, offset };
            }
            else {
                const marker = createMarker();
                const children = container.childNodes;
                if (offset < children.length) {
                    container.insertBefore(marker, children[offset]);
                    return { marker, before: true };
                }
                else {
                    container.appendChild(marker);
                    return { marker, before: false };
                }
            }
        };
        const end = getEndpoint(range.endContainer, range.endOffset);
        const start = getEndpoint(range.startContainer, range.startOffset);
        return { start, end };
    };
    const resolveBookmark = (bm) => {
        var _a, _b;
        const { start, end } = bm;
        const rng = new window.Range();
        if (isTextEndpoint(start)) {
            rng.setStart(start.text, start.offset);
        }
        else {
            if (isElementEndpoint(start)) {
                if (start.before) {
                    rng.setStartBefore(start.marker);
                }
                else {
                    rng.setStartAfter(start.marker);
                }
                (_a = start.marker.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(start.marker);
            }
        }
        if (isTextEndpoint(end)) {
            rng.setEnd(end.text, end.offset);
        }
        else {
            if (isElementEndpoint(end)) {
                if (end.before) {
                    rng.setEndBefore(end.marker);
                }
                else {
                    rng.setEndAfter(end.marker);
                }
                (_b = end.marker.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(end.marker);
            }
        }
        return rng;
    };

    const backspaceDelete$7 = (editor, forward) => {
        var _a;
        const dom = editor.dom;
        const startBlock = dom.getParent(editor.selection.getStart(), dom.isBlock);
        const endBlock = dom.getParent(editor.selection.getEnd(), dom.isBlock);
        const body = editor.getBody();
        const startBlockName = (_a = startBlock === null || startBlock === void 0 ? void 0 : startBlock.nodeName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        // Only act on single root div that is not empty
        if (startBlockName === 'div' && startBlock && endBlock && startBlock === body.firstChild && endBlock === body.lastChild && !dom.isEmpty(body)) {
            const wrapper = startBlock.cloneNode(false);
            const deleteAction = () => {
                if (forward) {
                    execNativeForwardDeleteCommand(editor);
                }
                else {
                    execNativeDeleteCommand(editor);
                }
                // Div was deleted by delete operation then lets restore it
                if (body.firstChild !== startBlock) {
                    const bookmark = getBookmark(editor.selection.getRng(), () => document.createElement('span'));
                    Array.from(body.childNodes).forEach((node) => wrapper.appendChild(node));
                    body.appendChild(wrapper);
                    editor.selection.setRng(resolveBookmark(bookmark));
                }
            };
            return Optional.some(deleteAction);
        }
        return Optional.none();
    };

    const deleteCaret$2 = (editor, forward) => {
        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
        return fromPosition(forward, editor.getBody(), fromPos)
            .filter((pos) => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos))
            .bind((pos) => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos))
            .map((elm) => () => editor.selection.select(elm));
    };
    const backspaceDelete$6 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();

    const isText$2 = isText$b;
    const startsWithCaretContainer = (node) => isText$2(node) && node.data[0] === ZWSP$1;
    const endsWithCaretContainer = (node) => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;
    const createZwsp = (node) => {
        var _a;
        const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
        return doc.createTextNode(ZWSP$1);
    };
    const insertBefore$1 = (node) => {
        var _a;
        if (isText$2(node.previousSibling)) {
            if (endsWithCaretContainer(node.previousSibling)) {
                return node.previousSibling;
            }
            else {
                node.previousSibling.appendData(ZWSP$1);
                return node.previousSibling;
            }
        }
        else if (isText$2(node)) {
            if (startsWithCaretContainer(node)) {
                return node;
            }
            else {
                node.insertData(0, ZWSP$1);
                return node;
            }
        }
        else {
            const newNode = createZwsp(node);
            (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);
            return newNode;
        }
    };
    const insertAfter$1 = (node) => {
        var _a, _b;
        if (isText$2(node.nextSibling)) {
            if (startsWithCaretContainer(node.nextSibling)) {
                return node.nextSibling;
            }
            else {
                node.nextSibling.insertData(0, ZWSP$1);
                return node.nextSibling;
            }
        }
        else if (isText$2(node)) {
            if (endsWithCaretContainer(node)) {
                return node;
            }
            else {
                node.appendData(ZWSP$1);
                return node;
            }
        }
        else {
            const newNode = createZwsp(node);
            if (node.nextSibling) {
                (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);
            }
            else {
                (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);
            }
            return newNode;
        }
    };
    const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);
    const insertInlineBefore = curry(insertInline, true);
    const insertInlineAfter = curry(insertInline, false);

    const insertInlinePos = (pos, before) => {
        if (isText$b(pos.container())) {
            return insertInline(before, pos.container());
        }
        else {
            // TODO: TINY-8865 - This may not be safe to cast as Node and alternative solutions need to be looked into
            return insertInline(before, pos.getNode());
        }
    };
    const isPosCaretContainer = (pos, caret) => {
        const caretNode = caret.get();
        return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
    };
    const renderCaret = (caret, location) => location.fold((element) => {
        remove$2(caret.get());
        const text = insertInlineBefore(element);
        caret.set(text);
        return Optional.some(CaretPosition(text, text.length - 1));
    }, (element) => // Start
     firstPositionIn(element).map((pos) => {
        if (!isPosCaretContainer(pos, caret)) {
            remove$2(caret.get());
            const text = insertInlinePos(pos, true);
            caret.set(text);
            return CaretPosition(text, 1);
        }
        else {
            const node = caret.get();
            return CaretPosition(node, 1);
        }
    }), (element) => // End
     lastPositionIn(element).map((pos) => {
        if (!isPosCaretContainer(pos, caret)) {
            remove$2(caret.get());
            const text = insertInlinePos(pos, false);
            caret.set(text);
            return CaretPosition(text, text.length - 1);
        }
        else {
            const node = caret.get();
            return CaretPosition(node, node.length - 1);
        }
    }), (element) => {
        remove$2(caret.get());
        const text = insertInlineAfter(element);
        caret.set(text);
        return Optional.some(CaretPosition(text, 1));
    });

    const evaluateUntil = (fns, args) => {
        for (let i = 0; i < fns.length; i++) {
            const result = fns[i].apply(null, args);
            if (result.isSome()) {
                return result;
            }
        }
        return Optional.none();
    };

    const Location = Adt.generate([
        { before: ['element'] },
        { start: ['element'] },
        { end: ['element'] },
        { after: ['element'] }
    ]);
    const rescope$1 = (rootNode, node) => {
        const parentBlock = getParentBlock$3(node, rootNode);
        return parentBlock ? parentBlock : rootNode;
    };
    const before = (isInlineTarget, rootNode, pos) => {
        const nPos = normalizeForwards(pos);
        const scope = rescope$1(rootNode, nPos.container());
        return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos)
            .bind(curry(findRootInline, isInlineTarget, scope))
            .map((inline) => Location.before(inline)), Optional.none);
    };
    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;
    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
    const start$1 = (isInlineTarget, rootNode, pos) => {
        const nPos = normalizeBackwards(pos);
        return findInsideRootInline(isInlineTarget, rootNode, nPos).bind((inline) => {
            const prevPos = prevPosition(inline, nPos);
            return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();
        });
    };
    const end = (isInlineTarget, rootNode, pos) => {
        const nPos = normalizeForwards(pos);
        return findInsideRootInline(isInlineTarget, rootNode, nPos).bind((inline) => {
            const nextPos = nextPosition(inline, nPos);
            return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();
        });
    };
    const after = (isInlineTarget, rootNode, pos) => {
        const nPos = normalizeBackwards(pos);
        const scope = rescope$1(rootNode, nPos.container());
        return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos)
            .bind(curry(findRootInline, isInlineTarget, scope))
            .map((inline) => Location.after(inline)), Optional.none);
    };
    const isValidLocation = (location) => !isRtl(getElement(location));
    const readLocation = (isInlineTarget, rootNode, pos) => {
        const location = evaluateUntil([
            before,
            start$1,
            end,
            after
        ], [isInlineTarget, rootNode, pos]);
        return location.filter(isValidLocation);
    };
    const getElement = (location) => location.fold(identity, // Before
    identity, // Start
    identity, // End
    identity // After
    );
    const getName = (location) => location.fold(constant('before'), // Before
    constant('start'), // Start
    constant('end'), // End
    constant('after') // After
    );
    const outside = (location) => location.fold(Location.before, // Before
    Location.before, // Start
    Location.after, // End
    Location.after // After
    );
    const inside = (location) => location.fold(Location.start, // Before
    Location.start, // Start
    Location.end, // End
    Location.end // After
    );
    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {
        if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {
            // Force after since some browsers normalize and lean left into the closest inline
            return Location.after(forward ? fromInline : toInline);
        }
        else {
            return location;
        }
    }).getOr(location);
    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, (fromLocation) => !isEq(fromLocation, toLocation));
    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {
        const from = normalizePosition(forward, pos);
        const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));
        const location = to.fold(() => fromLocation.map(outside), (to) => readLocation(isInlineTarget, rootNode, to)
            .map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to))
            .filter(curry(skipNoMovement, fromLocation)));
        return location.filter(isValidLocation);
    };
    const findLocationSimple = (forward, location) => {
        if (forward) {
            return location.fold(compose(Optional.some, Location.start), // Before -> Start
            Optional.none, compose(Optional.some, Location.after), // End -> After
            Optional.none);
        }
        else {
            return location.fold(Optional.none, compose(Optional.some, Location.before), // Before <- Start
            Optional.none, compose(Optional.some, Location.end) // End <- After
            );
        }
    };
    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {
        const from = normalizePosition(forward, pos);
        const fromLocation = readLocation(isInlineTarget, rootNode, from);
        return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward))
            .orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));
    };

    const hasSelectionModifyApi = (editor) => {
        return isFunction(editor.selection.getSel().modify);
    };
    const moveRel = (forward, selection, pos) => {
        const delta = forward ? 1 : -1;
        selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());
        selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');
        return true;
    };
    const moveByWord = (forward, editor) => {
        const rng = editor.selection.getRng();
        const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
        if (!hasSelectionModifyApi(editor)) {
            return false;
        }
        else if (forward && isBeforeInline(pos)) {
            return moveRel(true, editor.selection, pos);
        }
        else if (!forward && isAfterInline(pos)) {
            return moveRel(false, editor.selection, pos);
        }
        else {
            return false;
        }
    };

    var BreakType;
    (function (BreakType) {
        BreakType[BreakType["Br"] = 0] = "Br";
        BreakType[BreakType["Block"] = 1] = "Block";
        BreakType[BreakType["Wrap"] = 2] = "Wrap";
        BreakType[BreakType["Eol"] = 3] = "Eol";
    })(BreakType || (BreakType = {}));
    const flip = (direction, positions) => direction === -1 /* HDirection.Backwards */ ? reverse(positions) : positions;
    const walk$1 = (direction, caretWalker, pos) => direction === 1 /* HDirection.Forwards */ ? caretWalker.next(pos) : caretWalker.prev(pos);
    const getBreakType = (scope, direction, currentPos, nextPos) => {
        if (isBr$7(nextPos.getNode(direction === 1 /* HDirection.Forwards */))) {
            return BreakType.Br;
        }
        else if (isInSameBlock(currentPos, nextPos) === false) {
            return BreakType.Block;
        }
        else {
            return BreakType.Wrap;
        }
    };
    const getPositionsUntil = (predicate, direction, scope, start) => {
        const caretWalker = CaretWalker(scope);
        let currentPos = start;
        const positions = [];
        while (currentPos) {
            const nextPos = walk$1(direction, caretWalker, currentPos);
            if (!nextPos) {
                break;
            }
            if (isBr$7(nextPos.getNode(false))) {
                if (direction === 1 /* HDirection.Forwards */) {
                    return { positions: flip(direction, positions).concat([nextPos]), breakType: BreakType.Br, breakAt: Optional.some(nextPos) };
                }
                else {
                    return { positions: flip(direction, positions), breakType: BreakType.Br, breakAt: Optional.some(nextPos) };
                }
            }
            if (!nextPos.isVisible()) {
                currentPos = nextPos;
                continue;
            }
            if (predicate(currentPos, nextPos)) {
                const breakType = getBreakType(scope, direction, currentPos, nextPos);
                return { positions: flip(direction, positions), breakType, breakAt: Optional.some(nextPos) };
            }
            positions.push(nextPos);
            currentPos = nextPos;
        }
        return { positions: flip(direction, positions), breakType: BreakType.Eol, breakAt: Optional.none() };
    };
    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map((pos) => {
        const positions = getPositionsUntilBreak(scope, pos).positions;
        return direction === -1 /* HDirection.Backwards */ ? positions.concat(pos) : [pos].concat(positions);
    }).getOr([]);
    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), (lastPos) => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {
        const lastDist = Math.abs(x - lastRect.left);
        const newDist = Math.abs(x - newRect.left);
        return newDist <= lastDist ? newPos : lastPos;
    }).or(acc)), Optional.none());
    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind((targetRect) => findClosestHorizontalPositionFromPoint(positions, targetRect.left));
    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();
    const getFirstLinePositions = (scope) => firstPositionIn(scope).map((pos) => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);
    const getLastLinePositions = (scope) => lastPositionIn(scope).map((pos) => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);
    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);
    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);

    const isContentEditableFalse$4 = isContentEditableFalse$a;
    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
    const isNodeClientRect = (rect) => hasNonNullableKey(rect, 'node');
    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {
        const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));
        const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));
        // cE=false has higher priority
        if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {
            return clientRect;
        }
        if (newDistance < oldDistance) {
            return clientRect;
        }
        return oldClientRect;
    });

    const getNodeClientRects = (node) => {
        const toArrayWithNode = (clientRects) => {
            return map$3(clientRects, (rect) => {
                const clientRect = clone$1(rect);
                clientRect.node = node;
                return clientRect;
            });
        };
        if (isElement$7(node)) {
            return toArrayWithNode(node.getClientRects());
        }
        else if (isText$b(node)) {
            const rng = node.ownerDocument.createRange();
            rng.setStart(node, 0);
            rng.setEnd(node, node.data.length);
            return toArrayWithNode(rng.getClientRects());
        }
        else {
            return [];
        }
    };
    const getClientRects = (nodes) => bind$3(nodes, getNodeClientRects);

    var VDirection;
    (function (VDirection) {
        VDirection[VDirection["Up"] = -1] = "Up";
        VDirection[VDirection["Down"] = 1] = "Down";
    })(VDirection || (VDirection = {}));
    const findUntil = (direction, root, predicateFn, node) => {
        let currentNode = node;
        while ((currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root))) {
            if (predicateFn(currentNode)) {
                return;
            }
        }
    };
    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {
        let line = 0;
        const result = [];
        const add = (node) => {
            let clientRects = getClientRects([node]);
            if (direction === VDirection.Up) {
                clientRects = clientRects.reverse();
            }
            for (let i = 0; i < clientRects.length; i++) {
                const clientRect = clientRects[i];
                if (isBeflowFn(clientRect, targetClientRect)) {
                    continue;
                }
                if (result.length > 0 && isAboveFn(clientRect, last(result))) {
                    line++;
                }
                clientRect.line = line;
                if (predicateFn(clientRect)) {
                    return true;
                }
                result.push(clientRect);
            }
            return false;
        };
        const targetClientRect = last(caretPosition.getClientRects());
        if (!targetClientRect) {
            return result;
        }
        const node = caretPosition.getNode();
        if (node) {
            add(node);
            findUntil(direction, root, add, node);
        }
        return result;
    };
    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;
    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;
    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);
    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);
    const getLastClientRect = (caretPosition) => {
        // ASSUMPTION: There should always be at least one client rect here
        return last(caretPosition.getClientRects());
    };
    const positionsUntil = (direction, root, predicateFn, node) => {
        const caretWalker = CaretWalker(root);
        let walkFn;
        let isBelowFn;
        let isAboveFn;
        let caretPosition;
        const result = [];
        let line = 0;
        if (direction === VDirection.Down) {
            walkFn = caretWalker.next;
            isBelowFn = isBelow$1;
            isAboveFn = isAbove$1;
            caretPosition = CaretPosition.after(node);
        }
        else {
            walkFn = caretWalker.prev;
            isBelowFn = isAbove$1;
            isAboveFn = isBelow$1;
            caretPosition = CaretPosition.before(node);
        }
        const targetClientRect = getLastClientRect(caretPosition);
        do {
            if (!caretPosition.isVisible()) {
                continue;
            }
            const rect = getLastClientRect(caretPosition);
            if (isAboveFn(rect, targetClientRect)) {
                continue;
            }
            if (result.length > 0 && isBelowFn(rect, last(result))) {
                line++;
            }
            const clientRect = clone$1(rect);
            clientRect.position = caretPosition;
            clientRect.line = line;
            if (predicateFn(clientRect)) {
                return result;
            }
            result.push(clientRect);
        } while ((caretPosition = walkFn(caretPosition)));
        return result;
    };
    const isAboveLine = (lineNumber) => (clientRect) => aboveLineNumber(lineNumber, clientRect);
    const isLine = (lineNumber) => (clientRect) => isLineNumber(lineNumber, clientRect);

    const moveToRange = (editor, rng) => {
        editor.selection.setRng(rng);
        // Don't reuse the original range as TinyMCE will adjust it
        scrollRangeIntoView(editor, editor.selection.getRng());
    };
    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));
    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {
        const forwards = direction === 1 /* HDirection.Forwards */;
        const caretWalker = CaretWalker(editor.getBody());
        const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);
        const isBeforeFn = forwards ? isBefore : isAfter;
        if (!range.collapsed) {
            const node = getSelectedNode(range);
            if (isElement(node)) {
                return showCaret(direction, editor, node, direction === -1 /* HDirection.Backwards */, false);
            }
            else if (isCefAtEdgeSelected(editor)) {
                const newRange = range.cloneRange();
                newRange.collapse(direction === -1 /* HDirection.Backwards */);
                return Optional.from(newRange);
            }
        }
        const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
        if (isBeforeFn(caretPosition)) {
            return selectNode(editor, caretPosition.getNode(!forwards));
        }
        let nextCaretPosition = getNextPosFn(caretPosition);
        const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
        if (!nextCaretPosition) {
            return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();
        }
        else {
            nextCaretPosition = normalizePosition(forwards, nextCaretPosition);
        }
        if (isBeforeFn(nextCaretPosition)) {
            return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);
        }
        // Peek ahead for handling of ab|c<span cE=false> -> abc|<span cE=false>
        const peekCaretPosition = getNextPosFn(nextCaretPosition);
        if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
            if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
                return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);
            }
        }
        if (rangeIsInContainerBlock) {
            return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
        }
        return Optional.none();
    };
    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {
        const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
        const caretClientRect = last(caretPosition.getClientRects());
        const forwards = direction === VDirection.Down;
        const root = editor.getBody();
        if (!caretClientRect) {
            return Optional.none();
        }
        if (isCefAtEdgeSelected(editor)) {
            const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);
            const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;
            return getClosestFn(root, caretPosition)
                .orThunk(() => Optional.from(caretPosition))
                .map((pos) => pos.toRange());
        }
        const walkerFn = forwards ? downUntil : upUntil;
        const linePositions = walkerFn(root, isAboveLine(1), caretPosition);
        const nextLinePositions = filter$5(linePositions, isLine(1));
        const clientX = caretClientRect.left;
        const nextLineRect = findClosestClientRect(nextLinePositions, clientX);
        if (nextLineRect && isElement(nextLineRect.node)) {
            const dist1 = Math.abs(clientX - nextLineRect.left);
            const dist2 = Math.abs(clientX - nextLineRect.right);
            return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);
        }
        let currentNode;
        if (isBefore(caretPosition)) {
            currentNode = caretPosition.getNode();
        }
        else if (isAfter(caretPosition)) {
            currentNode = caretPosition.getNode(true);
        }
        else {
            currentNode = getSelectedNode(range);
        }
        if (currentNode) {
            const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);
            let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);
            if (closestNextLineRect) {
                return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
            }
            closestNextLineRect = last(filter$5(caretPositions, isLine(0)));
            if (closestNextLineRect) {
                return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
            }
        }
        if (nextLinePositions.length === 0) {
            return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore)
                .map((pos) => renderRangeCaret(editor, pos.toRange(), false));
        }
        return Optional.none();
    };
    const getLineEndPoint = (editor, forward) => {
        const rng = editor.selection.getRng();
        const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
        const host = getEditingHost(from.container(), editor.getBody());
        if (forward) {
            const lineInfo = getPositionsUntilNextLine(host, from);
            return last$2(lineInfo.positions);
        }
        else {
            const lineInfo = getPositionsUntilPreviousLine(host, from);
            return head(lineInfo.positions);
        }
    };
    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists((pos) => {
        editor.selection.setRng(pos.toRange());
        return true;
    });

    const setCaretPosition = (editor, pos) => {
        const rng = editor.dom.createRng();
        rng.setStart(pos.container(), pos.offset());
        rng.setEnd(pos.container(), pos.offset());
        editor.selection.setRng(rng);
    };
    const setSelected = (state, elm) => {
        if (state) {
            elm.setAttribute('data-mce-selected', 'inline-boundary');
        }
        else {
            elm.removeAttribute('data-mce-selected');
        }
    };
    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map((pos) => {
        setCaretPosition(editor, pos);
        return location;
    });
    const getPositionFromRange = (range, root, forward) => {
        const start = CaretPosition.fromRangeStart(range);
        if (range.collapsed) {
            return start;
        }
        else {
            const end = CaretPosition.fromRangeEnd(range);
            return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);
        }
    };
    const findLocation = (editor, caret, forward) => {
        const rootNode = editor.getBody();
        const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);
        return location.bind((location) => renderCaretLocation(editor, caret, location));
    };
    const toggleInlines = (isInlineTarget, dom, elms) => {
        const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected="inline-boundary"]'), (e) => e.dom);
        const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);
        const targetInlines = filter$5(elms, isInlineTarget);
        each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));
        each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));
    };
    const safeRemoveCaretContainer = (editor, caret) => {
        const caretValue = caret.get();
        if (editor.selection.isCollapsed() && !editor.composing && caretValue) {
            const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
            if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {
                setCaretPosition(editor, removeAndReposition(caretValue, pos));
                caret.set(null);
            }
        }
    };
    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {
        if (editor.selection.isCollapsed()) {
            const inlines = filter$5(elms, isInlineTarget);
            each$e(inlines, (_inline) => {
                const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
                readLocation(isInlineTarget, editor.getBody(), pos).bind((location) => renderCaretLocation(editor, caret, location));
            });
        }
    };
    const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;
    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
    const setupSelectedState = (editor) => {
        const caret = Cell(null);
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        editor.on('NodeChange', (e) => {
            if (isInlineBoundariesEnabled(editor)) {
                toggleInlines(isInlineTarget$1, editor.dom, e.parents);
                safeRemoveCaretContainer(editor, caret);
                renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);
            }
        });
        return caret;
    };
    const moveNextWord = curry(moveWord, true);
    const movePrevWord = curry(moveWord, false);
    const moveToLineEndPoint$2 = (editor, forward, caret) => {
        if (isInlineBoundariesEnabled(editor)) {
            // Try to find the line endpoint, however if one isn't found then assume we're already at the end point
            const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {
                const rng = editor.selection.getRng();
                return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
            });
            return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists((loc) => {
                const outsideLoc = outside(loc);
                return renderCaret(caret, outsideLoc).exists((pos) => {
                    setCaretPosition(editor, pos);
                    return true;
                });
            });
        }
        else {
            return false;
        }
    };

    const rangeFromPositions = (from, to) => {
        const range = document.createRange();
        range.setStart(from.container(), from.offset());
        range.setEnd(to.container(), to.offset());
        return range;
    };
    // Checks for delete at <code>|a</code> when there is only one item left except the zwsp caret container nodes
    const hasOnlyTwoOrLessPositionsLeft = (elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
        const normalizedFirstPos = normalizePosition(true, firstPos);
        const normalizedLastPos = normalizePosition(false, lastPos);
        return nextPosition(elm, normalizedFirstPos).forall((pos) => pos.isEqual(normalizedLastPos));
    }).getOr(true);
    const setCaretLocation = (editor, caret) => (location) => renderCaret(caret, location).map((pos) => () => setCaretPosition(editor, pos));
    const deleteFromTo = (editor, caret, from, to) => {
        const rootNode = editor.getBody();
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        editor.undoManager.ignore(() => {
            editor.selection.setRng(rangeFromPositions(from, to));
            // TODO: TINY-9120 - Investigate if this should be using our custom overrides
            execNativeDeleteCommand(editor);
            readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng()))
                .map(inside)
                .bind(setCaretLocation(editor, caret))
                .each(call);
        });
        editor.nodeChanged();
    };
    const rescope = (rootNode, node) => {
        const parentBlock = getParentBlock$3(node, rootNode);
        return parentBlock ? parentBlock : rootNode;
    };
    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {
        const rootNode = rescope(editor.getBody(), from.container());
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        const fromLocation = readLocation(isInlineTarget$1, rootNode, from);
        const location = fromLocation.bind((location) => {
            if (forward) {
                return location.fold(constant(Optional.some(inside(location))), // Before
                Optional.none, // Start
                constant(Optional.some(outside(location))), // End
                Optional.none // After
                );
            }
            else {
                return location.fold(Optional.none, // Before
                constant(Optional.some(outside(location))), // Start
                Optional.none, // End
                constant(Optional.some(inside(location))) // After
                );
            }
        });
        return location.map(setCaretLocation(editor, caret))
            .getOrThunk(() => {
            const toPosition = navigate(forward, rootNode, from);
            const toLocation = toPosition.bind((pos) => readLocation(isInlineTarget$1, rootNode, pos));
            return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind((elm) => {
                if (hasOnlyTwoOrLessPositionsLeft(elm)) {
                    return Optional.some(() => {
                        deleteElement$2(editor, forward, SugarElement.fromDom(elm));
                    });
                }
                else {
                    return Optional.none();
                }
            })).getOrThunk(() => toLocation.bind(() => toPosition.map((to) => {
                return () => {
                    if (forward) {
                        deleteFromTo(editor, caret, from, to);
                    }
                    else {
                        deleteFromTo(editor, caret, to, from);
                    }
                };
            })));
        });
    };
    const backspaceDelete$5 = (editor, caret, forward) => {
        if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {
            const from = CaretPosition.fromRangeStart(editor.selection.getRng());
            return backspaceDeleteCollapsed(editor, caret, forward, from);
        }
        return Optional.none();
    };

    const hasMultipleChildren = (elm) => childNodesCount(elm) > 1;
    const getParentsUntil = (editor, pred) => {
        const rootElm = SugarElement.fromDom(editor.getBody());
        const startElm = SugarElement.fromDom(editor.selection.getStart());
        const parents = parentsAndSelf(startElm, rootElm);
        return findIndex$2(parents, pred).fold(constant(parents), (index) => parents.slice(0, index));
    };
    const hasOnlyOneChild = (elm) => childNodesCount(elm) === 1;
    const getParentInlinesUntilMultichildInline = (editor) => getParentsUntil(editor, (elm) => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm));
    const getParentInlines = (editor) => getParentsUntil(editor, (el) => editor.schema.isBlock(name(el)));
    const getFormatNodes = (editor, parentInlines) => {
        const isFormatElement$1 = curry(isFormatElement, editor);
        return bind$3(parentInlines, (elm) => isFormatElement$1(elm) ? [elm.dom] : []);
    };
    const getFormatNodesAtStart = (editor) => {
        const parentInlines = getParentInlines(editor);
        return getFormatNodes(editor, parentInlines);
    };
    const deleteLastPosition = (forward, editor, target, parentInlines) => {
        const formatNodes = getFormatNodes(editor, parentInlines);
        if (formatNodes.length === 0) {
            deleteElement$2(editor, forward, target);
        }
        else {
            const pos = replaceWithCaretFormat(target.dom, formatNodes);
            editor.selection.setRng(pos.toRange());
        }
    };
    const deleteCaret$1 = (editor, forward) => {
        const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);
        return last$2(parentInlines).bind((target) => {
            const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
            if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {
                return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));
            }
            else {
                return Optional.none();
            }
        });
    };
    const isBrInEmptyElement = (editor, elm) => {
        const parentElm = elm.parentElement;
        return isBr$7(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);
    };
    const isEmptyCaret = (elm) => isEmptyCaretFormatElement(SugarElement.fromDom(elm));
    const createCaretFormatAtStart = (editor, formatNodes) => {
        const startElm = editor.selection.getStart();
        // replace <br> in empty node or existing caret at start if applicable
        // otherwise create new caret format at start
        const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm)
            ? replaceWithCaretFormat(startElm, formatNodes)
            : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);
        editor.selection.setRng(pos.toRange());
    };
    const updateCaretFormat = (editor, updateFormats) => {
        // Create a caret format at cursor containing missing formats to ensure all formats
        // that are supposed to be retained are retained
        const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));
        if (missingFormats.length > 0) {
            createCaretFormatAtStart(editor, missingFormats);
        }
    };
    const rangeStartsAtTextContainer = (rng) => isText$b(rng.startContainer);
    const rangeStartsAtStartOfTextContainer = (rng) => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);
    const rangeStartParentIsFormatElement = (editor, rng) => {
        const startParent = rng.startContainer.parentElement;
        return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));
    };
    const rangeStartAndEndHaveSameParent = (rng) => {
        const startParent = rng.startContainer.parentNode;
        const endParent = rng.endContainer.parentNode;
        return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);
    };
    const rangeEndsAtEndOfEndContainer = (rng) => {
        const endContainer = rng.endContainer;
        return rng.endOffset === (isText$b(endContainer) ? endContainer.length : endContainer.childNodes.length);
    };
    const rangeEndsAtEndOfStartContainer = (rng) => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);
    const rangeEndsAfterEndOfStartContainer = (rng) => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);
    const rangeEndsAtOrAfterEndOfStartContainer = (rng) => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);
    const requiresDeleteRangeOverride = (editor) => {
        const rng = editor.selection.getRng();
        return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);
    };
    const deleteRange$2 = (editor) => {
        if (requiresDeleteRangeOverride(editor)) {
            const formatNodes = getFormatNodesAtStart(editor);
            return Optional.some(() => {
                execNativeDeleteCommand(editor);
                updateCaretFormat(editor, formatNodes);
            });
        }
        else {
            return Optional.none();
        }
    };
    const backspaceDelete$4 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$2(editor);
    const hasAncestorInlineCaret = (elm, schema) => ancestor$3(elm, (node) => isCaretNode(node.dom), (el) => schema.isBlock(name(el)));
    const hasAncestorInlineCaretAtStart = (editor) => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()), editor.schema);
    const requiresRefreshCaretOverride = (editor) => {
        const rng = editor.selection.getRng();
        return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);
    };
    const refreshCaret = (editor) => {
        if (requiresRefreshCaretOverride(editor)) {
            createCaretFormatAtStart(editor, []);
        }
        return true;
    };

    const deleteElement = (editor, forward, element) => {
        if (isNonNullable(element)) {
            return Optional.some(() => {
                editor._selectionOverrides.hideFakeCaret();
                deleteElement$2(editor, forward, SugarElement.fromDom(element));
            });
        }
        else {
            return Optional.none();
        }
    };
    const deleteCaret = (editor, forward) => {
        const isNearMedia = forward ? isBeforeMedia : isAfterMedia;
        const direction = forward ? 1 /* HDirection.Forwards */ : -1 /* HDirection.Backwards */;
        const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());
        if (isNearMedia(fromPos)) {
            return deleteElement(editor, forward, fromPos.getNode(!forward));
        }
        else {
            return Optional.from(normalizePosition(forward, fromPos))
                .filter((pos) => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos))
                .bind((pos) => deleteElement(editor, forward, pos.getNode(!forward)));
        }
    };
    const deleteRange$1 = (editor, forward) => {
        const selectedNode = editor.selection.getNode();
        return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();
    };
    const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange$1(editor, forward);

    const isEditable = (target) => closest$4(target, (elm) => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$a(elm.dom))
        .exists((elm) => isContentEditableTrue$3(elm.dom));
    const parseIndentValue = (value) => toInt(value !== null && value !== void 0 ? value : '').getOr(0);
    const getIndentStyleName = (useMargin, element) => {
        const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';
        const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';
        return indentStyleName + suffix;
    };
    const indentElement = (dom, command, useMargin, value, unit, element) => {
        const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));
        const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));
        if (command === 'outdent') {
            const styleValue = Math.max(0, parsedValue - value);
            dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');
        }
        else {
            const styleValue = (parsedValue + value) + unit;
            dom.setStyle(element, indentStyleName, styleValue);
        }
    };
    const validateBlocks = (editor, blocks) => forall(blocks, (block) => {
        const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);
        const intentValue = getRaw$1(block, indentStyleName).map(parseIndentValue).getOr(0);
        const contentEditable = editor.dom.getContentEditable(block.dom);
        return contentEditable !== 'false' && intentValue > 0;
    });
    const canOutdent = (editor) => {
        const blocks = getBlocksToIndent(editor);
        return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));
    };
    const canIndent = (editor) => !editor.mode.isReadOnly() && canIndent$1(editor);
    const isListComponent = (el) => isList$1(el) || isListItem$2(el);
    const parentIsListComponent = (el) => parent(el).exists(isListComponent);
    const getBlocksToIndent = (editor) => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), (el) => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));
    const handle = (editor, command) => {
        var _a, _b;
        if (editor.mode.isReadOnly()) {
            return;
        }
        const { dom } = editor;
        const indentation = getIndentation(editor);
        const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';
        const indentValue = parseIndentValue(indentation);
        const useMargin = shouldIndentUseMargin(editor);
        each$e(getBlocksToIndent(editor), (block) => {
            indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);
        });
        if (command === 'indent') {
            indentListSelection(editor);
        }
        else {
            outdentListSelection(editor);
        }
    };
    const indent = (editor) => handle(editor, 'indent');
    const outdent = (editor) => handle(editor, 'outdent');

    const backspaceDelete$2 = (editor) => {
        if (editor.selection.isCollapsed() && canOutdent(editor)) {
            const dom = editor.dom;
            const rng = editor.selection.getRng();
            const pos = CaretPosition.fromRangeStart(rng);
            const block = dom.getParent(rng.startContainer, dom.isBlock);
            if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)) {
                return Optional.some(() => outdent(editor));
            }
        }
        return Optional.none();
    };

    const deleteRange = (editor, forward) => {
        const rng = normalize(editor.selection.getRng());
        return isSelectionOverWholeHTMLElement(rng)
            ? Optional.some(() => deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode())))
            : Optional.none();
    };
    const backspaceDelete$1 = (editor, forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange(editor, forward);

    const findAction = (editor, caret, forward) => findMap([
        backspaceDelete$2,
        backspaceDelete$8,
        backspaceDelete$9,
        (editor, forward) => backspaceDelete$5(editor, caret, forward),
        backspaceDelete$b,
        backspaceDelete$d,
        backspaceDelete$6,
        backspaceDelete$3,
        backspaceDelete$a,
        backspaceDelete$4,
        backspaceDelete$7,
        backspaceDelete$1,
    ], (item) => item(editor, forward))
        .filter((_) => editor.selection.isEditable());
    const deleteCommand = (editor, caret) => {
        const result = findAction(editor, caret, false);
        result.fold(() => {
            // We can't use an `execEditorDeleteCommand` here, otherwise we'd get
            // possible infinite recursion (as it would trigger `deleteCommand` again)
            if (editor.selection.isEditable()) {
                execNativeDeleteCommand(editor);
                paddEmptyBody(editor);
            }
        }, call);
        if (hasListSelection(editor)) {
            normalizeLists(editor.dom, editor.getBody());
        }
    };
    const forwardDeleteCommand = (editor, caret) => {
        const result = findAction(editor, caret, true);
        result.fold(() => {
            if (editor.selection.isEditable()) {
                execNativeForwardDeleteCommand(editor);
            }
        }, call);
        if (hasListSelection(editor)) {
            normalizeLists(editor.dom, editor.getBody());
        }
    };
    const setup$v = (editor, caret) => {
        editor.addCommand('delete', () => {
            deleteCommand(editor, caret);
        });
        editor.addCommand('forwardDelete', () => {
            forwardDeleteCommand(editor, caret);
        });
    };

    // This is based heavily on Alloy's TapEvent.ts, just modified to use TinyMCE's event system.
    const SIGNIFICANT_MOVE = 5;
    const LONGPRESS_DELAY = 400;
    const getTouch = (event) => {
        if (event.touches === undefined || event.touches.length !== 1) {
            return Optional.none();
        }
        return Optional.some(event.touches[0]);
    };
    const isFarEnough = (touch, data) => {
        const distX = Math.abs(touch.clientX - data.x);
        const distY = Math.abs(touch.clientY - data.y);
        return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    const setup$u = (editor) => {
        const startData = value$1();
        const longpressFired = Cell(false);
        const debounceLongpress = last$1((e) => {
            editor.dispatch('longpress', { ...e, type: 'longpress' });
            longpressFired.set(true);
        }, LONGPRESS_DELAY);
        editor.on('touchstart', (e) => {
            getTouch(e).each((touch) => {
                debounceLongpress.cancel();
                const data = {
                    x: touch.clientX,
                    y: touch.clientY,
                    target: e.target
                };
                debounceLongpress.throttle(e);
                longpressFired.set(false);
                startData.set(data);
            });
        }, true);
        editor.on('touchmove', (e) => {
            debounceLongpress.cancel();
            getTouch(e).each((touch) => {
                startData.on((data) => {
                    if (isFarEnough(touch, data)) {
                        startData.clear();
                        longpressFired.set(false);
                        editor.dispatch('longpresscancel');
                    }
                });
            });
        }, true);
        editor.on('touchend touchcancel', (e) => {
            debounceLongpress.cancel();
            if (e.type === 'touchcancel') {
                return;
            }
            // Cancel the touchend event if a longpress was fired, otherwise fire the tap event
            startData.get()
                .filter((data) => data.target.isEqualNode(e.target))
                .each(() => {
                if (longpressFired.get()) {
                    e.preventDefault();
                }
                else {
                    editor.dispatch('tap', { ...e, type: 'tap' });
                }
            });
        }, true);
    };

    /**
     * Makes sure that everything gets wrapped in paragraphs.
     *
     * @private
     * @class tinymce.ForceBlocks
     */
    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);
    const isValidTarget = (schema, node) => {
        if (isText$b(node)) {
            return true;
        }
        else if (isElement$7(node)) {
            return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) &&
                !isTransparentBlock(schema, node) && !isNonHtmlElementRoot(node) && !isTemplate(node);
        }
        else {
            return false;
        }
    };
    const hasBlockParent = (blockElements, root, node) => {
        return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), (elm) => {
            return isBlockElement(blockElements, elm.dom);
        });
    };
    const shouldRemoveTextNode = (blockElements, node) => {
        if (isText$b(node)) {
            if (node.data.length === 0) {
                return true;
            }
            else if (/^\s+$/.test(node.data)) {
                return !node.nextSibling || isBlockElement(blockElements, node.nextSibling) || isNonHtmlElementRoot(node.nextSibling);
            }
        }
        return false;
    };
    const createRootBlock = (editor) => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
    const addRootBlocks = (editor) => {
        const dom = editor.dom, selection = editor.selection;
        const schema = editor.schema;
        const blockElements = schema.getBlockElements();
        const startNode = selection.getStart();
        const rootNode = editor.getBody();
        let rootBlockNode;
        let tempNode;
        let bm = null;
        const forcedRootBlock = getForcedRootBlock(editor);
        if (!startNode || !isElement$7(startNode)) {
            return;
        }
        const rootNodeName = rootNode.nodeName.toLowerCase();
        if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {
            return;
        }
        // Firefox will automatically remove the last BR if you insert nodes next to it and add a BR back if you remove those siblings
        // and since the bookmark code inserts temporary nodes an new BR will be constantly removed and added and triggering a selection
        // change causing an infinite recursion. So we treat this special case on it's own.
        if (rootNode.firstChild === rootNode.lastChild && isBr$7(rootNode.firstChild)) {
            rootBlockNode = createRootBlock(editor);
            rootBlockNode.appendChild(createPaddingBr().dom);
            rootNode.replaceChild(rootBlockNode, rootNode.firstChild);
            editor.selection.setCursorLocation(rootBlockNode, 0);
            editor.nodeChanged();
            return;
        }
        // Wrap non block elements and text nodes
        let node = rootNode.firstChild;
        while (node) {
            if (isElement$7(node)) {
                updateElement(schema, node);
            }
            if (isValidTarget(schema, node)) {
                // Remove empty text nodes and nodes containing only whitespace
                if (shouldRemoveTextNode(blockElements, node)) {
                    tempNode = node;
                    node = node.nextSibling;
                    dom.remove(tempNode);
                    continue;
                }
                if (!rootBlockNode) {
                    if (!bm && editor.hasFocus()) {
                        bm = getBookmark(editor.selection.getRng(), () => document.createElement('span'));
                    }
                    // Firefox will remove the last BR element if you insert nodes next to it using DOM APIs like insertBefore
                    // so for that weird edge case we stop processing.
                    if (!node.parentNode) {
                        node = null;
                        break;
                    }
                    rootBlockNode = createRootBlock(editor);
                    rootNode.insertBefore(rootBlockNode, node);
                }
                tempNode = node;
                node = node.nextSibling;
                rootBlockNode.appendChild(tempNode);
            }
            else {
                rootBlockNode = null;
                node = node.nextSibling;
            }
        }
        if (bm) {
            editor.selection.setRng(resolveBookmark(bm));
            editor.nodeChanged();
        }
    };
    const insertEmptyLine = (editor, root, insertBlock) => {
        const block = SugarElement.fromDom(createRootBlock(editor));
        const br = createPaddingBr();
        append$1(block, br);
        insertBlock(root, block);
        const rng = document.createRange();
        rng.setStartBefore(br.dom);
        rng.setEndBefore(br.dom);
        return rng;
    };
    const setup$t = (editor) => {
        editor.on('NodeChange', () => addRootBlocks(editor));
    };

    const hasClass = (checkClassName) => (node) => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;
    const replaceMatchWithSpan = (editor, content, cls) => {
        return function (match) {
            const args = arguments, index = args[args.length - 2];
            const prevChar = index > 0 ? content.charAt(index - 1) : '';
            // Is value inside an attribute then don't replace
            if (prevChar === '"') {
                return match;
            }
            // Is value inside a contentEditable='false' tag
            if (prevChar === '>') {
                const findStartTagIndex = content.lastIndexOf('<', index);
                if (findStartTagIndex !== -1) {
                    const tagHtml = content.substring(findStartTagIndex, index);
                    if (tagHtml.indexOf('contenteditable="false"') !== -1) {
                        return match;
                    }
                }
            }
            return ('<span class="' + cls + '" data-mce-content="' + editor.dom.encode(args[0]) + '">' +
                editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>');
        };
    };
    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {
        let i = nonEditableRegExps.length, content = e.content;
        // Don't replace the variables when raw is used for example on undo/redo
        if (e.format === 'raw') {
            return;
        }
        while (i--) {
            content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));
        }
        e.content = content;
    };
    const isValidContent = (nonEditableRegExps, content) => {
        return forall(nonEditableRegExps, (re) => {
            const matches = content.match(re);
            return matches !== null && matches[0].length === content.length;
        });
    };
    const setup$s = (editor) => {
        const contentEditableAttrName = 'contenteditable';
        const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';
        const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';
        const hasEditClass = hasClass(editClass);
        const hasNonEditClass = hasClass(nonEditClass);
        const nonEditableRegExps = getNonEditableRegExps(editor);
        if (nonEditableRegExps.length > 0) {
            editor.on('BeforeSetContent', (e) => {
                convertRegExpsToNonEditable(editor, nonEditableRegExps, e);
            });
        }
        editor.parser.addAttributeFilter('class', (nodes) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                if (hasEditClass(node)) {
                    node.attr(contentEditableAttrName, 'true');
                }
                else if (hasNonEditClass(node)) {
                    node.attr(contentEditableAttrName, 'false');
                }
            }
        });
        editor.serializer.addAttributeFilter(contentEditableAttrName, (nodes) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                if (!hasEditClass(node) && !hasNonEditClass(node)) {
                    continue;
                }
                const content = node.attr('data-mce-content');
                if (nonEditableRegExps.length > 0 && content) {
                    if (isValidContent(nonEditableRegExps, content)) {
                        node.name = '#text';
                        node.type = 3;
                        node.raw = true;
                        node.value = content;
                    }
                    else {
                        node.remove();
                    }
                }
                else {
                    node.attr(contentEditableAttrName, null);
                }
            }
        });
    };

    /**
     * This module shows the invisible block that the caret is currently in when contents is added to that block.
     */
    const findBlockCaretContainer = (editor) => descendant$1(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]')
        .map((elm) => elm.dom)
        .getOrNull();
    const showBlockCaretContainer = (editor, blockCaretContainer) => {
        if (blockCaretContainer.hasAttribute('data-mce-caret')) {
            showCaretContainerBlock(blockCaretContainer);
            editor.selection.setRng(editor.selection.getRng()); // Clears the fake caret state
            editor.selection.scrollIntoView(blockCaretContainer);
        }
    };
    const handleBlockContainer = (editor, e) => {
        const blockCaretContainer = findBlockCaretContainer(editor);
        if (!blockCaretContainer) {
            return;
        }
        if (e.type === 'compositionstart') {
            e.preventDefault();
            e.stopPropagation();
            showBlockCaretContainer(editor, blockCaretContainer);
            return;
        }
        if (hasContent(blockCaretContainer)) {
            showBlockCaretContainer(editor, blockCaretContainer);
            editor.undoManager.add();
        }
    };
    const setup$r = (editor) => {
        editor.on('keyup compositionstart', curry(handleBlockContainer, editor));
    };

    const isContentEditableFalse$3 = isContentEditableFalse$a;
    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);
    const moveToCeFalseVertically = (direction, editor, range) => {
        const isBefore = (caretPosition) => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);
        const isAfter = (caretPosition) => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
        return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$3);
    };
    const createTextBlock = (editor) => {
        const textBlock = editor.dom.create(getForcedRootBlock(editor));
        textBlock.innerHTML = '<br data-mce-bogus="1">';
        return textBlock;
    };
    const exitPreBlock = (editor, direction, range) => {
        const caretWalker = CaretWalker(editor.getBody());
        const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 /* HDirection.Forwards */ ? caretWalker.next : caretWalker.prev);
        if (range.collapsed) {
            const pre = editor.dom.getParent(range.startContainer, 'PRE');
            if (!pre) {
                return;
            }
            const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));
            if (!caretPos) {
                const newBlock = SugarElement.fromDom(createTextBlock(editor));
                if (direction === 1 /* HDirection.Forwards */) {
                    after$4(SugarElement.fromDom(pre), newBlock);
                }
                else {
                    before$4(SugarElement.fromDom(pre), newBlock);
                }
                editor.selection.select(newBlock.dom, true);
                editor.selection.collapse();
            }
        }
    };
    const getHorizontalRange = (editor, forward) => {
        const direction = forward ? 1 /* HDirection.Forwards */ : -1 /* HDirection.Backwards */;
        const range = editor.selection.getRng();
        return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {
            exitPreBlock(editor, direction, range);
            return Optional.none();
        });
    };
    const getVerticalRange = (editor, down) => {
        const direction = down ? 1 : -1;
        const range = editor.selection.getRng();
        return moveToCeFalseVertically(direction, editor, range).orThunk(() => {
            exitPreBlock(editor, direction, range);
            return Optional.none();
        });
    };
    const flipDirection = (selection, forward) => {
        const elm = forward ? selection.getEnd(true) : selection.getStart(true);
        return isRtl(elm) ? !forward : forward;
    };
    const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists((newRange) => {
        moveToRange(editor, newRange);
        return true;
    });
    const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists((newRange) => {
        moveToRange(editor, newRange);
        return true;
    });
    const moveToLineEndPoint$1 = (editor, forward) => {
        const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;
        return moveToLineEndPoint$3(editor, forward, isCefPosition);
    };
    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward)
        .map((pos) => {
        const rng = pos.toRange();
        const curRng = editor.selection.getRng();
        if (forward) {
            rng.setStart(curRng.startContainer, curRng.startOffset);
        }
        else {
            rng.setEnd(curRng.endContainer, curRng.endOffset);
        }
        return rng;
    })
        .exists((rng) => {
        moveToRange(editor, rng);
        return true;
    });

    const isTarget = (node) => contains$2(['figcaption'], name(node));
    const getClosestTargetBlock = (pos, root, schema) => {
        const isRoot = curry(eq, root);
        return closest$4(SugarElement.fromDom(pos.container()), (el) => schema.isBlock(name(el)), isRoot).filter(isTarget);
    };
    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);
    const moveCaretToNewEmptyLine = (editor, forward) => {
        const root = SugarElement.fromDom(editor.getBody());
        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        return getClosestTargetBlock(pos, root, editor.schema).exists(() => {
            if (isAtFirstOrLastLine(root, forward, pos)) {
                const insertFn = forward ? append$1 : prepend;
                const rng = insertEmptyLine(editor, root, insertFn);
                editor.selection.setRng(rng);
                return true;
            }
            else {
                return false;
            }
        });
    };
    const moveV$3 = (editor, forward) => {
        if (editor.selection.isCollapsed()) {
            return moveCaretToNewEmptyLine(editor, forward);
        }
        else {
            return false;
        }
    };

    const moveUp = (editor, details, summary) => {
        const rng = editor.selection.getRng();
        const pos = CaretPosition.fromRangeStart(rng);
        const root = editor.getBody();
        if (root.firstChild === details && isAtFirstLine(summary, pos)) {
            editor.execCommand('InsertNewBlockBefore');
            return true;
        }
        else {
            return false;
        }
    };
    const moveDown = (editor, details) => {
        const rng = editor.selection.getRng();
        const pos = CaretPosition.fromRangeStart(rng);
        const root = editor.getBody();
        if (root.lastChild === details && isAtLastLine(details, pos)) {
            editor.execCommand('InsertNewBlockAfter');
            return true;
        }
        else {
            return false;
        }
    };
    const move$2 = (editor, forward) => {
        if (forward) {
            return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details'))
                .map((details) => moveDown(editor, details))
                .getOr(false);
        }
        else {
            return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary'))
                .bind((summary) => Optional.from(editor.dom.getParent(summary, 'details'))
                .map((details) => moveUp(editor, details, summary))).getOr(false);
        }
    };
    const moveV$2 = (editor, forward) => move$2(editor, forward);

    const baseKeyPattern = {
        shiftKey: false,
        altKey: false,
        ctrlKey: false,
        metaKey: false,
        keyCode: 0
    };
    const defaultPatterns = (patterns) => map$3(patterns, (pattern) => ({
        ...baseKeyPattern,
        ...pattern
    }));
    const defaultDelayedPatterns = (patterns) => map$3(patterns, (pattern) => ({
        ...baseKeyPattern,
        ...pattern
    }));
    const matchesEvent = (pattern, evt) => (evt.keyCode === pattern.keyCode &&
        evt.shiftKey === pattern.shiftKey &&
        evt.altKey === pattern.altKey &&
        evt.ctrlKey === pattern.ctrlKey &&
        evt.metaKey === pattern.metaKey);
    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), (pattern) => matchesEvent(pattern, evt) ? [pattern] : []);
    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), (pattern) => matchesEvent(pattern, evt) ? [pattern] : []);
    const action = (f, ...x) => () => f.apply(null, x);
    const execute = (patterns, evt) => find$2(match$1(patterns, evt), (pattern) => pattern.action());
    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), (pattern) => pattern.action());

    const moveH$1 = (editor, forward) => {
        const direction = forward ? 1 /* HDirection.Forwards */ : -1 /* HDirection.Backwards */;
        const range = editor.selection.getRng();
        return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists((newRange) => {
            moveToRange(editor, newRange);
            return true;
        });
    };
    const moveV$1 = (editor, down) => {
        const direction = down ? 1 : -1;
        const range = editor.selection.getRng();
        return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists((newRange) => {
            moveToRange(editor, newRange);
            return true;
        });
    };
    const moveToLineEndPoint = (editor, forward) => {
        const isNearMedia = forward ? isAfterMedia : isBeforeMedia;
        return moveToLineEndPoint$3(editor, forward, isNearMedia);
    };

    const firstLayer = (scope, selector) => {
        return filterFirstLayer(scope, selector, always);
    };
    const filterFirstLayer = (scope, selector, predicate) => {
        return bind$3(children$1(scope), (x) => {
            if (is$2(x, selector)) {
                return predicate(x) ? [x] : [];
            }
            else {
                return filterFirstLayer(x, selector, predicate);
            }
        });
    };

    // lookup inside this table
    const lookup$1 = (tags, element, isRoot = never) => {
        // If the element we're inspecting is the root, we definitely don't want it.
        if (isRoot(element)) {
            return Optional.none();
        }
        // This looks a lot like SelectorFind.closest, with one big exception - the isRoot check.
        // The code here will look for parents if passed a table, SelectorFind.closest with that specific isRoot check won't.
        if (contains$2(tags, name(element))) {
            return Optional.some(element);
        }
        const isRootOrUpperTable = (elm) => is$2(elm, 'table') || isRoot(elm);
        return ancestor$4(element, tags.join(','), isRootOrUpperTable);
    };
    /*
     * Identify the optional cell that element represents.
     */
    const cell = (element, isRoot) => lookup$1(['td', 'th'], element, isRoot);
    const cells = (ancestor) => firstLayer(ancestor, 'th,td');
    const table = (element, isRoot) => closest$3(element, 'table', isRoot);

    const adt = Adt.generate([
        { none: ['current'] },
        { first: ['current'] },
        { middle: ['current', 'target'] },
        { last: ['current'] }
    ]);
    const none = (current) => adt.none(current);
    const CellLocation = {
        ...adt,
        none
    };

    /*
     *  Walk until the next eligible cell location is found, or the start/end of the table is found.
     */
    const walk = (all, current, index, direction, isEligible = always) => {
        const forwards = direction === 1 /* Direction.Forwards */;
        if (!forwards && index <= 0) {
            return CellLocation.first(all[0]);
        }
        else if (forwards && index >= all.length - 1) {
            return CellLocation.last(all[all.length - 1]);
        }
        else {
            const newIndex = index + direction;
            const elem = all[newIndex];
            return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);
        }
    };
    /*
     * Identify the index of the current cell within all the cells, and
     * a list of the cells within its table.
     */
    const detect = (current, isRoot) => {
        return table(current, isRoot).bind((table) => {
            const all = cells(table);
            const index = findIndex$2(all, (x) => eq(current, x));
            return index.map((index) => ({ index, all }));
        });
    };
    /*
     * Identify the CellLocation of the cell when navigating forward from current
     */
    const next = (current, isEligible, isRoot) => {
        const detection = detect(current, isRoot);
        return detection.fold(() => {
            return CellLocation.none(current);
        }, (info) => {
            return walk(info.all, current, info.index, 1 /* Direction.Forwards */, isEligible);
        });
    };
    /*
     * Identify the CellLocation of the cell when navigating back from current
     */
    const prev = (current, isEligible, isRoot) => {
        const detection = detect(current, isRoot);
        return detection.fold(() => {
            return CellLocation.none();
        }, (info) => {
            return walk(info.all, current, info.index, -1 /* Direction.Backwards */, isEligible);
        });
    };

    var TagBoundaries = [
        'body',
        'p',
        'div',
        'article',
        'aside',
        'figcaption',
        'figure',
        'footer',
        'header',
        'nav',
        'section',
        'ol',
        'ul',
        'li',
        'table',
        'thead',
        'tbody',
        'tfoot',
        'caption',
        'tr',
        'td',
        'th',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'blockquote',
        'pre',
        'address'
    ];

    var DomUniverse = () => {
        const clone = (element) => {
            return SugarElement.fromDom(element.dom.cloneNode(false));
        };
        const document = (element) => documentOrOwner(element).dom;
        const isBoundary = (element) => {
            if (!isElement$8(element)) {
                return false;
            }
            if (name(element) === 'body') {
                return true;
            }
            return contains$2(TagBoundaries, name(element));
        };
        const isEmptyTag = (element) => {
            if (!isElement$8(element)) {
                return false;
            }
            return contains$2(['br', 'img', 'hr', 'input'], name(element));
        };
        const isNonEditable = (element) => isElement$8(element) && get$9(element, 'contenteditable') === 'false';
        const comparePosition = (element, other) => {
            return element.dom.compareDocumentPosition(other.dom);
        };
        const copyAttributesTo = (source, destination) => {
            const as = clone$4(source);
            setAll$1(destination, as);
        };
        const isSpecial = (element) => {
            const tag = name(element);
            return contains$2([
                'script', 'noscript', 'iframe', 'noframes', 'noembed', 'title', 'style', 'textarea', 'xmp'
            ], tag);
        };
        const getLanguage = (element) => isElement$8(element) ? getOpt(element, 'lang') : Optional.none();
        return {
            up: constant({
                selector: ancestor$4,
                closest: closest$3,
                predicate: ancestor$5,
                all: parents$1
            }),
            down: constant({
                selector: descendants,
                predicate: descendants$1
            }),
            styles: constant({
                get: get$7,
                getRaw: getRaw$1,
                set: set$2,
                remove: remove$7
            }),
            attrs: constant({
                get: get$9,
                set: set$4,
                remove: remove$9,
                copyTo: copyAttributesTo
            }),
            insert: constant({
                before: before$4,
                after: after$4,
                afterAll: after$3,
                append: append$1,
                appendAll: append,
                prepend: prepend,
                wrap: wrap$2
            }),
            remove: constant({
                unwrap: unwrap,
                remove: remove$8
            }),
            create: constant({
                nu: SugarElement.fromTag,
                clone,
                text: SugarElement.fromText
            }),
            query: constant({
                comparePosition,
                prevSibling: prevSibling,
                nextSibling: nextSibling
            }),
            property: constant({
                children: children$1,
                name: name,
                parent: parent,
                document,
                isText: isText$c,
                isComment: isComment$1,
                isElement: isElement$8,
                isSpecial,
                getLanguage,
                getText: get$4,
                setText: set$1,
                isBoundary,
                isEmptyTag,
                isNonEditable
            }),
            eq: eq,
            is: is$1
        };
    };

    const point$1 = (element, offset) => ({
        element,
        offset
    });

    /**
     * Return the last available cursor position in the node.
     */
    const toLast$1 = (universe, node) => {
        if (universe.property().isText(node)) {
            return point$1(node, universe.property().getText(node).length);
        }
        else {
            const children = universe.property().children(node);
            // keep descending if there are children.
            return children.length > 0 ? toLast$1(universe, children[children.length - 1]) : point$1(node, children.length);
        }
    };
    /**
     * Descend down to a leaf node at the given offset.
     */
    const toLeaf$3 = (universe, element, offset) => {
        const children = universe.property().children(element);
        if (children.length > 0 && offset < children.length) {
            return toLeaf$3(universe, children[offset], 0);
        }
        else if (children.length > 0 && universe.property().isElement(element) && children.length === offset) {
            return toLast$1(universe, children[children.length - 1]);
        }
        else {
            return point$1(element, offset);
        }
    };

    const toLeaf$2 = toLeaf$3;

    const universe = DomUniverse();
    const toLeaf$1 = (element, offset) => {
        return toLeaf$2(universe, element, offset);
    };

    const imageId = generate$1('image');
    const getDragImage = (transfer) => {
        const dt = transfer;
        return Optional.from(dt[imageId]);
    };
    const setDragImage = (transfer, imageData) => {
        const dt = transfer;
        dt[imageId] = imageData;
    };

    const eventId = generate$1('event');
    const getEvent = (transfer) => {
        const dt = transfer;
        return Optional.from(dt[eventId]);
    };
    const mkSetEventFn = (type) => (transfer) => {
        const dt = transfer;
        dt[eventId] = type;
    };
    const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);
    const setDragstartEvent = mkSetEventFn(0 /* Event.Dragstart */);
    const setDropEvent = mkSetEventFn(2 /* Event.Drop */);
    const setDragendEvent = mkSetEventFn(1 /* Event.Dragend */);
    const checkEvent = (expectedType) => (transfer) => {
        const dt = transfer;
        return Optional.from(dt[eventId]).exists((type) => type === expectedType);
    };
    const isInDragStartEvent = checkEvent(0 /* Event.Dragstart */);

    const createEmptyFileList = () => Object.freeze({
        length: 0,
        item: (_) => null
    });

    const modeId = generate$1('mode');
    const getMode = (transfer) => {
        const dt = transfer;
        return Optional.from(dt[modeId]);
    };
    const mkSetModeFn = (mode) => (transfer) => {
        const dt = transfer;
        dt[modeId] = mode;
    };
    const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);
    const setReadWriteMode = mkSetModeFn(0 /* Mode.ReadWrite */);
    const setReadOnlyMode = mkSetModeFn(2 /* Mode.ReadOnly */);
    const setProtectedMode = mkSetModeFn(1 /* Mode.Protected */);
    const checkMode = (expectedMode) => (transfer) => {
        const dt = transfer;
        return Optional.from(dt[modeId]).exists((mode) => mode === expectedMode);
    };
    const isInReadWriteMode = checkMode(0 /* Mode.ReadWrite */);
    const isInProtectedMode = checkMode(1 /* Mode.Protected */);

    const normalizeItems = (dataTransfer, itemsImpl) => ({
        ...itemsImpl,
        get length() {
            return itemsImpl.length;
        },
        add: (data, type) => {
            if (isInReadWriteMode(dataTransfer)) {
                if (isString(data)) {
                    if (!isUndefined(type)) {
                        return itemsImpl.add(data, type);
                    }
                }
                else {
                    return itemsImpl.add(data);
                }
            }
            return null;
        },
        remove: (idx) => {
            if (isInReadWriteMode(dataTransfer)) {
                itemsImpl.remove(idx);
            }
        },
        clear: () => {
            if (isInReadWriteMode(dataTransfer)) {
                itemsImpl.clear();
            }
        }
    });

    const validDropEffects = ['none', 'copy', 'link', 'move'];
    const validEffectAlloweds = ['none', 'copy', 'copyLink', 'copyMove', 'link', 'linkMove', 'move', 'all', 'uninitialized'];
    const createDataTransfer = () => {
        const dataTransferImpl = new window.DataTransfer();
        let dropEffect = 'move';
        let effectAllowed = 'all';
        const dataTransfer = {
            get dropEffect() {
                return dropEffect;
            },
            set dropEffect(effect) {
                if (contains$2(validDropEffects, effect)) {
                    dropEffect = effect;
                }
            },
            get effectAllowed() {
                return effectAllowed;
            },
            set effectAllowed(allowed) {
                // TINY-9601: Only allow setting effectAllowed to a valid value in a dragstart event
                // https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/effectAllowed
                if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {
                    effectAllowed = allowed;
                }
            },
            get items() {
                return normalizeItems(dataTransfer, dataTransferImpl.items);
            },
            get files() {
                if (isInProtectedMode(dataTransfer)) {
                    return createEmptyFileList();
                }
                else {
                    return dataTransferImpl.files;
                }
            },
            get types() {
                return dataTransferImpl.types;
            },
            setDragImage: (image, x, y) => {
                if (isInReadWriteMode(dataTransfer)) {
                    setDragImage(dataTransfer, { image, x, y });
                    dataTransferImpl.setDragImage(image, x, y);
                }
            },
            getData: (format) => {
                if (isInProtectedMode(dataTransfer)) {
                    return '';
                }
                else {
                    return dataTransferImpl.getData(format);
                }
            },
            setData: (format, data) => {
                if (isInReadWriteMode(dataTransfer)) {
                    dataTransferImpl.setData(format, data);
                }
            },
            clearData: (format) => {
                if (isInReadWriteMode(dataTransfer)) {
                    dataTransferImpl.clearData(format);
                }
            }
        };
        setReadWriteMode(dataTransfer);
        return dataTransfer;
    };
    const cloneDataTransfer = (original) => {
        // Create new DataTransfer object to ensure scope is not shared between original and clone
        const clone = createDataTransfer();
        const originalMode = getMode(original);
        // Set original to read-only to ensure data can be copied
        setReadOnlyMode(original);
        // Set clone event to dragstart to ensure effectAllowed can be set
        setDragstartEvent(clone);
        clone.dropEffect = original.dropEffect;
        clone.effectAllowed = original.effectAllowed;
        getDragImage(original).each((imageData) => clone.setDragImage(imageData.image, imageData.x, imageData.y));
        each$e(original.types, (type) => {
            if (type !== 'Files') {
                clone.setData(type, original.getData(type));
            }
        });
        each$e(original.files, (file) => clone.items.add(file));
        getEvent(original).each((type) => {
            setEvent(clone, type);
        });
        originalMode.each((mode) => {
            // Reset original mode since it was set to read-only earlier
            setMode$1(original, mode);
            setMode$1(clone, mode);
        });
        return clone;
    };

    const getHtmlData = (dataTransfer) => {
        const html = dataTransfer.getData('text/html');
        return html === '' ? Optional.none() : Optional.some(html);
    };
    const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);

    const deflate = (rect, delta) => ({
        left: rect.left - delta,
        top: rect.top - delta,
        right: rect.right + delta * 2,
        bottom: rect.bottom + delta * 2,
        width: rect.width + delta,
        height: rect.height + delta
    });
    const getCorners = (getYAxisValue, tds) => bind$3(tds, (td) => {
        const rect = deflate(clone$1(td.getBoundingClientRect()), -1);
        return [
            { x: rect.left, y: getYAxisValue(rect), cell: td },
            { x: rect.right, y: getYAxisValue(rect), cell: td }
        ];
    });
    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), (oldCorner) => {
        const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
        const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
        return Optional.some(newDist < oldDist ? newCorner : oldCorner);
    }), Optional.none());
    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {
        const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map((e) => e.dom);
        const corners = filter$5(getCorners(getYAxisValue, cells), (corner) => isTargetCorner(corner, y));
        return findClosestCorner(corners, x, y).map((corner) => corner.cell);
    };
    const getBottomValue = (rect) => rect.bottom;
    const getTopValue = (rect) => rect.top;
    const isAbove = (corner, y) => corner.y < y;
    const isBelow = (corner, y) => corner.y > y;
    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);
    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);
    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects())
        .bind((rect) => getClosestCellAbove(table, rect.left, rect.top))
        .bind((cell) => findClosestHorizontalPosition(getLastLinePositions(cell), pos));
    const findClosestPositionInBelowCell = (table, pos) => last$2(pos.getClientRects())
        .bind((rect) => getClosestCellBelow(table, rect.left, rect.top))
        .bind((cell) => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));

    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists((breakPos) => getPositionsUntil(scope, breakPos).breakAt.isSome());
    const startsWithWrapBreak = (lineInfo) => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
    const startsWithBrBreak = (lineInfo) => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {
        const lineInfo = getPositionsUntil(scope, pos);
        // Since we can't determine if the caret is on the above or below line in a word wrap break we asume it's always
        // on the below/above line based on direction. This will make the caret jump one line if you are at the end of the last
        // line and moving down or at the beginning of the second line moving up.
        if (startsWithWrapBreak(lineInfo) || (!isBr$7(pos.getNode()) && startsWithBrBreak(lineInfo))) {
            return !hasNextBreak(getPositionsUntil, scope, lineInfo);
        }
        else {
            return lineInfo.breakAt.isNone();
        }
    };
    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {
        const caretPos = CaretPosition.fromRangeStart(rng);
        return positionIn(!forward, table).exists((pos) => pos.isEqual(caretPos));
    };
    const navigateHorizontally = (editor, forward, table, _td) => {
        const rng = editor.selection.getRng();
        const direction = forward ? 1 : -1;
        if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {
            showCaret(direction, editor, table, !forward, false).each((newRng) => {
                moveToRange(editor, newRng);
            });
            return true;
        }
        return false;
    };
    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind((rect) => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));
    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind((rect) => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));
    const getTable = (previous, pos) => {
        const node = pos.getNode(previous);
        return isTable$2(node) ? Optional.some(node) : Optional.none();
    };
    const renderBlock = (down, editor, table) => {
        editor.undoManager.transact(() => {
            const insertFn = down ? after$4 : before$4;
            const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);
            moveToRange(editor, rng);
        });
    };
    const moveCaret = (editor, down, pos) => {
        const table = down ? getTable(true, pos) : getTable(false, pos);
        const last = down === false;
        table.fold(() => moveToRange(editor, pos.toRange()), (table) => positionIn(last, editor.getBody()).filter((lastPos) => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), (_) => renderBlock(down, editor, table)));
    };
    const navigateVertically = (editor, down, table, td) => {
        const rng = editor.selection.getRng();
        const pos = CaretPosition.fromRangeStart(rng);
        const root = editor.getBody();
        if (!down && isAtFirstTableCellLine(td, pos)) {
            const newPos = getClosestAbovePosition(root, table, pos);
            moveCaret(editor, down, newPos);
            return true;
        }
        else if (down && isAtLastTableCellLine(td, pos)) {
            const newPos = getClosestBelowPosition(root, table, pos);
            moveCaret(editor, down, newPos);
            return true;
        }
        else {
            return false;
        }
    };
    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th'))
        .bind((td) => Optional.from(editor.dom.getParent(td, 'table'))
        .map((table) => mover(editor, forward, table, td))).getOr(false);
    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);
    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);
    const getCellFirstCursorPosition = (cell) => {
        const selection = SimSelection.exact(cell, 0, cell, 0);
        return toNative(selection);
    };
    const rowHasEditableCell = (cell) => {
        return isCellEditable(cell) || siblings(cell).some((element) => isHTMLElement$1(element) && isCellEditable(element));
    };
    const tabGo = (editor, isRoot, cell) => {
        return cell.fold(Optional.none, Optional.none, (_current, next) => {
            return first(next).map((cell) => {
                return getCellFirstCursorPosition(cell);
            });
        }, (current) => {
            if (editor.mode.isReadOnly() || !isCellInEditableTable(current) || !rowHasEditableCell(current)) {
                return Optional.none();
            }
            editor.execCommand('mceTableInsertRowAfter');
            // Move forward from the last cell so that we move into the first valid position in the new row
            return tabForward(editor, isRoot, current);
        });
    };
    const isCellInEditableTable = (cell) => closest$4(cell, isTag('table')).exists(isEditable$2);
    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isCellEditable));
    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isCellEditable));
    const isCellEditable = (cell) => isEditable$2(cell) || descendant(cell, isEditableHTMLElement);
    const isEditableHTMLElement = (node) => isHTMLElement$1(node) && isEditable$2(node);
    const handleTab = (editor, forward) => {
        const rootElements = ['table', 'li', 'dl'];
        const body = SugarElement.fromDom(editor.getBody());
        const isRoot = (element) => {
            const name$1 = name(element);
            return eq(element, body) || contains$2(rootElements, name$1);
        };
        const rng = editor.selection.getRng();
        // If navigating backwards, use the start of the ranged selection
        const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);
        return cell(container, isRoot).map((cell) => {
            // Clear fake ranged selection because our new selection will always be collapsed
            table(cell, isRoot).each((table) => {
                editor.model.table.clearSelectedCells(table.dom);
            });
            // Collapse selection to start or end based on shift key
            editor.selection.collapse(!forward);
            const navigation = !forward ? tabBackward : tabForward;
            const rng = navigation(editor, isRoot, cell);
            rng.each((range) => {
                editor.selection.setRng(range);
            });
            return true;
        }).getOr(false);
    };

    const executeKeydownOverride$4 = (editor, caret, evt) => {
        const isMac = Env.os.isMacOS() || Env.os.isiOS();
        execute([
            { keyCode: VK.RIGHT, action: action(moveH$2, editor, true) },
            { keyCode: VK.LEFT, action: action(moveH$2, editor, false) },
            { keyCode: VK.UP, action: action(moveV$4, editor, false) },
            { keyCode: VK.DOWN, action: action(moveV$4, editor, true) },
            ...(isMac ? [
                { keyCode: VK.UP, action: action(selectToEndPoint, editor, false), metaKey: true, shiftKey: true },
                { keyCode: VK.DOWN, action: action(selectToEndPoint, editor, true), metaKey: true, shiftKey: true }
            ] : []),
            { keyCode: VK.RIGHT, action: action(moveH, editor, true) },
            { keyCode: VK.LEFT, action: action(moveH, editor, false) },
            { keyCode: VK.UP, action: action(moveV, editor, false) },
            { keyCode: VK.DOWN, action: action(moveV, editor, true) },
            { keyCode: VK.UP, action: action(moveV, editor, false) },
            { keyCode: VK.UP, action: action(moveV$2, editor, false) },
            { keyCode: VK.DOWN, action: action(moveV$2, editor, true) },
            { keyCode: VK.RIGHT, action: action(moveH$1, editor, true) },
            { keyCode: VK.LEFT, action: action(moveH$1, editor, false) },
            { keyCode: VK.UP, action: action(moveV$1, editor, false) },
            { keyCode: VK.DOWN, action: action(moveV$1, editor, true) },
            { keyCode: VK.RIGHT, action: action(move$3, editor, caret, true) },
            { keyCode: VK.LEFT, action: action(move$3, editor, caret, false) },
            { keyCode: VK.RIGHT, ctrlKey: !isMac, altKey: isMac, action: action(moveNextWord, editor, caret) },
            { keyCode: VK.LEFT, ctrlKey: !isMac, altKey: isMac, action: action(movePrevWord, editor, caret) },
            { keyCode: VK.UP, action: action(moveV$3, editor, false) },
            { keyCode: VK.DOWN, action: action(moveV$3, editor, true) }
        ], evt).each((_) => {
            evt.preventDefault();
        });
    };
    const setup$q = (editor, caret) => {
        editor.on('keydown', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeydownOverride$4(editor, caret, evt);
            }
        });
    };

    const point = (container, offset) => ({
        container,
        offset
    });

    const DOM$7 = DOMUtils.DOM;
    const alwaysNext = (startNode) => (node) => startNode === node ? -1 : 0;
    // This largely is derived from robins isBoundary check, however it also treats contenteditable=false elements as a boundary
    // See robins `Structure.isEmptyTag` for the list of quasi block elements
    const isBoundary = (dom) => (node) => dom.isBlock(node) || contains$2(['BR', 'IMG', 'HR', 'INPUT'], node.nodeName) || dom.getContentEditable(node) === 'false';
    // Finds the text node before the specified node, or just returns the node if it's already on a text node
    const textBefore = (node, offset, rootNode) => {
        if (isText$b(node) && offset >= 0) {
            return Optional.some(point(node, offset));
        }
        else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map((prev) => point(prev.container, prev.container.data.length));
        }
    };
    const textAfter = (node, offset, rootNode) => {
        if (isText$b(node) && offset >= node.length) {
            return Optional.some(point(node, offset));
        }
        else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map((prev) => point(prev.container, 0));
        }
    };
    const scanLeft = (node, offset, rootNode) => {
        if (!isText$b(node)) {
            return Optional.none();
        }
        const text = node.data;
        if (offset >= 0 && offset <= text.length) {
            return Optional.some(point(node, offset));
        }
        else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind((prev) => {
                const prevText = prev.container.data;
                return scanLeft(prev.container, offset + prevText.length, rootNode);
            });
        }
    };
    const scanRight = (node, offset, rootNode) => {
        if (!isText$b(node)) {
            return Optional.none();
        }
        const text = node.data;
        if (offset <= text.length) {
            return Optional.some(point(node, offset));
        }
        else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind((next) => scanRight(next.container, offset - text.length, rootNode));
        }
    };
    const repeatLeft = (dom, node, offset, process, rootNode) => {
        const search = TextSeeker(dom, isBoundary(dom));
        return Optional.from(search.backwards(node, offset, process, rootNode));
    };

    const isValidTextRange = (rng) => rng.collapsed && isText$b(rng.startContainer);
    // Normalize the text by replacing non-breaking spaces with regular spaces and stripping zero-width spaces (fake carets).
    const getText = (rng) => trim$2(rng.toString().replace(/\u00A0/g, ' '));
    const isWhitespace = (chr) => chr !== '' && ' \u00a0\ufeff\f\n\r\t\v'.indexOf(chr) !== -1;

    const stripTrigger = (text, trigger) => text.substring(trigger.length);
    const findTrigger = (text, index, trigger, includeWhitespace = false) => {
        // Identify the `char` in, and start the text from that point forward. If there is ever any whitespace, fail
        let i;
        const firstChar = trigger.charAt(0);
        for (i = index - 1; i >= 0; i--) {
            const char = text.charAt(i);
            if (!includeWhitespace && isWhitespace(char)) {
                return Optional.none();
            }
            if (firstChar === char && contains$1(text, trigger, i, index)) {
                break;
            }
        }
        return Optional.some(i);
    };
    const getContext = (dom, initRange, trigger, includeWhitespace = false) => {
        if (!isValidTextRange(initRange)) {
            return Optional.none();
        }
        const buffer = { text: '', offset: 0 };
        const findTriggerIndex = (element, offset, text) => {
            buffer.text = text + buffer.text;
            buffer.offset += offset;
            // Stop searching by just returning the current offset if whitespace was found (eg Optional.none())
            // and we'll handle the final checks below instead
            return findTrigger(buffer.text, buffer.offset, trigger, includeWhitespace).getOr(offset);
        };
        const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();
        return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind((spot) => {
            const range = initRange.cloneRange();
            range.setStart(spot.container, spot.offset);
            range.setEnd(initRange.endContainer, initRange.endOffset);
            // If the range is collapsed then we didn't find a match so abort
            if (range.collapsed) {
                return Optional.none();
            }
            const text = getText(range);
            const triggerIndex = text.lastIndexOf(trigger);
            // If the match doesn't start with the trigger (eg whitespace found)
            if (triggerIndex !== 0) {
                return Optional.none();
            }
            else {
                return Optional.some({ text: stripTrigger(text, trigger), range, trigger });
            }
        });
    };

    const isText$1 = (node) => node.nodeType === TEXT;
    const isElement = (node) => node.nodeType === ELEMENT;
    const toLast = (node) => {
        if (isText$1(node)) {
            return point(node, node.data.length);
        }
        else {
            const children = node.childNodes;
            // keep descending if there are children.
            return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);
        }
    };
    const toLeaf = (node, offset) => {
        const children = node.childNodes;
        if (children.length > 0 && offset < children.length) {
            return toLeaf(children[offset], 0);
        }
        else if (children.length > 0 && isElement(node) && children.length === offset) {
            return toLast(children[children.length - 1]);
        }
        else {
            return point(node, offset);
        }
    };

    const isPreviousCharContent = (dom, leaf) => {
        var _a;
        // If at the start of the range, then we need to look backwards one more place. Otherwise we just need to look at the current text
        const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();
        return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter((spot) => {
            const char = spot.container.data.charAt(spot.offset - 1);
            return !isWhitespace(char);
        }).isSome();
    };
    const isStartOfWord = (dom) => (rng) => {
        const leaf = toLeaf(rng.startContainer, rng.startOffset);
        return !isPreviousCharContent(dom, leaf);
    };
    const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, (trigger) => getContext(dom, initRange, trigger));
    const lookup = (editor, getDatabase) => {
        const database = getDatabase();
        const rng = editor.selection.getRng();
        return getTriggerContext(editor.dom, rng, database).bind((context) => lookupWithContext(editor, getDatabase, context));
    };
    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {
        var _a;
        const database = getDatabase();
        const rng = editor.selection.getRng();
        const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';
        const autocompleters = filter$5(database.lookupByTrigger(context.trigger), (autocompleter) => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));
        if (autocompleters.length === 0) {
            return Optional.none();
        }
        const lookupData = Promise.all(map$3(autocompleters, (ac) => {
            // TODO: Find a sensible way to do maxResults
            const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);
            return fetchResult.then((results) => ({
                matchText: context.text,
                items: results,
                columns: ac.columns,
                onAction: ac.onAction,
                highlightOn: ac.highlightOn
            }));
        }));
        return Optional.some({
            lookupData,
            context
        });
    };

    var SimpleResultType;
    (function (SimpleResultType) {
        SimpleResultType[SimpleResultType["Error"] = 0] = "Error";
        SimpleResultType[SimpleResultType["Value"] = 1] = "Value";
    })(SimpleResultType || (SimpleResultType = {}));
    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);
    const partition = (results) => {
        const values = [];
        const errors = [];
        each$e(results, (obj) => {
            fold$1(obj, (err) => errors.push(err), (val) => values.push(val));
        });
        return { values, errors };
    };
    const mapError = (res, f) => {
        if (res.stype === SimpleResultType.Error) {
            return { stype: SimpleResultType.Error, serror: f(res.serror) };
        }
        else {
            return res;
        }
    };
    const map = (res, f) => {
        if (res.stype === SimpleResultType.Value) {
            return { stype: SimpleResultType.Value, svalue: f(res.svalue) };
        }
        else {
            return res;
        }
    };
    const bind = (res, f) => {
        if (res.stype === SimpleResultType.Value) {
            return f(res.svalue);
        }
        else {
            return res;
        }
    };
    const bindError = (res, f) => {
        if (res.stype === SimpleResultType.Error) {
            return f(res.serror);
        }
        else {
            return res;
        }
    };
    const svalue = (v) => ({ stype: SimpleResultType.Value, svalue: v });
    const serror = (e) => ({ stype: SimpleResultType.Error, serror: e });
    const toResult = (res) => fold$1(res, Result.error, Result.value);
    const fromResult = (res) => res.fold(serror, svalue);
    const SimpleResult = {
        fromResult,
        toResult,
        svalue,
        partition,
        serror,
        bind,
        bindError,
        map,
        mapError,
        fold: fold$1
    };

    const formatObj = (input) => {
        return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);
    };
    const formatErrors = (errors) => {
        const es = errors.length > 10 ? errors.slice(0, 10).concat([
            {
                path: [],
                getErrorInfo: constant('... (only showing first ten failures)')
            }
        ]) : errors;
        // TODO: Work out a better split between PrettyPrinter and SchemaError
        return map$3(es, (e) => {
            return 'Failed path: (' + e.path.join(' > ') + ')\n' + e.getErrorInfo();
        });
    };

    const nu = (path, getErrorInfo) => {
        return SimpleResult.serror([{
                path,
                // This is lazy so that it isn't calculated unnecessarily
                getErrorInfo
            }]);
    };
    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for "' + key + '" in ' + formatObj(obj));
    const custom = (path, err) => nu(path, constant(err));

    const value = (validator) => {
        const extract = (path, val) => {
            return SimpleResult.bindError(validator(val), (err) => custom(path, err));
        };
        const toString = constant('val');
        return {
            extract,
            toString
        };
    };
    const anyValue$1 = value(SimpleResult.svalue);

    const anyValue = constant(anyValue$1);
    const typedValue = (validator, expectedType) => value((a) => {
        const actualType = typeof a;
        return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);
    });
    const number = typedValue(isNumber, 'number');
    const string = typedValue(isString, 'string');
    typedValue(isBoolean, 'boolean');
    const functionProcessor = typedValue(isFunction, 'function');
    // Test if a value can be copied by the structured clone algorithm and hence sendable via postMessage
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
    // from https://stackoverflow.com/a/32673910/7377237 with adjustments for typescript
    const isPostMessageable = (val) => {
        if (Object(val) !== val) { // Primitive value
            return true;
        }
        switch ({}.toString.call(val).slice(8, -1)) { // Class
            case 'Boolean':
            case 'Number':
            case 'String':
            case 'Date':
            case 'RegExp':
            case 'Blob':
            case 'FileList':
            case 'ImageData':
            case 'ImageBitmap':
            case 'ArrayBuffer':
                return true;
            case 'Array':
            case 'Object':
                return Object.keys(val).every((prop) => isPostMessageable(val[prop]));
            default:
                return false;
        }
    };
    value((a) => {
        if (isPostMessageable(a)) {
            return SimpleResult.svalue(a);
        }
        else {
            return SimpleResult.serror('Expected value to be acceptable for sending via postMessage');
        }
    });

    const required$1 = () => ({ tag: "required" /* FieldPresenceTag.Required */, process: {} });
    const defaultedThunk = (fallbackThunk) => ({ tag: "defaultedThunk" /* FieldPresenceTag.DefaultedThunk */, process: fallbackThunk });
    const defaulted$1 = (fallback) => defaultedThunk(constant(fallback));
    const asOption = () => ({ tag: "option" /* FieldPresenceTag.Option */, process: {} });

    const field$1 = (key, newKey, presence, prop) => ({ tag: "field" /* FieldTag.Field */, key, newKey, presence, prop });
    const fold = (value, ifField, ifCustom) => {
        switch (value.tag) {
            case "field" /* FieldTag.Field */:
                return ifField(value.key, value.newKey, value.presence, value.prop);
            case "custom" /* FieldTag.CustomField */:
                return ifCustom(value.newKey, value.instantiator);
        }
    };

    const mergeValues = (values, base) => {
        return SimpleResult.svalue(deepMerge(base, merge$1.apply(undefined, values)));
    };
    const mergeErrors = (errors) => compose(SimpleResult.serror, flatten)(errors);
    const consolidateObj = (objects, base) => {
        const partition = SimpleResult.partition(objects);
        return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);
    };
    const consolidateArr = (objects) => {
        const partitions = SimpleResult.partition(objects);
        return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);
    };
    const ResultCombine = {
        consolidateObj,
        consolidateArr
    };

    const requiredAccess = (path, obj, key, bundle) => 
    // In required mode, if it is undefined, it is an error.
    get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);
    const fallbackAccess = (obj, key, fallback, bundle) => {
        const v = get$a(obj, key).getOrThunk(() => fallback(obj));
        return bundle(v);
    };
    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));
    const optionDefaultedAccess = (obj, key, fallback, bundle) => {
        const opt = get$a(obj, key).map((val) => val === true ? fallback(obj) : val);
        return bundle(opt);
    };
    const extractField = (field, path, obj, key, prop) => {
        const bundle = (av) => prop.extract(path.concat([key]), av);
        const bundleAsOption = (optValue) => optValue.fold(() => SimpleResult.svalue(Optional.none()), (ov) => {
            const result = prop.extract(path.concat([key]), ov);
            return SimpleResult.map(result, Optional.some);
        });
        switch (field.tag) {
            case "required" /* FieldPresenceTag.Required */:
                return requiredAccess(path, obj, key, bundle);
            case "defaultedThunk" /* FieldPresenceTag.DefaultedThunk */:
                return fallbackAccess(obj, key, field.process, bundle);
            case "option" /* FieldPresenceTag.Option */:
                return optionAccess(obj, key, bundleAsOption);
            case "defaultedOptionThunk" /* FieldPresenceTag.DefaultedOptionThunk */:
                return optionDefaultedAccess(obj, key, field.process, bundleAsOption);
            case "mergeWithThunk" /* FieldPresenceTag.MergeWithThunk */: {
                return fallbackAccess(obj, key, constant({}), (v) => {
                    const result = deepMerge(field.process(obj), v);
                    return bundle(result);
                });
            }
        }
    };
    const extractFields = (path, obj, fields) => {
        const success = {};
        const errors = [];
        // PERFORMANCE: We use a for loop here instead of Arr.each as this is a hot code path
        for (const field of fields) {
            fold(field, (key, newKey, presence, prop) => {
                const result = extractField(presence, path, obj, key, prop);
                SimpleResult.fold(result, (err) => {
                    errors.push(...err);
                }, (res) => {
                    success[newKey] = res;
                });
            }, (newKey, instantiator) => {
                success[newKey] = instantiator(obj);
            });
        }
        return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
    };
    const objOf = (values) => {
        const extract = (path, o) => extractFields(path, o, values);
        const toString = () => {
            const fieldStrings = map$3(values, (value) => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));
            return 'obj{\n' + fieldStrings.join('\n') + '}';
        };
        return {
            extract,
            toString
        };
    };
    const arrOf = (prop) => {
        const extract = (path, array) => {
            const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));
            return ResultCombine.consolidateArr(results);
        };
        const toString = () => 'array(' + prop.toString() + ')';
        return {
            extract,
            toString
        };
    };

    const extractValue = (label, prop, obj) => {
        const res = prop.extract([label], obj);
        return SimpleResult.mapError(res, (errs) => ({ input: obj, errors: errs }));
    };
    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));
    const formatError = (errInfo) => {
        return 'Errors: \n' + formatErrors(errInfo.errors).join('\n') +
            '\n\nInput object: ' + formatObj(errInfo.input);
    };

    const field = field$1;
    const required = (key) => field(key, key, required$1(), anyValue());
    const requiredOf = (key, schema) => field(key, key, required$1(), schema);
    const requiredString = (key) => requiredOf(key, string);
    const requiredFunction = (key) => requiredOf(key, functionProcessor);
    const option = (key) => field(key, key, asOption(), anyValue());
    const optionOf = (key, schema) => field(key, key, asOption(), schema);
    const optionString = (key) => optionOf(key, string);
    const optionFunction = (key) => optionOf(key, functionProcessor);
    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());
    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);
    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);
    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));

    const type = requiredString('type');
    const fetch$1 = requiredFunction('fetch');
    const onAction = requiredFunction('onAction');
    optionString('name');
    optionString('text');
    optionString('role');
    optionString('icon');
    optionString('url');
    optionString('tooltip');
    optionString('chevronTooltip');
    optionString('label');
    optionString('shortcut');
    const defaultedColumns = (num) => defaulted('columns', num);

    const autocompleterSchema = objOf([
        type,
        requiredString('trigger'),
        defaultedNumber('minChars', 1),
        defaultedColumns(1),
        defaultedNumber('maxResults', 10),
        optionFunction('matches'),
        fetch$1,
        onAction,
        defaultedArrayOf('highlightOn', [], string)
    ]);
    const createAutocompleter = (spec) => asRaw('Autocompleter', autocompleterSchema, spec);

    const create$6 = () => {
        const buttons = {};
        const menuItems = {};
        const popups = {};
        const icons = {};
        const contextMenus = {};
        const contextToolbars = {};
        const contexts = {};
        const sidebars = {};
        const views = {};
        const add = (collection, type) => (name, spec) => {
            collection[name.toLowerCase()] = { ...spec, type };
        };
        const addDefaulted = (collection, type) => (name, spec) => {
            collection[name.toLowerCase()] = { type, ...spec };
        };
        const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;
        const addContext = (name, pred) => contexts[name.toLowerCase()] = pred;
        return {
            addButton: add(buttons, 'button'),
            addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),
            addToggleButton: add(buttons, 'togglebutton'),
            addMenuButton: add(buttons, 'menubutton'),
            addSplitButton: add(buttons, 'splitbutton'),
            addMenuItem: add(menuItems, 'menuitem'),
            addNestedMenuItem: add(menuItems, 'nestedmenuitem'),
            addToggleMenuItem: add(menuItems, 'togglemenuitem'),
            addAutocompleter: add(popups, 'autocompleter'),
            addContextMenu: add(contextMenus, 'contextmenu'),
            addContextToolbar: add(contextToolbars, 'contexttoolbar'),
            addContextForm: addDefaulted(contextToolbars, 'contextform'),
            addSidebar: add(sidebars, 'sidebar'),
            addView: add(views, 'views'),
            addIcon,
            addContext,
            getAll: () => ({
                buttons,
                menuItems,
                icons,
                // TODO: should popups be combined with context menus? We'd need to make a new add function.
                // Right now using `add` shares the key namespace, which prevents registering both
                // a completer and a context menu with the same name
                popups,
                contextMenus,
                contextToolbars,
                sidebars,
                views,
                contexts
            })
        };
    };

    const register$2 = (editor) => {
        const popups = editor.ui.registry.getAll().popups;
        const dataset = map$2(popups, (popup) => createAutocompleter(popup).fold((err) => {
            throw new Error(formatError(err));
        }, identity));
        const triggers = stringArray(mapToArray(dataset, (v) => v.trigger));
        const datasetValues = values(dataset);
        const lookupByTrigger = (trigger) => filter$5(datasetValues, (dv) => dv.trigger === trigger);
        return {
            dataset,
            triggers,
            lookupByTrigger
        };
    };

    const setupEditorInput = (editor, api) => {
        const update = last$1(api.load, 50);
        editor.on('input', (e) => {
            // TINY-10715: Firefox on Android using Korean Gboard will produce stray composition events when you move the caret by tapping inside the composed text
            if (e.inputType === 'insertCompositionText' && !editor.composing) {
                return;
            }
            update.throttle();
        });
        editor.on('keydown', (e) => {
            const keyCode = e.which;
            // Pressing <backspace> updates the autocompleter
            if (keyCode === 8) {
                update.throttle();
                // Pressing <esc> closes the autocompleter
            }
            else if (keyCode === 27) {
                update.cancel(); // We need to cancel here since Esc cancels the IME composition and triggers an input event
                api.cancelIfNecessary();
            }
            else if (keyCode === 38 || keyCode === 40) {
                // Arrow up and down keys needs to cancel the update since while composing arrow up or down will end the compose and issue a input event
                // that causes the list to update and then the focus moves up to the first item in the auto completer list.
                update.cancel();
            }
        }, true); // Need to add this to the top so that it exectued before the silver keyboard event
        editor.on('remove', update.cancel);
    };
    const setup$p = (editor) => {
        const activeAutocompleter = value$1();
        const uiActive = Cell(false);
        const isActive = activeAutocompleter.isSet;
        const cancelIfNecessary = () => {
            if (isActive()) {
                fireAutocompleterEnd(editor);
                uiActive.set(false);
                activeAutocompleter.clear();
            }
        };
        const commenceIfNecessary = (context) => {
            if (!isActive()) {
                // store the element/context
                activeAutocompleter.set({
                    trigger: context.trigger,
                    matchLength: context.text.length
                });
            }
        };
        // This needs to be calculated once things are ready, but the key events must be bound
        // before `init` or other keydown / keypress listeners will fire first. Therefore,
        // this is a thunk so that its value is calculated just once when it is used for the
        // first time, and after that it's value is stored.
        const getAutocompleters = cached(() => register$2(editor));
        const doLookup = (fetchOptions) => activeAutocompleter.get().map((ac) => getContext(editor.dom, editor.selection.getRng(), ac.trigger, true)
            .bind((newContext) => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));
        const load = (fetchOptions) => {
            doLookup(fetchOptions).fold(cancelIfNecessary, (lookupInfo) => {
                commenceIfNecessary(lookupInfo.context);
                // Wait for the results to return and then display the menu
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                lookupInfo.lookupData.then((lookupData) => {
                    // Lookup the active autocompleter to make sure it's still active, if it isn't then do nothing
                    activeAutocompleter.get().map((ac) => {
                        const context = lookupInfo.context;
                        // Ensure the active autocompleter trigger matches, as the old one may have closed
                        // and a new one may have opened. If it doesn't match, then do nothing.
                        if (ac.trigger !== context.trigger) {
                            return;
                        }
                        activeAutocompleter.set({
                            ...ac,
                            matchLength: context.text.length
                        });
                        if (uiActive.get()) {
                            fireAutocompleterUpdateActiveRange(editor, { range: context.range });
                            fireAutocompleterUpdate(editor, { lookupData });
                        }
                        else {
                            uiActive.set(true);
                            fireAutocompleterUpdateActiveRange(editor, { range: context.range });
                            fireAutocompleterStart(editor, { lookupData });
                        }
                    });
                });
            });
        };
        const isRangeInsideOrEqual = (innerRange, outerRange) => {
            const startComparison = innerRange.compareBoundaryPoints(window.Range.START_TO_START, outerRange);
            const endComparison = innerRange.compareBoundaryPoints(window.Range.END_TO_END, outerRange);
            return startComparison >= 0 && endComparison <= 0;
        };
        const readActiveRange = () => {
            return activeAutocompleter.get().bind(({ trigger }) => {
                const selRange = editor.selection.getRng();
                return getContext(editor.dom, selRange, trigger, uiActive.get())
                    .filter(({ range }) => isRangeInsideOrEqual(selRange, range))
                    .map(({ range }) => range);
            });
        };
        editor.addCommand('mceAutocompleterReload', (_ui, value) => {
            const fetchOptions = isObject(value) ? value.fetchOptions : {};
            load(fetchOptions);
        });
        editor.addCommand('mceAutocompleterClose', cancelIfNecessary);
        editor.addCommand('mceAutocompleterRefreshActiveRange', () => {
            readActiveRange().each((range) => {
                fireAutocompleterUpdateActiveRange(editor, { range });
            });
        });
        editor.editorCommands.addQueryStateHandler('mceAutoCompleterInRange', () => readActiveRange().isSome());
        setupEditorInput(editor, {
            cancelIfNecessary,
            load
        });
    };

    const browser$1 = detect$1().browser;
    const isSafari = browser$1.isSafari();
    const emptyNodeContents = (node) => fillWithPaddingBr(SugarElement.fromDom(node));
    const isEntireNodeSelected = (rng, node) => { var _a; return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length); };
    const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));
    const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();
    const getDetailsElements = (dom, rng) => {
        const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));
        const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));
        if (startDetails.isSome() || endDetails.isSome()) {
            const startSummary = startDetails.bind((details) => Optional.from(dom.select('summary', details)[0]));
            return Optional.some({ startSummary, startDetails, endDetails });
        }
        else {
            return Optional.none();
        }
    };
    const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists((pos) => pos.isEqual(caretPos));
    const isCaretInTheEndOf = (caretPos, element) => {
        return lastPositionIn(element).exists((pos) => {
            // Summary may or may not have a trailing BR
            if (isBr$7(pos.getNode())) {
                return prevPosition(element, pos).exists((pos2) => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);
            }
            else {
                return pos.isEqual(caretPos);
            }
        });
    };
    const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists((summary) => isCaretInTheBeginningOf(caretPos, summary));
    const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists((summary) => isCaretInTheEndOf(caretPos, summary));
    const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists((details) => prevPosition(details, caretPos).forall((pos) => detailsElements.startSummary.exists((summary) => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));
    const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists((details) => nextPosition(root, caretPos).forall((pos) => !details.contains(pos.container())));
    const setCaretToPosition = (editor, position) => {
        const node = position.getNode();
        if (!isUndefined(node)) {
            editor.selection.setCursorLocation(node, position.offset());
        }
    };
    const moveCaretToDetailsPos = (editor, pos, forward) => {
        const details = editor.dom.getParent(pos.container(), 'details');
        if (details && !details.open) {
            const summary = editor.dom.select('summary', details)[0];
            if (summary) {
                const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);
                newPos.each((pos) => setCaretToPosition(editor, pos));
            }
        }
        else {
            setCaretToPosition(editor, pos);
        }
    };
    const isPartialDelete = (rng, detailsElements) => {
        const containsStart = (element) => element.contains(rng.startContainer);
        const containsEnd = (element) => element.contains(rng.endContainer);
        const startInSummary = detailsElements.startSummary.exists(containsStart);
        const endInSummary = detailsElements.startSummary.exists(containsEnd);
        const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall((startDetails) => detailsElements.endDetails.forall((endDetails) => startDetails !== endDetails));
        const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);
        return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;
    };
    const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {
        const { dom, selection } = editor;
        const root = editor.getBody();
        if (granularity === 'character') {
            const caretPos = CaretPosition.fromRangeStart(selection.getRng());
            const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);
            const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);
            const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);
            const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);
            const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);
            // Pressing backspace or delete in an first or last empty block before or after details
            if (inEmptyParentBlock) {
                const firstOrLast = forward ? isLastBlock : isFirstBlock;
                if (firstOrLast) {
                    const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists((pos) => {
                        return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));
                    });
                    if (isBeforeAfterDetails) {
                        return true;
                    }
                }
            }
            return navigate(forward, root, caretPos).fold(never, (pos) => {
                const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);
                if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {
                    if (!forward) {
                        moveCaretToDetailsPos(editor, pos, false);
                    }
                    if (parentBlock && inEmptyParentBlock) {
                        if (forward && isFirstBlock) {
                            return true;
                        }
                        else if (!forward && isLastBlock) {
                            return true;
                        }
                        moveCaretToDetailsPos(editor, pos, forward);
                        editor.dom.remove(parentBlock);
                    }
                    return true;
                }
                else {
                    return false;
                }
            });
        }
        else {
            return false;
        }
    };
    const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {
        const selection = editor.selection;
        const rng = selection.getRng();
        const caretPos = CaretPosition.fromRangeStart(rng);
        const root = editor.getBody();
        if (granularity === 'selection') {
            return isPartialDelete(rng, detailElements);
        }
        else if (forward) {
            return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);
        }
        else {
            return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);
        }
    };
    const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), (detailsElements) => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));
    const handleDeleteActionSafari = (editor, forward, granularity) => {
        const selection = editor.selection;
        const node = selection.getNode();
        const rng = selection.getRng();
        const caretPos = CaretPosition.fromRangeStart(rng);
        if (isSummary$1(node)) {
            // TINY-9951: Safari bug, deleting within the summary causes all content to be removed and no caret position to be left
            // https://bugs.webkit.org/show_bug.cgi?id=257745
            if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {
                emptyNodeContents(node);
            }
            else {
                editor.undoManager.transact(() => {
                    // Wrap all summary children in a temporary container to execute Backspace/Delete there, then unwrap
                    const sel = selection.getSel();
                    let { anchorNode, anchorOffset, focusNode, focusOffset } = sel !== null && sel !== void 0 ? sel : {};
                    const applySelection = () => {
                        if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {
                            sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
                        }
                    };
                    const updateSelection = () => {
                        anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
                        anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;
                        focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
                        focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;
                    };
                    const appendAllChildNodes = (from, to) => {
                        each$e(from.childNodes, (child) => {
                            if (isNode(child)) {
                                to.appendChild(child);
                            }
                        });
                    };
                    const container = editor.dom.create('span', { 'data-mce-bogus': '1' });
                    appendAllChildNodes(node, container);
                    node.appendChild(container);
                    applySelection();
                    // Manually perform deletion with modified granularities
                    if (granularity === 'word' || granularity === 'line') {
                        sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);
                    }
                    if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {
                        emptyNodeContents(node);
                    }
                    else {
                        editor.execCommand(forward ? 'ForwardDelete' : 'Delete');
                        updateSelection();
                        appendAllChildNodes(container, node);
                        applySelection();
                    }
                    editor.dom.remove(container);
                });
            }
            return true;
        }
        else {
            return false;
        }
    };
    const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity)
        ? Optional.some(noop) : Optional.none();

    const createAndFireInputEvent = (eventType) => (editor, inputType, specifics = {}) => {
        const target = editor.getBody();
        const overrides = {
            bubbles: true,
            composed: true,
            data: null,
            isComposing: false,
            detail: 0,
            view: null,
            target,
            currentTarget: target,
            eventPhase: Event.AT_TARGET,
            originalTarget: target,
            explicitOriginalTarget: target,
            isTrusted: false,
            srcElement: target,
            cancelable: false,
            preventDefault: noop,
            inputType
        };
        const input = clone$2(new InputEvent(eventType));
        return editor.dispatch(eventType, { ...input, ...overrides, ...specifics });
    };
    const fireInputEvent = createAndFireInputEvent('input');
    const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');

    const platform$2 = detect$1();
    const os = platform$2.os;
    const isMacOSOriOS = os.isMacOS() || os.isiOS();
    const browser = platform$2.browser;
    const isFirefox = browser.isFirefox();
    const executeKeydownOverride$3 = (editor, caret, evt) => {
        const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';
        const isCollapsed = editor.selection.isCollapsed();
        const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';
        const getModifiedGranularity = (isWord) => {
            if (isCollapsed) {
                return isWord ? 'word' : 'line';
            }
            else {
                return 'selection';
            }
        };
        executeWithDelayedAction([
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$2, editor) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$8, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$8, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$9, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$9, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$5, editor, caret, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$5, editor, caret, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$d, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$d, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete, editor, false, unmodifiedGranularity) },
            { keyCode: VK.DELETE, action: action(backspaceDelete, editor, true, unmodifiedGranularity) },
            ...isMacOSOriOS ? [
                { keyCode: VK.BACKSPACE, altKey: true, action: action(backspaceDelete, editor, false, getModifiedGranularity(true)) },
                { keyCode: VK.DELETE, altKey: true, action: action(backspaceDelete, editor, true, getModifiedGranularity(true)) },
                { keyCode: VK.BACKSPACE, metaKey: true, action: action(backspaceDelete, editor, false, getModifiedGranularity(false)) },
            ] : [
                { keyCode: VK.BACKSPACE, ctrlKey: true, action: action(backspaceDelete, editor, false, getModifiedGranularity(true)) },
                { keyCode: VK.DELETE, ctrlKey: true, action: action(backspaceDelete, editor, true, getModifiedGranularity(true)) }
            ],
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$6, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$6, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$3, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$3, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$a, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$a, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$b, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$b, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$4, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$4, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$7, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$7, editor, true) },
            { keyCode: VK.BACKSPACE, action: action(backspaceDelete$1, editor, false) },
            { keyCode: VK.DELETE, action: action(backspaceDelete$1, editor, true) },
        ], evt)
            .filter((_) => editor.selection.isEditable())
            .each((applyAction) => {
            evt.preventDefault();
            const beforeInput = fireBeforeInputEvent(editor, inputType);
            if (!beforeInput.isDefaultPrevented()) {
                applyAction();
                fireInputEvent(editor, inputType);
            }
        });
    };
    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([
        { keyCode: VK.BACKSPACE, action: action(paddEmptyElement, editor) },
        { keyCode: VK.DELETE, action: action(paddEmptyElement, editor) },
        ...isMacOSOriOS ? [
            { keyCode: VK.BACKSPACE, altKey: true, action: action(refreshCaret, editor) },
            { keyCode: VK.DELETE, altKey: true, action: action(refreshCaret, editor) },
            // macOS surpresses keyup events for most keys including Backspace when Meta key is engaged
            // To emulate Meta + Backspace on macOS, add a pattern for the meta key when backspace was
            // detected on keydown
            ...isBackspaceKeydown ? [{
                    // Firefox detects macOS Command key code as "Command" not "Meta"
                    keyCode: isFirefox ? 224 : 91,
                    action: action(refreshCaret, editor)
                }] : []
        ] : [
            { keyCode: VK.BACKSPACE, ctrlKey: true, action: action(refreshCaret, editor) },
            { keyCode: VK.DELETE, ctrlKey: true, action: action(refreshCaret, editor) }
        ]
    ], evt);
    const setup$o = (editor, caret) => {
        // track backspace keydown state for emulating Meta + Backspace keyup detection on macOS
        let isBackspaceKeydown = false;
        editor.on('keydown', (evt) => {
            isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;
            if (!evt.isDefaultPrevented()) {
                executeKeydownOverride$3(editor, caret, evt);
            }
        });
        editor.on('keyup', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeyupOverride(editor, evt, isBackspaceKeydown);
            }
            isBackspaceKeydown = false;
        });
    };

    const reduceFontStyleNesting = (block, node) => {
        const blockSugar = SugarElement.fromDom(block);
        const nodeSugar = SugarElement.fromDom(node);
        const isSpan = isTag('span');
        const isEndBlock = curry(eq, blockSugar);
        const hasFontSize = (element) => isElement$8(element) && getRaw$1(element, 'font-size').isSome();
        const elementsWithFontSize = [
            ...(hasFontSize(nodeSugar) ? [nodeSugar] : []),
            ...ancestors$1(nodeSugar, hasFontSize, isEndBlock)
        ];
        each$e(elementsWithFontSize.slice(1), (element) => {
            remove$7(element, 'font-size');
            remove$9(element, 'data-mce-style');
            if (isSpan(element) && hasNone(element)) {
                unwrap(element);
            }
        });
    };

    const firstNonWhiteSpaceNodeSibling = (node) => {
        while (node) {
            if (isElement$7(node) || (isText$b(node) && node.data && /[\r\n\s]/.test(node.data))) {
                return Optional.from(SugarElement.fromDom(node));
            }
            node = node.nextSibling;
        }
        return Optional.none();
    };
    const moveToCaretPosition = (editor, root) => {
        const dom = editor.dom;
        const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
        if (!root) {
            return;
        }
        if (/^(LI|DT|DD)$/.test(root.nodeName)) {
            const isList = (e) => /^(ul|ol|dl)$/.test(name(e));
            const findFirstList = (e) => isList(e) ? Optional.from(e) : descendant$2(e, isList);
            const isEmpty = (e) => dom.isEmpty(e.dom);
            firstNonWhiteSpaceNodeSibling(root.firstChild).each((firstChild) => {
                findFirstList(firstChild).fold(() => {
                    if (isEmpty(firstChild)) {
                        const element = toLeaf$1(firstChild, 0).element;
                        if (!isBr$6(element)) {
                            append$1(element, SugarElement.fromText(nbsp));
                        }
                    }
                }, (firstList) => {
                    before$4(firstList, SugarElement.fromText(nbsp));
                });
            });
        }
        const rng = dom.createRng();
        root.normalize();
        if (root.hasChildNodes()) {
            const walker = new DomTreeWalker(root, root);
            let lastNode = root;
            let node;
            while ((node = walker.current())) {
                if (isText$b(node)) {
                    rng.setStart(node, 0);
                    rng.setEnd(node, 0);
                    break;
                }
                if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
                    rng.setStartBefore(node);
                    rng.setEndBefore(node);
                    break;
                }
                lastNode = node;
                node = walker.next();
            }
            if (!node) {
                rng.setStart(lastNode, 0);
                rng.setEnd(lastNode, 0);
            }
        }
        else {
            if (isBr$7(root)) {
                if (root.nextSibling && dom.isBlock(root.nextSibling)) {
                    rng.setStartBefore(root);
                    rng.setEndBefore(root);
                }
                else {
                    rng.setStartAfter(root);
                    rng.setEndAfter(root);
                }
            }
            else {
                rng.setStart(root, 0);
                rng.setEnd(root, 0);
            }
        }
        editor.selection.setRng(rng);
        scrollRangeIntoView(editor, rng);
    };
    const getEditableRoot = (dom, node) => {
        const root = dom.getRoot();
        let editableRoot;
        // Get all parents until we hit a non editable parent or the root
        let parent = node;
        while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {
            if (dom.getContentEditable(parent) === 'true') {
                editableRoot = parent;
                break;
            }
            parent = parent.parentNode;
        }
        return parent !== root ? editableRoot : root;
    };
    const getParentBlock$1 = (editor) => {
        return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
    };
    const getParentBlockName = (editor) => {
        return getParentBlock$1(editor).fold(constant(''), (parentBlock) => {
            return parentBlock.nodeName.toUpperCase();
        });
    };
    const isListItemParentBlock = (editor) => {
        return getParentBlock$1(editor).filter((elm) => {
            return isListItem$2(SugarElement.fromDom(elm));
        }).isSome();
    };
    const emptyBlock = (elm) => {
        elm.innerHTML = '<br data-mce-bogus="1">';
    };
    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {
        const dom = editor.dom;
        // Merge and apply style attribute
        Optional.from(forcedRootBlockAttrs.style)
            .map(dom.parseStyle)
            .each((attrStyles) => {
            const currentStyles = getAllRaw(SugarElement.fromDom(node));
            const newStyles = { ...currentStyles, ...attrStyles };
            dom.setStyles(node, newStyles);
        });
        // Merge and apply class attribute
        const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map((attrClasses) => attrClasses.split(/\s+/));
        const currentClassesOpt = Optional.from(node.className).map((currentClasses) => filter$5(currentClasses.split(/\s+/), (clazz) => clazz !== ''));
        lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {
            const filteredClasses = filter$5(currentClasses, (clazz) => !contains$2(attrClasses, clazz));
            const newClasses = [...attrClasses, ...filteredClasses];
            dom.setAttrib(node, 'class', newClasses.join(' '));
        });
        // Apply any remaining forced root block attributes
        const appliedAttrs = ['style', 'class'];
        const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));
        dom.setAttribs(node, remainingAttrs);
    };
    const setForcedBlockAttrs = (editor, node) => {
        const forcedRootBlockName = getForcedRootBlock(editor);
        if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
            const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);
            applyAttributes(editor, node, forcedRootBlockAttrs);
        }
    };
    // Creates a new block element by cloning the current one or creating a new one if the name is specified
    // This function will also copy any text formatting from the parent block and add it to the new one
    const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name, styles) => {
        const dom = editor.dom;
        const schema = editor.schema;
        const newBlockName = getForcedRootBlock(editor);
        const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
        let node = container;
        const textInlineElements = schema.getTextInlineElements();
        let block;
        if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {
            block = dom.create(name || newBlockName, styles || {});
        }
        else {
            block = parentBlock.cloneNode(false);
        }
        let caretNode = block;
        if (!keepStyles) {
            dom.setAttrib(block, 'style', null); // wipe out any styles that came over with the block
            dom.setAttrib(block, 'class', null);
        }
        else {
            // Clone any parent styles
            do {
                if (textInlineElements[node.nodeName]) {
                    // Ignore caret or bookmark nodes when cloning
                    if (isCaretNode(node) || isBookmarkNode$1(node)) {
                        continue;
                    }
                    const clonedNode = node.cloneNode(false);
                    dom.setAttrib(clonedNode, 'id', ''); // Remove ID since it needs to be document unique
                    if (block.hasChildNodes()) {
                        clonedNode.appendChild(block.firstChild);
                        block.appendChild(clonedNode);
                    }
                    else {
                        caretNode = clonedNode;
                        block.appendChild(clonedNode);
                    }
                }
            } while ((node = node.parentNode) && node !== editableRoot);
            reduceFontStyleNesting(block, caretNode);
        }
        setForcedBlockAttrs(editor, block);
        emptyBlock(caretNode);
        return block;
    };

    const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);
    const isAtDetailsEdge = (root, element, isTextBlock) => {
        let node = element;
        while (node && node !== root && isNull(node.nextSibling)) {
            const parent = node.parentElement;
            if (!parent || !isTextBlock(parent)) {
                return isDetails(parent);
            }
            node = parent;
        }
        return false;
    };
    const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey &&
        element.nodeName.toLowerCase() === getForcedRootBlock(editor) &&
        editor.dom.isEmpty(element) &&
        isAtDetailsEdge(editor.getBody(), element, (el) => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));
    const insertNewLine = (editor, createNewBlock, parentBlock) => {
        var _a, _b, _c;
        const newBlock = createNewBlock(getForcedRootBlock(editor));
        const root = getDetailsRoot(editor, parentBlock);
        if (!root) {
            return;
        }
        editor.dom.insertAfter(newBlock, root);
        moveToCaretPosition(editor, newBlock);
        // TODO: This now only works with our Accordions not details with multiple root level children should we support that
        if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {
            editor.dom.remove(parentBlock);
        }
    };

    const hasFirstChild = (elm, name) => {
        return elm.firstChild && elm.firstChild.nodeName === name;
    };
    const isFirstChild = (elm) => {
        var _a;
        return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;
    };
    const hasParent = (elm, parentName) => {
        const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;
        return isNonNullable(parentNode) && parentNode.nodeName === parentName;
    };
    const isListBlock = (elm) => {
        return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);
    };
    const isListItem = (elm) => {
        return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);
    };
    const isNestedList = (elm) => {
        return isListBlock(elm) && isListBlock(elm.parentNode);
    };
    const getContainerBlock = (containerBlock) => {
        const containerBlockParent = containerBlock.parentNode;
        return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;
    };
    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {
        let node = containerBlock[first ? 'firstChild' : 'lastChild'];
        // Find first/last element since there might be whitespace there
        while (node) {
            if (isElement$7(node)) {
                break;
            }
            node = node[first ? 'nextSibling' : 'previousSibling'];
        }
        return node === parentBlock;
    };
    const getStyles = (elm) => foldl(mapToArray(getAllRaw(SugarElement.fromDom(elm)), (style, styleName) => `${styleName}: ${style};`), (acc, s) => acc + s, '');
    // Inserts a block or br before/after or in the middle of a split list of the LI is empty
    const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {
        const dom = editor.dom;
        const rng = editor.selection.getRng();
        const containerParent = containerBlock.parentNode;
        if (containerBlock === editor.getBody() || !containerParent) {
            return;
        }
        if (isNestedList(containerBlock)) {
            newBlockName = 'LI';
        }
        const parentBlockStyles = isListItem(parentBlock) ? getStyles(parentBlock) : undefined;
        let newBlock = isListItem(parentBlock) && parentBlockStyles
            ? createNewBlock(newBlockName, { style: getStyles(parentBlock) })
            : createNewBlock(newBlockName);
        if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
            if (hasParent(containerBlock, 'LI')) {
                // Nested list is inside a LI
                const containerBlockParent = getContainerBlock(containerBlock);
                dom.insertAfter(newBlock, containerBlockParent);
                if (isFirstChild(containerBlock)) {
                    dom.remove(containerBlockParent);
                }
                else {
                    dom.remove(containerBlock);
                }
            }
            else {
                // Is first and last list item then replace the OL/UL with a text block
                dom.replace(newBlock, containerBlock);
            }
        }
        else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
            if (hasParent(containerBlock, 'LI')) {
                // List nested in an LI then move the list to a new sibling LI
                dom.insertAfter(newBlock, getContainerBlock(containerBlock));
                newBlock.appendChild(dom.doc.createTextNode(' ')); // Needed for IE so the caret can be placed
                newBlock.appendChild(containerBlock);
            }
            else {
                // First LI in list then remove LI and add text block before list
                containerParent.insertBefore(newBlock, containerBlock);
            }
            dom.remove(parentBlock);
        }
        else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
            // Last LI in list then remove LI and add text block after list
            dom.insertAfter(newBlock, getContainerBlock(containerBlock));
            dom.remove(parentBlock);
        }
        else {
            // Middle LI in list then split the list and insert a text block in the middle
            // Extract after fragment and insert it after the current block
            containerBlock = getContainerBlock(containerBlock);
            const tmpRng = rng.cloneRange();
            tmpRng.setStartAfter(parentBlock);
            tmpRng.setEndAfter(containerBlock);
            const fragment = tmpRng.extractContents();
            if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {
                const previousChildren = filter$5(map$3(newBlock.children, SugarElement.fromDom), not(isTag('br')));
                newBlock = fragment.firstChild;
                dom.insertAfter(fragment, containerBlock);
                each$e(previousChildren, (child) => prepend(SugarElement.fromDom(newBlock), child));
                if (parentBlockStyles) {
                    newBlock.setAttribute('style', parentBlockStyles);
                }
            }
            else {
                dom.insertAfter(fragment, containerBlock);
                dom.insertAfter(newBlock, containerBlock);
            }
            dom.remove(parentBlock);
        }
        moveToCaretPosition(editor, newBlock);
    };

    const trimZwsp = (fragment) => {
        each$e(descendants$1(SugarElement.fromDom(fragment), isText$c), (text) => {
            const rawNode = text.dom;
            rawNode.nodeValue = trim$2(rawNode.data);
        });
    };
    const isWithinNonEditableList = (editor, node) => {
        const parentList = editor.dom.getParent(node, 'ol,ul,dl');
        return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';
    };
    const isEmptyAnchor = (dom, elm) => {
        return elm && elm.nodeName === 'A' && dom.isEmpty(elm);
    };
    const containerAndPreviousSiblingName = (container, nodeName) => {
        return container.nodeName === nodeName || (container.previousSibling && container.previousSibling.nodeName === nodeName);
    };
    const containerAndNextSiblingName = (container, nodeName) => {
        return container.nodeName === nodeName || (container.nextSibling && container.nextSibling.nodeName === nodeName);
    };
    // Returns true if the block can be split into two blocks or not
    const canSplitBlock = (dom, node) => {
        return isNonNullable(node) &&
            dom.isBlock(node) &&
            !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) &&
            !/^(fixed|absolute)/i.test(node.style.position) &&
            dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';
    };
    // Remove the first empty inline element of the block so this: <p><b><em></em></b>x</p> becomes this: <p>x</p>
    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {
        var _a;
        const firstChilds = [];
        if (!block) {
            return;
        }
        // Find inner most first child ex: <p><i><b>*</b></i></p>
        let currentNode = block;
        while ((currentNode = currentNode.firstChild)) {
            if (dom.isBlock(currentNode)) {
                return;
            }
            if (isElement$7(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {
                firstChilds.push(currentNode);
            }
        }
        let i = firstChilds.length;
        while (i--) {
            currentNode = firstChilds[i];
            if (!currentNode.hasChildNodes() || (currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '')) {
                dom.remove(currentNode);
            }
            else {
                if (isEmptyAnchor(dom, currentNode)) {
                    dom.remove(currentNode);
                }
            }
        }
    };
    const normalizeZwspOffset = (start, container, offset) => {
        if (!isText$b(container)) {
            return offset;
        }
        else if (start) {
            return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;
        }
        else {
            return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;
        }
    };
    const includeZwspInRange = (rng) => {
        const newRng = rng.cloneRange();
        newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
        newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
        return newRng;
    };
    // Trims any linebreaks at the beginning of node user for example when pressing enter in a PRE element
    const trimLeadingLineBreaks = (node) => {
        let currentNode = node;
        do {
            if (isText$b(currentNode)) {
                currentNode.data = currentNode.data.replace(/^[\r\n]+/, '');
            }
            currentNode = currentNode.firstChild;
        } while (currentNode);
    };
    // Wraps any text nodes or inline elements in the specified forced root block name
    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {
        var _a, _b;
        const dom = editor.dom;
        const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();
        // Not in a block element or in a table cell or caption
        let parentBlock = dom.getParent(container, dom.isBlock);
        if (!parentBlock || !canSplitBlock(dom, parentBlock)) {
            parentBlock = parentBlock || editableRoot;
            if (!parentBlock.hasChildNodes()) {
                const newBlock = dom.create(newBlockName);
                setForcedBlockAttrs(editor, newBlock);
                parentBlock.appendChild(newBlock);
                rng.setStart(newBlock, 0);
                rng.setEnd(newBlock, 0);
                return newBlock;
            }
            // Find parent that is the first child of parentBlock
            let node = container;
            while (node && node.parentNode !== parentBlock) {
                node = node.parentNode;
            }
            // Loop left to find start node start wrapping at
            let startNode;
            while (node && !dom.isBlock(node)) {
                startNode = node;
                node = node.previousSibling;
            }
            const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;
            if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {
                // This should never be null since we check it above
                const startNodeParent = startNode.parentNode;
                const newBlock = dom.create(newBlockName);
                setForcedBlockAttrs(editor, newBlock);
                startNodeParent.insertBefore(newBlock, startNode);
                // Start wrapping until we hit a block
                node = startNode;
                while (node && !dom.isBlock(node)) {
                    const next = node.nextSibling;
                    newBlock.appendChild(node);
                    node = next;
                }
                // Restore range to it's past location
                rng.setStart(container, offset);
                rng.setEnd(container, offset);
            }
        }
        return container;
    };
    // Adds a BR at the end of blocks that only contains an IMG or INPUT since
    // these might be floated and then they won't expand the block
    const addBrToBlockIfNeeded = (dom, block) => {
        // IE will render the blocks correctly other browsers needs a BR
        block.normalize(); // Remove empty text nodes that got left behind by the extract
        // Check if the block is empty or contains a floated last child
        const lastChild = block.lastChild;
        if (!lastChild || isElement$7(lastChild) && (/^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true)))) {
            dom.add(block, 'br');
        }
    };
    const shouldEndContainer = (editor, container) => {
        const optionValue = shouldEndContainerOnEmptyBlock(editor);
        if (isNullable(container)) {
            return false;
        }
        else if (isString(optionValue)) {
            return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());
        }
        else {
            return optionValue;
        }
    };
    const insert$3 = (editor, evt) => {
        let container;
        let offset;
        let parentBlockName;
        let containerBlock;
        let isAfterLastNodeInContainer = false;
        const dom = editor.dom;
        const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
        const rng = editor.selection.getRng();
        const newBlockName = getForcedRootBlock(editor);
        const start = SugarElement.fromDom(rng.startContainer);
        const child = child$1(start, rng.startOffset);
        const isCef = child.exists((element) => isHTMLElement$1(element) && !isEditable$2(element));
        const collapsedAndCef = rng.collapsed && isCef;
        const createNewBlock$1 = (name, styles) => {
            return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name, styles);
        };
        // Returns true/false if the caret is at the start/end of the parent block element
        const isCaretAtStartOrEndOfBlock = (start) => {
            const normalizedOffset = normalizeZwspOffset(start, container, offset);
            // Caret is in the middle of a text node like "a|b"
            if (isText$b(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {
                return false;
            }
            // If after the last element in block node edge case for #5091
            if ((container.parentNode === parentBlock || container === parentBlock) && isAfterLastNodeInContainer && !start) {
                return true;
            }
            // If the caret if before the first element in parentBlock
            if (start && isElement$7(container) && container === parentBlock.firstChild) {
                return true;
            }
            // Caret can be before/after a table or a hr
            if (containerAndPreviousSiblingName(container, 'TABLE') || containerAndPreviousSiblingName(container, 'HR')) {
                if (containerAndNextSiblingName(container, 'BR')) {
                    return !start;
                }
                return (isAfterLastNodeInContainer && !start) || (!isAfterLastNodeInContainer && start);
            }
            // Walk the DOM and look for text nodes or non empty elements
            const walker = new DomTreeWalker(container, parentBlock);
            // If caret is in beginning or end of a text block then jump to the next/previous node
            if (isText$b(container)) {
                if (start && normalizedOffset === 0) {
                    walker.prev();
                }
                else if (!start && normalizedOffset === container.data.length) {
                    walker.next();
                }
            }
            let node;
            while ((node = walker.current())) {
                if (isElement$7(node)) {
                    // Ignore bogus elements
                    if (!node.getAttribute('data-mce-bogus')) {
                        // Keep empty elements like <img /> <input /> but not trailing br:s like <p>text|<br></p>
                        const name = node.nodeName.toLowerCase();
                        if (nonEmptyElementsMap[name] && name !== 'br') {
                            return false;
                        }
                    }
                }
                else if (isText$b(node) && !isWhitespaceText(node.data)) {
                    return false;
                }
                if (start) {
                    walker.prev();
                }
                else {
                    walker.next();
                }
            }
            return true;
        };
        const insertNewBlockAfter = () => {
            let block;
            // If the caret is at the end of a header we produce a P tag after it similar to Word unless we are in a hgroup
            if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {
                block = createNewBlock$1(newBlockName);
            }
            else {
                block = createNewBlock$1();
            }
            // Split the current container block element if enter is pressed inside an empty inner block element
            if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, { includeZwsp: true })) {
                // Split container block for example a BLOCKQUOTE at the current blockParent location for example a P
                block = dom.split(containerBlock, parentBlock);
            }
            else {
                dom.insertAfter(block, parentBlock);
            }
            moveToCaretPosition(editor, block);
            return block;
        };
        // Setup range items and newBlockName
        normalize$2(dom, rng).each((normRng) => {
            rng.setStart(normRng.startContainer, normRng.startOffset);
            rng.setEnd(normRng.endContainer, normRng.endOffset);
        });
        container = rng.startContainer;
        offset = rng.startOffset;
        const shiftKey = !!(evt && evt.shiftKey);
        const ctrlKey = !!(evt && evt.ctrlKey);
        // Resolve node index
        if (isElement$7(container) && container.hasChildNodes() && !collapsedAndCef) {
            isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && isText$b(container)) {
                offset = container.data.length;
            }
            else {
                offset = 0;
            }
        }
        // Get editable root node, normally the body element but sometimes a div or span
        const editableRoot = getEditableRoot(dom, container);
        // If there is no editable root then enter is done inside a contentEditable false element
        if (!editableRoot || isWithinNonEditableList(editor, container)) {
            return;
        }
        // Wrap the current node and it's sibling in a default block if it's needed.
        // for example this <td>text|<b>text2</b></td> will become this <td><p>text|<b>text2</p></b></td>
        // This won't happen if root blocks are disabled or the shiftKey is pressed
        if (!shiftKey) {
            container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
        }
        // Find parent block and setup empty block paddings
        let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();
        containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
        // Setup block names
        parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
        const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
        // Enter inside block contained within a LI then split or insert before/after LI
        if (containerBlockName === 'LI' && !ctrlKey) {
            const liBlock = containerBlock;
            parentBlock = liBlock;
            containerBlock = liBlock.parentNode;
            parentBlockName = containerBlockName;
        }
        if (isElement$7(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {
            return insertNewLine(editor, createNewBlock$1, parentBlock);
        }
        // Handle enter in list item
        if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$7(containerBlock)) {
            // Handle enter inside an empty list item
            if (dom.isEmpty(parentBlock)) {
                insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);
                return;
            }
        }
        // Never split the body or blocks that we can't split like noneditable host elements
        if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {
            return;
        }
        const parentBlockParent = parentBlock.parentNode;
        // Insert new block before/after the parent block depending on caret location
        let newBlock;
        if (collapsedAndCef) {
            newBlock = createNewBlock$1(newBlockName);
            child.fold(() => {
                append$1(start, SugarElement.fromDom(newBlock));
            }, (child) => {
                before$4(child, SugarElement.fromDom(newBlock));
            });
            editor.selection.setCursorLocation(newBlock, 0);
        }
        else if (isCaretContainerBlock$1(parentBlock)) {
            // TODO: TINY-10384 NOTE: Added logic to make sure pressing enter is consistent between browsers.
            // As an example a fake caret is used before/after tables on Firefox but not on Chrome. So different behaviour could occur
            newBlock = showCaretContainerBlock(parentBlock);
            if (dom.isEmpty(parentBlock)) {
                emptyBlock(parentBlock);
            }
            setForcedBlockAttrs(editor, newBlock);
            moveToCaretPosition(editor, newBlock);
        }
        else if (isCaretAtStartOrEndOfBlock(false)) {
            // Caret is moved to the new block in the insertNewBlockAfter fn
            newBlock = insertNewBlockAfter();
        }
        else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {
            // Check where caret is positioned before it is potentially moved by 'insertBefore' fn
            const caretPos = CaretPosition.fromRangeStart(rng);
            const afterTable = isAfterTable(caretPos);
            const parentBlockSugar = SugarElement.fromDom(parentBlock);
            const afterBr = isAfterBr(parentBlockSugar, caretPos, editor.schema);
            const prevBrOpt = afterBr
                ? findPreviousBr(parentBlockSugar, caretPos, editor.schema).bind((pos) => Optional.from(pos.getNode()))
                : Optional.none();
            newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);
            const root = containerAndPreviousSiblingName(parentBlock, 'HR') || afterTable ? newBlock : prevBrOpt.getOr(parentBlock);
            moveToCaretPosition(editor, root);
        }
        else {
            // Extract after fragment and insert it after the current block
            const tmpRng = includeZwspInRange(rng).cloneRange();
            tmpRng.setEndAfter(parentBlock);
            const fragment = tmpRng.extractContents();
            trimZwsp(fragment);
            trimLeadingLineBreaks(fragment);
            newBlock = fragment.firstChild;
            if (parentBlock === newBlock) { // Can't add yourself to yourself. Additionally the newBlock is removed from the DOM earlier, so even if you could, it'd still not work.
                if (isNonNullable(parentBlockParent)) {
                    dom.insertAfter(fragment, parentBlockParent);
                }
            }
            else {
                dom.insertAfter(fragment, parentBlock);
            }
            trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);
            addBrToBlockIfNeeded(dom, parentBlock);
            if (dom.isEmpty(parentBlock)) {
                emptyBlock(parentBlock);
            }
            newBlock.normalize();
            // New block might become empty if it's <p><b>a |</b></p>
            if (dom.isEmpty(newBlock)) {
                dom.remove(newBlock);
                insertNewBlockAfter();
            }
            else {
                setForcedBlockAttrs(editor, newBlock);
                moveToCaretPosition(editor, newBlock);
            }
        }
        dom.setAttrib(newBlock, 'id', ''); // Remove ID since it needs to be document unique
        // Allow custom handling of new blocks
        editor.dispatch('NewBlock', { newBlock });
    };
    const fakeEventName$1 = 'insertParagraph';
    const blockbreak = {
        insert: insert$3,
        fakeEventName: fakeEventName$1
    };

    // Walks the parent block to the right and look for BR elements
    const hasRightSideContent = (schema, container, parentBlock) => {
        const walker = new DomTreeWalker(container, parentBlock);
        let node;
        const nonEmptyElementsMap = schema.getNonEmptyElements();
        while ((node = walker.next())) {
            if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$b(node) && node.length > 0) {
                return true;
            }
        }
        return false;
    };
    const moveSelectionToBr = (editor, brElm, extraBr) => {
        const rng = editor.dom.createRng();
        if (!extraBr) {
            rng.setStartAfter(brElm);
            rng.setEndAfter(brElm);
        }
        else {
            rng.setStartBefore(brElm);
            rng.setEndBefore(brElm);
        }
        editor.selection.setRng(rng);
        scrollRangeIntoView(editor, rng);
    };
    const insertBrAtCaret = (editor, evt) => {
        // We load the current event in from EnterKey.js when appropriate to heed
        // certain event-specific variations such as ctrl-enter in a list
        const selection = editor.selection;
        const dom = editor.dom;
        const rng = selection.getRng();
        let brElm;
        let extraBr = false;
        normalize$2(dom, rng).each((normRng) => {
            rng.setStart(normRng.startContainer, normRng.startOffset);
            rng.setEnd(normRng.endContainer, normRng.endOffset);
        });
        let offset = rng.startOffset;
        let container = rng.startContainer;
        // Resolve node index
        if (isElement$7(container) && container.hasChildNodes()) {
            const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && isText$b(container)) {
                offset = container.data.length;
            }
            else {
                offset = 0;
            }
        }
        let parentBlock = dom.getParent(container, dom.isBlock);
        const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
        const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
        // Enter inside block contained within a LI then split or insert before/after LI
        const isControlKey = !!(evt && evt.ctrlKey);
        if (containerBlockName === 'LI' && !isControlKey) {
            parentBlock = containerBlock;
        }
        if (isText$b(container) && offset >= container.data.length) {
            // Insert extra BR element at the end block elements
            if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {
                brElm = dom.create('br');
                rng.insertNode(brElm);
                rng.setStartAfter(brElm);
                rng.setEndAfter(brElm);
                extraBr = true;
            }
        }
        brElm = dom.create('br');
        rangeInsertNode(dom, rng, brElm);
        moveSelectionToBr(editor, brElm, extraBr);
        editor.undoManager.add();
    };
    const insertBrBefore = (editor, inline) => {
        const br = SugarElement.fromTag('br');
        before$4(SugarElement.fromDom(inline), br);
        editor.undoManager.add();
    };
    const insertBrAfter = (editor, inline) => {
        if (!hasBrAfter(editor.getBody(), inline)) {
            after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));
        }
        const br = SugarElement.fromTag('br');
        after$4(SugarElement.fromDom(inline), br);
        moveSelectionToBr(editor, br.dom, false);
        editor.undoManager.add();
    };
    const isBeforeBr = (pos) => {
        return isBr$7(pos.getNode());
    };
    const hasBrAfter = (rootNode, startNode) => {
        if (isBeforeBr(CaretPosition.after(startNode))) {
            return true;
        }
        else {
            return nextPosition(rootNode, CaretPosition.after(startNode)).map((pos) => {
                return isBr$7(pos.getNode());
            }).getOr(false);
        }
    };
    const isAnchorLink = (elm) => {
        return elm && elm.nodeName === 'A' && 'href' in elm;
    };
    const isInsideAnchor = (location) => {
        return location.fold(never, isAnchorLink, isAnchorLink, never);
    };
    const readInlineAnchorLocation = (editor) => {
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        const position = CaretPosition.fromRangeStart(editor.selection.getRng());
        return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);
    };
    const insertBrOutsideAnchor = (editor, location) => {
        location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
    };
    const insert$2 = (editor, evt) => {
        const anchorLocation = readInlineAnchorLocation(editor);
        if (anchorLocation.isSome()) {
            anchorLocation.each(curry(insertBrOutsideAnchor, editor));
        }
        else {
            insertBrAtCaret(editor, evt);
        }
    };
    const fakeEventName = 'insertLineBreak';
    const linebreak = {
        insert: insert$2,
        fakeEventName
    };

    const matchesSelector = (editor, selector) => {
        return getParentBlock$1(editor).filter((parentBlock) => {
            return selector.length > 0 && is$2(SugarElement.fromDom(parentBlock), selector);
        }).isSome();
    };
    const shouldInsertBr = (editor) => {
        return matchesSelector(editor, getBrNewLineSelector(editor));
    };
    const shouldBlockNewLine$1 = (editor) => {
        return matchesSelector(editor, getNoNewLineSelector(editor));
    };

    const newLineAction = Adt.generate([
        { br: [] },
        { block: [] },
        { none: [] }
    ]);
    const shouldBlockNewLine = (editor, _shiftKey) => {
        return shouldBlockNewLine$1(editor);
    };
    const inListBlock = (requiredState) => {
        return (editor, _shiftKey) => {
            return isListItemParentBlock(editor) === requiredState;
        };
    };
    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {
        const state = getParentBlockName(editor) === blockName.toUpperCase();
        return state === requiredState;
    };
    const inCefBlock = (editor) => {
        const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());
        return isNullable(editableRoot);
    };
    const inPreBlock = (requiredState) => inBlock('pre', requiredState);
    const inSummaryBlock = () => inBlock('summary', true);
    const shouldPutBrInPre = (requiredState) => {
        return (editor, _shiftKey) => {
            return shouldPutBrInPre$1(editor) === requiredState;
        };
    };
    const inBrContext = (editor, _shiftKey) => {
        return shouldInsertBr(editor);
    };
    const hasShiftKey = (_editor, shiftKey) => {
        return shiftKey;
    };
    const canInsertIntoEditableRoot = (editor) => {
        const forcedRootBlock = getForcedRootBlock(editor);
        const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());
        return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);
    };
    const isInRootWithEmptyOrCEF = (editor) => {
        const rng = editor.selection.getRng();
        const start = SugarElement.fromDom(rng.startContainer);
        const child = child$1(start, rng.startOffset);
        const isCefOpt = child.map((element) => isHTMLElement$1(element) && !isEditable$2(element));
        return rng.collapsed && isCefOpt.getOr(true);
    };
    const match = (predicates, action) => {
        return (editor, shiftKey) => {
            const isMatch = foldl(predicates, (res, p) => {
                return res && p(editor, shiftKey);
            }, true);
            return isMatch ? Optional.some(action) : Optional.none();
        };
    };
    const getAction = (editor, evt) => {
        return evaluateUntil([
            match([shouldBlockNewLine], newLineAction.none()),
            // If the pre block is cef, do not try to insert a new line (or delete contents)
            match([inPreBlock(true), inCefBlock], newLineAction.none()),
            match([inSummaryBlock()], newLineAction.br()),
            match([inPreBlock(true), shouldPutBrInPre(false), hasShiftKey], newLineAction.br()),
            match([inPreBlock(true), shouldPutBrInPre(false)], newLineAction.block()),
            match([inPreBlock(true), shouldPutBrInPre(true), hasShiftKey], newLineAction.block()),
            match([inPreBlock(true), shouldPutBrInPre(true)], newLineAction.br()),
            // TODO: TINY-9127 investigate if the list handling (and pre) is correct here.
            match([inListBlock(true), hasShiftKey], newLineAction.br()),
            match([inListBlock(true)], newLineAction.block()),
            match([inBrContext], newLineAction.br()),
            match([hasShiftKey], newLineAction.br()),
            match([canInsertIntoEditableRoot], newLineAction.block()),
            match([isInRootWithEmptyOrCEF], newLineAction.block())
        ], [editor, !!(evt && evt.shiftKey)]).getOr(newLineAction.none());
    };

    const insertBreak = (breakType, editor, evt) => {
        if (editor.mode.isReadOnly()) {
            return;
        }
        if (!editor.selection.isCollapsed()) {
            // IMPORTANT: We want to use the editor execCommand here, so that our `delete` execCommand
            // overrides will be considered.
            execEditorDeleteCommand(editor);
        }
        if (isNonNullable(evt)) {
            const event = fireBeforeInputEvent(editor, breakType.fakeEventName);
            if (event.isDefaultPrevented()) {
                return;
            }
        }
        breakType.insert(editor, evt);
        if (isNonNullable(evt)) {
            fireInputEvent(editor, breakType.fakeEventName);
        }
    };
    const insert$1 = (editor, evt) => {
        if (editor.mode.isReadOnly()) {
            return;
        }
        const br = () => insertBreak(linebreak, editor, evt);
        const block = () => insertBreak(blockbreak, editor, evt);
        const logicalAction = getAction(editor, evt);
        switch (getNewlineBehavior(editor)) {
            case 'linebreak':
                logicalAction.fold(br, br, noop);
                break;
            case 'block':
                logicalAction.fold(block, block, noop);
                break;
            case 'invert':
                logicalAction.fold(block, br, noop);
                break;
            // implied by the options processor, unnecessary
            // case 'default':
            default:
                logicalAction.fold(br, block, noop);
                break;
        }
    };

    const platform$1 = detect$1();
    const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();
    const handleEnterKeyEvent = (editor, event) => {
        if (event.isDefaultPrevented()) {
            return;
        }
        event.preventDefault();
        endTypingLevelIgnoreLocks(editor.undoManager);
        editor.undoManager.transact(() => {
            insert$1(editor, event);
        });
    };
    const isCaretAfterKoreanCharacter = (rng) => {
        if (!rng.collapsed) {
            return false;
        }
        const startContainer = rng.startContainer;
        if (isText$b(startContainer)) {
            // Hangul: \uAC00-\uD7AF
            // Hangul Jamo: \u1100-\u11FF
            // Hangul Compatibility Jamo: \u3130-\u318F
            // Hangul Jamo Extended-A: \uA960-\uA97F
            // Hangul Jamo Extended-B: \uD7B0-\uD7FF
            const koreanCharRegex = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/;
            const char = startContainer.data.charAt(rng.startOffset - 1);
            return koreanCharRegex.test(char);
        }
        else {
            return false;
        }
    };
    const setup$n = (editor) => {
        let iOSSafariKeydownBookmark = Optional.none();
        const iOSSafariKeydownOverride = (editor) => {
            iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());
            editor.undoManager.add();
        };
        const iOSSafariKeyupOverride = (editor, event) => {
            editor.undoManager.undo();
            iOSSafariKeydownBookmark.fold(noop, (b) => editor.selection.moveToBookmark(b));
            handleEnterKeyEvent(editor, event);
            iOSSafariKeydownBookmark = Optional.none();
        };
        editor.on('keydown', (event) => {
            if (event.keyCode === VK.ENTER) {
                if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {
                    // TINY-9746: iOS Safari composes Korean characters by deleting the previous partial character and inserting
                    // the composed character. If the native Enter keypress event is not fired, iOS Safari will continue to compose across
                    // our custom newline by deleting it and inserting the composed character on the previous line, causing a bug. The workaround
                    // is to save a bookmark and an undo level on keydown while not preventing default to allow the native Enter keypress.
                    // Then on keyup, the effects of the native Enter keypress is undone and our own Enter key handler is called.
                    iOSSafariKeydownOverride(editor);
                }
                else {
                    handleEnterKeyEvent(editor, event);
                }
            }
        });
        editor.on('keyup', (event) => {
            if (event.keyCode === VK.ENTER) {
                iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));
            }
        });
    };

    const executeKeydownOverride$2 = (editor, caret, evt) => {
        const isMac = Env.os.isMacOS() || Env.os.isiOS();
        execute([
            { keyCode: VK.END, action: action(moveToLineEndPoint$1, editor, true) },
            { keyCode: VK.HOME, action: action(moveToLineEndPoint$1, editor, false) },
            ...(!isMac ? [
                { keyCode: VK.HOME, action: action(selectToEndPoint, editor, false), ctrlKey: true, shiftKey: true },
                { keyCode: VK.END, action: action(selectToEndPoint, editor, true), ctrlKey: true, shiftKey: true }
            ] : []),
            { keyCode: VK.END, action: action(moveToLineEndPoint, editor, true) },
            { keyCode: VK.HOME, action: action(moveToLineEndPoint, editor, false) },
            { keyCode: VK.END, action: action(moveToLineEndPoint$2, editor, true, caret) },
            { keyCode: VK.HOME, action: action(moveToLineEndPoint$2, editor, false, caret) }
        ], evt).each((_) => {
            evt.preventDefault();
        });
    };
    const setup$m = (editor, caret) => {
        editor.on('keydown', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeydownOverride$2(editor, caret, evt);
            }
        });
    };

    const setup$l = (editor) => {
        editor.on('input', (e) => {
            // We only care about non composing inputs since moving the caret or modifying the text node will blow away the IME
            if (!e.isComposing) {
                normalizeNbspsInEditor(editor);
            }
        });
    };

    const platform = detect$1();
    const executeKeyupAction = (editor, caret, evt) => {
        execute([
            { keyCode: VK.PAGE_UP, action: action(moveToLineEndPoint$2, editor, false, caret) },
            { keyCode: VK.PAGE_DOWN, action: action(moveToLineEndPoint$2, editor, true, caret) }
        ], evt);
    };
    const stopImmediatePropagation = (e) => e.stopImmediatePropagation();
    const isPageUpDown = (evt) => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
    const setNodeChangeBlocker = (blocked, editor, block) => {
        // Node change event is only blocked while the user is holding down the page up/down key it would have limited effects on other things
        // Prevents a flickering UI while caret move in and out of the inline boundary element
        if (block && !blocked.get()) {
            editor.on('NodeChange', stopImmediatePropagation, true);
        }
        else if (!block && blocked.get()) {
            editor.off('NodeChange', stopImmediatePropagation);
        }
        blocked.set(block);
    };
    // Determining the correct placement on key up/down is very complicated and would require handling many edge cases,
    // which we don't have the resources to handle currently. As such, we allow the browser to change the selection and then make adjustments later.
    const setup$k = (editor, caret) => {
        // Mac OS doesn't move the selection when pressing page up/down and as such TinyMCE shouldn't be moving it either
        if (platform.os.isMacOS()) {
            return;
        }
        const blocked = Cell(false);
        editor.on('keydown', (evt) => {
            if (isPageUpDown(evt)) {
                setNodeChangeBlocker(blocked, editor, true);
            }
        });
        editor.on('keyup', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeyupAction(editor, caret, evt);
            }
            if (isPageUpDown(evt) && blocked.get()) {
                setNodeChangeBlocker(blocked, editor, false);
                editor.nodeChanged();
            }
        });
    };

    const isValidContainer = (root, container) => root === container || root.contains(container);
    const isInEditableRange = (editor, range) => {
        // If the range is not in the body then it's in a shadow root and we should allow that more details in: TINY-11446
        if (!isValidContainer(editor.getBody(), range.startContainer) || !isValidContainer(editor.getBody(), range.endContainer)) {
            return true;
        }
        return isEditableRange(editor.dom, range);
    };
    const setup$j = (editor) => {
        editor.on('beforeinput', (e) => {
            // Normally input is blocked on non-editable elements that have contenteditable="false" however we are also treating
            // SVG elements as non-editable and deleting inside or into is possible in some browsers so we need to detect that and prevent that.
            if (!editor.selection.isEditable() || exists(e.getTargetRanges(), (rng) => !isInEditableRange(editor, rng))) {
                e.preventDefault();
            }
        });
    };

    const insertTextAtPosition = (text, pos) => {
        const container = pos.container();
        const offset = pos.offset();
        if (isText$b(container)) {
            container.insertData(offset, text);
            return Optional.some(CaretPosition(container, offset + text.length));
        }
        else {
            return getElementFromPosition(pos).map((elm) => {
                const textNode = SugarElement.fromText(text);
                if (pos.isAtEnd()) {
                    after$4(elm, textNode);
                }
                else {
                    before$4(elm, textNode);
                }
                return CaretPosition(textNode.dom, text.length);
            });
        }
    };
    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');

    const insertSpaceOrNbspAtPosition = (root, pos, schema) => needsToHaveNbsp(root, pos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
    const locationToCaretPosition = (root) => (location) => location.fold((element) => prevPosition(root.dom, CaretPosition.before(element)), (element) => firstPositionIn(element), (element) => lastPositionIn(element), (element) => nextPosition(root.dom, CaretPosition.after(element)));
    const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => (checkPos) => needsToHaveNbsp(root, checkPos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
    const setSelection = (editor) => (pos) => {
        editor.selection.setRng(pos.toRange());
        editor.nodeChanged();
    };
    const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));
    const insertSpaceOrNbspAtSelection = (editor) => {
        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        const root = SugarElement.fromDom(editor.getBody());
        if (editor.selection.isCollapsed()) {
            const isInlineTarget$1 = curry(isInlineTarget, editor);
            const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
            return readLocation(isInlineTarget$1, editor.getBody(), caretPosition)
                .bind(locationToCaretPosition(root))
                .map((checkPos) => () => insertInlineBoundarySpaceOrNbsp(root, pos, editor.schema)(checkPos).each(setSelection(editor)));
        }
        else {
            return Optional.none();
        }
    };
    // TINY-9964: Firefox has a bug where the space key is toggling the open state instead of inserting a space in a summary element
    const insertSpaceInSummaryAtSelectionOnFirefox = (editor) => {
        const insertSpaceThunk = () => {
            const root = SugarElement.fromDom(editor.getBody());
            if (!editor.selection.isCollapsed()) {
                editor.getDoc().execCommand('Delete');
            }
            const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
            insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(setSelection(editor));
        };
        return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);
    };

    const executeKeydownOverride$1 = (editor, evt) => {
        executeWithDelayedAction([
            { keyCode: VK.SPACEBAR, action: action(insertSpaceOrNbspAtSelection, editor) },
            { keyCode: VK.SPACEBAR, action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor) }
        ], evt).each((applyAction) => {
            evt.preventDefault();
            const event = fireBeforeInputEvent(editor, 'insertText', { data: ' ' });
            if (!event.isDefaultPrevented()) {
                applyAction();
                // Browsers sends space in data even if the dom ends up with a nbsp so we should always be sending a space
                fireInputEvent(editor, 'insertText', { data: ' ' });
            }
        });
    };
    const setup$i = (editor) => {
        editor.on('keydown', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeydownOverride$1(editor, evt);
            }
        });
    };

    const tableTabNavigation = (editor) => {
        if (hasTableTabNavigation(editor)) {
            return [
                { keyCode: VK.TAB, action: action(handleTab, editor, true) },
                { keyCode: VK.TAB, shiftKey: true, action: action(handleTab, editor, false) },
            ];
        }
        else {
            return [];
        }
    };
    const executeKeydownOverride = (editor, evt) => {
        execute([
            ...tableTabNavigation(editor)
        ], evt).each((_) => {
            evt.preventDefault();
        });
    };
    const setup$h = (editor) => {
        editor.on('keydown', (evt) => {
            if (!evt.isDefaultPrevented()) {
                executeKeydownOverride(editor, evt);
            }
        });
    };

    const setup$g = (editor) => {
        editor.addShortcut('Meta+P', '', 'mcePrint');
        setup$p(editor);
        if (isRtc(editor)) {
            return Cell(null);
        }
        else {
            const caret = setupSelectedState(editor);
            setup$j(editor);
            setup$r(editor);
            setup$q(editor, caret);
            setup$o(editor, caret);
            setup$n(editor);
            setup$i(editor);
            setup$l(editor);
            setup$h(editor);
            setup$m(editor, caret);
            setup$k(editor, caret);
            return caret;
        }
    };

    const updateList = (editor, update) => {
        const parentList = getParentList(editor);
        if (parentList === null || isWithinNonEditableList$1(editor, parentList)) {
            return;
        }
        editor.undoManager.transact(() => {
            if (isObject(update.styles)) {
                editor.dom.setStyles(parentList, update.styles);
            }
            if (isObject(update.attrs)) {
                each$d(update.attrs, (v, k) => editor.dom.setAttrib(parentList, k, v));
            }
        });
    };

    const queryListCommandState = (editor, listName) => () => {
        const parentList = getParentList(editor);
        return isNonNullable(parentList) && parentList.nodeName === listName;
    };
    const setup$f = (editor) => {
        editor.addCommand('InsertUnorderedList', (ui, detail) => {
            toggleList(editor, 'UL', detail);
        });
        editor.addCommand('InsertOrderedList', (ui, detail) => {
            toggleList(editor, 'OL', detail);
        });
        editor.addCommand('InsertDefinitionList', (ui, detail) => {
            toggleList(editor, 'DL', detail);
        });
        editor.addCommand('RemoveList', () => {
            flattenListSelection(editor);
        });
        editor.addCommand('mceListUpdate', (ui, detail) => {
            if (isObject(detail)) {
                updateList(editor, detail);
            }
        });
        editor.addCommand('mceListBackspaceDelete', (_ui, forward) => {
            backspaceDelete$c(editor, forward);
        });
        editor.addQueryStateHandler('InsertUnorderedList', queryListCommandState(editor, 'UL'));
        editor.addQueryStateHandler('InsertOrderedList', queryListCommandState(editor, 'OL'));
        editor.addQueryStateHandler('InsertDefinitionList', queryListCommandState(editor, 'DL'));
    };

    const setup$e = (editor) => {
        editor.on('keydown', (e) => {
            if (e.keyCode === VK.BACKSPACE) {
                if (backspaceDelete$c(editor, false)) {
                    e.preventDefault();
                }
            }
            else if (e.keyCode === VK.DELETE) {
                if (backspaceDelete$c(editor, true)) {
                    e.preventDefault();
                }
            }
        });
    };

    const isTextNode = (node) => node.type === 3;
    const isEmpty = (nodeBuffer) => nodeBuffer.length === 0;
    const wrapInvalidChildren = (list) => {
        const insertListItem = (buffer, refNode) => {
            const li = AstNode.create('li');
            each$e(buffer, (node) => li.append(node));
            if (refNode) {
                list.insert(li, refNode, true);
            }
            else {
                list.append(li);
            }
        };
        const reducer = (buffer, node) => {
            if (isTextNode(node)) {
                return [...buffer, node];
            }
            else if (!isEmpty(buffer) && !isTextNode(node)) {
                insertListItem(buffer, node);
                return [];
            }
            else {
                return buffer;
            }
        };
        const restBuffer = foldl(list.children(), reducer, []);
        if (!isEmpty(restBuffer)) {
            insertListItem(restBuffer);
        }
    };
    const setup$d = (editor) => {
        editor.on('PreInit', () => {
            const { parser } = editor;
            parser.addNodeFilter('ul,ol', (nodes) => each$e(nodes, wrapInvalidChildren));
        });
    };

    const setupTabKey = (editor) => {
        editor.on('keydown', (e) => {
            // Check for tab but not ctrl/cmd+tab since it switches browser tabs
            if (e.keyCode !== VK.TAB || VK.metaKeyPressed(e)) {
                return;
            }
            editor.undoManager.transact(() => {
                if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) {
                    e.preventDefault();
                }
            });
        });
    };
    const setup$c = (editor) => {
        if (shouldIndentOnTab(editor)) {
            setupTabKey(editor);
        }
    };

    const setup$b = (editor) => {
        setup$e(editor);
        setup$f(editor);
        setup$d(editor);
        setup$c(editor);
    };

    /**
     * This class handles the nodechange event dispatching both manual and through selection change events.
     *
     * @class tinymce.NodeChange
     * @private
     */
    class NodeChange {
        constructor(editor) {
            this.lastPath = [];
            this.editor = editor;
            let lastRng;
            const self = this;
            // Gecko doesn't support the "selectionchange" event
            if (!('onselectionchange' in editor.getDoc())) {
                editor.on('NodeChange click mouseup keyup focus', (e) => {
                    // Since DOM Ranges mutate on modification
                    // of the DOM we need to clone it's contents
                    const nativeRng = editor.selection.getRng();
                    const fakeRng = {
                        startContainer: nativeRng.startContainer,
                        startOffset: nativeRng.startOffset,
                        endContainer: nativeRng.endContainer,
                        endOffset: nativeRng.endOffset
                    };
                    // Always treat nodechange as a selectionchange since applying
                    // formatting to the current range wouldn't update the range but it's parent
                    if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {
                        editor.dispatch('SelectionChange');
                    }
                    lastRng = fakeRng;
                });
            }
            // IE has a bug where it fires a selectionchange on right click that has a range at the start of the body
            // When the contextmenu event fires the selection is located at the right location
            editor.on('contextmenu', () => {
                store(editor);
                editor.dispatch('SelectionChange');
            });
            // Selection change is delayed ~200ms on IE when you click inside the current range
            editor.on('SelectionChange', () => {
                const startElm = editor.selection.getStart(true);
                // When focusout from after cef element to other input element the startelm can be undefined
                if (!startElm) {
                    return;
                }
                if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
                    editor.nodeChanged({ selectionChange: true });
                }
            });
            // Fire an extra nodeChange on mouseup for compatibility reasons
            editor.on('mouseup', (e) => {
                if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
                    // Delay nodeChanged call for WebKit edge case issue where the range
                    // isn't updated until after you click outside a selected image
                    if (editor.selection.getNode().nodeName === 'IMG') {
                        Delay.setEditorTimeout(editor, () => {
                            editor.nodeChanged();
                        });
                    }
                    else {
                        editor.nodeChanged();
                    }
                }
            });
        }
        /**
         * Dispatches out a onNodeChange event to all observers. This method should be called when you
         * need to update the UI states or element path etc.
         *
         * @method nodeChanged
         * @param {Object} args Optional args to pass to NodeChange event handlers.
         */
        nodeChanged(args = {}) {
            const editor = this.editor;
            const selection = editor.selection;
            let node;
            // Fix for bug #1896577 it seems that this can not be fired while the editor is loading
            if (editor.initialized && selection && !shouldDisableNodeChange(editor) && !isDisabled$1(editor)) {
                // Get start node
                const root = editor.getBody();
                node = selection.getStart(true) || root;
                // Make sure the node is within the editor root or is the editor root
                if (node.ownerDocument !== editor.getDoc() || !editor.dom.isChildOf(node, root)) {
                    node = root;
                }
                // Get parents and add them to object
                const parents = [];
                editor.dom.getParent(node, (node) => {
                    if (node === root) {
                        return true;
                    }
                    else {
                        parents.push(node);
                        return false;
                    }
                });
                editor.dispatch('NodeChange', {
                    ...args,
                    element: node,
                    parents
                });
            }
        }
        /**
         * Returns true/false if the current element path has been changed or not.
         *
         * @private
         * @return {Boolean} True if the element path is the same false if it's not.
         */
        isSameElementPath(startElm) {
            let i;
            const editor = this.editor;
            const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));
            if (currentPath.length === this.lastPath.length) {
                for (i = currentPath.length; i >= 0; i--) {
                    if (currentPath[i] !== this.lastPath[i]) {
                        break;
                    }
                }
                if (i === -1) {
                    this.lastPath = currentPath;
                    return true;
                }
            }
            this.lastPath = currentPath;
            return false;
        }
    }

    const internalMimeType = 'x-tinymce/html';
    const internalHtmlMime = constant(internalMimeType);
    const internalMark = '<!-- ' + internalMimeType + ' -->';
    const mark = (html) => internalMark + html;
    const unmark = (html) => html.replace(internalMark, '');
    const isMarked = (html) => html.indexOf(internalMark) !== -1;

    /*
     * This module contains utilities to convert newlines (\n or \r\n) to BRs or to a combination of the specified block element and BRs
     */
    const isPlainText = (text) => {
        // so basically any tag that is not one of the "p, div, span, br", or is one of them, but is followed
        // by some additional characters qualifies the text as not a plain text (having some HTML tags)
        // <span style="white-space:pre"> and <br /> are added as separate exceptions to the rule
        return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(text);
    };
    const openContainer = (rootTag, rootAttrs) => {
        let tag = '<' + rootTag;
        const attrs = mapToArray(rootAttrs, (value, key) => key + '="' + Entities.encodeAllRaw(value) + '"');
        if (attrs.length) {
            tag += ' ' + attrs.join(' ');
        }
        return tag + '>';
    };
    const toBlockElements = (text, rootTag, rootAttrs) => {
        const blocks = text.split(/\n\n/);
        const tagOpen = openContainer(rootTag, rootAttrs);
        const tagClose = '</' + rootTag + '>';
        const paragraphs = map$3(blocks, (p) => {
            return p.split(/\n/).join('<br />');
        });
        const stitch = (p) => {
            return tagOpen + p + tagClose;
        };
        return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');
    };

    const pasteBinDefaultContent = '%MCEPASTEBIN%';
    /*
     * Creates a paste bin element as close as possible to the current caret location and places the focus inside that element
     * so that when the real paste event occurs the contents gets inserted into this element
     * instead of the current editor selection element.
     */
    const create$5 = (editor, lastRngCell) => {
        const { dom, selection } = editor;
        const body = editor.getBody();
        lastRngCell.set(selection.getRng());
        // Create a pastebin
        const pasteBinElm = dom.add(editor.getBody(), 'div', {
            'id': 'mcepastebin',
            'class': 'mce-pastebin',
            'contentEditable': true,
            'data-mce-bogus': 'all',
            'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'
        }, pasteBinDefaultContent);
        // Move paste bin out of sight since the controlSelection rect gets displayed otherwise on Gecko
        if (Env.browser.isFirefox()) {
            dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 0xFFFF : -0xFFFF);
        }
        // Prevent focus events from bubbling fixed FocusManager issues
        dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', (e) => {
            e.stopPropagation();
        });
        pasteBinElm.focus();
        selection.select(pasteBinElm, true);
    };
    /*
     * Removes the paste bin if it exists.
     */
    const remove = (editor, lastRngCell) => {
        const dom = editor.dom;
        if (getEl(editor)) {
            let pasteBinClone;
            const lastRng = lastRngCell.get();
            // WebKit/Blink might clone the div so
            // lets make sure we remove all clones
            // TODO: Man o man is this ugly. WebKit is the new IE! Remove this if they ever fix it!
            while ((pasteBinClone = getEl(editor))) {
                dom.remove(pasteBinClone);
                dom.unbind(pasteBinClone);
            }
            if (lastRng) {
                editor.selection.setRng(lastRng);
            }
        }
        lastRngCell.set(null);
    };
    const getEl = (editor) => editor.dom.get('mcepastebin');
    const isPasteBin = (elm) => isNonNullable(elm) && elm.id === 'mcepastebin';
    /*
     * Returns the contents of the paste bin as a HTML string.
     */
    const getHtml = (editor) => {
        const dom = editor.dom;
        // Since WebKit/Chrome might clone the paste bin when pasting
        // for example: <img style="float: right"> we need to check if any of them contains some useful html.
        // TODO: Man o man is this ugly. WebKit is the new IE! Remove this if they ever fix it!
        const copyAndRemove = (toElm, fromElm) => {
            toElm.appendChild(fromElm);
            dom.remove(fromElm, true); // remove, but keep children
        };
        // find only top level elements (there might be more nested inside them as well, see TINY-1162)
        const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);
        // if clones were found, move their content into the first bin
        each$e(pasteBinClones, (pasteBinClone) => {
            copyAndRemove(pasteBinElm, pasteBinClone);
        });
        // TINY-1162: when copying plain text (from notepad for example) WebKit clones
        // paste bin (with styles and attributes) and uses it as a default  wrapper for
        // the chunks of the content, here we cycle over the whole paste bin and replace
        // those wrappers with a basic div
        const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);
        for (let i = dirtyWrappers.length - 1; i >= 0; i--) {
            const cleanWrapper = dom.create('div');
            pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);
            copyAndRemove(cleanWrapper, dirtyWrappers[i]);
        }
        return pasteBinElm ? pasteBinElm.innerHTML : '';
    };
    const isDefaultPasteBinContent = (content) => content === pasteBinDefaultContent;
    const PasteBin = (editor) => {
        const lastRng = Cell(null);
        return {
            create: () => create$5(editor, lastRng),
            remove: () => remove(editor, lastRng),
            getEl: () => getEl(editor),
            getHtml: () => getHtml(editor),
            getLastRng: lastRng.get
        };
    };

    /*
     * This module contains various utility functions for the paste logic.
     */
    const filter = (content, items) => {
        Tools.each(items, (v) => {
            if (is$5(v, RegExp)) {
                content = content.replace(v, '');
            }
            else {
                content = content.replace(v[0], v[1]);
            }
        });
        return content;
    };
    /*
     * Gets the innerText of the specified element. It will handle edge cases
     * and works better than textContent on Gecko.
     */
    const innerText = (html) => {
        const schema = Schema();
        const domParser = DomParser({}, schema);
        let text = '';
        const voidElements = schema.getVoidElements();
        const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');
        const blockElements = schema.getBlockElements();
        const walk = (node) => {
            const name = node.name, currentNode = node;
            if (name === 'br') {
                text += '\n';
                return;
            }
            // Ignore wbr, to replicate innerText on Chrome/Firefox
            if (name === 'wbr') {
                return;
            }
            // img/input/hr but ignore wbr as it's just a potential word break
            if (voidElements[name]) {
                text += ' ';
            }
            // Ignore script, video contents
            if (ignoreElements[name]) {
                text += ' ';
                return;
            }
            if (node.type === 3) {
                text += node.value;
            }
            // Walk all children
            if (!(node.name in schema.getVoidElements())) {
                let currentNode = node.firstChild;
                if (currentNode) {
                    do {
                        walk(currentNode);
                    } while ((currentNode = currentNode.next));
                }
            }
            // Add \n or \n\n for blocks or P
            if (blockElements[name] && currentNode.next) {
                text += '\n';
                if (name === 'p') {
                    text += '\n';
                }
            }
        };
        html = filter(html, [
            /<!\[[^\]]+\]>/g // Conditional comments
        ]);
        walk(domParser.parse(html));
        return text;
    };
    /*
     * Trims the specified HTML by removing all WebKit fragments, all elements wrapping the body trailing BR elements etc.
     */
    const trimHtml = (html) => {
        const trimSpaces = (all, s1, s2) => {
            // WebKit &nbsp; meant to preserve multiple spaces but instead inserted around all inline tags,
            // including the spans with inline styles created on paste
            if (!s1 && !s2) {
                return ' ';
            }
            return nbsp;
        };
        html = filter(html, [
            /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig, // Remove anything but the contents within the BODY element
            /<!--StartFragment-->|<!--EndFragment-->/g, // Inner fragments (tables from excel on mac)
            [/( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g, trimSpaces],
            /<br class="Apple-interchange-newline">/g,
            /<br>$/i // Trailing BR elements
        ]);
        return html;
    };
    // TODO: Should be in some global class
    const createIdGenerator = (prefix) => {
        let count = 0;
        return () => {
            return prefix + (count++);
        };
    };
    const getImageMimeType = (ext) => {
        const lowerExt = ext.toLowerCase();
        const mimeOverrides = {
            jpg: 'jpeg',
            jpe: 'jpeg',
            jfi: 'jpeg',
            jif: 'jpeg',
            jfif: 'jpeg',
            pjpeg: 'jpeg',
            pjp: 'jpeg',
            svg: 'svg+xml'
        };
        return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;
    };

    const preProcess = (editor, html) => {
        const parser = DomParser({
            sanitize: shouldSanitizeXss(editor),
            sandbox_iframes: shouldSandboxIframes(editor),
            sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),
            convert_unsafe_embeds: shouldConvertUnsafeEmbeds(editor)
        }, editor.schema);
        // Strip meta elements
        parser.addNodeFilter('meta', (nodes) => {
            Tools.each(nodes, (node) => {
                node.remove();
            });
        });
        const fragment = parser.parse(html, { forced_root_block: false, isRootContent: true });
        return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);
    };
    const processResult = (content, cancelled) => ({ content, cancelled });
    const postProcessFilter = (editor, html, internal) => {
        const tempBody = editor.dom.create('div', { style: 'display:none' }, html);
        const postProcessArgs = firePastePostProcess(editor, tempBody, internal);
        return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());
    };
    const filterContent = (editor, content, internal) => {
        const preProcessArgs = firePastePreProcess(editor, content, internal);
        // Filter the content to remove potentially dangerous content (eg scripts)
        const filteredContent = preProcess(editor, preProcessArgs.content);
        if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {
            return postProcessFilter(editor, filteredContent, internal);
        }
        else {
            return processResult(filteredContent, preProcessArgs.isDefaultPrevented());
        }
    };
    const process = (editor, html, internal) => {
        return filterContent(editor, html, internal);
    };

    const pasteHtml$1 = (editor, html) => {
        editor.insertContent(html, {
            merge: shouldPasteMergeFormats(editor),
            paste: true
        });
        return true;
    };
    const isAbsoluteUrl = (url) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(url);
    const isImageUrl = (editor, url) => {
        return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), (type) => endsWith(url.toLowerCase(), `.${type.toLowerCase()}`));
    };
    const createImage = (editor, url, pasteHtmlFn) => {
        editor.undoManager.extra(() => {
            pasteHtmlFn(editor, url);
        }, () => {
            editor.insertContent('<img src="' + url + '">');
        });
        return true;
    };
    const createLink = (editor, url, pasteHtmlFn) => {
        editor.undoManager.extra(() => {
            pasteHtmlFn(editor, url);
        }, () => {
            editor.execCommand('mceInsertLink', false, url);
        });
        return true;
    };
    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;
    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;
    const smartInsertContent = (editor, html) => {
        Tools.each([
            linkSelection,
            insertImage,
            pasteHtml$1
        ], (action) => {
            return !action(editor, html, pasteHtml$1);
        });
    };
    const insertContent = (editor, html, pasteAsText) => {
        if (pasteAsText || !isSmartPasteEnabled(editor)) {
            pasteHtml$1(editor, html);
        }
        else {
            smartInsertContent(editor, html);
        }
    };

    const uniqueId = createIdGenerator('mceclip');
    const createPasteDataTransfer = (html) => {
        const dataTransfer = createDataTransfer();
        setHtmlData(dataTransfer, html);
        // TINY-9829: Set to read-only mode as per https://www.w3.org/TR/input-events-2/
        setReadOnlyMode(dataTransfer);
        return dataTransfer;
    };
    const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {
        const res = process(editor, content, internal);
        if (!res.cancelled) {
            const content = res.content;
            const doPasteAction = () => insertContent(editor, content, pasteAsText);
            if (shouldSimulateInputEvent) {
                const args = fireBeforeInputEvent(editor, 'insertFromPaste', { dataTransfer: createPasteDataTransfer(content) });
                if (!args.isDefaultPrevented()) {
                    doPasteAction();
                    fireInputEvent(editor, 'insertFromPaste');
                }
            }
            else {
                doPasteAction();
            }
        }
    };
    /*
     * Pastes the specified HTML. This means that the HTML is filtered and then
     * inserted at the current selection in the editor. It will also fire paste events
     * for custom user filtering.
     */
    const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {
        const internal = internalFlag ? internalFlag : isMarked(html);
        doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);
    };
    /*
     * Pastes the specified text. This means that the plain text is processed
     * and converted into BR and P elements. It will fire paste events for custom filtering.
     */
    const pasteText = (editor, text, shouldSimulateInputEvent) => {
        const encodedText = editor.dom.encode(text).replace(/\r\n/g, '\n');
        const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));
        const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
        doPaste(editor, html, false, true, shouldSimulateInputEvent);
    };
    /*
     * Gets various content types out of a datatransfer object.
     */
    const getDataTransferItems = (dataTransfer) => {
        const items = {};
        if (dataTransfer && dataTransfer.types) {
            for (let i = 0; i < dataTransfer.types.length; i++) {
                const contentType = dataTransfer.types[i];
                try { // IE11 throws exception when contentType is Files (type is present but data cannot be retrieved via getData())
                    items[contentType] = dataTransfer.getData(contentType);
                }
                catch (_a) {
                    items[contentType] = ''; // useless in general, but for consistency across browsers
                }
            }
        }
        return items;
    };
    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
    const hasHtmlOrText = (content) => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');
    const extractFilename = (editor, str) => {
        const m = str.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
        return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;
    };
    const createBlobInfo = (editor, blobCache, file, base64) => {
        const id = uniqueId();
        const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);
        const name = useFileName ? extractFilename(editor, file.name) : id;
        const filename = useFileName ? file.name : undefined;
        const blobInfo = blobCache.create(id, file, base64, name, filename);
        blobCache.add(blobInfo);
        return blobInfo;
    };
    const pasteImage = (editor, imageItem) => {
        parseDataUri(imageItem.uri).each(({ data, type, base64Encoded }) => {
            const base64 = base64Encoded ? data : btoa(data);
            const file = imageItem.file;
            // TODO: Move the bulk of the cache logic to EditorUpload
            const blobCache = editor.editorUpload.blobCache;
            const existingBlobInfo = blobCache.getByData(base64, type);
            const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);
            pasteHtml(editor, `<img src="${blobInfo.blobUri()}">`, false, true);
        });
    };
    const isClipboardEvent = (event) => event.type === 'paste';
    const readFilesAsDataUris = (items) => Promise.all(map$3(items, (file) => {
        return blobToDataUri(file).then((uri) => ({ file, uri }));
    }));
    const isImage = (editor) => {
        const allowedExtensions = getAllowedImageFileTypes(editor);
        return (file) => startsWith(file.type, 'image/') && exists(allowedExtensions, (extension) => {
            return getImageMimeType(extension) === file.type;
        });
    };
    const getImagesFromDataTransfer = (editor, dataTransfer) => {
        const items = dataTransfer.items ? bind$3(from(dataTransfer.items), (item) => {
            return item.kind === 'file' ? [item.getAsFile()] : [];
        }) : [];
        const files = dataTransfer.files ? from(dataTransfer.files) : [];
        return filter$5(items.length > 0 ? items : files, isImage(editor));
    };
    /*
     * Checks if the clipboard contains image data if it does it will take that data
     * and convert it into a data url image and paste that image at the caret location.
     */
    const pasteImageData = (editor, e, rng) => {
        const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;
        if (shouldPasteDataImages(editor) && dataTransfer) {
            const images = getImagesFromDataTransfer(editor, dataTransfer);
            if (images.length > 0) {
                e.preventDefault();
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                readFilesAsDataUris(images).then((fileResults) => {
                    if (rng) {
                        editor.selection.setRng(rng);
                    }
                    each$e(fileResults, (result) => {
                        pasteImage(editor, result);
                    });
                });
                return true;
            }
        }
        return false;
    };
    // Chrome on Android doesn't support proper clipboard access so we have no choice but to allow the browser default behavior.
    const isBrokenAndroidClipboardEvent = (e) => { var _a, _b; return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0; };
    // Ctrl+V or Shift+Insert
    const isKeyboardPasteEvent = (e) => (VK.metaKeyPressed(e) && e.keyCode === 86) || (e.shiftKey && e.keyCode === 45);
    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {
        let content = trimHtml(html);
        const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);
        const isPlainTextHtml = !isInternal && isPlainText(content);
        const isAbsoluteUrl$1 = isAbsoluteUrl(content);
        // If the paste bin is empty try using plain text mode since that is better than nothing right?
        // Also if we got nothing from clipboard API/pastebin or the content is a plain text (with only
        // some BRs, Ps or DIVs as newlines) then we fallback to plain/text
        if (isDefaultPasteBinContent(content) || !content.length || (isPlainTextHtml && !isAbsoluteUrl$1)) {
            plainTextMode = true;
        }
        // Grab plain text from Clipboard API or convert existing HTML to plain text
        if (plainTextMode || isAbsoluteUrl$1) {
            // Use plain text contents from Clipboard API unless the HTML contains paragraphs then
            // we should convert the HTML to plain text since works better when pasting HTML/Word contents as plain text
            if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {
                content = clipboardContent['text/plain'];
            }
            else {
                content = innerText(content);
            }
        }
        // If the content is the paste bin default HTML then it was impossible to get the clipboard data out.
        if (isDefaultPasteBinContent(content)) {
            return;
        }
        if (plainTextMode) {
            pasteText(editor, content, shouldSimulateInputEvent);
        }
        else {
            pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);
        }
    };
    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {
        let keyboardPastePlainTextState;
        const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();
        editor.on('keydown', (e) => {
            if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
                keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;
            }
        });
        editor.on('paste', (e) => {
            if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {
                return;
            }
            const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;
            keyboardPastePlainTextState = false;
            const clipboardContent = getDataTransferItems(e.clipboardData);
            if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {
                return;
            }
            // If the clipboard API has HTML then use that directly
            if (hasContentType(clipboardContent, 'text/html')) {
                e.preventDefault();
                insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);
            }
            else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {
                /*
                Safari adds the uri-list attribute to links copied within it.
                When pasting something with the url-list within safari using the default functionality it will convert it from www.example.com to <a href="www.example.com">www.example.com</a> when pasting into the pasteBin-div.
                This causes issues. To solve this we bypass the default paste functionality for this situation.
                 */
                e.preventDefault();
                insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);
            }
            else {
                // We can't extract the HTML content from the clipboard so we need to allow the paste
                // to run via the pastebin and then extract from there
                pasteBin.create();
                Delay.setEditorTimeout(editor, () => {
                    // Get the pastebin content and then remove it so the selection is restored
                    const html = pasteBin.getHtml();
                    pasteBin.remove();
                    insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);
                }, 0);
            }
        });
    };
    const registerDataImageFilter = (editor) => {
        const isWebKitFakeUrl = (src) => startsWith(src, 'webkit-fake-url');
        const isDataUri = (src) => startsWith(src, 'data:');
        const isPasteInsert = (args) => { var _a; return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true; };
        // Remove all data images from paste for example from Gecko
        // except internal images like video elements
        editor.parser.addNodeFilter('img', (nodes, name, args) => {
            if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {
                for (const node of nodes) {
                    const src = node.attr('src');
                    if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {
                        // Safari on Mac produces webkit-fake-url see: https://bugs.webkit.org/show_bug.cgi?id=49141
                        if (isWebKitFakeUrl(src)) {
                            node.remove();
                        }
                        else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {
                            node.remove();
                        }
                    }
                }
            }
        });
    };
    /*
     * This class contains logic for getting HTML contents out of the clipboard.
     *
     * This by default will attempt to use the W3C clipboard API to get HTML content.
     * If that can't be used then fallback to letting the browser paste natively with
     * some logic to clean up what the browser generated, as it can mutate the content.
     *
     * Current implementation steps:
     *  1. On keydown determine if we should paste as plain text.
     *  2. Wait for the browser to fire a "paste" event and get the contents out of clipboard.
     *  3. If no content is available, then attach the paste bin and change the selection to be inside the bin.
     *  4. Extract the contents from the bin in the next event loop.
     *  5. If no HTML is found or we're using plain text paste mode then convert the HTML or lookup the clipboard to get the plain text.
     *  6. Process the content from the clipboard or pastebin and insert it into the editor.
     */
    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {
        registerEventHandlers(editor, pasteBin, pasteFormat);
        registerDataImageFilter(editor);
    };

    const togglePlainTextPaste = (editor, pasteFormat) => {
        if (pasteFormat.get() === 'text') {
            pasteFormat.set('html');
            firePastePlainTextToggle(editor, false);
        }
        else {
            pasteFormat.set('text');
            firePastePlainTextToggle(editor, true);
        }
        editor.focus();
    };
    const register$1 = (editor, pasteFormat) => {
        editor.addCommand('mceTogglePlainTextPaste', () => {
            togglePlainTextPaste(editor, pasteFormat);
        });
        editor.addCommand('mceInsertClipboardContent', (ui, value) => {
            if (value.html) {
                // TINY-9997: Input events are not simulated when using paste commands, similar to how the 'mceInsertContent'
                // and 'Delete' commands work.
                pasteHtml(editor, value.html, value.internal, false);
            }
            if (value.text) {
                pasteText(editor, value.text, false);
            }
        });
    };

    const setHtml5Clipboard = (clipboardData, html, text) => {
        if (clipboardData) {
            try {
                clipboardData.clearData();
                clipboardData.setData('text/html', html);
                clipboardData.setData('text/plain', text);
                clipboardData.setData(internalHtmlMime(), html);
                return true;
            }
            catch (_a) {
                return false;
            }
        }
        else {
            return false;
        }
    };
    const setClipboardData = (evt, data, fallback, done) => {
        if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {
            evt.preventDefault();
            done();
        }
        else {
            fallback(data.html, done);
        }
    };
    const fallback = (editor) => (html, done) => {
        const { dom, selection } = editor;
        const outer = dom.create('div', { 'contenteditable': 'false', 'data-mce-bogus': 'all' });
        const inner = dom.create('div', { contenteditable: 'true' }, html);
        dom.setStyles(outer, {
            position: 'fixed',
            top: '0',
            left: '-3000px',
            width: '1000px',
            overflow: 'hidden'
        });
        outer.appendChild(inner);
        dom.add(editor.getBody(), outer);
        const range = selection.getRng();
        inner.focus();
        const offscreenRange = dom.createRng();
        offscreenRange.selectNodeContents(inner);
        selection.setRng(offscreenRange);
        Delay.setEditorTimeout(editor, () => {
            selection.setRng(range);
            dom.remove(outer);
            done();
        }, 0);
    };
    const getData = (editor) => ({
        html: mark(editor.selection.getContent({ contextual: true })),
        text: editor.selection.getContent({ format: 'text' })
    });
    const isTableSelection = (editor) => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());
    const hasSelectedContent = (editor) => !editor.selection.isCollapsed() || isTableSelection(editor);
    const cut = (editor, caret) => (evt) => {
        if (!evt.isDefaultPrevented() && hasSelectedContent(editor) && editor.selection.isEditable()) {
            setClipboardData(evt, getData(editor), fallback(editor), () => {
                if (Env.browser.isChromium() || Env.browser.isFirefox()) {
                    const rng = editor.selection.getRng();
                    // Chrome fails to execCommand from another execCommand with this message:
                    // "We don't execute document.execCommand() this time, because it is called recursively.""
                    // Firefox 82 now also won't run recursive commands, but it doesn't log an error
                    Delay.setEditorTimeout(editor, () => {
                        // Restore the range before deleting, as Chrome on Android will
                        // collapse the selection after a cut event has fired.
                        editor.selection.setRng(rng);
                        // Delete command is called directly without using editor.execCommand to avoid running editor.focus() which side effect was selection normalization and additional undo level
                        deleteCommand(editor, caret);
                    }, 0);
                }
                else {
                    // Delete command is called directly without using editor.execCommand to avoid running editor.focus() which side effect was selection normalization and additional undo level
                    deleteCommand(editor, caret);
                }
            });
        }
    };
    const copy = (editor) => (evt) => {
        if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
            setClipboardData(evt, getData(editor), fallback(editor), noop);
        }
    };
    const register = (editor, caret) => {
        editor.on('cut', cut(editor, caret));
        editor.on('copy', copy(editor));
    };

    const getCaretRangeFromEvent = (editor, e) => { var _a, _b; 
    // TODO: TINY-7075 Remove the "?? 0" here when agar passes valid client coords
    return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc()); };
    const isPlainTextFileUrl = (content) => {
        const plainTextContent = content['text/plain'];
        return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;
    };
    const setFocusedRange = (editor, rng) => {
        editor.focus();
        if (rng) {
            editor.selection.setRng(rng);
        }
    };
    const hasImage = (dataTransfer) => exists(dataTransfer.files, (file) => /^image\//.test(file.type));
    const needsCustomInternalDrop = (dom, schema, target, dropContent) => {
        const parentTransparent = dom.getParent(target, (node) => isTransparentBlock(schema, node));
        const inSummary = !isNull(dom.getParent(target, 'summary'));
        if (inSummary) {
            return true;
        }
        else if (parentTransparent && has$2(dropContent, 'text/html')) {
            const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;
            return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));
        }
        else {
            return false;
        }
    };
    const setupSummaryDeleteByDragFix = (editor) => {
        editor.on('input', (e) => {
            const hasNoSummary = (el) => isNull(el.querySelector('summary'));
            if (e.inputType === 'deleteByDrag') {
                const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);
                each$e(brokenDetailElements, (details) => {
                    // Firefox leaves a BR
                    if (isBr$7(details.firstChild)) {
                        details.firstChild.remove();
                    }
                    const summary = editor.dom.create('summary');
                    summary.appendChild(createPaddingBr().dom);
                    details.prepend(summary);
                });
            }
        });
    };
    const setup$a = (editor, draggingInternallyState) => {
        // Block all drag/drop events
        if (shouldPasteBlockDrop(editor)) {
            editor.on('dragend dragover draggesture dragdrop drop drag', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        }
        // Prevent users from dropping data images on Gecko
        if (!shouldPasteDataImages(editor)) {
            editor.on('drop', (e) => {
                const dataTransfer = e.dataTransfer;
                if (dataTransfer && hasImage(dataTransfer)) {
                    e.preventDefault();
                }
            });
        }
        editor.on('drop', (e) => {
            if (e.isDefaultPrevented()) {
                return;
            }
            const rng = getCaretRangeFromEvent(editor, e);
            if (isNullable(rng)) {
                return;
            }
            const dropContent = getDataTransferItems(e.dataTransfer);
            const internal = hasContentType(dropContent, internalHtmlMime());
            if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {
                return;
            }
            const internalContent = dropContent[internalHtmlMime()];
            const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];
            const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);
            const isInternalDrop = draggingInternallyState.get();
            if (isInternalDrop && !needsInternalDrop) {
                return;
            }
            if (content) {
                e.preventDefault();
                // FF 45 doesn't paint a caret when dragging in text in due to focus call by execCommand
                Delay.setEditorTimeout(editor, () => {
                    editor.undoManager.transact(() => {
                        if (internalContent || (isInternalDrop && needsInternalDrop)) {
                            editor.execCommand('Delete');
                        }
                        setFocusedRange(editor, rng);
                        const trimmedContent = trimHtml(content);
                        if (dropContent['text/html']) {
                            pasteHtml(editor, trimmedContent, internal, true);
                        }
                        else {
                            pasteText(editor, trimmedContent, true);
                        }
                    });
                });
            }
        });
        editor.on('dragstart', (_e) => {
            draggingInternallyState.set(true);
        });
        editor.on('dragover dragend', (e) => {
            if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {
                e.preventDefault();
                setFocusedRange(editor, getCaretRangeFromEvent(editor, e));
            }
            if (e.type === 'dragend') {
                draggingInternallyState.set(false);
            }
        });
        setupSummaryDeleteByDragFix(editor);
    };

    const setup$9 = (editor) => {
        const processEvent = (f) => (e) => {
            f(editor, e);
        };
        const preProcess = getPastePreProcess(editor);
        if (isFunction(preProcess)) {
            editor.on('PastePreProcess', processEvent(preProcess));
        }
        const postProcess = getPastePostProcess(editor);
        if (isFunction(postProcess)) {
            editor.on('PastePostProcess', processEvent(postProcess));
        }
    };

    /*
     * This module contains various fixes for browsers. These issues can not be feature
     * detected since we have no direct control over the clipboard. However we might be able
     * to remove some of these fixes once the browsers gets updated/fixed.
     */
    const addPreProcessFilter = (editor, filterFunc) => {
        editor.on('PastePreProcess', (e) => {
            e.content = filterFunc(editor, e.content, e.internal);
        });
    };
    const rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
    const rgbToHex = (value) => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();
    /*
     * WebKit has a nasty quirk where the all computed styles gets added to style attributes when copy/pasting contents.
     * This fix solves that by simply removing the whole style attribute.
     *
     * The paste_webkit_styles option can be set to specify what to keep:
     *  paste_webkit_styles: "none" // Keep no styles
     *  paste_webkit_styles: "all", // Keep all of them
     *  paste_webkit_styles: "font-weight color" // Keep specific ones
     */
    const removeWebKitStyles = (editor, content, internal) => {
        const webKitStylesOption = getPasteWebkitStyles(editor);
        // If the content is internal or if we're keeping all styles then we don't need any processing
        if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {
            return content;
        }
        const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];
        // Keep specific styles that don't match the current node computed style
        if (webKitStyles && webKitStylesOption !== 'none') {
            const dom = editor.dom, node = editor.selection.getNode();
            content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (all, before, value, after) => {
                const inputStyles = dom.parseStyle(dom.decode(value));
                const outputStyles = {};
                for (let i = 0; i < webKitStyles.length; i++) {
                    const inputValue = inputStyles[webKitStyles[i]];
                    let compareInput = inputValue;
                    let currentValue = dom.getStyle(node, webKitStyles[i], true);
                    if (/color/.test(webKitStyles[i])) {
                        compareInput = rgbToHex(compareInput);
                        currentValue = rgbToHex(currentValue);
                    }
                    if (currentValue !== compareInput) {
                        outputStyles[webKitStyles[i]] = inputValue;
                    }
                }
                const outputStyle = dom.serializeStyle(outputStyles, 'span');
                if (outputStyle) {
                    return before + ' style="' + outputStyle + '"' + after;
                }
                return before + after;
            });
        }
        else {
            // Remove all external styles
            content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, '$1$3');
        }
        // Keep internal styles
        content = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (all, before, value, after) => {
            return before + ' style="' + value + '"' + after;
        });
        return content;
    };
    const setup$8 = (editor) => {
        if (Env.browser.isChromium() || Env.browser.isSafari()) {
            addPreProcessFilter(editor, removeWebKitStyles);
        }
    };

    const setup$7 = (editor, caret) => {
        const draggingInternallyState = Cell(false);
        const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');
        const pasteBin = PasteBin(editor);
        setup$8(editor);
        register$1(editor, pasteFormat);
        setup$9(editor);
        editor.addQueryStateHandler('mceTogglePlainTextPaste', () => pasteFormat.get() === 'text');
        // IMPORTANT: The following event hooks need to be setup later so that other things
        // can hook in and prevent the event so core paste doesn't handle them.
        editor.on('PreInit', () => {
            register(editor, caret);
            setup$a(editor, draggingInternallyState);
            registerEventsAndFilters(editor, pasteBin, pasteFormat);
        });
    };

    const preventSummaryToggle = (editor) => {
        editor.on('click', (e) => {
            if (editor.dom.getParent(e.target, 'details')) {
                e.preventDefault();
            }
        });
    };
    const filterDetails = (editor) => {
        editor.parser.addNodeFilter('details', (elms) => {
            const initialStateOption = getDetailsInitialState(editor);
            each$e(elms, (details) => {
                if (initialStateOption === 'expanded') {
                    details.attr('open', 'open');
                }
                else if (initialStateOption === 'collapsed') {
                    details.attr('open', null);
                }
            });
        });
        editor.serializer.addNodeFilter('details', (elms) => {
            const serializedStateOption = getDetailsSerializedState(editor);
            each$e(elms, (details) => {
                if (serializedStateOption === 'expanded') {
                    details.attr('open', 'open');
                }
                else if (serializedStateOption === 'collapsed') {
                    details.attr('open', null);
                }
            });
        });
    };
    const setup$6 = (editor) => {
        preventSummaryToggle(editor);
        filterDetails(editor);
    };

    const isBr = isBr$7;
    const isText = isText$b;
    const isContentEditableFalse$2 = (elm) => isContentEditableFalse$a(elm.dom);
    const isContentEditableTrue = (elm) => isContentEditableTrue$3(elm.dom);
    const isRoot = (rootNode) => (elm) => eq(SugarElement.fromDom(rootNode), elm);
    const getClosestScope = (node, rootNode, schema) => closest$4(SugarElement.fromDom(node), (elm) => isContentEditableTrue(elm) || schema.isBlock(name(elm)), isRoot(rootNode))
        .getOr(SugarElement.fromDom(rootNode)).dom;
    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));
    const findEdgeCaretCandidate = (startNode, scope, forward) => {
        const walker = new DomTreeWalker(startNode, scope);
        const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);
        let result = startNode;
        for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {
            if (isCaretCandidate$3(current)) {
                result = current;
            }
        }
        return result;
    };
    const findClosestBlockRange = (startRng, rootNode, schema) => {
        const startPos = CaretPosition.fromRangeStart(startRng);
        // TODO: TINY-8865 - This may not be safe to cast as Node and alternative solutions need to be looked into
        const clickNode = startPos.getNode();
        const scope = getClosestScope(clickNode, rootNode, schema);
        const startNode = findEdgeCaretCandidate(clickNode, scope, false);
        const endNode = findEdgeCaretCandidate(clickNode, scope, true);
        const rng = document.createRange();
        getClosestCef(startNode, scope).fold(() => {
            if (isText(startNode)) {
                rng.setStart(startNode, 0);
            }
            else {
                rng.setStartBefore(startNode);
            }
        }, (cef) => rng.setStartBefore(cef.dom));
        getClosestCef(endNode, scope).fold(() => {
            if (isText(endNode)) {
                rng.setEnd(endNode, endNode.data.length);
            }
            else {
                rng.setEndAfter(endNode);
            }
        }, (cef) => rng.setEndAfter(cef.dom));
        return rng;
    };
    const onTripleClickSelect = (editor) => {
        const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody(), editor.schema);
        editor.selection.setRng(normalize(rng));
    };
    const setup$5 = (editor) => {
        editor.on('mousedown', (e) => {
            if (e.detail >= 3) {
                e.preventDefault();
                onTripleClickSelect(editor);
            }
        });
    };

    var FakeCaretPosition;
    (function (FakeCaretPosition) {
        FakeCaretPosition["Before"] = "before";
        FakeCaretPosition["After"] = "after";
    })(FakeCaretPosition || (FakeCaretPosition = {}));
    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;
    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;
    const isOverlapping = (r1, r2) => {
        // Rectangles might overlap a bit so this checks if the overlap is more than 50% then we count that as on the same line
        const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);
        return collidesY(r1, r2) && overlap > 0.5;
    };
    const splitRectsPerAxis = (rects, y) => {
        const intersectingRects = filter$5(rects, (rect) => isInsideY(y, rect));
        return boundingClientRectFromRects(intersectingRects).fold(() => ([[], rects]), (boundingRect) => {
            const { pass: horizontal, fail: vertical } = partition$2(rects, (rect) => isOverlapping(rect, boundingRect));
            return [horizontal, vertical];
        });
    };
    const clientInfo = (rect, clientX) => {
        return {
            node: rect.node,
            position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After
        };
    };
    // Measure the distance between the x and the closest edge of the rect.
    // If the x is inside the rect then always return 0.
    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));
    const closestChildCaretCandidateNodeRect = (children, clientX, clientY, findCloserTextNode) => {
        const caretCandidateRect = (rect) => {
            if (isCaretCandidate$3(rect.node)) {
                return Optional.some(rect);
            }
            else if (isElement$7(rect.node)) {
                return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY, false);
            }
            else {
                return Optional.none();
            }
        };
        // If an element and a text node has nearly equal distance then favor the text node over the element to make it easier to select text
        // since setting the selection range will cancel any text select operation.
        const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {
            return caretCandidateRect(sndClosest).filter((rect) => {
                const deltaDistance = Math.abs(distance(closest, clientX, clientY) - distance(rect, clientX, clientY));
                return deltaDistance < 2 && isText$b(rect.node);
            });
        };
        const findClosestCaretCandidateNodeRect = (rects, distance) => {
            const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));
            return findMap(sortedRects, caretCandidateRect).map((closest) => {
                // If the closest rect is not a text node then lets try to see if the second rect has a text node that is close enough
                if (findCloserTextNode && !isText$b(closest.node) && sortedRects.length > 1) {
                    return tryFindSecondBestTextNode(closest, sortedRects[1], distance).getOr(closest);
                }
                else {
                    return closest;
                }
            });
        };
        const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);
        const { pass: above, fail: below } = partition$2(verticalRects, (rect) => rect.top < clientY);
        return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance)
            .orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY))
            .orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));
    };
    const traverseUp = (rootElm, scope, clientX, clientY) => {
        const helper = (scope, prevScope) => {
            const isDragGhostContainer = (node) => isElement$7(node) && node.classList.contains('mce-drag-container');
            const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));
            return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY, true), (prevScope) => {
                const uncheckedChildren = filter$5(childNodesWithoutGhost, (node) => node !== prevScope.dom);
                return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY, true);
            }).orThunk(() => {
                const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);
                return parent.bind((newScope) => helper(newScope, Optional.some(scope)));
            });
        };
        return helper(scope, Optional.none());
    };
    // Rough description of how this algorithm works:
    // 1. It starts by finding the element at the specified X, Y coordinate.
    // 2. Then it checks its children for the closest one and traverses down into those repeating step 2, 3 until it finds a caret candidate.
    // 3. If no caret candidate is found in the closest child node then it checks the second closest and so on until all decendants have been checked.
    // 4. If no caret candidate is found, it traverses up skips the element it already checked and checks its siblings using steps 2, 3.
    // 5. If no caret candidate is found, it continues step 4 until it finds the root. Then we have checked all the nodes in the document.
    //
    // This is less accurate but more performant, since for the common case you are likely to find a caret candidate close to where you are clicking.
    // The more accurate algorithm would be to read all caret candidates rects in the whole document in and in one big step to find the closest one, but that is just too slow for bigger documents.
    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {
        const rootElm = SugarElement.fromDom(root);
        const ownerDoc = documentOrOwner(rootElm);
        const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter((elm) => contains(rootElm, elm));
        const element = elementAtPoint.getOr(rootElm);
        return traverseUp(rootElm, element, clientX, clientY);
    };
    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY)
        .filter((rect) => isFakeCaretTarget(rect.node))
        .map((rect) => clientInfo(rect, clientX));

    const getAbsolutePosition = (elm) => {
        var _a, _b;
        const clientRect = elm.getBoundingClientRect();
        const doc = elm.ownerDocument;
        const docElem = doc.documentElement;
        const win = doc.defaultView;
        return {
            top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,
            left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft
        };
    };
    const getBodyPosition = (editor) => editor.inline ? getAbsolutePosition(editor.getBody()) : { left: 0, top: 0 };
    const getScrollPosition = (editor) => {
        const body = editor.getBody();
        return editor.inline ? { left: body.scrollLeft, top: body.scrollTop } : { left: 0, top: 0 };
    };
    const getBodyScroll = (editor) => {
        const body = editor.getBody(), docElm = editor.getDoc().documentElement;
        const inlineScroll = { left: body.scrollLeft, top: body.scrollTop };
        const iframeScroll = { left: body.scrollLeft || docElm.scrollLeft, top: body.scrollTop || docElm.scrollTop };
        return editor.inline ? inlineScroll : iframeScroll;
    };
    const getMousePosition = (editor, event) => {
        if (event.target.ownerDocument !== editor.getDoc()) {
            const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
            const scrollPosition = getBodyScroll(editor);
            return {
                left: event.pageX - iframePosition.left + scrollPosition.left,
                top: event.pageY - iframePosition.top + scrollPosition.top
            };
        }
        return {
            left: event.pageX,
            top: event.pageY
        };
    };
    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({
        pageX: (mousePosition.left - bodyPosition.left) + scrollPosition.left,
        pageY: (mousePosition.top - bodyPosition.top) + scrollPosition.top
    });
    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));

    const getTargetProps = (target) => ({ target, srcElement: target });
    const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({
        ...mouseEvent,
        dataTransfer,
        type,
        ...getTargetProps(target)
    });
    const makeDndEvent = (type, target, dataTransfer) => {
        const fail = die('Function not supported on simulated event.');
        const event = {
            // Event
            bubbles: true,
            cancelBubble: false,
            cancelable: true,
            composed: false,
            currentTarget: null,
            defaultPrevented: false,
            eventPhase: 0,
            isTrusted: true,
            returnValue: false,
            timeStamp: 0,
            type,
            composedPath: fail,
            initEvent: fail,
            preventDefault: noop,
            stopImmediatePropagation: noop,
            stopPropagation: noop,
            AT_TARGET: window.Event.AT_TARGET,
            BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
            CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
            NONE: window.Event.NONE,
            // UIEvent
            altKey: false,
            button: 0,
            buttons: 0,
            clientX: 0,
            clientY: 0,
            ctrlKey: false,
            layerX: 0,
            layerY: 0,
            metaKey: false,
            movementX: 0,
            movementY: 0,
            offsetX: 0,
            offsetY: 0,
            pageX: 0,
            pageY: 0,
            relatedTarget: null,
            screenX: 0,
            screenY: 0,
            shiftKey: false,
            x: 0,
            y: 0,
            detail: 0,
            view: null,
            which: 0,
            initUIEvent: fail,
            initMouseEvent: fail,
            getModifierState: fail,
            // DragEvent
            dataTransfer,
            ...getTargetProps(target)
        };
        return event;
    };
    const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {
        const copy = cloneDataTransfer(dataTransfer);
        // TINY-9601: Set mode as per https://html.spec.whatwg.org/dev/dnd.html#concept-dnd-rw
        if (eventType === 'dragstart') {
            setDragstartEvent(copy);
            setReadWriteMode(copy);
        }
        else if (eventType === 'drop') {
            setDropEvent(copy);
            setReadOnlyMode(copy);
        }
        else {
            setDragendEvent(copy);
            setProtectedMode(copy);
        }
        return copy;
    };
    const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {
        // TINY-9601: Get copy for each new event to prevent undesired mutations on dispatched DataTransfer objects
        const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);
        return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);
    };

    /**
     * This module contains logic overriding the drag/drop logic of the editor.
     *
     * @private
     * @class tinymce.DragDropOverrides
     */
    // Arbitrary values needed when scrolling CEF elements
    const scrollPixelsPerInterval = 32;
    const scrollIntervalValue = 100;
    const mouseRangeToTriggerScrollInsideEditor = 8;
    const mouseRangeToTriggerScrollOutsideEditor = 16;
    const isContentEditableFalse$1 = isContentEditableFalse$a;
    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);
    const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);
    const isValidDropTarget = (editor, targetElement, dragElement) => {
        if (isNullable(targetElement)) {
            return false;
        }
        else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
            return false;
        }
        else {
            return editor.dom.isEditable(targetElement);
        }
    };
    const createGhost = (editor, elm, width, height) => {
        const dom = editor.dom;
        const clonedElm = elm.cloneNode(true);
        dom.setStyles(clonedElm, { width, height });
        dom.setAttrib(clonedElm, 'data-mce-selected', null);
        const ghostElm = dom.create('div', {
            'class': 'mce-drag-container',
            'data-mce-bogus': 'all',
            'unselectable': 'on',
            'contenteditable': 'false'
        });
        dom.setStyles(ghostElm, {
            position: 'absolute',
            opacity: 0.5,
            overflow: 'hidden',
            border: 0,
            padding: 0,
            margin: 0,
            width,
            height
        });
        dom.setStyles(clonedElm, {
            margin: 0,
            boxSizing: 'border-box'
        });
        ghostElm.appendChild(clonedElm);
        return ghostElm;
    };
    const appendGhostToBody = (ghostElm, bodyElm) => {
        if (ghostElm.parentNode !== bodyElm) {
            bodyElm.appendChild(ghostElm);
        }
    };
    // Helper function needed for scrolling the editor inside moveGhost function
    const scrollEditor = (direction, amount) => (win) => () => {
        const current = direction === 'left' ? win.scrollX : win.scrollY;
        win.scroll({
            [direction]: current + amount,
            behavior: 'smooth',
        });
    };
    const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);
    const scrollRight = scrollEditor('left', scrollPixelsPerInterval);
    const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);
    const scrollDown = scrollEditor('top', scrollPixelsPerInterval);
    const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {
        let overflowX = 0, overflowY = 0;
        ghostElm.style.left = position.pageX + 'px';
        ghostElm.style.top = position.pageY + 'px';
        if (position.pageX + width > maxX) {
            overflowX = (position.pageX + width) - maxX;
        }
        if (position.pageY + height > maxY) {
            overflowY = (position.pageY + height) - maxY;
        }
        ghostElm.style.width = (width - overflowX) + 'px';
        ghostElm.style.height = (height - overflowY) + 'px';
        // Code needed for dragging CEF elements (specifically fixing TINY-8874)
        // The idea behind the algorithm is that the user will start dragging the
        // CEF element to the edge of the editor and that would cause scrolling.
        // The way that happens is that the user will trigger a mousedown event,
        // then a mousemove event until they reach the edge of the editor. Then
        // no event triggers. That's when I set an interval to keep scrolling the editor.
        // Once a new event triggers I clear the existing interval and set it back to none.
        const clientHeight = contentAreaContainer.clientHeight;
        const clientWidth = contentAreaContainer.clientWidth;
        const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;
        const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;
        state.on((state) => {
            state.intervalId.clear();
            if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {
                // This basically means that the mouse is close to the bottom edge
                // (within MouseRange pixels of the bottom edge)
                if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {
                    state.intervalId.set(scrollDown(win));
                    // This basically means that the mouse is close to the top edge
                    // (within MouseRange pixels)
                }
                else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {
                    state.intervalId.set(scrollUp(win));
                    // This basically means that the mouse is close to the right edge
                    // (within MouseRange pixels of the right edge)
                }
                else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {
                    state.intervalId.set(scrollRight(win));
                    // This basically means that the mouse is close to the left edge
                    // (within MouseRange pixels of the left edge)
                }
                else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {
                    state.intervalId.set(scrollLeft(win));
                    // This basically means that the mouse is close to the bottom edge
                    // of the page (within MouseRange pixels) when the bottom of
                    // the editor is offscreen
                }
                else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {
                    state.intervalId.set(scrollDown(window));
                    // This basically means that the mouse is close to the upper edge
                    // of the page (within MouseRange pixels) when the top of
                    // the editor is offscreen
                }
                else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {
                    state.intervalId.set(scrollUp(window));
                    // This basically means that the mouse is close to the right edge
                    // of the page (within MouseRange pixels) when the right edge of
                    // the editor is offscreen
                }
                else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {
                    state.intervalId.set(scrollRight(window));
                    // This basically means that the mouse is close to the left edge
                    // of the page (within MouseRange pixels) when the left edge of
                    // the editor is offscreen
                }
                else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {
                    state.intervalId.set(scrollLeft(window));
                }
            }
        });
    };
    const removeElement = (elm) => {
        if (elm && elm.parentNode) {
            elm.parentNode.removeChild(elm);
        }
    };
    const removeElementWithPadding = (dom, elm) => {
        const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);
        removeElement(elm);
        if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {
            fillWithPaddingBr(SugarElement.fromDom(parentBlock));
        }
    };
    const isLeftMouseButtonPressed = (e) => e.button === 0;
    const applyRelPos = (state, position) => ({
        pageX: position.pageX - state.relX,
        pageY: position.pageY + 5
    });
    const start = (state, editor) => (e) => {
        if (isLeftMouseButtonPressed(e)) {
            const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);
            if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {
                const elmPos = editor.dom.getPos(ceElm);
                const bodyElm = editor.getBody();
                const docElm = editor.getDoc().documentElement;
                state.set({
                    element: ceElm,
                    dataTransfer: createDataTransfer(),
                    dragging: false,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
                    maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
                    relX: e.pageX - elmPos.x,
                    relY: e.pageY - elmPos.y,
                    width: ceElm.offsetWidth,
                    height: ceElm.offsetHeight,
                    ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),
                    intervalId: repeatable(scrollIntervalValue)
                });
            }
        }
    };
    const placeCaretAt = (editor, clientX, clientY) => {
        editor._selectionOverrides.hideFakeCaret();
        closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), (caretInfo) => {
            const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
            if (range) {
                editor.selection.setRng(range);
            }
            else {
                editor.selection.placeCaretAt(clientX, clientY);
            }
        });
    };
    const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {
        if (type === 'dragstart') {
            setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));
        }
        const event = makeDragEvent(type, target, dataTransfer, mouseEvent);
        const args = editor.dispatch(type, event);
        return args;
    };
    const move = (state, editor) => {
        // Reduces laggy drag behavior on Gecko
        const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);
        editor.on('remove', throttledPlaceCaretAt.cancel);
        const state_ = state;
        return (e) => state.on((state) => {
            const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));
            if (!state.dragging && movement > 10) {
                const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);
                // TINY-9601: dataTransfer is writable in dragstart, so keep it up-to-date
                if (isNonNullable(args.dataTransfer)) {
                    state.dataTransfer = args.dataTransfer;
                }
                if (args.isDefaultPrevented()) {
                    return;
                }
                state.dragging = true;
                editor.focus();
            }
            if (state.dragging) {
                const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;
                const targetPos = applyRelPos(state, calc(editor, e));
                appendGhostToBody(state.ghost, editor.getBody());
                moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);
                throttledPlaceCaretAt.throttle(e.clientX, e.clientY);
            }
        });
    };
    // Returns the raw element instead of the fake cE=false element
    const getRawTarget = (selection) => {
        const sel = selection.getSel();
        if (isNonNullable(sel)) {
            const rng = sel.getRangeAt(0);
            const startContainer = rng.startContainer;
            return isText$b(startContainer) ? startContainer.parentNode : startContainer;
        }
        else {
            return null;
        }
    };
    const drop = (state, editor) => (e) => {
        state.on((state) => {
            var _a;
            state.intervalId.clear();
            if (state.dragging) {
                if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
                    const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();
                    const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);
                    if (!args.isDefaultPrevented()) {
                        editor.undoManager.transact(() => {
                            removeElementWithPadding(editor.dom, state.element);
                            // TINY-9601: Use dataTransfer property to determine inserted content on drop. This allows users to
                            // manipulate drop content by modifying dataTransfer in the dragstart event.
                            getHtmlData(state.dataTransfer).each((content) => editor.insertContent(content));
                            editor._selectionOverrides.hideFakeCaret();
                        });
                    }
                }
                // Use body as the target since the element we are dragging no longer exists. Native drag/drop works in a similar way.
                dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);
            }
        });
        removeDragState(state);
    };
    const stopDragging = (state, editor, e) => {
        state.on((state) => {
            state.intervalId.clear();
            if (state.dragging) {
                e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), (mouseEvent) => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));
            }
        });
        removeDragState(state);
    };
    const stop = (state, editor) => (e) => stopDragging(state, editor, Optional.some(e));
    const removeDragState = (state) => {
        state.on((state) => {
            state.intervalId.clear();
            removeElement(state.ghost);
        });
        state.clear();
    };
    const bindFakeDragEvents = (editor) => {
        const state = value$1();
        const pageDom = DOMUtils.DOM;
        const rootDocument = document;
        const dragStartHandler = start(state, editor);
        const dragHandler = move(state, editor);
        const dropHandler = drop(state, editor);
        const dragEndHandler = stop(state, editor);
        editor.on('mousedown', dragStartHandler);
        editor.on('mousemove', dragHandler);
        editor.on('mouseup', dropHandler);
        pageDom.bind(rootDocument, 'mousemove', dragHandler);
        pageDom.bind(rootDocument, 'mouseup', dragEndHandler);
        editor.on('remove', () => {
            pageDom.unbind(rootDocument, 'mousemove', dragHandler);
            pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);
        });
        editor.on('keydown', (e) => {
            // Fire 'dragend' when the escape key is pressed
            if (e.keyCode === VK.ESC) {
                stopDragging(state, editor, Optional.none());
            }
        });
    };
    // Block files being dropped within the editor to prevent accidentally navigating away
    // while editing. Note that we can't use the `editor.on` API here, as we want these
    // to run after the editor event handlers have run. We also bind to the document
    // so that it'll try to ensure it's the last thing that runs, as it bubbles up the dom.
    const blockUnsupportedFileDrop = (editor) => {
        const preventFileDrop = (e) => {
            if (!e.isDefaultPrevented()) {
                // Prevent file drop events within the editor, as they'll cause the browser to navigate away
                const dataTransfer = e.dataTransfer;
                if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {
                    e.preventDefault();
                    if (e.type === 'drop') {
                        displayError(editor, 'Dropped file type is not supported');
                    }
                }
            }
        };
        const preventFileDropIfUIElement = (e) => {
            if (isUIElement(editor, e.target)) {
                preventFileDrop(e);
            }
        };
        const setup = () => {
            const pageDom = DOMUtils.DOM;
            const dom = editor.dom;
            const doc = document;
            const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
            const eventNames = ['drop', 'dragover'];
            each$e(eventNames, (name) => {
                pageDom.bind(doc, name, preventFileDropIfUIElement);
                dom.bind(editorRoot, name, preventFileDrop);
            });
            editor.on('remove', () => {
                each$e(eventNames, (name) => {
                    pageDom.unbind(doc, name, preventFileDropIfUIElement);
                    dom.unbind(editorRoot, name, preventFileDrop);
                });
            });
        };
        editor.on('init', () => {
            // Use a timeout to ensure this fires after all other init callbacks
            Delay.setEditorTimeout(editor, setup, 0);
        });
    };
    const init$2 = (editor) => {
        bindFakeDragEvents(editor);
        if (shouldBlockUnsupportedDrop(editor)) {
            blockUnsupportedFileDrop(editor);
        }
    };

    const setup$4 = (editor) => {
        const renderFocusCaret = first$1(() => {
            // AP-24 Added the second condition in this if because of a race condition with setting focus on the PowerPaste
            // remove/keep formatting dialog on paste in IE11. Without this, because we paste twice on IE11, focus ends up set
            // in the editor, not the dialog buttons. Specifically, we focus, blur, focus, blur, focus then enter this throttled
            // code before the next blur has been able to run. With this check, this function doesn't run at all in this case,
            // so focus goes to the dialog's buttons correctly.
            if (!editor.removed && editor.getBody().contains(document.activeElement)) {
                const rng = editor.selection.getRng();
                if (rng.collapsed) { // see TINY-1479
                    const caretRange = renderRangeCaret(editor, rng, false);
                    editor.selection.setRng(caretRange);
                }
            }
        }, 0);
        editor.on('focus', () => {
            renderFocusCaret.throttle();
        });
        editor.on('blur', () => {
            renderFocusCaret.cancel();
        });
    };

    const setup$3 = (editor) => {
        editor.on('init', () => {
            // Audio elements don't fire mousedown/click events and only fire a focus event so
            // we need to capture that event being fired and use it to update the selection.
            editor.on('focusin', (e) => {
                const target = e.target;
                if (isMedia$2(target)) {
                    const ceRoot = getContentEditableRoot$1(editor.getBody(), target);
                    const node = isContentEditableFalse$a(ceRoot) ? ceRoot : target;
                    if (editor.selection.getNode() !== node) {
                        selectNode(editor, node).each((rng) => editor.selection.setRng(rng));
                    }
                }
            });
        });
    };

    const isContentEditableFalse = isContentEditableFalse$a;
    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);
    const SelectionOverrides = (editor) => {
        const selection = editor.selection, dom = editor.dom;
        const rootNode = editor.getBody();
        const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));
        const realSelectionId = 'sel-' + dom.uniqueId();
        const elementSelectionAttr = 'data-mce-selected';
        let selectedElement;
        const isFakeSelectionElement = (node) => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');
        // Note: isChildOf will return true if node === rootNode, so we need an additional check for that
        const isFakeSelectionTargetElement = (node) => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);
        const setRange = (range) => {
            if (range) {
                selection.setRng(range);
            }
        };
        const showCaret = (direction, node, before, scrollIntoView = true) => {
            const e = editor.dispatch('ShowCaret', {
                target: node,
                direction,
                before
            });
            if (e.isDefaultPrevented()) {
                return null;
            }
            if (scrollIntoView) {
                selection.scrollIntoView(node, direction === -1);
            }
            return fakeCaret.show(before, node);
        };
        const showBlockCaretContainer = (blockCaretContainer) => {
            if (blockCaretContainer.hasAttribute('data-mce-caret')) {
                showCaretContainerBlock(blockCaretContainer);
                selection.scrollIntoView(blockCaretContainer);
            }
        };
        const registerEvents = () => {
            editor.on('click', (e) => {
                // Prevent clicks on links in a cE=false element
                if (!dom.isEditable(e.target)) {
                    e.preventDefault();
                    editor.focus();
                }
            });
            editor.on('blur NewBlock', removeElementSelection);
            editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);
            editor.on('tap', (e) => {
                const targetElm = e.target;
                const contentEditableRoot = getContentEditableRoot(editor, targetElm);
                if (isContentEditableFalse(contentEditableRoot)) {
                    e.preventDefault();
                    selectNode(editor, contentEditableRoot).each(setElementSelection);
                }
                else if (isFakeSelectionTargetElement(targetElm)) {
                    selectNode(editor, targetElm).each(setElementSelection);
                }
            }, true);
            editor.on('mousedown', (e) => {
                const targetElm = e.target;
                if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {
                    return;
                }
                if (!isXYInContentArea(editor, e.clientX, e.clientY)) {
                    return;
                }
                // Remove needs to be called here since the mousedown might alter the selection without calling selection.setRng
                // and therefore not fire the AfterSetSelectionRange event.
                removeElementSelection();
                hideFakeCaret();
                const closestContentEditable = getContentEditableRoot(editor, targetElm);
                if (isContentEditableFalse(closestContentEditable)) {
                    e.preventDefault();
                    selectNode(editor, closestContentEditable).each(setElementSelection);
                }
                else {
                    closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each((caretInfo) => {
                        e.preventDefault();
                        const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
                        setRange(range);
                        // Set the focus after the range has been set to avoid potential issues where the body has no selection
                        if (isHTMLElement(closestContentEditable)) {
                            closestContentEditable.focus();
                        }
                        else {
                            editor.getBody().focus();
                        }
                    });
                }
            });
            editor.on('keypress', (e) => {
                if (VK.modifierPressed(e)) {
                    return;
                }
                if (isContentEditableFalse(selection.getNode())) {
                    e.preventDefault();
                }
            });
            editor.on('GetSelectionRange', (e) => {
                let rng = e.range;
                if (selectedElement) {
                    if (!selectedElement.parentNode) {
                        selectedElement = null;
                        return;
                    }
                    rng = rng.cloneRange();
                    rng.selectNode(selectedElement);
                    e.range = rng;
                }
            });
            editor.on('focusin', (e) => {
                // for medias the selection is already managed in `MediaFocus.ts`
                if (editor.selection.isCollapsed() && !isMedia$2(e.target) && editor.getBody().contains(e.target) && e.target !== editor.getBody() && !editor.dom.isEditable(e.target.parentNode)) {
                    if (fakeCaret.isShowing()) {
                        fakeCaret.hide();
                    }
                    if (!e.target.contains(editor.selection.getNode())) {
                        editor.selection.select(e.target, true);
                        editor.selection.collapse(true);
                    }
                    const rng = setElementSelection(editor.selection.getRng(), true);
                    if (rng) {
                        editor.selection.setRng(rng);
                    }
                }
            });
            editor.on('SetSelectionRange', (e) => {
                // If the range is set inside a short ended element, then move it
                // to the side as IE for example will try to add content inside
                e.range = normalizeVoidElementSelection(e.range);
                const rng = setElementSelection(e.range, e.forward);
                if (rng) {
                    e.range = rng;
                }
            });
            const isPasteBin = (node) => isElement$7(node) && node.id === 'mcepastebin';
            editor.on('AfterSetSelectionRange', (e) => {
                const rng = e.range;
                const parent = rng.startContainer.parentElement;
                if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {
                    hideFakeCaret();
                }
                if (!isFakeSelectionElement(parent)) {
                    removeElementSelection();
                }
            });
            init$2(editor);
            setup$4(editor);
            setup$3(editor);
        };
        const isWithinCaretContainer = (node) => (isCaretContainer$2(node) ||
            startsWithCaretContainer$1(node) ||
            endsWithCaretContainer$1(node));
        const isRangeInCaretContainer = (rng) => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
        const normalizeVoidElementSelection = (rng) => {
            const voidElements = editor.schema.getVoidElements();
            const newRng = dom.createRng();
            const startContainer = rng.startContainer;
            const startOffset = rng.startOffset;
            const endContainer = rng.endContainer;
            const endOffset = rng.endOffset;
            if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {
                if (startOffset === 0) {
                    newRng.setStartBefore(startContainer);
                }
                else {
                    newRng.setStartAfter(startContainer);
                }
            }
            else {
                newRng.setStart(startContainer, startOffset);
            }
            if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {
                if (endOffset === 0) {
                    newRng.setEndBefore(endContainer);
                }
                else {
                    newRng.setEndAfter(endContainer);
                }
            }
            else {
                newRng.setEnd(endContainer, endOffset);
            }
            return newRng;
        };
        const setupOffscreenSelection = (node, targetClone) => {
            const body = SugarElement.fromDom(editor.getBody());
            const doc = editor.getDoc();
            const realSelectionContainer = descendant$1(body, '#' + realSelectionId).getOrThunk(() => {
                const newContainer = SugarElement.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', doc);
                set$4(newContainer, 'id', realSelectionId);
                append$1(body, newContainer);
                return newContainer;
            });
            const newRange = dom.createRng();
            empty(realSelectionContainer);
            append(realSelectionContainer, [
                SugarElement.fromText(nbsp, doc),
                SugarElement.fromDom(targetClone),
                SugarElement.fromText(nbsp, doc)
            ]);
            newRange.setStart(realSelectionContainer.dom.firstChild, 1);
            newRange.setEnd(realSelectionContainer.dom.lastChild, 0);
            setAll(realSelectionContainer, {
                top: dom.getPos(node, editor.getBody()).y + 'px'
            });
            focus$1(realSelectionContainer);
            const sel = selection.getSel();
            if (sel) {
                sel.removeAllRanges();
                sel.addRange(newRange);
            }
            return newRange;
        };
        const selectElement = (elm) => {
            const targetClone = elm.cloneNode(true);
            const e = editor.dispatch('ObjectSelected', { target: elm, targetClone });
            if (e.isDefaultPrevented()) {
                return null;
            }
            // Setup the offscreen selection
            const range = setupOffscreenSelection(elm, e.targetClone);
            // We used to just remove all data-mce-selected values and set 1 on node.
            // But data-mce-selected can be values other than 1 so keep existing value if
            // node has one, and remove data-mce-selected from everything else
            const nodeElm = SugarElement.fromDom(elm);
            each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${elementSelectionAttr}]`), (elm) => {
                if (!eq(nodeElm, elm)) {
                    remove$9(elm, elementSelectionAttr);
                }
            });
            if (!dom.getAttrib(elm, elementSelectionAttr)) {
                elm.setAttribute(elementSelectionAttr, '1');
            }
            selectedElement = elm;
            hideFakeCaret();
            return range;
        };
        const setElementSelection = (range, forward) => {
            if (!range) {
                return null;
            }
            if (range.collapsed) {
                if (!isRangeInCaretContainer(range)) {
                    const dir = forward ? 1 : -1;
                    const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);
                    const beforeNode = caretPosition.getNode(!forward);
                    if (isNonNullable(beforeNode)) {
                        if (isFakeCaretTarget(beforeNode)) {
                            return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);
                        }
                        if (isCaretContainerInline(beforeNode) && isContentEditableFalse$a(beforeNode.nextSibling)) {
                            const rng = dom.createRng();
                            rng.setStart(beforeNode, 0);
                            rng.setEnd(beforeNode, 0);
                            return rng;
                        }
                    }
                    const afterNode = caretPosition.getNode(forward);
                    if (isNonNullable(afterNode)) {
                        if (isFakeCaretTarget(afterNode)) {
                            return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);
                        }
                        if (isCaretContainerInline(afterNode) && isContentEditableFalse$a(afterNode.previousSibling)) {
                            const rng = dom.createRng();
                            rng.setStart(afterNode, 1);
                            rng.setEnd(afterNode, 1);
                            return rng;
                        }
                    }
                }
                return null;
            }
            let startContainer = range.startContainer;
            let startOffset = range.startOffset;
            const endOffset = range.endOffset;
            // Normalizes <span cE=false>[</span>] to [<span cE=false></span>]
            if (isText$b(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {
                startContainer = startContainer.parentNode;
                startOffset = dom.nodeIndex(startContainer);
                startContainer = startContainer.parentNode;
            }
            if (!isElement$7(startContainer)) {
                return null;
            }
            if (endOffset === startOffset + 1 && startContainer === range.endContainer) {
                const node = startContainer.childNodes[startOffset];
                if (isFakeSelectionTargetElement(node)) {
                    return selectElement(node);
                }
            }
            return null;
        };
        const removeElementSelection = () => {
            if (selectedElement) {
                selectedElement.removeAttribute(elementSelectionAttr);
            }
            descendant$1(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$8);
            selectedElement = null;
        };
        const destroy = () => {
            fakeCaret.destroy();
            selectedElement = null;
        };
        const hideFakeCaret = () => {
            fakeCaret.hide();
        };
        if (!isRtc(editor)) {
            registerEvents();
        }
        return {
            showCaret,
            showBlockCaretContainer,
            hideFakeCaret,
            destroy
        };
    };

    const getNormalizedTextOffset = (container, offset) => {
        let normalizedOffset = offset;
        for (let node = container.previousSibling; isText$b(node); node = node.previousSibling) {
            normalizedOffset += node.data.length;
        }
        return normalizedOffset;
    };
    const generatePath = (dom, root, node, offset, normalized) => {
        if (isText$b(node) && (offset < 0 || offset > node.data.length)) {
            return [];
        }
        const p = normalized && isText$b(node) ? [getNormalizedTextOffset(node, offset)] : [offset];
        let current = node;
        while (current !== root && current.parentNode) {
            p.push(dom.nodeIndex(current, normalized));
            current = current.parentNode;
        }
        return current === root ? p.reverse() : [];
    };
    const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {
        const start = generatePath(dom, root, startNode, startOffset, normalized);
        const end = generatePath(dom, root, endNode, endOffset, normalized);
        return { start, end };
    };
    const resolvePath = (root, path) => {
        const nodePath = path.slice();
        const offset = nodePath.pop();
        if (!isNumber(offset)) {
            return Optional.none();
        }
        else {
            const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind((node) => Optional.from(node.childNodes[index])), Optional.some(root));
            return resolvedNode.bind((node) => {
                if (isText$b(node) && (offset < 0 || offset > node.data.length)) {
                    return Optional.none();
                }
                else {
                    return Optional.some({ node, offset });
                }
            });
        }
    };
    const resolvePathRange = (root, range) => resolvePath(root, range.start)
        .bind(({ node: startNode, offset: startOffset }) => resolvePath(root, range.end).map(({ node: endNode, offset: endOffset }) => {
        const rng = document.createRange();
        rng.setStart(startNode, startOffset);
        rng.setEnd(endNode, endOffset);
        return rng;
    }));
    const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);

    const cleanEmptyNodes = (dom, node, isRoot) => {
        // Recursively walk up the tree while we have a parent and the node is empty. If the node is empty, then remove it.
        if (node && dom.isEmpty(node) && !isRoot(node)) {
            const parent = node.parentNode;
            dom.remove(node, isText$b(node.firstChild) && isWhitespaceText(node.firstChild.data));
            cleanEmptyNodes(dom, parent, isRoot);
        }
    };
    const deleteRng = (dom, rng, isRoot, clean = true) => {
        const startParent = rng.startContainer.parentNode;
        const endParent = rng.endContainer.parentNode;
        rng.deleteContents();
        // Clean up any empty nodes if required
        if (clean && !isRoot(rng.startContainer)) {
            if (isText$b(rng.startContainer) && rng.startContainer.data.length === 0) {
                dom.remove(rng.startContainer);
            }
            if (isText$b(rng.endContainer) && rng.endContainer.data.length === 0) {
                dom.remove(rng.endContainer);
            }
            cleanEmptyNodes(dom, startParent, isRoot);
            if (startParent !== endParent) {
                cleanEmptyNodes(dom, endParent, isRoot);
            }
        }
    };
    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));
    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {
        const dynamicPatterns = patternSet.dynamicPatternsLookup({
            text: beforeText,
            block
        });
        // dynamic patterns take precedence here
        return {
            ...patternSet,
            blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),
            inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)
        };
    };
    const getBeforeText = (dom, block, node, offset) => {
        const rng = dom.createRng();
        rng.setStart(block, 0);
        rng.setEnd(node, offset);
        return rng.toString();
    };

    const newMarker = (dom, id) => dom.create('span', { 'data-mce-type': 'bookmark', id });
    const rangeFromMarker = (dom, marker) => {
        const rng = dom.createRng();
        rng.setStartAfter(marker.start);
        rng.setEndBefore(marker.end);
        return rng;
    };
    const createMarker = (dom, markerPrefix, pathRange) => {
        // Resolve the path range
        const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');
        const startNode = rng.startContainer;
        const endNode = rng.endContainer;
        // Create the marker
        const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);
        const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);
        const startParentNode = textStart.parentNode;
        const endParentNode = textEnd.parentNode;
        return {
            prefix: markerPrefix,
            end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),
            start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)
        };
    };
    const removeMarker = (dom, marker, isRoot) => {
        // Note: Use dom.get() here instead of marker.end/start, as applying the format/command can
        // clone the nodes meaning the old reference isn't usable
        cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);
        cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);
    };

    const isReplacementPattern = (pattern) => pattern.start.length === 0;
    const matchesPattern = (patternContent) => (element, offset) => {
        const text = element.data;
        const searchText = text.substring(0, offset);
        const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));
        const startIndex = searchText.lastIndexOf(patternContent);
        if (startIndex !== -1) {
            // Complete string found
            return startIndex + patternContent.length;
        }
        else if (startEndIndex !== -1) {
            // Potential partial string found
            return startEndIndex + 1;
        }
        else {
            // No match in current node, so continue
            return -1;
        }
    };
    const findPatternStartFromSpot = (dom, pattern, block, spot) => {
        const startPattern = pattern.start;
        const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);
        return startSpot.bind((spot) => {
            var _a, _b;
            const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;
            const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;
            if (isCompleteMatch) {
                // Complete match
                const rng = dom.createRng();
                rng.setStart(spot.container, spot.offset - startPattern.length);
                rng.setEnd(spot.container, spot.offset);
                return Optional.some(rng);
            }
            else {
                // Partial match so lean left to see if the string exists over fragmented text nodes
                const offset = spot.offset - startPattern.length;
                return scanLeft(spot.container, offset, block).map((nextSpot) => {
                    // Build up the range between the last char and the first char
                    const rng = dom.createRng();
                    rng.setStart(nextSpot.container, nextSpot.offset);
                    rng.setEnd(spot.container, spot.offset);
                    return rng;
                }).filter((rng) => 
                // Ensure the range content matches the start
                rng.toString() === startPattern).orThunk(() => 
                // No match found, so continue searching
                findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));
            }
        });
    };
    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {
        if (pattern.start.length === 0 && !requireGap) {
            const rng = dom.createRng();
            rng.setStart(node, offset);
            rng.setEnd(node, offset);
            return Optional.some(rng);
        }
        return textBefore(node, offset, block).bind((spot) => {
            const start = findPatternStartFromSpot(dom, pattern, block, spot);
            return start.bind((startRange) => {
                var _a;
                if (requireGap) {
                    if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {
                        return Optional.none();
                    }
                    else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {
                        return Optional.none();
                    }
                }
                return Optional.some(startRange);
            });
        });
    };
    const findPattern$3 = (editor, block, details, normalizedMatches) => {
        const dom = editor.dom;
        const root = dom.getRoot();
        const pattern = details.pattern;
        const endNode = details.position.container;
        const endOffset = details.position.offset;
        // Lean left to find the start of the end pattern, as it could be across fragmented nodes
        return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind((spot) => {
            const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);
            // If we have a replacement pattern, then it can't have nested patterns so just return immediately
            if (isReplacementPattern(pattern)) {
                return Optional.some({
                    matches: [{
                            pattern,
                            startRng: endPathRng,
                            endRng: endPathRng
                        }],
                    position: spot
                });
            }
            else {
                // Find any nested patterns, making sure not to process the current pattern again
                const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);
                const results = resultsOpt.getOr({ matches: [], position: spot });
                const pos = results.position;
                // Find the start of the matched pattern
                const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());
                return start.map((startRng) => {
                    const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);
                    return {
                        matches: results.matches.concat([{
                                pattern,
                                startRng: startPathRng,
                                endRng: endPathRng
                            }]),
                        position: point(startRng.startContainer, startRng.startOffset)
                    };
                });
            }
        });
    };
    // Assumptions:
    // 0. Patterns are sorted by priority so we should preferentially match earlier entries
    // 1. Patterns may be nested but may only occur once
    // 2. Patterns will not have matching prefixes which contain space or standard punctuation ',', '.', ';', ':', '!', '?'
    // 3. Patterns will not extend outside of the root element
    // 4. All pattern ends must be directly before the cursor (represented by node + offset)
    // 5. Only text nodes matter
    const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {
        const dom = editor.dom;
        return textBefore(node, offset, dom.getRoot()).bind((endSpot) => {
            const text = getBeforeText(dom, block, node, offset);
            for (let i = 0; i < patterns.length; i++) {
                const pattern = patterns[i];
                // If the text does not end with the same string as the pattern, then we can exit
                // early, because this pattern isn't going to match this text. This saves us doing more
                // expensive matching calls.
                if (!endsWith(text, pattern.end)) {
                    continue;
                }
                // Generate a new array without the current pattern
                const patternsWithoutCurrent = patterns.slice();
                patternsWithoutCurrent.splice(i, 1);
                // Try to find the current pattern
                const result = findPattern$3(editor, block, {
                    pattern,
                    remainingPatterns: patternsWithoutCurrent,
                    position: endSpot
                }, normalizedMatches);
                if (result.isNone() && offset > 0) {
                    return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);
                }
                // If a match was found then return that
                if (result.isSome()) {
                    return result;
                }
            }
            return Optional.none();
        });
    };
    const applyPattern$2 = (editor, pattern, patternRange) => {
        editor.selection.setRng(patternRange);
        if (pattern.type === 'inline-format') {
            each$e(pattern.format, (format) => {
                editor.formatter.apply(format);
            });
        }
        else {
            editor.execCommand(pattern.cmd, false, pattern.value);
        }
    };
    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {
        // Remove the original text
        const markerRange = rangeFromMarker(editor.dom, marker);
        deleteRng(editor.dom, markerRange, isRoot);
        // Apply the replacement
        applyPattern$2(editor, pattern, markerRange);
    };
    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {
        const dom = editor.dom;
        // Create the marker ranges for the patterns start/end content
        const markerEndRange = rangeFromMarker(dom, endMarker);
        const markerStartRange = rangeFromMarker(dom, startMarker);
        // Clean up the pattern start/end content
        deleteRng(dom, markerStartRange, isRoot);
        deleteRng(dom, markerEndRange, isRoot);
        // Apply the pattern
        const patternMarker = { prefix: startMarker.prefix, start: startMarker.end, end: endMarker.start };
        const patternRange = rangeFromMarker(dom, patternMarker);
        applyPattern$2(editor, pattern, patternRange);
    };
    const addMarkers = (dom, matches) => {
        const markerPrefix = generate$1('mce_textpattern');
        // Add end markers
        const matchesWithEnds = foldr(matches, (acc, match) => {
            const endMarker = createMarker(dom, markerPrefix + `_end${acc.length}`, match.endRng);
            return acc.concat([{
                    ...match,
                    endMarker
                }]);
        }, []);
        // Add start markers
        return foldr(matchesWithEnds, (acc, match) => {
            const idx = matchesWithEnds.length - acc.length - 1;
            const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${idx}`, match.startRng);
            return acc.concat([{
                    ...match,
                    startMarker
                }]);
        }, []);
    };
    const sortPatterns$1 = (patterns) => sort(patterns, (a, b) => b.end.length - a.end.length);
    const getBestMatches = (matches, matchesWithSortedPatterns) => {
        const hasSameMatches = forall(matches, (match) => exists(matchesWithSortedPatterns, (sortedMatch) => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));
        if (matches.length === matchesWithSortedPatterns.length) {
            if (hasSameMatches) {
                return matches;
            }
            else {
                return matchesWithSortedPatterns;
            }
        }
        return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;
    };
    const findPatterns$2 = (editor, block, node, offset, patternSet, normalizedMatches) => {
        const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], (result) => result.matches);
        const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns$1(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], (result) => result.matches);
        return getBestMatches(matches, matchesWithSortedPatterns);
    };
    const applyMatches$2 = (editor, matches) => {
        if (matches.length === 0) {
            return;
        }
        // Store the current selection
        const dom = editor.dom;
        const bookmark = editor.selection.getBookmark();
        // Add markers for the matched patterns
        const matchesWithMarkers = addMarkers(dom, matches);
        // Do the replacements
        each$e(matchesWithMarkers, (match) => {
            const block = dom.getParent(match.startMarker.start, dom.isBlock);
            const isRoot = (node) => node === block;
            if (isReplacementPattern(match.pattern)) {
                applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);
            }
            else {
                applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);
            }
            // Remove the markers
            removeMarker(dom, match.endMarker, isRoot);
            removeMarker(dom, match.startMarker, isRoot);
        });
        // Restore the selection
        editor.selection.moveToBookmark(bookmark);
    };

    const stripPattern$1 = (dom, block, pattern) => {
        // The pattern could be across fragmented text nodes, so we need to find the end
        // of the pattern and then remove all elements between the start/end range
        return textAfter(block, 0, block).map((spot) => {
            const node = spot.container;
            scanRight(node, pattern.start.length, block).each((end) => {
                const rng = dom.createRng();
                rng.setStart(node, 0);
                rng.setEnd(end.container, end.offset);
                deleteRng(dom, rng, (e) => e === block);
            });
            return node;
        });
    };
    const createApplyPattern = (stripPattern) => (editor, match) => {
        const dom = editor.dom;
        const pattern = match.pattern;
        const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');
        const isBlockFormatName = (name, formatter) => {
            const formatSet = formatter.get(name);
            return isArray$1(formatSet) && head(formatSet).exists((format) => has$2(format, 'block'));
        };
        getParentBlock(editor, rng).each((block) => {
            if (pattern.type === 'block-format') {
                if (isBlockFormatName(pattern.format, editor.formatter)) {
                    editor.undoManager.transact(() => {
                        stripPattern(editor.dom, block, pattern);
                        editor.formatter.apply(pattern.format);
                    });
                }
            }
            else if (pattern.type === 'block-command') {
                editor.undoManager.transact(() => {
                    stripPattern(editor.dom, block, pattern);
                    editor.execCommand(pattern.cmd, false, pattern.value);
                });
            }
        });
        return true;
    };
    const sortPatterns = (patterns) => sort(patterns, (a, b) => b.start.length - a.start.length);
    // Finds a matching pattern to the specified text
    const findPattern$2 = (predicate) => (patterns, text) => {
        const sortedPatterns = sortPatterns(patterns);
        const nuText = text.replace(nbsp, ' ');
        return find$2(sortedPatterns, (pattern) => predicate(pattern, text, nuText));
    };
    const createFindPatterns = (findPattern, skipFullMatch) => (editor, block, patternSet, normalizedMatches, text) => {
        var _a;
        if (text === void 0) { text = (_a = block.textContent) !== null && _a !== void 0 ? _a : ''; }
        const dom = editor.dom;
        const forcedRootBlock = getForcedRootBlock(editor);
        if (!dom.is(block, forcedRootBlock)) {
            return [];
        }
        return findPattern(patternSet.blockPatterns, text).map((pattern) => {
            if (skipFullMatch && Tools.trim(text).length === pattern.start.length) {
                return [];
            }
            return [{
                    pattern,
                    range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)
                }];
        }).getOr([]);
    };

    const startsWithSingleSpace = (s) => /^\s[^\s]/.test(s);
    const stripPattern = (dom, block, pattern) => {
        stripPattern$1(dom, block, pattern).each((node) => {
            /**
             * TINY-9603: If there is a single space between pattern.start and text (e.g. #1)
             * then it will be left in the text content and then can appear in certain circumstances.
             * This is not an issue with multiple spaces because they are transformed to non-breaking ones.
             *
             * In this specific case we've decided to remove this single space whatsoever
             * as it feels to be the expected behavior.
             */
            const text = SugarElement.fromDom(node);
            const textContent = get$4(text);
            if (startsWithSingleSpace(textContent)) {
                set$1(text, textContent.slice(1));
            }
        });
    };
    const applyPattern$1 = createApplyPattern(stripPattern);
    const findPattern$1 = findPattern$2((pattern, text, nuText) => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);
    const findPatterns$1 = createFindPatterns(findPattern$1, true);
    const getMatches$1 = (editor, patternSet) => {
        const rng = editor.selection.getRng();
        return getParentBlock(editor, rng).map((block) => {
            var _a;
            const offset = Math.max(0, rng.startOffset);
            const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');
            // IMPORTANT: We need to get normalized match results since undoing and redoing the editor state
            // via undoManager.extra() will result in the DOM being normalized.
            const inlineMatches = findPatterns$2(editor, block, rng.startContainer, offset, dynamicPatternSet, true);
            const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);
            return { inlineMatches, blockMatches };
        }).filter(({ inlineMatches, blockMatches }) => blockMatches.length > 0 || inlineMatches.length > 0);
    };
    const applyMatches$1 = (editor, matches) => {
        if (matches.length === 0) {
            return;
        }
        // Store the current selection and then apply the matched patterns
        const bookmark = editor.selection.getBookmark();
        each$e(matches, (match) => applyPattern$1(editor, match));
        editor.selection.moveToBookmark(bookmark);
    };

    const applyPattern = createApplyPattern(stripPattern$1);
    const findPattern = findPattern$2((pattern, text, nuText) => text === pattern.start || nuText === pattern.start);
    const findPatterns = createFindPatterns(findPattern, false);
    const getMatches = (editor, patternSet) => {
        const rng = editor.selection.getRng();
        return getParentBlock(editor, rng).map((block) => {
            const offset = Math.max(0, rng.startOffset);
            const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);
            const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);
            return findPatterns(editor, block, dynamicPatternSet, false, beforeText);
        }).filter((matches) => matches.length > 0);
    };
    const applyMatches = (editor, matches) => {
        each$e(matches, (match) => applyPattern(editor, match));
    };

    const handleEnter = (editor, patternSet) => getMatches$1(editor, patternSet).fold(never, ({ inlineMatches, blockMatches }) => {
        editor.undoManager.add();
        editor.undoManager.extra(() => {
            editor.execCommand('mceInsertNewLine');
        }, () => {
            // create a cursor position that we can move to avoid the inline formats
            insert$5(editor);
            applyMatches$2(editor, inlineMatches);
            applyMatches$1(editor, blockMatches);
            // find the spot before the cursor position
            const range = editor.selection.getRng();
            const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());
            editor.execCommand('mceInsertNewLine');
            // clean up the cursor position we used to preserve the format
            spot.each((s) => {
                const node = s.container;
                if (node.data.charAt(s.offset - 1) === zeroWidth) {
                    node.deleteData(s.offset - 1, 1);
                    cleanEmptyNodes(editor.dom, node.parentNode, (e) => e === editor.dom.getRoot());
                }
            });
        });
        return true;
    });
    const handleInlineKey = (editor, patternSet) => {
        const rng = editor.selection.getRng();
        getParentBlock(editor, rng).map((block) => {
            const offset = Math.max(0, rng.startOffset - 1);
            const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);
            const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);
            const inlineMatches = findPatterns$2(editor, block, rng.startContainer, offset, dynamicPatternSet, false);
            if (inlineMatches.length > 0) {
                editor.undoManager.transact(() => {
                    applyMatches$2(editor, inlineMatches);
                });
            }
        });
    };
    const handleBlockPatternOnSpace = (editor, patternSet) => getMatches(editor, patternSet).fold(never, (matches) => {
        editor.undoManager.transact(() => {
            applyMatches(editor, matches);
        });
        return true;
    });
    const checkKeyEvent = (codes, event, predicate) => {
        for (let i = 0; i < codes.length; i++) {
            if (predicate(codes[i], event)) {
                return true;
            }
        }
        return false;
    };
    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {
        return code === event.keyCode && !VK.modifierPressed(event);
    });
    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {
        return chr.charCodeAt(0) === event.charCode;
    });

    const setup$2 = (editor) => {
        const charCodes = [',', '.', ';', ':', '!', '?'];
        const keyCodes = [32];
        // This is a thunk so that they reflect changes in the underlying options each time they are requested.
        const getPatternSet = () => createPatternSet(getTextPatterns(editor)
            .filter((pattern) => {
            if (pattern.type === 'inline-command' || pattern.type === 'block-command') {
                return editor.queryCommandSupported(pattern.cmd);
            }
            return true;
        }), getTextPatternsLookup(editor));
        // Only used for skipping text pattern matching altogether if nothing has been defined.
        const hasDynamicPatterns = () => hasTextPatternsLookup(editor);
        editor.on('keydown', (e) => {
            if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed() && editor.selection.isEditable()) {
                const patternSet = filterByTrigger(getPatternSet(), 'enter');
                // Do not process anything if we don't have any inline patterns, block patterns,
                // or dynamic lookup defined
                const hasPatterns = patternSet.inlinePatterns.length > 0 ||
                    patternSet.blockPatterns.length > 0 ||
                    hasDynamicPatterns();
                if (hasPatterns && handleEnter(editor, patternSet)) {
                    e.preventDefault();
                }
            }
        }, true);
        editor.on('keydown', (e) => {
            if (e.keyCode === 32 && editor.selection.isCollapsed() && editor.selection.isEditable()) {
                const patternSet = filterByTrigger(getPatternSet(), 'space');
                const hasPatterns = patternSet.blockPatterns.length > 0 || hasDynamicPatterns();
                if (hasPatterns && handleBlockPatternOnSpace(editor, patternSet)) {
                    e.preventDefault();
                }
            }
        }, true);
        const handleInlineTrigger = () => {
            if (editor.selection.isCollapsed() && editor.selection.isEditable()) {
                const patternSet = filterByTrigger(getPatternSet(), 'space');
                // Do not process anything if we don't have any inline patterns or dynamic lookup defined
                const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();
                if (hasPatterns) {
                    handleInlineKey(editor, patternSet);
                }
            }
        };
        editor.on('keyup', (e) => {
            if (checkKeyCode(keyCodes, e)) {
                handleInlineTrigger();
            }
        });
        editor.on('keypress', (e) => {
            if (checkCharCode(charCodes, e)) {
                Delay.setEditorTimeout(editor, handleInlineTrigger);
            }
        });
    };

    const setup$1 = (editor) => {
        setup$2(editor);
    };

    const Quirks = (editor) => {
        const each = Tools.each;
        const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;
        const browser = Env.browser;
        const isGecko = browser.isFirefox();
        const isWebKit = browser.isChromium() || browser.isSafari();
        const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();
        const isMac = Env.os.isMacOS() || Env.os.isiOS();
        /**
         * Executes a command with a specific state this can be to enable/disable browser editing features.
         */
        const setEditorCommandState = (cmd, state) => {
            try {
                editor.getDoc().execCommand(cmd, false, String(state));
            }
            catch (_a) {
                // Ignore
            }
        };
        /**
         * Returns true/false if the event is prevented or not.
         *
         * @private
         * @param {Event} e Event object.
         * @return {Boolean} true/false if the event is prevented or not.
         */
        const isDefaultPrevented = (e) => {
            return e.isDefaultPrevented();
        };
        /**
         * Makes sure that the editor body becomes empty when backspace or delete is pressed in empty editors.
         *
         * For example:
         * <p><b>|</b></p>
         *
         * Or:
         * <h1>|</h1>
         *
         * Or:
         * [<h1></h1>]
         */
        const emptyEditorWhenDeleting = () => {
            const serializeRng = (rng) => {
                const body = dom.create('body');
                const contents = rng.cloneContents();
                body.appendChild(contents);
                return selection.serializer.serialize(body, { format: 'html' });
            };
            const allContentsSelected = (rng) => {
                const selection = serializeRng(rng);
                const allRng = dom.createRng();
                allRng.selectNode(editor.getBody());
                const allSelection = serializeRng(allRng);
                return selection === allSelection;
            };
            editor.on('keydown', (e) => {
                const keyCode = e.keyCode;
                // Empty the editor if it's needed for example backspace at <p><b>|</b></p>
                if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {
                    const isCollapsed = editor.selection.isCollapsed();
                    const body = editor.getBody();
                    // Selection is collapsed but the editor isn't empty
                    if (isCollapsed && !isEmptyNode(editor.schema, body)) {
                        return;
                    }
                    // Selection isn't collapsed but not all the contents is selected
                    if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
                        return;
                    }
                    // Manually empty the editor
                    e.preventDefault();
                    editor.setContent('');
                    if (body.firstChild && dom.isBlock(body.firstChild)) {
                        editor.selection.setCursorLocation(body.firstChild, 0);
                    }
                    else {
                        editor.selection.setCursorLocation(body, 0);
                    }
                    editor.nodeChanged();
                }
            });
        };
        /**
         * WebKit doesn't select all the nodes in the body when you press Ctrl+A.
         * IE selects more than the contents <body>[<p>a</p>]</body> instead of <body><p>[a]</p]</body> see bug #6438
         * This selects the whole body so that backspace/delete logic will delete everything
         */
        const selectAll = () => {
            editor.shortcuts.add('meta+a', null, 'SelectAll');
        };
        /**
         * It seems that Chrome doesn't place the caret if you click on the documentElement in iframe mode
         * something that is very easy to do by accident so this problem is now more generic than the original issue.
         *
         * Original IME specific issue:
         * WebKit has a weird issue where it some times fails to properly convert keypresses to input method keystrokes.
         * The IME on Mac doesn't initialize when it doesn't fire a proper focus event.
         *
         * This seems to happen when the user manages to click the documentElement element then the window doesn't get proper focus until
         * you enter a character into the editor.
         *
         * See: https://bugs.webkit.org/show_bug.cgi?id=83566
         */
        const documentElementEditingFocus = () => {
            if (!editor.inline) {
                // Needs to be both down/up due to weird rendering bug on Chrome Windows
                dom.bind(editor.getDoc(), 'mousedown mouseup', (e) => {
                    let rng;
                    if (e.target === editor.getDoc().documentElement) {
                        rng = selection.getRng();
                        editor.getBody().focus();
                        if (e.type === 'mousedown') {
                            if (isCaretContainer$2(rng.startContainer)) {
                                return;
                            }
                            // Edge case for mousedown, drag select and mousedown again within selection on Chrome Windows to render caret
                            selection.placeCaretAt(e.clientX, e.clientY);
                        }
                        else {
                            selection.setRng(rng);
                        }
                    }
                });
            }
        };
        /**
         * Backspacing in FireFox/IE from a paragraph into a horizontal rule results in a floating text node because the
         * browser just deletes the paragraph - the browser fails to merge the text node with a horizontal rule so it is
         * left there. TinyMCE sees a floating text node and wraps it in a paragraph on the key up event (ForceBlocks.js
         * addRootBlocks), meaning the action does nothing. With this code, FireFox/IE matche the behaviour of other
         * browsers.
         *
         * It also fixes a bug on Firefox where it's impossible to delete HR elements.
         */
        const removeHrOnBackspace = () => {
            editor.on('keydown', (e) => {
                if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
                    // Check if there is any HR elements this is faster since getRng on IE 7 & 8 is slow
                    if (!editor.getBody().getElementsByTagName('hr').length) {
                        return;
                    }
                    if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
                        const node = selection.getNode();
                        const previousSibling = node.previousSibling;
                        if (node.nodeName === 'HR') {
                            dom.remove(node);
                            e.preventDefault();
                            return;
                        }
                        if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {
                            dom.remove(previousSibling);
                            e.preventDefault();
                        }
                    }
                }
            });
        };
        /**
         * Firefox 3.x has an issue where the body element won't get proper focus if you click out
         * side it's rectangle.
         */
        const focusBody = () => {
            // Fix for a focus bug in FF 3.x where the body element
            // wouldn't get proper focus if the user clicked on the HTML element
            if (!Range.prototype.getClientRects) { // Detect getClientRects got introduced in FF 4
                editor.on('mousedown', (e) => {
                    if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {
                        const body = editor.getBody();
                        // Blur the body it's focused but not correctly focused
                        body.blur();
                        // Refocus the body after a little while
                        Delay.setEditorTimeout(editor, () => {
                            body.focus();
                        });
                    }
                });
            }
        };
        /**
         * WebKit has a bug where it isn't possible to select image, hr or anchor elements
         * by clicking on them so we need to fake that.
         */
        const selectControlElements = () => {
            const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);
            editor.on('click', (e) => {
                const target = e.target;
                // Workaround for bug, http://bugs.webkit.org/show_bug.cgi?id=12250
                // WebKit can't even do simple things like selecting an image
                // Needs to be the setBaseAndExtend or it will fail to select floated images
                if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {
                    e.preventDefault();
                    editor.selection.select(target);
                    editor.nodeChanged();
                }
                if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {
                    e.preventDefault();
                    selection.select(target);
                }
            });
        };
        /**
         * Fixes a Gecko a selection bug where if there is a floating image
         * more details here: https://bugzilla.mozilla.org/show_bug.cgi?id=1959606
         */
        const fixFirefoxImageSelection = () => {
            const isEditableImage = (node) => node.nodeName === 'IMG' && editor.dom.isEditable(node);
            editor.on('mousedown', (e) => {
                lift2(Optional.from(e.clientX), Optional.from(e.clientY), (clientX, clientY) => {
                    const caretPos = editor.getDoc().caretPositionFromPoint(clientX, clientY);
                    const img = (caretPos === null || caretPos === void 0 ? void 0 : caretPos.offsetNode.childNodes[caretPos.offset - (caretPos.offset > 0 ? 1 : 0)]) || (caretPos === null || caretPos === void 0 ? void 0 : caretPos.offsetNode);
                    if (img && isEditableImage(img)) {
                        const rect = img.getBoundingClientRect();
                        e.preventDefault();
                        if (!editor.hasFocus()) {
                            editor.focus();
                        }
                        editor.selection.select(img);
                        if (e.clientX < rect.left || e.clientY < rect.top) {
                            editor.selection.collapse(true);
                        }
                        else if (e.clientX > rect.right || e.clientY > rect.bottom) {
                            editor.selection.collapse(false);
                        }
                    }
                });
            });
        };
        /**
         * Fixes a Gecko bug where the style attribute gets added to the wrong element when deleting between two block elements.
         *
         * Fixes do backspace/delete on this:
         * <p>bla[ck</p><p style="color:red">r]ed</p>
         *
         * Would become:
         * <p>bla|ed</p>
         *
         * Instead of:
         * <p style="color:red">bla|ed</p>
         */
        const removeStylesWhenDeletingAcrossBlockElements = () => {
            const getAttributeApplyFunction = () => {
                const template = dom.getAttribs(selection.getStart().cloneNode(false));
                return () => {
                    const target = selection.getStart();
                    if (target !== editor.getBody()) {
                        dom.setAttrib(target, 'style', null);
                        each(template, (attr) => {
                            target.setAttributeNode(attr.cloneNode(true));
                        });
                    }
                };
            };
            const isSelectionAcrossElements = () => {
                return !selection.isCollapsed() &&
                    dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);
            };
            editor.on('keypress', (e) => {
                let applyAttributes;
                if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
                    applyAttributes = getAttributeApplyFunction();
                    editor.getDoc().execCommand('delete', false);
                    applyAttributes();
                    e.preventDefault();
                    return false;
                }
                else {
                    return true;
                }
            });
            dom.bind(editor.getDoc(), 'cut', (e) => {
                if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
                    const applyAttributes = getAttributeApplyFunction();
                    Delay.setEditorTimeout(editor, () => {
                        applyAttributes();
                    });
                }
            });
        };
        /**
         * Backspacing into a table behaves differently depending upon browser type.
         * Therefore, disable Backspace when cursor immediately follows a table.
         */
        const disableBackspaceIntoATable = () => {
            editor.on('keydown', (e) => {
                if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
                    if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
                        const previousSibling = selection.getNode().previousSibling;
                        if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {
                            e.preventDefault();
                            return false;
                        }
                    }
                }
                return true;
            });
        };
        /**
         * Removes a blockquote when backspace is pressed at the beginning of it.
         *
         * For example:
         * <blockquote><p>|x</p></blockquote>
         *
         * Becomes:
         * <p>|x</p>
         */
        const removeBlockQuoteOnBackSpace = () => {
            // Add block quote deletion handler
            editor.on('keydown', (e) => {
                if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
                    return;
                }
                let rng = selection.getRng();
                const container = rng.startContainer;
                const offset = rng.startOffset;
                const root = dom.getRoot();
                let parent = container;
                if (!rng.collapsed || offset !== 0) {
                    return;
                }
                while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {
                    parent = parent.parentNode;
                }
                // Is the cursor at the beginning of a blockquote?
                if (parent.nodeName === 'BLOCKQUOTE') {
                    // Remove the blockquote
                    editor.formatter.toggle('blockquote', undefined, parent);
                    // Move the caret to the beginning of container
                    rng = dom.createRng();
                    rng.setStart(container, 0);
                    rng.setEnd(container, 0);
                    selection.setRng(rng);
                }
            });
        };
        /*
         * Firefox-specific fix for arrow key navigation. In Firefox, users can't move the caret out of a
         * `<figcaption>` element using the left and right arrow keys. This function handles those keystrokes
         * to allow navigation to the previous/next sibling of the figure element.
        */
        const arrowInFigcaption = () => {
            const isFigcaption = isTag('figcaption');
            editor.on('keydown', (e) => {
                if (e.keyCode === VK.LEFT || e.keyCode === VK.RIGHT) {
                    const currentNode = SugarElement.fromDom(editor.selection.getNode());
                    if (isFigcaption(currentNode) && editor.selection.isCollapsed()) {
                        parent(currentNode).bind((parent) => {
                            var _a;
                            if (editor.selection.getRng().startOffset === 0 && e.keyCode === VK.LEFT) {
                                return prevSibling(parent);
                            }
                            else if (editor.selection.getRng().endOffset === ((_a = currentNode.dom.textContent) === null || _a === void 0 ? void 0 : _a.length) && e.keyCode === VK.RIGHT) {
                                return nextSibling(parent);
                            }
                            else {
                                return Optional.none();
                            }
                        }).each((targetSibling) => {
                            editor.selection.setCursorLocation(targetSibling.dom, 0);
                        });
                    }
                }
            });
        };
        /**
         * Sets various Gecko editing options on mouse down and before a execCommand to disable inline table editing that is broken etc.
         */
        const setGeckoEditingOptions = () => {
            const setOpts = () => {
                setEditorCommandState('StyleWithCSS', false);
                setEditorCommandState('enableInlineTableEditing', false);
                if (!getObjectResizing(editor)) {
                    setEditorCommandState('enableObjectResizing', false);
                }
            };
            if (!isReadOnly$1(editor)) {
                editor.on('BeforeExecCommand mousedown', setOpts);
            }
        };
        /**
         * Fixes a gecko link bug, when a link is placed at the end of block elements there is
         * no way to move the caret behind the link. This fix adds a bogus br element after the link.
         *
         * For example this:
         * <p><b><a href="#">x</a></b></p>
         *
         * Becomes this:
         * <p><b><a href="#">x</a></b><br></p>
         */
        const addBrAfterLastLinks = () => {
            const fixLinks = () => {
                each(dom.select('a:not([data-mce-block])'), (node) => {
                    var _a;
                    let parentNode = node.parentNode;
                    const root = dom.getRoot();
                    if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {
                        while (parentNode && !dom.isBlock(parentNode)) {
                            if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {
                                return;
                            }
                            parentNode = parentNode.parentNode;
                        }
                        dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });
                    }
                });
            };
            editor.on('SetContent ExecCommand', (e) => {
                if (e.type === 'setcontent' || e.command === 'mceInsertLink') {
                    fixLinks();
                }
            });
        };
        /**
         * WebKit will produce DIV elements here and there by default. But since TinyMCE uses paragraphs by
         * default we want to change that behavior.
         */
        const setDefaultBlockType = () => {
            editor.on('init', () => {
                setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));
            });
        };
        const isAllContentSelected = (editor) => {
            const body = editor.getBody();
            const rng = editor.selection.getRng();
            return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;
        };
        /**
         * Fixes selection issues where the caret can be placed between two inline elements like <b>a</b>|<b>b</b>
         * this fix will lean the caret right into the closest inline element.
         */
        const normalizeSelection = () => {
            // Normalize selection for example <b>a</b><i>|a</i> becomes <b>a|</b><i>a</i>
            editor.on('keyup focusin mouseup', (e) => {
                // no point to exclude Ctrl+A, since normalization will still run after Ctrl will be unpressed
                // better exclude any key combinations with the modifiers to avoid double normalization
                // (also addresses TINY-1130)
                // The use of isAllContentSelected addresses TINY-4550
                if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {
                    selection.normalize();
                }
            }, true);
        };
        /**
         * Forces Gecko to render a broken image icon if it fails to load an image.
         */
        const showBrokenImageIcon = () => {
            editor.contentStyles.push('img:-moz-broken {' +
                '-moz-force-broken-image-icon:1;' +
                'min-width:24px;' +
                'min-height:24px' +
                '}');
        };
        /**
         * iOS has a bug where it's impossible to type if the document has a touchstart event
         * bound and the user touches the document while having the on screen keyboard visible.
         *
         * The touch event moves the focus to the parent document while having the caret inside the iframe
         * this fix moves the focus back into the iframe document.
         */
        const restoreFocusOnKeyDown = () => {
            if (!editor.inline) {
                editor.on('keydown', () => {
                    if (document.activeElement === document.body) {
                        editor.getWin().focus();
                    }
                });
            }
        };
        /**
         * IE 11 has an annoying issue where you can't move focus into the editor
         * by clicking on the white area HTML element. We used to be able to fix this with
         * the fixCaretSelectionOfDocumentElementOnIe fix. But since M$ removed the selection
         * object it's not possible anymore. So we need to hack in a ungly CSS to force the
         * body to be at least 150px. If the user clicks the HTML element out side this 150px region
         * we simply move the focus into the first paragraph. Not ideal since you loose the
         * positioning of the caret but goot enough for most cases.
         */
        const bodyHeight = () => {
            if (!editor.inline) {
                editor.contentStyles.push('body {min-height: 150px}');
                editor.on('click', (e) => {
                    let rng;
                    if (e.target.nodeName === 'HTML') {
                        // Need to store away non collapsed ranges since the focus call will mess that up see #7382
                        rng = editor.selection.getRng();
                        editor.getBody().focus();
                        editor.selection.setRng(rng);
                        editor.selection.normalize();
                        editor.nodeChanged();
                    }
                });
            }
        };
        /**
         * Firefox on Mac OS will move the browser back to the previous page if you press CMD+Left arrow.
         * You might then loose all your work so we need to block that behavior and replace it with our own.
         */
        const blockCmdArrowNavigation = () => {
            if (isMac) {
                editor.on('keydown', (e) => {
                    if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
                        e.preventDefault();
                        // The modify component isn't part of the standard spec, so we need to add the type here
                        const selection = editor.selection.getSel();
                        selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');
                    }
                });
            }
        };
        /**
         * iOS 7.1 introduced two new bugs:
         * 1) It's possible to open links within a contentEditable area by clicking on them.
         * 2) If you hold down the finger it will display the link/image touch callout menu.
         */
        const tapLinksAndImages = () => {
            editor.on('click', (e) => {
                let elm = e.target;
                do {
                    if (elm.tagName === 'A') {
                        e.preventDefault();
                        return;
                    }
                } while ((elm = elm.parentNode));
            });
            editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');
        };
        /**
         * iOS Safari and possible other browsers have a bug where it won't fire
         * a click event when a contentEditable is focused. This function fakes click events
         * by using touchstart/touchend and measuring the time and distance travelled.
         */
        /*
        function touchClickEvent() {
          editor.on('touchstart', function(e) {
            var elm, time, startTouch, changedTouches;
      
            elm = e.target;
            time = new Date().getTime();
            changedTouches = e.changedTouches;
      
            if (!changedTouches || changedTouches.length > 1) {
              return;
            }
      
            startTouch = changedTouches[0];
      
            editor.once('touchend', function(e) {
              var endTouch = e.changedTouches[0], args;
      
              if (new Date().getTime() - time > 500) {
                return;
              }
      
              if (Math.abs(startTouch.clientX - endTouch.clientX) > 5) {
                return;
              }
      
              if (Math.abs(startTouch.clientY - endTouch.clientY) > 5) {
                return;
              }
      
              args = {
                target: elm
              };
      
              each('pageX pageY clientX clientY screenX screenY'.split(' '), function(key) {
                args[key] = endTouch[key];
              });
      
              args = editor.dispatch('click', args);
      
              if (!args.isDefaultPrevented()) {
                // iOS WebKit can't place the caret properly once
                // you bind touch events so we need to do this manually
                // TODO: Expand to the closest word? Touble tap still works.
                editor.selection.placeCaretAt(endTouch.clientX, endTouch.clientY);
                editor.nodeChanged();
              }
            });
          });
        }
        */
        /**
         * WebKit has a bug where it will allow forms to be submitted if they are inside a contentEditable element.
         * For example this: <form><button></form>
         */
        const blockFormSubmitInsideEditor = () => {
            editor.on('init', () => {
                editor.dom.bind(editor.getBody(), 'submit', (e) => {
                    e.preventDefault();
                });
            });
        };
        /**
         * Sometimes WebKit/Blink generates BR elements with the Apple-interchange-newline class.
         *
         * Scenario:
         *  1) Create a table 2x2.
         *  2) Select and copy cells A2-B2.
         *  3) Paste and it will add BR element to table cell.
         */
        const removeAppleInterchangeBrs = () => {
            parser.addNodeFilter('br', (nodes) => {
                let i = nodes.length;
                while (i--) {
                    if (nodes[i].attr('class') === 'Apple-interchange-newline') {
                        nodes[i].remove();
                    }
                }
            });
        };
        // No-op since Mozilla seems to have fixed the caret repaint issues
        const refreshContentEditable = noop;
        const isHidden = () => {
            if (!isGecko || editor.removed) {
                return false;
            }
            // Weird, wheres that cursor selection?
            const sel = editor.selection.getSel();
            return (!sel || !sel.rangeCount || sel.rangeCount === 0);
        };
        const setupRtc = () => {
            if (isWebKit) {
                documentElementEditingFocus();
                selectControlElements();
                blockFormSubmitInsideEditor();
                selectAll();
                if (isiOS) {
                    restoreFocusOnKeyDown();
                    bodyHeight();
                    tapLinksAndImages();
                }
            }
            if (isGecko) {
                focusBody();
                setGeckoEditingOptions();
                showBrokenImageIcon();
                blockCmdArrowNavigation();
            }
        };
        const setup = () => {
            // All browsers
            removeBlockQuoteOnBackSpace();
            emptyEditorWhenDeleting();
            // Windows phone will return a range like [body, 0] on mousedown so
            // it will always normalize to the wrong location
            if (!Env.windowsPhone) {
                normalizeSelection();
            }
            // WebKit
            if (isWebKit) {
                documentElementEditingFocus();
                selectControlElements();
                setDefaultBlockType();
                blockFormSubmitInsideEditor();
                disableBackspaceIntoATable();
                removeAppleInterchangeBrs();
                // touchClickEvent();
                // iOS
                if (isiOS) {
                    restoreFocusOnKeyDown();
                    bodyHeight();
                    tapLinksAndImages();
                }
                else {
                    selectAll();
                }
            }
            // Gecko
            if (isGecko) {
                arrowInFigcaption();
                fixFirefoxImageSelection();
                removeHrOnBackspace();
                focusBody();
                removeStylesWhenDeletingAcrossBlockElements();
                setGeckoEditingOptions();
                addBrAfterLastLinks();
                showBrokenImageIcon();
                blockCmdArrowNavigation();
                disableBackspaceIntoATable();
            }
        };
        if (isRtc(editor)) {
            setupRtc();
        }
        else {
            setup();
        }
        return {
            refreshContentEditable,
            isHidden
        };
    };

    const DOM$6 = DOMUtils.DOM;
    const appendStyle = (editor, text) => {
        const body = SugarElement.fromDom(editor.getBody());
        const container = getStyleContainer(getRootNode(body));
        const style = SugarElement.fromTag('style');
        set$4(style, 'type', 'text/css');
        append$1(style, SugarElement.fromText(text));
        append$1(container, style);
        editor.on('remove', () => {
            remove$8(style);
        });
    };
    const getRootName = (editor) => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;
    const removeUndefined = (obj) => filter$4(obj, (v) => isUndefined(v) === false);
    const mkParserSettings = (editor) => {
        const getOption = editor.options.get;
        const blobCache = editor.editorUpload.blobCache;
        return removeUndefined({
            allow_conditional_comments: getOption('allow_conditional_comments'),
            allow_html_data_urls: getOption('allow_html_data_urls'),
            allow_svg_data_urls: getOption('allow_svg_data_urls'),
            allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),
            allow_script_urls: getOption('allow_script_urls'),
            allow_html_in_comments: getOption('allow_html_in_comments'),
            allow_mathml_annotation_encodings: getOption('allow_mathml_annotation_encodings'),
            allow_unsafe_link_target: getOption('allow_unsafe_link_target'),
            convert_unsafe_embeds: getOption('convert_unsafe_embeds'),
            convert_fonts_to_spans: getOption('convert_fonts_to_spans'),
            extended_mathml_attributes: getOption('extended_mathml_attributes'),
            extended_mathml_elements: getOption('extended_mathml_elements'),
            fix_list_elements: getOption('fix_list_elements'),
            font_size_legacy_values: getOption('font_size_legacy_values'),
            forced_root_block: getOption('forced_root_block'),
            forced_root_block_attrs: getOption('forced_root_block_attrs'),
            preserve_cdata: getOption('preserve_cdata'),
            inline_styles: getOption('inline_styles'),
            root_name: getRootName(editor),
            sandbox_iframes: getOption('sandbox_iframes'),
            sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),
            sanitize: getOption('xss_sanitization'),
            validate: true,
            blob_cache: blobCache,
            document: editor.getDoc()
        });
    };
    const mkSchemaSettings = (editor) => {
        const getOption = editor.options.get;
        return removeUndefined({
            custom_elements: getOption('custom_elements'),
            extended_valid_elements: getOption('extended_valid_elements'),
            invalid_elements: getOption('invalid_elements'),
            invalid_styles: getOption('invalid_styles'),
            schema: getOption('schema'),
            valid_children: getOption('valid_children'),
            valid_classes: getOption('valid_classes'),
            valid_elements: getOption('valid_elements'),
            valid_styles: getOption('valid_styles'),
            verify_html: getOption('verify_html'),
            padd_empty_block_inline_children: getOption('format_empty_lines')
        });
    };
    const mkSerializerSettings = (editor) => {
        const getOption = editor.options.get;
        return {
            ...mkParserSettings(editor),
            ...mkSchemaSettings(editor),
            ...removeUndefined({
                // SerializerSettings
                remove_trailing_brs: getOption('remove_trailing_brs'),
                pad_empty_with_br: getOption('pad_empty_with_br'),
                url_converter: getOption('url_converter'),
                url_converter_scope: getOption('url_converter_scope'),
                // Writer settings
                element_format: getOption('element_format'),
                entities: getOption('entities'),
                entity_encoding: getOption('entity_encoding'),
                indent: getOption('indent'),
                indent_after: getOption('indent_after'),
                indent_before: getOption('indent_before')
            })
        };
    };
    const createParser = (editor) => {
        const parser = DomParser(mkParserSettings(editor), editor.schema);
        // Convert src and href into data-mce-src, data-mce-href and data-mce-style
        parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {
            const dom = editor.dom;
            const internalName = 'data-mce-' + name;
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                let value = node.attr(name);
                // Add internal attribute if we need to we don't on a refresh of the document
                if (value && !node.attr(internalName)) {
                    // Don't duplicate these since they won't get modified by any browser
                    if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {
                        continue;
                    }
                    if (name === 'style') {
                        value = dom.serializeStyle(dom.parseStyle(value), node.name);
                        if (!value.length) {
                            value = null;
                        }
                        node.attr(internalName, value);
                        node.attr(name, value);
                    }
                    else if (name === 'tabindex') {
                        node.attr(internalName, value);
                        node.attr(name, null);
                    }
                    else {
                        node.attr(internalName, editor.convertURL(value, name, node.name));
                    }
                }
            }
        });
        // Keep scripts from executing
        parser.addNodeFilter('script', (nodes) => {
            let i = nodes.length;
            while (i--) {
                const node = nodes[i];
                const type = node.attr('type') || 'no/type';
                if (type.indexOf('mce-') !== 0) {
                    node.attr('type', 'mce-' + type);
                }
            }
        });
        if (shouldPreserveCData(editor)) {
            parser.addNodeFilter('#cdata', (nodes) => {
                var _a;
                let i = nodes.length;
                while (i--) {
                    const node = nodes[i];
                    node.type = 8;
                    node.name = '#comment';
                    node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';
                }
            });
        }
        parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', (nodes) => {
            let i = nodes.length;
            const nonEmptyElements = editor.schema.getNonEmptyElements();
            while (i--) {
                const node = nodes[i];
                if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {
                    node.append(new AstNode('br', 1));
                }
            }
        });
        return parser;
    };
    const autoFocus = (editor) => {
        const autoFocus = getAutoFocus(editor);
        if (autoFocus) {
            Delay.setEditorTimeout(editor, () => {
                let focusEditor;
                if (autoFocus === true) {
                    focusEditor = editor;
                }
                else {
                    focusEditor = editor.editorManager.get(autoFocus);
                }
                if (focusEditor && !focusEditor.destroyed) {
                    focusEditor.focus();
                    focusEditor.selection.scrollIntoView();
                }
            }, 100);
        }
    };
    const moveSelectionToFirstCaretPosition = (editor) => {
        // If not inline and no useful selection, we want to set selection to the first valid cursor position
        // We don't do this on inline because then it selects the editor container
        // This must run AFTER editor.focus!
        const root = editor.dom.getRoot();
        if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {
            firstPositionIn(root).each((pos) => {
                const node = pos.getNode();
                // If a table is the first caret pos, then walk down one more level
                const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
                editor.selection.setRng(caretPos.toRange());
            });
        }
    };
    const initEditor = (editor) => {
        editor.bindPendingEventDelegates();
        editor.initialized = true;
        fireInit(editor);
        editor.focus(true);
        moveSelectionToFirstCaretPosition(editor);
        editor.nodeChanged({ initial: true });
        const initInstanceCallback = getInitInstanceCallback(editor);
        if (isFunction(initInstanceCallback)) {
            initInstanceCallback.call(editor, editor);
        }
        autoFocus(editor);
        if (isDisabled(editor)) {
            toggleDisabled(editor, true);
        }
    };
    const getStyleSheetLoader$1 = (editor) => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {
        const { pass: bundledCss, fail: normalCss } = partition$2(css, (name) => tinymce.Resource.has(toContentSkinResourceName(name)));
        const bundledPromises = bundledCss.map((url) => {
            const css = tinymce.Resource.get(toContentSkinResourceName(url));
            if (isString(css)) {
                return Promise.resolve(getStyleSheetLoader$1(editor).loadRawCss(url, css));
            }
            return Promise.resolve();
        });
        const promises = [...bundledPromises,
            getStyleSheetLoader$1(editor).loadAll(normalCss),
        ];
        if (editor.inline) {
            return promises;
        }
        else {
            return promises.concat([
                editor.ui.styleSheetLoader.loadAll(framedFonts)
            ]);
        }
    };
    const loadContentCss = (editor) => {
        const styleSheetLoader = getStyleSheetLoader$1(editor);
        const fontCss = getFontCss(editor);
        const css = editor.contentCSS;
        const removeCss = () => {
            styleSheetLoader.unloadAll(css);
            if (!editor.inline) {
                editor.ui.styleSheetLoader.unloadAll(fontCss);
            }
        };
        const loaded = () => {
            if (editor.removed) {
                removeCss();
            }
            else {
                editor.on('remove', removeCss);
            }
        };
        // Add editor specific CSS styles
        if (editor.contentStyles.length > 0) {
            let contentCssText = '';
            Tools.each(editor.contentStyles, (style) => {
                contentCssText += style + '\r\n';
            });
            editor.dom.addStyle(contentCssText);
        }
        // Load all stylesheets
        const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);
        // Append specified content CSS last
        const contentStyle = getContentStyle(editor);
        if (contentStyle) {
            appendStyle(editor, contentStyle);
        }
        return allStylesheets;
    };
    const preInit = (editor) => {
        const doc = editor.getDoc(), body = editor.getBody();
        firePreInit(editor);
        if (!shouldBrowserSpellcheck(editor)) {
            doc.body.spellcheck = false; // Gecko
            DOM$6.setAttrib(body, 'spellcheck', 'false');
        }
        editor.quirks = Quirks(editor);
        firePostRender(editor);
        const directionality = getDirectionality(editor);
        if (directionality !== undefined) {
            body.dir = directionality;
        }
        const protect = getProtect(editor);
        if (protect) {
            editor.on('BeforeSetContent', (e) => {
                Tools.each(protect, (pattern) => {
                    e.content = e.content.replace(pattern, (str) => {
                        return '<!--mce:protected ' + escape(str) + '-->';
                    });
                });
            });
        }
        editor.on('SetContent', () => {
            editor.addVisual(editor.getBody());
        });
        editor.on('compositionstart compositionend', (e) => {
            editor.composing = e.type === 'compositionstart';
        });
    };
    const loadInitialContent = (editor) => {
        if (!isRtc(editor)) {
            editor.load({ initial: true, format: 'html' });
        }
        editor.startContent = editor.getContent({ format: 'raw' });
    };
    const initEditorWithInitialContent = (editor) => {
        if (editor.removed !== true) {
            loadInitialContent(editor);
            initEditor(editor);
        }
    };
    const startProgress = (editor) => {
        let canceled = false;
        const progressTimeout = setTimeout(() => {
            if (!canceled) {
                editor.setProgressState(true);
            }
        }, 500);
        return () => {
            clearTimeout(progressTimeout);
            canceled = true;
            editor.setProgressState(false);
        };
    };
    const contentBodyLoaded = (editor) => {
        const targetElm = editor.getElement();
        let doc = editor.getDoc();
        if (editor.inline) {
            DOM$6.addClass(targetElm, 'mce-content-body');
            editor.contentDocument = doc = document;
            editor.contentWindow = window;
            editor.bodyElement = targetElm;
            editor.contentAreaContainer = targetElm;
        }
        // It will not steal focus while setting contentEditable
        const body = editor.getBody();
        // disabled isn't valid on all body elements, so need to cast here
        // TODO: See if we actually need to disable/re-enable here
        body.disabled = true;
        editor.readonly = isReadOnly$1(editor);
        editor._editableRoot = hasEditableRoot$1(editor);
        if (!isDisabled$1(editor) && editor.hasEditableRoot()) {
            if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {
                body.style.position = 'relative';
            }
            body.contentEditable = 'true';
        }
        body.disabled = false;
        editor.editorUpload = EditorUpload(editor);
        editor.schema = Schema(mkSchemaSettings(editor));
        editor.dom = DOMUtils(doc, {
            keep_values: true,
            // Note: Don't bind here, as the binding is handled via the `url_converter_scope`
            // eslint-disable-next-line @typescript-eslint/unbound-method
            url_converter: editor.convertURL,
            url_converter_scope: editor,
            update_styles: true,
            root_element: editor.inline ? editor.getBody() : null,
            collect: editor.inline,
            schema: editor.schema,
            contentCssCors: shouldUseContentCssCors(editor),
            referrerPolicy: getReferrerPolicy(editor),
            crossOrigin: getCrossOrigin(editor),
            onSetAttrib: (e) => {
                editor.dispatch('SetAttrib', e);
            },
        });
        editor.parser = createParser(editor);
        editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
        editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);
        editor.annotator = Annotator(editor);
        editor.formatter = Formatter(editor);
        editor.undoManager = UndoManager(editor);
        editor._nodeChangeDispatcher = new NodeChange(editor);
        editor._selectionOverrides = SelectionOverrides(editor);
        setup$b(editor);
        setup$u(editor);
        setup$6(editor);
        setup$s(editor);
        if (!isRtc(editor)) {
            setup$5(editor);
            setup$1(editor);
        }
        const caret = setup$g(editor);
        setup$v(editor, caret);
        setup$t(editor);
        setup$w(editor);
        setup$7(editor, caret);
        const setupRtcThunk = setup$z(editor);
        preInit(editor);
        setupRtcThunk.fold(() => {
            const cancelProgress = startProgress(editor);
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            loadContentCss(editor).then(() => {
                initEditorWithInitialContent(editor);
                cancelProgress();
            });
        }, (setupRtc) => {
            editor.setProgressState(true);
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            loadContentCss(editor).then(() => {
                setupRtc().then((_rtcMode) => {
                    editor.setProgressState(false);
                    initEditorWithInitialContent(editor);
                    bindEvents(editor);
                }, (err) => {
                    editor.notificationManager.open({ type: 'error', text: String(err) });
                    initEditorWithInitialContent(editor);
                    bindEvents(editor);
                });
            });
        });
    };

    const DOM$5 = DOMUtils.DOM;
    const createIframeElement = (id, title, customAttrs, tabindex) => {
        const iframe = SugarElement.fromTag('iframe');
        // This can also be explicitly set by customAttrs, so do this first
        tabindex.each((t) => set$4(iframe, 'tabindex', t));
        setAll$1(iframe, customAttrs);
        setAll$1(iframe, {
            id: id + '_ifr',
            frameBorder: '0',
            allowTransparency: 'true',
            title
        });
        add$2(iframe, 'tox-edit-area__iframe');
        return iframe;
    };
    const getIframeHtml = (editor) => {
        let iframeHTML = getDocType(editor) + '<html><head>';
        // We only need to override paths if we have to
        // IE has a bug where it remove site absolute urls to relative ones if this is specified
        if (getDocumentBaseUrl(editor) !== editor.editorManager.documentBaseURL) {
            iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
        }
        iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
        const bodyId = getBodyId(editor);
        const bodyClass = getBodyClass(editor);
        const translatedAriaText = editor.translate(getIframeAriaText(editor));
        if (getContentSecurityPolicy(editor)) {
            iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + getContentSecurityPolicy(editor) + '" />';
        }
        iframeHTML += '</head>' +
            `<body id="${bodyId}" class="mce-content-body ${bodyClass}" data-id="${editor.id}" aria-label="${translatedAriaText}">` +
            '<br>' +
            '</body></html>';
        return iframeHTML;
    };
    const createIframe = (editor, boxInfo) => {
        const iframeTitle = Env.browser.isFirefox() ? getIframeAriaText(editor) : 'Rich Text Area';
        const translatedTitle = editor.translate(iframeTitle);
        const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);
        const ifr = createIframeElement(editor.id, translatedTitle, getIframeAttrs(editor), tabindex).dom;
        ifr.onload = () => {
            ifr.onload = null;
            editor.dispatch('load');
        };
        editor.contentAreaContainer = boxInfo.iframeContainer;
        editor.iframeElement = ifr;
        editor.iframeHTML = getIframeHtml(editor);
        DOM$5.add(boxInfo.iframeContainer, ifr);
    };
    const setupIframeBody = (editor) => {
        // Setup iframe body
        const iframe = editor.iframeElement;
        const ready = () => {
            // Set the content document, now that it is available
            editor.contentDocument = iframe.contentDocument;
            // Continue to init the editor
            contentBodyLoaded(editor);
        };
        // TINY-8916: Firefox has a bug in its srcdoc implementation that prevents cookies being sent so unfortunately we need
        // to fallback to legacy APIs to load the iframe content. See https://bugzilla.mozilla.org/show_bug.cgi?id=1741489
        if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {
            const doc = editor.getDoc();
            doc.open();
            doc.write(editor.iframeHTML);
            doc.close();
            ready();
        }
        else {
            const binder = bind$1(SugarElement.fromDom(iframe), 'load', () => {
                binder.unbind();
                ready();
            });
            iframe.srcdoc = editor.iframeHTML;
        }
    };
    const init$1 = (editor, boxInfo) => {
        createIframe(editor, boxInfo);
        if (boxInfo.editorContainer) {
            boxInfo.editorContainer.style.display = editor.orgDisplay;
            editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
        }
        editor.getElement().style.display = 'none';
        DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');
        // Restore visibility on target element
        editor.getElement().style.visibility = editor.orgVisibility;
        setupIframeBody(editor);
    };

    const DOM$4 = DOMUtils.DOM;
    const initPlugin = (editor, initializedPlugins, plugin) => {
        const Plugin = PluginManager.get(plugin);
        const pluginUrl = PluginManager.urls[plugin] || editor.editorManager.documentBaseURL.replace(/\/$/, '');
        plugin = Tools.trim(plugin);
        if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
            if (editor.plugins[plugin]) {
                return;
            }
            try {
                const pluginInstance = Plugin(editor, pluginUrl) || {};
                editor.plugins[plugin] = pluginInstance;
                if (isFunction(pluginInstance.init)) {
                    pluginInstance.init(editor, pluginUrl);
                    initializedPlugins.push(plugin);
                }
            }
            catch (e) {
                pluginInitError(editor, plugin, e);
            }
        }
    };
    const initTooltipClosing = (editor) => {
        const closeTooltipsListener = (event) => {
            if (event.keyCode === VK.ESC && !event.defaultPrevented) {
                if (fireCloseTooltips(editor).isDefaultPrevented()) {
                    event.preventDefault();
                }
            }
        };
        document.addEventListener('keyup', closeTooltipsListener);
        if (!editor.inline) {
            editor.on('keyup', closeTooltipsListener);
        }
        editor.on('remove', () => {
            document.removeEventListener('keyup', closeTooltipsListener);
            if (!editor.inline) {
                editor.off('keyup', closeTooltipsListener);
            }
        });
    };
    const trimLegacyPrefix = (name) => {
        // Themes and plugins can be prefixed with - to prevent them from being lazy loaded
        return name.replace(/^\-/, '');
    };
    const initPlugins = (editor) => {
        const initializedPlugins = [];
        each$e(getPlugins(editor), (name) => {
            initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));
        });
    };
    const initIcons = (editor) => {
        const iconPackName = Tools.trim(getIconPackName(editor));
        const currentIcons = editor.ui.registry.getAll().icons;
        const loadIcons = {
            ...IconManager.get('default').icons,
            ...IconManager.get(iconPackName).icons
        };
        each$d(loadIcons, (svgData, icon) => {
            // Don't override an icon registered manually
            if (!has$2(currentIcons, icon)) {
                editor.ui.registry.addIcon(icon, svgData);
            }
        });
    };
    const initTheme = (editor) => {
        const theme = getTheme(editor);
        if (isString(theme)) {
            const Theme = ThemeManager.get(theme);
            editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};
            if (isFunction(editor.theme.init)) {
                editor.theme.init(editor, ThemeManager.urls[theme] || editor.editorManager.documentBaseURL.replace(/\/$/, ''));
            }
        }
        else {
            // Theme set to false or null doesn't produce a theme api
            editor.theme = {};
        }
    };
    const initModel = (editor) => {
        const model = getModel(editor);
        const Model = ModelManager.get(model);
        editor.model = Model(editor, ModelManager.urls[model]);
    };
    const initLicenseKeyManager = (editor) => {
        LicenseKeyManagerLoader.init(editor);
    };
    const renderFromLoadedTheme = (editor) => {
        // Render UI
        const render = editor.theme.renderUI;
        return render ? render() : renderThemeFalse(editor);
    };
    const renderFromThemeFunc = (editor) => {
        const elm = editor.getElement();
        const theme = getTheme(editor);
        const info = theme(editor, elm);
        if (info.editorContainer.nodeType) {
            info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';
        }
        if (info.iframeContainer && info.iframeContainer.nodeType) {
            info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';
        }
        info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
        return info;
    };
    const createThemeFalseResult = (element, iframe) => {
        return {
            editorContainer: element,
            iframeContainer: iframe,
            api: {}
        };
    };
    const renderThemeFalseIframe = (targetElement) => {
        const iframeContainer = DOM$4.create('div');
        DOM$4.insertAfter(iframeContainer, targetElement);
        return createThemeFalseResult(iframeContainer, iframeContainer);
    };
    const renderThemeFalse = (editor) => {
        const targetElement = editor.getElement();
        return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
    };
    const renderThemeUi = (editor) => {
        const elm = editor.getElement();
        editor.orgDisplay = elm.style.display;
        if (isString(getTheme(editor))) {
            return renderFromLoadedTheme(editor);
        }
        else if (isFunction(getTheme(editor))) {
            return renderFromThemeFunc(editor);
        }
        else {
            return renderThemeFalse(editor);
        }
    };
    const augmentEditorUiApi = (editor, api) => {
        const uiApiFacade = {
            show: Optional.from(api.show).getOr(noop),
            hide: Optional.from(api.hide).getOr(noop),
            isEnabled: Optional.from(api.isEnabled).getOr(always),
            setEnabled: (state) => {
                const shouldSkip = state && (editor.mode.get() === 'readonly' || isDisabled(editor));
                if (!shouldSkip) {
                    Optional.from(api.setEnabled).each((f) => f(state));
                }
            }
        };
        editor.ui = { ...editor.ui, ...uiApiFacade };
    };
    const init = async (editor) => {
        editor.dispatch('ScriptsLoaded');
        initIcons(editor);
        initTooltipClosing(editor);
        initTheme(editor);
        initModel(editor);
        initLicenseKeyManager(editor);
        initPlugins(editor);
        const renderInfo = await renderThemeUi(editor);
        augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
        editor.editorContainer = renderInfo.editorContainer;
        appendContentCssFromSettings(editor);
        if (editor.inline) {
            contentBodyLoaded(editor);
        }
        else {
            init$1(editor, {
                editorContainer: renderInfo.editorContainer,
                iframeContainer: renderInfo.iframeContainer
            });
        }
    };

    const DOM$3 = DOMUtils.DOM;
    const hasSkipLoadPrefix = (name) => name.charAt(0) === '-';
    const loadLanguage = (scriptLoader, editor) => {
        const languageCode = getLanguageCode(editor);
        const languageUrl = getLanguageUrl(editor);
        if (!I18n.hasCode(languageCode) && languageCode !== 'en') {
            const url = isNotEmpty(languageUrl) ? languageUrl : `${editor.editorManager.baseURL}/langs/${languageCode}.js`;
            scriptLoader.add(url).catch(() => {
                languageLoadError(editor, url, languageCode);
            });
        }
    };
    const loadTheme = (editor, suffix) => {
        const theme = getTheme(editor);
        if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {
            const themeUrl = getThemeUrl(editor);
            const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${theme}/theme${suffix}.js`;
            ThemeManager.load(theme, url).catch(() => {
                themeLoadError(editor, url, theme);
            });
        }
    };
    const loadModel = (editor, suffix) => {
        // Special case the 'wait for model' code if a plugin is responsible for it
        // as the plugin will provide the instance instead
        const model = getModel(editor);
        if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {
            const modelUrl = getModelUrl(editor);
            const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${model}/model${suffix}.js`;
            ModelManager.load(model, url).catch(() => {
                modelLoadError(editor, url, model);
            });
        }
    };
    const loadLicenseKeyManager = (editor, suffix) => {
        LicenseKeyManagerLoader.load(editor, suffix);
    };
    const getIconsUrlMetaFromUrl = (editor) => Optional.from(getIconsUrl(editor))
        .filter(isNotEmpty)
        .map((url) => ({
        url,
        name: Optional.none()
    }));
    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name)
        .filter((name) => isNotEmpty(name) && !IconManager.has(name))
        .map((name) => ({
        url: `${editor.editorManager.baseURL}/icons/${name}/icons${suffix}.js`,
        name: Optional.some(name)
    }));
    const loadIcons = (scriptLoader, editor, suffix) => {
        const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);
        const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));
        each$e(cat([defaultIconsUrl, customIconsUrl]), (urlMeta) => {
            scriptLoader.add(urlMeta.url).catch(() => {
                iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
            });
        });
    };
    const loadPlugins = (editor, suffix) => {
        const loadPlugin = (name, url) => {
            // If licensekeymanager is included in the plugins list
            // or through external_plugins, skip it
            if (name === 'licensekeymanager') {
                return;
            }
            PluginManager.load(name, url).catch(() => {
                pluginLoadError(editor, url, name);
            });
        };
        each$d(getExternalPlugins$1(editor), (url, name) => {
            loadPlugin(name, url);
            editor.options.set('plugins', getPlugins(editor).concat(name));
        });
        each$e(getPlugins(editor), (plugin) => {
            plugin = Tools.trim(plugin);
            if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {
                loadPlugin(plugin, `plugins/${plugin}/plugin${suffix}.js`);
            }
        });
    };
    const isThemeLoaded = (editor) => {
        const theme = getTheme(editor);
        return !isString(theme) || isNonNullable(ThemeManager.get(theme));
    };
    const isModelLoaded = (editor) => {
        const model = getModel(editor);
        return isNonNullable(ModelManager.get(model));
    };
    const loadScripts = (editor, suffix) => {
        const scriptLoader = ScriptLoader.ScriptLoader;
        const initEditor = () => {
            // If the editor has been destroyed or the theme, model haven't loaded then
            // don't continue to load the editor
            if (!editor.removed &&
                isThemeLoaded(editor) &&
                isModelLoaded(editor)) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                init(editor);
            }
        };
        loadTheme(editor, suffix);
        loadModel(editor, suffix);
        loadLicenseKeyManager(editor, suffix);
        loadLanguage(scriptLoader, editor);
        loadIcons(scriptLoader, editor, suffix);
        loadPlugins(editor, suffix);
        scriptLoader.loadQueue().then(initEditor, initEditor);
    };
    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {
        contentCssCors: hasContentCssCors(editor),
        referrerPolicy: getReferrerPolicy(editor)
    });
    const render = (editor) => {
        const id = editor.id;
        // The user might have bundled multiple language packs so we need to switch the active code to the user specified language
        I18n.setCode(getLanguageCode(editor));
        const readyHandler = () => {
            DOM$3.unbind(window, 'ready', readyHandler);
            editor.render();
        };
        // Page is not loaded yet, wait for it
        if (!EventUtils.Event.domLoaded) {
            DOM$3.bind(window, 'ready', readyHandler);
            return;
        }
        // Element not found, then skip initialization
        if (!editor.getElement()) {
            return;
        }
        // snapshot the element we're going to render to
        const element = SugarElement.fromDom(editor.getElement());
        const snapshot = clone$4(element);
        editor.on('remove', () => {
            eachr(element.dom.attributes, (attr) => remove$9(element, attr.name));
            setAll$1(element, snapshot);
        });
        editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);
        // Hide target element early to prevent content flashing
        if (!isInline$2(editor)) {
            editor.orgVisibility = editor.getElement().style.visibility;
            editor.getElement().style.visibility = 'hidden';
        }
        else {
            editor.inline = true;
        }
        // TODO: Investigate the types here
        const form = editor.getElement().form || DOM$3.getParent(id, 'form');
        if (form) {
            editor.formElement = form;
            // Add hidden input for non input elements inside form elements
            if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {
                DOM$3.insertAfter(DOM$3.create('input', { type: 'hidden', name: id }), id);
                editor.hasHiddenInput = true;
            }
            // Pass submit/reset from form to editor instance
            editor.formEventDelegate = (e) => {
                editor.dispatch(e.type, e);
            };
            DOM$3.bind(form, 'submit reset', editor.formEventDelegate);
            // Reset contents in editor when the form is reset
            editor.on('reset', () => {
                editor.resetContent();
            });
            // Check page uses id="submit" or name="submit" for it's submit button
            if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
                form._mceOldSubmit = form.submit;
                form.submit = () => {
                    editor.editorManager.triggerSave();
                    editor.setDirty(false);
                    return form._mceOldSubmit(form);
                };
            }
        }
        editor.windowManager = WindowManager(editor);
        editor.notificationManager = NotificationManager(editor);
        if (isEncodingXml(editor)) {
            editor.on('GetContent', (e) => {
                if (e.save) {
                    e.content = DOM$3.encode(e.content);
                }
            });
        }
        if (shouldAddFormSubmitTrigger(editor)) {
            editor.on('submit', () => {
                if (editor.initialized) {
                    editor.save();
                }
            });
        }
        if (shouldAddUnloadTrigger(editor)) {
            editor._beforeUnload = () => {
                if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
                    editor.save({ format: 'raw', no_events: true, set_dirty: false });
                }
            };
            editor.editorManager.on('BeforeUnload', editor._beforeUnload);
        }
        editor.editorManager.add(editor);
        loadScripts(editor, editor.suffix);
    };

    const AvatarColors = [
        '#E41B60', // Pink
        '#AD1457', // Dark Pink
        '#1939EC', // Indigo
        '#001CB5', // Dark Indigo
        '#648000', // Lime
        '#465B00', // Dark Lime
        '#006CE7', // Blue
        '#0054B4', // Dark Blue
        '#00838F', // Cyan
        '#006064', // Dark Cyan
        '#00866F', // Turquoise
        '#004D40', // Dark Turquoise
        '#51742F', // Green
        '#385021', // Dark Green
        '#CF4900', // Orange
        '#A84600', // Dark Orange
        '#CC0000', // Red
        '#6A1B9A', // Dark Red
        '#9C27B0', // Purple
        '#6A00AB', // Dark Purple
        '#3041BA', // Navy Blue
        '#0A1877', // Dark Navy Blue
        '#774433', // Brown
        '#452B24', // Dark Brown
        '#607D8B', // Blue Gray
        '#455A64', // Dark Blue Gray
    ];
    const getFirstChar = (name) => {
        var _a;
        if (Intl.Segmenter) {
            const segmenter = new Intl.Segmenter();
            const iterator = segmenter.segment(name)[Symbol.iterator]();
            return `${(_a = iterator.next().value) === null || _a === void 0 ? void 0 : _a.segment}`;
        }
        else {
            return name.trim()[0];
        }
    };
    const getRandomColor = () => {
        const colorIdx = Math.floor(random() * AvatarColors.length);
        return AvatarColors[colorIdx];
    };
    const generate = (name, color, size = 36) => {
        const halfSize = size / 2;
        return `<svg height="${size}" width="${size}" xmlns="http://www.w3.org/2000/svg">` +
            `<circle cx="${halfSize}" cy="${halfSize}" r="${halfSize}" fill="${color}"/>` +
            `<text x="50%" y="50%" text-anchor="middle" dominant-baseline="central" fill="#FFF" font-family="sans-serif" font-size="${halfSize}">` +
            getFirstChar(name) +
            `</text>` +
            '</svg>';
    };
    const deriveAvatar = (name) => {
        const avatarSvg = generate(name, getRandomColor());
        return 'data:image/svg+xml,' + encodeURIComponent(avatarSvg);
    };
    const userSchema = objOf([
        required('id'),
        optionString('name'),
        optionString('avatar'),
        option('custom')
    ]);
    const objectCat = (obj) => {
        const result = {};
        each$d(obj, (value, key) => {
            value.each((v) => {
                result[key] = v;
            });
        });
        return result;
    };
    const validateResponse = (items) => {
        if (!Array.isArray(items)) {
            throw new Error('fetch_users must return an array');
        }
        const results = map$3(items, (item) => asRaw('Invalid user object', userSchema, item));
        const { errors, values } = partition$1(results);
        if (errors.length > 0) {
            const formattedErrors = map$3(errors, (error, idx) => `User at index ${idx}: ${formatError(error)}`);
            // eslint-disable-next-line no-console
            console.warn('User validation errors:\n' + formattedErrors.join('\n'));
        }
        return map$3(values, (user) => {
            const { id, name, avatar, ...rest } = user;
            return {
                id,
                name: name.getOr(id),
                avatar: avatar.getOr(deriveAvatar(name.getOr(id))),
                ...objectCat(rest),
            };
        });
    };
    const UserLookup = (editor) => {
        const userCache = new Map();
        const pendingResolvers = new Map();
        const lookup = (userId) => Optional.from(userCache.get(userId));
        const store = (user, userId) => {
            userCache.set(userId, user);
        };
        const finallyReject = (userId, error) => Optional
            .from(pendingResolvers.get(userId))
            .each(({ reject }) => {
            reject(error);
            pendingResolvers.delete(userId);
        });
        const finallyResolve = (userId, user) => Optional
            .from(pendingResolvers.get(userId))
            .each(({ resolve }) => {
            resolve(user);
            pendingResolvers.delete(userId);
        });
        const fetchUsers = (userIds) => {
            const fetchUsersFn = getFetchUsers(editor);
            if (!Array.isArray(userIds)) {
                return {};
            }
            else if (!fetchUsersFn) {
                return mapToObject(userIds, (userId) => Promise.resolve({
                    id: userId,
                    name: userId,
                    avatar: deriveAvatar(userId)
                }));
            }
            const uncachedIds = unique$1(filter$5((userIds), (userId) => !lookup(userId).isSome()));
            each$e(uncachedIds, (userId) => {
                const newPromise = new Promise((resolve, reject) => {
                    pendingResolvers.set(userId, { resolve, reject });
                });
                store(newPromise, userId);
            });
            if (uncachedIds.length > 0) {
                fetchUsersFn(uncachedIds)
                    .then(validateResponse)
                    .then((users) => {
                    const foundUserIds = new Set(map$3(users, (user) => user.id));
                    // Resolve found users
                    each$e(users, (user) => finallyResolve(user.id, user));
                    // Reject promises for users not found in the response
                    each$e(uncachedIds, (userId) => {
                        if (!foundUserIds.has(userId)) {
                            finallyReject(userId, new Error(`User ${userId} not found`));
                        }
                    });
                })
                    .catch((error) => {
                    each$e(uncachedIds, (userId) => finallyReject(userId, error instanceof Error ? error : new Error('Network error')));
                });
            }
            return foldl(userIds, (acc, userId) => {
                acc[userId] = lookup(userId).getOr(Promise.resolve({
                    id: userId,
                    name: userId,
                    avatar: deriveAvatar(userId)
                }));
                return acc;
            }, {});
        };
        const userId = getUserId(editor);
        return Object.freeze({
            userId,
            fetchUsers,
        });
    };
    const createUserLookup = (editor) => UserLookup(editor);

    const setEditableRoot = (editor, state) => {
        if (editor._editableRoot !== state) {
            editor._editableRoot = state;
            if (!isDisabled(editor)) {
                editor.getBody().contentEditable = String(editor.hasEditableRoot());
                editor.nodeChanged();
            }
            fireEditableRootStateChange(editor, state);
        }
    };
    const hasEditableRoot = (editor) => editor._editableRoot;

    const sectionResult = (sections, settings) => ({
        sections: constant(sections),
        options: constant(settings)
    });
    const deviceDetection = detect$1().deviceType;
    const isPhone = deviceDetection.isPhone();
    const isTablet = deviceDetection.isTablet();
    const normalizePlugins = (plugins) => {
        if (isNullable(plugins)) {
            return [];
        }
        else {
            const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);
            const trimmedPlugins = map$3(pluginNames, trim$4);
            return filter$5(trimmedPlugins, isNotEmpty);
        }
    };
    const extractSections = (keys, options) => {
        const result = bifilter(options, (value, key) => {
            return contains$2(keys, key);
        });
        return sectionResult(result.t, result.f);
    };
    const getSection = (sectionResult, name, defaults = {}) => {
        const sections = sectionResult.sections();
        const sectionOptions = get$a(sections, name).getOr({});
        return Tools.extend({}, defaults, sectionOptions);
    };
    const hasSection = (sectionResult, name) => {
        return has$2(sectionResult.sections(), name);
    };
    const getSectionConfig = (sectionResult, name) => {
        return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};
    };
    // Get a list of options to override any desktop options
    const getMobileOverrideOptions = (mobileOptions, isPhone) => {
        const defaultMobileOptions = {
            table_grid: false, // Table grid relies on hover, which isn't available for touch devices so use the dialog instead
            object_resizing: false, // No nice way to do object resizing at this stage
            resize: false, // Editor resize doesn't make sense on mobile
            toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'), // Use the default side-scrolling toolbar for tablets/phones
            toolbar_sticky: false // Only enable sticky toolbar on desktop by default
        };
        const defaultPhoneOptions = {
            menubar: false // Phones don't have a lot of screen space, so disable the menubar
        };
        return {
            ...defaultMobileOptions,
            ...isPhone ? defaultPhoneOptions : {}
        };
    };
    const getExternalPlugins = (overrideOptions, options) => {
        var _a;
        const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};
        if (overrideOptions && overrideOptions.external_plugins) {
            return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);
        }
        else {
            return userDefinedExternalPlugins;
        }
    };
    const combinePlugins = (forcedPlugins, plugins) => [
        ...normalizePlugins(forcedPlugins),
        ...normalizePlugins(plugins)
    ];
    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {
        // is a mobile device with any mobile options
        if (isMobileDevice && hasSection(sectionResult, 'mobile')) {
            return mobilePlugins;
            // is desktop
        }
        else {
            return desktopPlugins;
        }
    };
    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {
        const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);
        const desktopPlugins = normalizePlugins(options.plugins);
        const mobileConfig = getSectionConfig(sectionResult, 'mobile');
        const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;
        const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);
        const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
        return Tools.extend(options, {
            forced_plugins: forcedPlugins,
            plugins: combinedPlugins
        });
    };
    const isOnMobile = (isMobileDevice, sectionResult) => {
        return isMobileDevice && hasSection(sectionResult, 'mobile');
    };
    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {
        var _a;
        // Use mobile mode by default on phones, so patch in the mobile override options
        const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};
        const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));
        const extendedOptions = Tools.extend(
        // Default options
        defaultOptions, 
        // tinymce.overrideOptions options
        defaultOverrideOptions, 
        // User options
        sectionResult.options(), 
        // Sections
        isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, 
        // Forced options
        {
            external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options())
        });
        return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);
    };
    const normalizeOptions = (defaultOverrideOptions, options) => {
        const copiedOptions = merge$1(options);
        return combineOptions(isPhone || isTablet, isPhone, copiedOptions, defaultOverrideOptions, copiedOptions);
    };

    const addVisual = (editor, elm) => addVisual$1(editor, elm);

    const registerExecCommands$2 = (editor) => {
        const toggleFormat = (name, value) => {
            editor.formatter.toggle(name, value);
            editor.nodeChanged();
        };
        const toggleAlign = (align) => () => {
            // Remove all other alignments first
            each$e('left,center,right,justify'.split(','), (name) => {
                if (align !== name) {
                    editor.formatter.remove('align' + name);
                }
            });
            if (align !== 'none') {
                toggleFormat('align' + align);
            }
        };
        editor.editorCommands.addCommands({
            JustifyLeft: toggleAlign('left'),
            JustifyCenter: toggleAlign('center'),
            JustifyRight: toggleAlign('right'),
            JustifyFull: toggleAlign('justify'),
            JustifyNone: toggleAlign('none')
        });
    };
    const registerQueryStateCommands = (editor) => {
        const alignStates = (name) => () => {
            const selection = editor.selection;
            const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();
            return exists(nodes, (node) => isNonNullable(editor.formatter.matchNode(node, name)));
        };
        editor.editorCommands.addCommands({
            JustifyLeft: alignStates('alignleft'),
            JustifyCenter: alignStates('aligncenter'),
            JustifyRight: alignStates('alignright'),
            JustifyFull: alignStates('alignjustify')
        }, 'state');
    };
    const registerCommands$a = (editor) => {
        registerExecCommands$2(editor);
        registerQueryStateCommands(editor);
    };

    const registerCommands$9 = (editor) => {
        editor.editorCommands.addCommands({
            'Cut,Copy,Paste': (command) => {
                const doc = editor.getDoc();
                let failed;
                // Try executing the native command
                try {
                    doc.execCommand(command);
                }
                catch (_a) {
                    // Command failed
                    failed = true;
                }
                // Chrome reports the paste command as supported however older IE:s will return false for cut/paste
                if (command === 'paste' && !doc.queryCommandEnabled(command)) {
                    failed = true;
                }
                // Present alert message about clipboard access not being available
                if (failed || !doc.queryCommandSupported(command)) {
                    let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` +
                        'Please use the Ctrl+X/C/V keyboard shortcuts instead.');
                    if (Env.os.isMacOS() || Env.os.isiOS()) {
                        msg = msg.replace(/Ctrl\+/g, '\u2318+');
                    }
                    editor.notificationManager.open({ text: msg, type: 'error' });
                }
            }
        });
    };

    const trimOrPadLeftRight = (dom, rng, html, schema) => {
        const root = SugarElement.fromDom(dom.getRoot());
        // Adjust the start if it needs to be an nbsp
        if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {
            html = html.replace(/^ /, '&nbsp;');
        }
        else {
            html = html.replace(/^&nbsp;/, ' ');
        }
        // Adjust the end if it needs to be an nbsp
        if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {
            html = html.replace(/(&nbsp;| )(<br( \/)>)?$/, '&nbsp;');
        }
        else {
            html = html.replace(/&nbsp;(<br( \/)?>)?$/, ' ');
        }
        return html;
    };

    const processValue$1 = (value) => {
        if (typeof value !== 'string') {
            const details = Tools.extend({
                paste: value.paste,
                data: {
                    paste: value.paste
                }
            }, value);
            return {
                content: value.content,
                details
            };
        }
        return {
            content: value,
            details: {}
        };
    };
    const trimOrPad = (editor, value) => {
        const selection = editor.selection;
        const dom = editor.dom;
        // Check for whitespace before/after value
        if (/^ | $/.test(value)) {
            return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);
        }
        else {
            return value;
        }
    };
    const insertAtCaret = (editor, value) => {
        if (editor.selection.isEditable()) {
            const { content, details } = processValue$1(value);
            preProcessSetContent(editor, { ...details, content: trimOrPad(editor, content), format: 'html', set: false, selection: true }).each((args) => {
                const insertedContent = insertContent$1(editor, args.content, details);
                postProcessSetContent(editor, insertedContent, args);
                editor.addVisual();
            });
        }
    };

    const registerCommands$8 = (editor) => {
        editor.editorCommands.addCommands({
            mceCleanup: () => {
                const bm = editor.selection.getBookmark();
                editor.setContent(editor.getContent());
                editor.selection.moveToBookmark(bm);
            },
            insertImage: (_command, _ui, value) => {
                insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));
            },
            insertHorizontalRule: () => {
                editor.execCommand('mceInsertContent', false, '<hr>');
            },
            insertText: (_command, _ui, value) => {
                insertAtCaret(editor, editor.dom.encode(value));
            },
            insertHTML: (_command, _ui, value) => {
                insertAtCaret(editor, value);
            },
            mceInsertContent: (_command, _ui, value) => {
                insertAtCaret(editor, value);
            },
            mceSetContent: (_command, _ui, value) => {
                editor.setContent(value);
            },
            mceReplaceContent: (_command, _ui, value) => {
                editor.execCommand('mceInsertContent', false, value.replace(/\{\$selection\}/g, editor.selection.getContent({ format: 'text' })));
            },
            mceNewDocument: () => {
                editor.setContent(getNewDocumentContent(editor));
            }
        });
    };

    const legacyPropNames = {
        'font-size': 'size',
        'font-family': 'face'
    };
    const isFont = isTag('font');
    const getSpecifiedFontProp = (propName, rootElm, elm) => {
        const getProperty = (elm) => getRaw$1(elm, propName).orThunk(() => {
            if (isFont(elm)) {
                return get$a(legacyPropNames, propName).bind((legacyPropName) => getOpt(elm, legacyPropName));
            }
            else {
                return Optional.none();
            }
        });
        const isRoot = (elm) => eq(SugarElement.fromDom(rootElm), elm);
        return closest$1(SugarElement.fromDom(elm), (elm) => getProperty(elm), isRoot);
    };
    const normalizeFontFamily = (fontFamily) => 
    // 'Font name', Font -> Font name,Font
    fontFamily.replace(/[\'\"\\]/g, '').replace(/,\s+/g, ',');
    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
    const getFontProp = (propName) => (rootElm, elm) => Optional.from(elm)
        .map(SugarElement.fromDom)
        .filter(isElement$8)
        .bind((element) => getSpecifiedFontProp(propName, rootElm, element.dom)
        .or(getComputedFontProp(propName, element.dom)))
        .getOr('');
    const getFontSize = getFontProp('font-size');
    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));

    const findFirstCaretElement = (editor) => firstPositionIn(editor.getBody())
        .bind((caret) => {
        const container = caret.container();
        return Optional.from(isText$b(container) ? container.parentNode : container);
    });
    const getCaretElement = (editor) => Optional.from(editor.selection.getRng())
        .bind((rng) => {
        const root = editor.getBody();
        const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;
        return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));
    });
    const bindRange = (editor, binder) => getCaretElement(editor)
        .orThunk(curry(findFirstCaretElement, editor))
        .map(SugarElement.fromDom)
        .filter(isElement$8)
        .bind(binder);
    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));

    const fromFontSizeNumber = (editor, value) => {
        if (/^[0-9.]+$/.test(value)) {
            const fontSizeNumber = parseInt(value, 10);
            // Convert font size 1-7 to styles
            if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
                const fontSizes = getFontStyleValues(editor);
                const fontClasses = getFontSizeClasses(editor);
                if (fontClasses.length > 0) {
                    return fontClasses[fontSizeNumber - 1] || value;
                }
                else {
                    return fontSizes[fontSizeNumber - 1] || value;
                }
            }
            else {
                return value;
            }
        }
        else {
            return value;
        }
    };
    const normalizeFontNames = (font) => {
        const fonts = font.split(/\s*,\s*/);
        return map$3(fonts, (font) => {
            if (font.indexOf(' ') !== -1 && !(startsWith(font, '"') || startsWith(font, `'`))) {
                // TINY-3801: The font has spaces, so need to wrap with quotes as the browser sometimes automatically handles this, but not always
                return `'${font}'`;
            }
            else {
                return font;
            }
        }).join(',');
    };
    const fontNameAction = (editor, value) => {
        const font = fromFontSizeNumber(editor, value);
        editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });
        editor.nodeChanged();
    };
    const fontNameQuery = (editor) => mapRange(editor, (elm) => getFontFamily(editor.getBody(), elm.dom)).getOr('');
    const fontSizeAction = (editor, value) => {
        editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });
        editor.nodeChanged();
    };
    const fontSizeQuery = (editor) => mapRange(editor, (elm) => getFontSize(editor.getBody(), elm.dom)).getOr('');

    const lineHeightQuery = (editor) => mapRange(editor, (elm) => {
        const root = SugarElement.fromDom(editor.getBody());
        const specifiedStyle = closest$1(elm, (elm) => getRaw$1(elm, 'line-height'), curry(eq, root));
        const computedStyle = () => {
            // Css.get returns computed values (in px), and parseFloat will strip any non-number suffix
            const lineHeight = parseFloat(get$7(elm, 'line-height'));
            const fontSize = parseFloat(get$7(elm, 'font-size'));
            return String(lineHeight / fontSize);
        };
        return specifiedStyle.getOrThunk(computedStyle);
    }).getOr('');
    const lineHeightAction = (editor, lineHeight) => {
        editor.formatter.toggle('lineheight', { value: String(lineHeight) });
        editor.nodeChanged();
    };

    const registerExecCommands$1 = (editor) => {
        const toggleFormat = (name, value) => {
            editor.formatter.toggle(name, value);
            editor.nodeChanged();
        };
        editor.editorCommands.addCommands({
            'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': (command) => {
                toggleFormat(command);
            },
            'ForeColor,HiliteColor': (command, _ui, value) => {
                toggleFormat(command, { value });
            },
            'BackColor': (_command, _ui, value) => {
                toggleFormat('hilitecolor', { value });
            },
            'FontName': (_command, _ui, value) => {
                fontNameAction(editor, value);
            },
            'FontSize': (_command, _ui, value) => {
                fontSizeAction(editor, value);
            },
            'LineHeight': (_command, _ui, value) => {
                lineHeightAction(editor, value);
            },
            'Lang': (command, _ui, lang) => {
                var _a;
                toggleFormat(command, { value: lang.code, customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null });
            },
            'RemoveFormat': (command) => {
                editor.formatter.remove(command);
            },
            'mceBlockQuote': () => {
                toggleFormat('blockquote');
            },
            'FormatBlock': (_command, _ui, value) => {
                toggleFormat(isString(value) ? value : 'p');
            },
            'mceToggleFormat': (_command, _ui, value) => {
                toggleFormat(value);
            }
        });
    };
    const registerQueryValueCommands = (editor) => {
        const isFormatMatch = (name) => editor.formatter.match(name);
        editor.editorCommands.addCommands({
            'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': (command) => isFormatMatch(command),
            'mceBlockQuote': () => isFormatMatch('blockquote')
        }, 'state');
        editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));
        editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));
        editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));
    };
    const registerCommands$7 = (editor) => {
        registerExecCommands$1(editor);
        registerQueryValueCommands(editor);
    };

    const registerCommands$6 = (editor) => {
        editor.editorCommands.addCommands({
            mceAddUndoLevel: () => {
                editor.undoManager.add();
            },
            mceEndUndoLevel: () => {
                editor.undoManager.add();
            },
            Undo: () => {
                editor.undoManager.undo();
            },
            Redo: () => {
                editor.undoManager.redo();
            }
        });
    };

    const registerCommands$5 = (editor) => {
        editor.editorCommands.addCommands({
            Indent: () => {
                indent(editor);
            },
            Outdent: () => {
                outdent(editor);
            },
        });
        editor.editorCommands.addCommands({
            Outdent: () => canOutdent(editor),
            Indent: () => canIndent(editor),
        }, 'state');
    };

    const registerCommands$4 = (editor) => {
        const applyLinkToSelection = (_command, _ui, value) => {
            if (editor.mode.isReadOnly()) {
                return;
            }
            const linkDetails = isString(value) ? { href: value } : value;
            const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');
            if (isObject(linkDetails) && isString(linkDetails.href)) {
                // Spaces are never valid in URLs and it's a very common mistake for people to make so we fix it here.
                linkDetails.href = linkDetails.href.replace(/ /g, '%20');
                // Remove existing links if there could be child links or that the href isn't specified
                if (!anchor || !linkDetails.href) {
                    editor.formatter.remove('link');
                }
                // Apply new link to selection
                if (linkDetails.href) {
                    editor.formatter.apply('link', linkDetails, anchor);
                }
            }
        };
        editor.editorCommands.addCommands({
            unlink: () => {
                if (editor.selection.isEditable()) {
                    if (editor.selection.isCollapsed()) {
                        const elm = editor.dom.getParent(editor.selection.getStart(), 'a');
                        if (elm) {
                            editor.dom.remove(elm, true);
                        }
                        return;
                    }
                    editor.formatter.remove('link');
                }
            },
            mceInsertLink: applyLinkToSelection,
            createLink: applyLinkToSelection
        });
    };

    const getTopParentBlock = (editor, node, root, container) => {
        const dom = editor.dom;
        const selector = (node) => dom.isBlock(node) && node.parentElement === root;
        const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);
        return Optional.from(topParentBlock).map(SugarElement.fromDom);
    };
    const insert = (editor, before) => {
        if (editor.mode.isReadOnly()) {
            return;
        }
        const dom = editor.dom;
        const rng = editor.selection.getRng();
        const node = before ? editor.selection.getStart() : editor.selection.getEnd();
        const container = before ? rng.startContainer : rng.endContainer;
        const root = getEditableRoot(dom, container);
        if (!root || !root.isContentEditable) {
            return;
        }
        const insertFn = before ? before$4 : after$4;
        const newBlockName = getForcedRootBlock(editor);
        getTopParentBlock(editor, node, root, container).each((parentBlock) => {
            const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);
            insertFn(parentBlock, SugarElement.fromDom(newBlock));
            editor.selection.setCursorLocation(newBlock, 0);
            editor.dispatch('NewBlock', { newBlock });
            fireInputEvent(editor, 'insertParagraph');
        });
    };
    const insertBefore = (editor) => insert(editor, true);
    const insertAfter = (editor) => insert(editor, false);

    const registerCommands$3 = (editor) => {
        editor.editorCommands.addCommands({
            InsertNewBlockBefore: () => {
                insertBefore(editor);
            },
            InsertNewBlockAfter: () => {
                insertAfter(editor);
            },
        });
    };

    const registerCommands$2 = (editor) => {
        editor.editorCommands.addCommands({
            insertParagraph: () => {
                insertBreak(blockbreak, editor);
            },
            mceInsertNewLine: (_command, _ui, value) => {
                insert$1(editor, value);
            },
            InsertLineBreak: (_command, _ui, _value) => {
                insertBreak(linebreak, editor);
            }
        });
    };

    const registerCommands$1 = (editor) => {
        editor.editorCommands.addCommands({
            mceSelectNodeDepth: (_command, _ui, value) => {
                let counter = 0;
                editor.dom.getParent(editor.selection.getNode(), (node) => {
                    if (isElement$7(node) && counter++ === value) {
                        editor.selection.select(node);
                        return false;
                    }
                    else {
                        return true;
                    }
                }, editor.getBody());
            },
            mceSelectNode: (_command, _ui, value) => {
                editor.selection.select(value);
            },
            selectAll: () => {
                const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);
                if (editingHost) {
                    const rng = editor.dom.createRng();
                    rng.selectNodeContents(editingHost);
                    editor.selection.setRng(rng);
                }
            }
        });
    };

    const registerExecCommands = (editor) => {
        editor.editorCommands.addCommands({
            mceRemoveNode: (_command, _ui, value) => {
                const node = value !== null && value !== void 0 ? value : editor.selection.getNode();
                // Make sure that the body node isn't removed
                if (node !== editor.getBody()) {
                    const bm = editor.selection.getBookmark();
                    editor.dom.remove(node, true);
                    editor.selection.moveToBookmark(bm);
                }
            },
            mcePrint: () => {
                editor.getWin().print();
            },
            mceFocus: (_command, _ui, value) => {
                focus(editor, value === true);
            },
            mceToggleVisualAid: () => {
                editor.hasVisual = !editor.hasVisual;
                editor.addVisual();
            }
        });
    };
    const registerCommands = (editor) => {
        registerCommands$a(editor);
        registerCommands$9(editor);
        registerCommands$6(editor);
        registerCommands$1(editor);
        registerCommands$8(editor);
        registerCommands$4(editor);
        registerCommands$5(editor);
        registerCommands$3(editor);
        registerCommands$2(editor);
        registerCommands$7(editor);
        registerExecCommands(editor);
    };

    // List of commands that are considered safe even if the editor has no selection when the iframe is hidden in Firefox. See TINY-9210 for details.
    const selectionSafeCommands = ['toggleview'];
    const isSelectionSafeCommand = (command) => contains$2(selectionSafeCommands, command.toLowerCase());
    class EditorCommands {
        constructor(editor) {
            this.commands = { state: {}, exec: {}, value: {} };
            this.editor = editor;
        }
        /**
         * Executes a registered command on the current instance. A list of available commands can be found in
         * the tinymce command identifiers documentation.
         *
         * @method execCommand
         * @param {String} command Command name to execute, for example mceLink or Bold.
         * @param {Boolean} ui Specifies if a UI (dialog) should be presented or not.
         * @param {Object/Array/String/Number/Boolean} value Optional command value, this can be anything.
         * @param {Object} args Optional arguments object.
         * @return {Boolean} true or false if the command was supported or not.
         */
        execCommand(command, ui = false, value, args) {
            const editor = this.editor;
            const lowerCaseCommand = command.toLowerCase();
            const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;
            if (editor.removed) {
                return false;
            }
            if (lowerCaseCommand !== 'mcefocus') {
                if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {
                    editor.focus();
                }
                else {
                    restore(editor);
                }
            }
            const eventArgs = editor.dispatch('BeforeExecCommand', { command, ui, value });
            if (eventArgs.isDefaultPrevented()) {
                return false;
            }
            const func = this.commands.exec[lowerCaseCommand];
            if (isFunction(func)) {
                func(lowerCaseCommand, ui, value, args);
                editor.dispatch('ExecCommand', { command, ui, value, args });
                return true;
            }
            return false;
        }
        /**
         * Queries the current state for a command. For example: If the current selection is "bold".
         *
         * @method queryCommandState
         * @param {String} command Command to check the state of.
         * @return {Boolean} true/false - For example: If the selected contents is bold or not.
         */
        queryCommandState(command) {
            if ((!isSelectionSafeCommand(command) && this.editor.quirks.isHidden()) || this.editor.removed) {
                return false;
            }
            const lowerCaseCommand = command.toLowerCase();
            const func = this.commands.state[lowerCaseCommand];
            if (isFunction(func)) {
                return func(lowerCaseCommand);
            }
            return false;
        }
        /**
         * Returns a command specific value, for example the current font size.
         *
         * @method queryCommandValue
         * @param {String} command Command to query value from.
         * @return {String} Command value, for example the current font size or an empty string (`""`) if the query command is not found.
         */
        queryCommandValue(command) {
            if ((!isSelectionSafeCommand(command) && this.editor.quirks.isHidden()) || this.editor.removed) {
                return '';
            }
            const lowerCaseCommand = command.toLowerCase();
            const func = this.commands.value[lowerCaseCommand];
            if (isFunction(func)) {
                return func(lowerCaseCommand);
            }
            return '';
        }
        addCommands(commandList, type = 'exec') {
            const commands = this.commands;
            each$d(commandList, (callback, command) => {
                each$e(command.toLowerCase().split(','), (command) => {
                    commands[type][command] = callback;
                });
            });
        }
        addCommand(command, callback, scope) {
            const lowerCaseCommand = command.toLowerCase();
            this.commands.exec[lowerCaseCommand] = (_command, ui, value, args) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value, args);
        }
        /**
         * Returns true/false if the command is supported or not.
         *
         * @method queryCommandSupported
         * @param {String} command Command that we check support for.
         * @return {Boolean} true/false if the command is supported or not.
         */
        queryCommandSupported(command) {
            const lowerCaseCommand = command.toLowerCase();
            if (this.commands.exec[lowerCaseCommand]) {
                return true;
            }
            else {
                return false;
            }
        }
        addQueryStateHandler(command, callback, scope) {
            this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
        }
        addQueryValueHandler(command, callback, scope) {
            this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
        }
    }

    /**
     * This class lets you add/remove and dispatch events by name on the specified scope. This makes
     * it easy to add event listener logic to any class.
     *
     * @class tinymce.util.EventDispatcher
     * @example
     * const eventDispatcher = new EventDispatcher();
     *
     * eventDispatcher.on('click', () => console.log('data'));
     * eventDispatcher.dispatch('click', { data: 123 });
     */
    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' +
        'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' +
        'draggesture dragdrop drop drag submit ' +
        'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');
    class EventDispatcher {
        /**
         * Returns true/false if the specified event name is a native browser event or not.
         *
         * @method isNative
         * @param {String} name Name to check if it's native.
         * @return {Boolean} true/false if the event is native or not.
         * @static
         */
        static isNative(name) {
            return !!nativeEvents[name.toLowerCase()];
        }
        constructor(settings) {
            this.bindings = {};
            this.settings = settings || {};
            this.scope = this.settings.scope || this;
            this.toggleEvent = this.settings.toggleEvent || never;
        }
        /**
         * Fires the specified event by name.
         * <br>
         * <em>Marked for removal in TinyMCE 8.0. Use <code>dispatch</code> instead.</em>
         *
         * @method fire
         * @param {String} name Name of the event to fire.
         * @param {Object?} args Event arguments.
         * @return {Object} Event args instance passed in.
         * @deprecated Use dispatch() instead
         * @example
         * instance.fire('event', {...});
         */
        fire(name, args) {
            return this.dispatch(name, args);
        }
        /**
         * Dispatches the specified event by name.
         *
         * @method dispatch
         * @param {String} name Name of the event to dispatch
         * @param {Object?} args Event arguments.
         * @return {Object} Event args instance passed in.
         * @example
         * instance.dispatch('event', {...});
         */
        dispatch(name, args) {
            const lcName = name.toLowerCase();
            const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);
            if (this.settings.beforeFire) {
                this.settings.beforeFire(event);
            }
            // Don't clone the array here as this is a hot code path, so instead the handlers
            // array is recreated and the this.bindings[name] reference is updated in the `on`
            // and `off` functions. This is done to avoid the handlers array being mutated while
            // we're iterating over it below.
            const handlers = this.bindings[lcName];
            if (handlers) {
                for (let i = 0, l = handlers.length; i < l; i++) {
                    const callback = handlers[i];
                    // The handler was removed by an earlier handler in this loop so skip it.
                    if (callback.removed) {
                        continue;
                    }
                    // Unbind handlers marked with "once"
                    if (callback.once) {
                        this.off(lcName, callback.func);
                    }
                    // Stop immediate propagation if needed
                    if (event.isImmediatePropagationStopped()) {
                        return event;
                    }
                    // If callback returns false then prevent default and stop all propagation
                    if (callback.func.call(this.scope, event) === false) {
                        event.preventDefault();
                        return event;
                    }
                }
            }
            return event;
        }
        /**
         * Binds an event listener to a specific event by name.
         *
         * @method on
         * @param {String} name Event name or space separated list of events to bind.
         * @param {Function} callback Callback to be executed when the event occurs.
         * @param {Boolean} prepend Optional flag if the event should be prepended. Use this with care.
         * @return {Object} Current class instance.
         * @example
         * instance.on('event', (e) => {
         *   // Callback logic
         * });
         */
        on(name, callback, prepend, extra) {
            if (callback === false) {
                callback = never;
            }
            if (callback) {
                const wrappedCallback = {
                    func: callback,
                    removed: false
                };
                if (extra) {
                    Tools.extend(wrappedCallback, extra);
                }
                const names = name.toLowerCase().split(' ');
                let i = names.length;
                while (i--) {
                    const currentName = names[i];
                    let handlers = this.bindings[currentName];
                    if (!handlers) {
                        handlers = [];
                        this.toggleEvent(currentName, true);
                    }
                    if (prepend) {
                        handlers = [wrappedCallback, ...handlers];
                    }
                    else {
                        handlers = [...handlers, wrappedCallback];
                    }
                    this.bindings[currentName] = handlers;
                }
            }
            return this;
        }
        /**
         * Unbinds an event listener to a specific event by name.
         *
         * @method off
         * @param {String?} name Name of the event to unbind.
         * @param {Function?} callback Callback to unbind.
         * @return {Object} Current class instance.
         * @example
         * // Unbind specific callback
         * instance.off('event', handler);
         *
         * // Unbind all listeners by name
         * instance.off('event');
         *
         * // Unbind all events
         * instance.off();
         */
        off(name, callback) {
            if (name) {
                const names = name.toLowerCase().split(' ');
                let i = names.length;
                while (i--) {
                    const currentName = names[i];
                    let handlers = this.bindings[currentName];
                    // Unbind all handlers
                    if (!currentName) {
                        each$d(this.bindings, (_value, bindingName) => {
                            this.toggleEvent(bindingName, false);
                            delete this.bindings[bindingName];
                        });
                        return this;
                    }
                    if (handlers) {
                        // Unbind all by name
                        if (!callback) {
                            handlers.length = 0;
                        }
                        else {
                            // Unbind specific handlers
                            const filteredHandlers = partition$2(handlers, (handler) => handler.func === callback);
                            handlers = filteredHandlers.fail;
                            this.bindings[currentName] = handlers;
                            // Mark the removed handlers in case this event is already being processed in `fire`
                            each$e(filteredHandlers.pass, (handler) => {
                                handler.removed = true;
                            });
                        }
                        if (!handlers.length) {
                            this.toggleEvent(name, false);
                            delete this.bindings[currentName];
                        }
                    }
                }
            }
            else {
                each$d(this.bindings, (_value, name) => {
                    this.toggleEvent(name, false);
                });
                this.bindings = {};
            }
            return this;
        }
        /**
         * Binds an event listener to a specific event by name
         * and automatically unbind the event once the callback fires.
         *
         * @method once
         * @param {String} name Event name or space separated list of events to bind.
         * @param {Function} callback Callback to be executed when the event occurs.
         * @param {Boolean} prepend Optional flag if the event should be prepended. Use this with care.
         * @return {Object} Current class instance.
         * @example
         * instance.once('event', (e) => {
         *   // Callback logic
         * });
         */
        once(name, callback, prepend) {
            return this.on(name, callback, prepend, { once: true });
        }
        /**
         * Returns true/false if the dispatcher has a event of the specified name.
         *
         * @method has
         * @param {String} name Name of the event to check for.
         * @return {Boolean} true/false if the event exists or not.
         */
        has(name) {
            name = name.toLowerCase();
            const binding = this.bindings[name];
            return !(!binding || binding.length === 0);
        }
    }

    /**
     * This mixin adds event binding logic to classes. Adapts the EventDispatcher class.
     *
     * @mixin tinymce.util.Observable
     */
    const getEventDispatcher = (obj) => {
        if (!obj._eventDispatcher) {
            obj._eventDispatcher = new EventDispatcher({
                scope: obj,
                toggleEvent: (name, state) => {
                    if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {
                        obj.toggleNativeEvent(name, state);
                    }
                }
            });
        }
        return obj._eventDispatcher;
    };
    const Observable = {
        /**
         * Fires the specified event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/8/events/">event reference</a> for more details on each event.
         * <br>
         * <em>Deprecated in TinyMCE 6.0 and has been marked for removal in TinyMCE 9.0. Use <code>dispatch</code> instead.</em>
         *
         * @method fire
         * @param {String} name Name of the event to fire.
         * @param {Object?} args Event arguments.
         * @param {Boolean?} bubble True/false if the event is to be bubbled.
         * @return {Object} Event args instance passed in.
         * @deprecated Use dispatch() instead
         * @example
         * instance.fire('event', {...});
         */
        fire(name, args, bubble) {
            logFeatureDeprecationWarning('fire');
            return this.dispatch(name, args, bubble);
        },
        /**
         * Dispatches the specified event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/8/events/">event reference</a> for more details on each event.
         *
         * @method dispatch
         * @param {String} name Name of the event to dispatch.
         * @param {Object?} args Event arguments.
         * @param {Boolean?} bubble True/false if the event is to be bubbled.
         * @return {Object} Event args instance passed in.
         * @example
         * instance.dispatch('event', {...});
         */
        dispatch(name, args, bubble) {
            const self = this;
            // Prevent all events except the remove/detach event after the instance has been removed
            if (self.removed && name !== 'remove' && name !== 'detach') {
                return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);
            }
            const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);
            // Bubble event up to parents
            if (bubble !== false && self.parent) {
                let parent = self.parent();
                while (parent && !dispatcherArgs.isPropagationStopped()) {
                    parent.dispatch(name, dispatcherArgs, false);
                    parent = parent.parent ? parent.parent() : undefined;
                }
            }
            return dispatcherArgs;
        },
        /**
         * Binds an event listener to a specific event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/8/events/">event reference</a> for more details on each event.
         *
         * @method on
         * @param {String} name Event name or space separated list of events to bind.
         * @param {Function} callback Callback to be executed when the event occurs.
         * @param {Boolean} prepend Optional flag if the event should be prepended. Use this with care.
         * @return {Object} Current class instance.
         * @example
         * instance.on('event', (e) => {
         *   // Callback logic
         * });
         */
        on(name, callback, prepend) {
            return getEventDispatcher(this).on(name, callback, prepend);
        },
        /**
         * Unbinds an event listener to a specific event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/8/events/">event reference</a> for more details on each event.
         *
         * @method off
         * @param {String?} name Name of the event to unbind.
         * @param {Function?} callback Callback to unbind.
         * @return {Object} Current class instance.
         * @example
         * // Unbind specific callback
         * instance.off('event', handler);
         *
         * // Unbind all listeners by name
         * instance.off('event');
         *
         * // Unbind all events
         * instance.off();
         */
        off(name, callback) {
            return getEventDispatcher(this).off(name, callback);
        },
        /**
         * Bind the event callback and once it fires the callback is removed. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/8/events/">event reference</a> for more details on each event.
         *
         * @method once
         * @param {String} name Name of the event to bind.
         * @param {Function} callback Callback to bind only once.
         * @return {Object} Current class instance.
         */
        once(name, callback) {
            return getEventDispatcher(this).once(name, callback);
        },
        /**
         * Returns true/false if the object has a event of the specified name.
         *
         * @method hasEventListeners
         * @param {String} name Name of the event to check for.
         * @return {Boolean} true/false if the event exists or not.
         */
        hasEventListeners(name) {
            return getEventDispatcher(this).has(name);
        }
    };

    /**
     * This mixin contains the event logic for the tinymce.Editor class.
     *
     * @mixin tinymce.EditorObservable
     * @extends tinymce.util.Observable
     * @private
     */
    const DOM$2 = DOMUtils.DOM;
    let customEventRootDelegates;
    /**
     * Returns the event target for the specified event. Some events fire
     * only on document, some fire on documentElement etc. This also handles the
     * custom event root setting where it returns that element instead of the body.
     *
     * @private
     * @param {tinymce.Editor} editor Editor instance to get event target from.
     * @param {String} eventName Name of the event for example "click".
     * @return {Element/Document} HTML Element or document target to bind on.
     */
    const getEventTarget = (editor, eventName) => {
        if (eventName === 'selectionchange') {
            return editor.getDoc();
        }
        // Need to bind mousedown/mouseup etc to document not body in iframe mode
        // Since the user might click on the HTML element not the BODY
        if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {
            return editor.getDoc().documentElement;
        }
        // Bind to event root instead of body if it's defined
        const eventRoot = getEventRoot(editor);
        if (eventRoot) {
            if (!editor.eventRoot) {
                editor.eventRoot = DOM$2.select(eventRoot)[0];
            }
            return editor.eventRoot;
        }
        return editor.getBody();
    };
    const isListening = (editor) => !editor.hidden && !isDisabled(editor);
    const fireEvent = (editor, eventName, e) => {
        if (isListening(editor)) {
            editor.dispatch(eventName, e);
        }
        else if (isDisabled(editor)) {
            processDisabledEvents(editor, e);
        }
    };
    /**
     * Binds a event delegate for the specified name this delegate will fire
     * the event to the editor dispatcher.
     *
     * @private
     * @param {tinymce.Editor} editor Editor instance to get event target from.
     * @param {String} eventName Name of the event for example "click".
     */
    const bindEventDelegate = (editor, eventName) => {
        if (!editor.delegates) {
            editor.delegates = {};
        }
        if (editor.delegates[eventName] || editor.removed) {
            return;
        }
        const eventRootElm = getEventTarget(editor, eventName);
        if (getEventRoot(editor)) {
            if (!customEventRootDelegates) {
                customEventRootDelegates = {};
                editor.editorManager.on('removeEditor', () => {
                    if (!editor.editorManager.activeEditor) {
                        if (customEventRootDelegates) {
                            each$d(customEventRootDelegates, (_value, name) => {
                                editor.dom.unbind(getEventTarget(editor, name));
                            });
                            customEventRootDelegates = null;
                        }
                    }
                });
            }
            if (customEventRootDelegates[eventName]) {
                return;
            }
            const delegate = (e) => {
                const target = e.target;
                const editors = editor.editorManager.get();
                let i = editors.length;
                while (i--) {
                    const body = editors[i].getBody();
                    if (body === target || DOM$2.isChildOf(target, body)) {
                        fireEvent(editors[i], eventName, e);
                    }
                }
            };
            customEventRootDelegates[eventName] = delegate;
            DOM$2.bind(eventRootElm, eventName, delegate);
        }
        else {
            const delegate = (e) => {
                fireEvent(editor, eventName, e);
            };
            DOM$2.bind(eventRootElm, eventName, delegate);
            editor.delegates[eventName] = delegate;
        }
    };
    const EditorObservable = {
        ...Observable,
        /**
         * Bind any pending event delegates. This gets executed after the target body/document is created.
         *
         * @private
         */
        bindPendingEventDelegates() {
            const self = this;
            Tools.each(self._pendingNativeEvents, (name) => {
                bindEventDelegate(self, name);
            });
        },
        /**
         * Toggles a native event on/off this is called by the EventDispatcher when
         * the first native event handler is added and when the last native event handler is removed.
         *
         * @private
         */
        toggleNativeEvent(name, state) {
            const self = this;
            // Never bind focus/blur since the FocusManager fakes those
            if (name === 'focus' || name === 'blur') {
                return;
            }
            // If the editor has been removed, `unbindAllNativeEvents` has already deleted all native event delegates
            if (self.removed) {
                return;
            }
            if (state) {
                if (self.initialized) {
                    bindEventDelegate(self, name);
                }
                else {
                    if (!self._pendingNativeEvents) {
                        self._pendingNativeEvents = [name];
                    }
                    else {
                        self._pendingNativeEvents.push(name);
                    }
                }
            }
            else if (self.initialized && self.delegates) {
                self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
                delete self.delegates[name];
            }
        },
        /**
         * Unbinds all native event handlers that means delegates, custom events bound using the Events API etc.
         *
         * @private
         */
        unbindAllNativeEvents() {
            const self = this;
            const body = self.getBody();
            const dom = self.dom;
            if (self.delegates) {
                each$d(self.delegates, (value, name) => {
                    self.dom.unbind(getEventTarget(self, name), name, value);
                });
                delete self.delegates;
            }
            if (!self.inline && body && dom) {
                body.onload = null;
                dom.unbind(self.getWin());
                dom.unbind(self.getDoc());
            }
            if (dom) {
                dom.unbind(body);
                dom.unbind(self.getContainer());
            }
        }
    };

    // A string array allows comma/space separated values as well for ease of use
    const stringListProcessor = (value) => {
        if (isString(value)) {
            return { value: value.split(/[ ,]/), valid: true };
        }
        else if (isArrayOf(value, isString)) {
            return { value, valid: true };
        }
        else {
            return { valid: false, message: `The value must be a string[] or a comma/space separated string.` };
        }
    };
    const getBuiltInProcessor = (type) => {
        const validator = (() => {
            switch (type) {
                case 'array':
                    return isArray$1;
                case 'boolean':
                    return isBoolean;
                case 'function':
                    return isFunction;
                case 'number':
                    return isNumber;
                case 'object':
                    return isObject;
                case 'string':
                    return isString;
                case 'string[]':
                    return stringListProcessor;
                case 'object[]':
                    return (val) => isArrayOf(val, isObject);
                case 'regexp':
                    return (val) => is$5(val, RegExp);
                default:
                    return always;
            }
        })();
        return (value) => processValue(value, validator, `The value must be a ${type}.`);
    };
    const isBuiltInSpec = (spec) => isString(spec.processor);
    const getErrorMessage = (message, result) => {
        const additionalText = isEmpty$5(result.message) ? '' : `. ${result.message}`;
        return message + additionalText;
    };
    const isValidResult = (result) => result.valid;
    const processValue = (value, processor, message = '') => {
        const result = processor(value);
        if (isBoolean(result)) {
            // Note: Need to cast here as if a boolean is returned then we're guaranteed to be returning the same value
            return result ? { value: value, valid: true } : { valid: false, message };
        }
        else {
            return result;
        }
    };
    const processDefaultValue = (name, defaultValue, processor) => {
        if (!isUndefined(defaultValue)) {
            const result = processValue(defaultValue, processor);
            if (isValidResult(result)) {
                return result.value;
            }
            else {
                // eslint-disable-next-line no-console
                console.error(getErrorMessage(`Invalid default value passed for the "${name}" option`, result));
            }
        }
        return undefined;
    };
    const create$4 = (editor, initialOptions, rawInitialOptions = initialOptions) => {
        const registry = {};
        const values = {};
        const setValue = (name, value, processor) => {
            const result = processValue(value, processor);
            if (isValidResult(result)) {
                values[name] = result.value;
                return true;
            }
            else {
                // eslint-disable-next-line no-console
                console.warn(getErrorMessage(`Invalid value passed for the ${name} option`, result));
                return false;
            }
        };
        const register = (name, spec) => {
            const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;
            // Process and validate the default value
            const defaultValue = processDefaultValue(name, spec.default, processor);
            // Register the spec with the validated default and normalized processor
            registry[name] = {
                ...spec,
                default: defaultValue,
                processor
            };
            // Setup the initial values
            const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));
            initValue.each((value) => setValue(name, value, processor));
        };
        const isRegistered = (name) => has$2(registry, name);
        const get = (name) => get$a(values, name)
            .orThunk(() => get$a(registry, name).map((spec) => spec.default))
            .getOrUndefined();
        const set = (name, value) => {
            if (!isRegistered(name)) {
                // eslint-disable-next-line no-console
                console.warn(`"${name}" is not a registered option. Ensure the option has been registered before setting a value.`);
                return false;
            }
            else {
                const spec = registry[name];
                if (spec.immutable) {
                    // eslint-disable-next-line no-console
                    console.error(`"${name}" is an immutable option and cannot be updated`);
                    return false;
                }
                else {
                    return setValue(name, value, spec.processor);
                }
            }
        };
        const unset = (name) => {
            const registered = isRegistered(name);
            if (registered) {
                delete values[name];
            }
            return registered;
        };
        const isSet = (name) => has$2(values, name);
        const debug = () => {
            try {
                // eslint-disable-next-line no-console
                console.log(JSON.parse(JSON.stringify(rawInitialOptions, (_key, value) => {
                    if (isBoolean(value) ||
                        isNumber(value) ||
                        isString(value) ||
                        isNull(value) ||
                        isArray$1(value) ||
                        isPlainObject(value)) {
                        return value;
                    }
                    return Object.prototype.toString.call(value);
                })));
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.error(error);
            }
        };
        return {
            register,
            isRegistered,
            get,
            set,
            unset,
            isSet,
            debug,
        };
    };

    const setContentEditable = (elm, state) => {
        elm.dom.contentEditable = state ? 'true' : 'false';
    };
    const toggleReadOnly = (editor, state) => {
        const body = SugarElement.fromDom(editor.getBody());
        if (state) {
            editor.readonly = true;
            if (editor.hasEditableRoot()) {
                setContentEditable(body, true);
            }
            disableEditor(editor);
        }
        else {
            editor.readonly = false;
            enableEditor(editor);
        }
    };
    const isReadOnly = (editor) => editor.readonly;
    const rollbackChange = (editor) => {
        const undoLevel = editor.undoManager.add();
        if (isNonNullable(undoLevel)) {
            editor.undoManager.undo();
            editor.undoManager.reset();
        }
    };
    const hasContentMutations = (mutations) => exists(mutations, (mutation) => mutation.type === 'characterData' || mutation.type === 'childList');
    const registerReadOnlyInputBlockers = (editor) => {
        const handleMutations = (mutations) => {
            if (isReadOnly(editor) && hasContentMutations(mutations)) {
                rollbackChange(editor);
            }
        };
        // Set up mutation observer to detect and revert unintended changes
        const observer = new MutationObserver(handleMutations);
        editor.on('beforeinput paste cut dragend dragover draggesture dragdrop drop drag', (e) => {
            if (isReadOnly(editor)) {
                e.preventDefault();
            }
        });
        editor.on('BeforeExecCommand', (e) => {
            if ((e.command === 'Undo' || e.command === 'Redo') && isReadOnly(editor)) {
                e.preventDefault();
            }
        });
        editor.on('compositionstart', () => {
            if (isReadOnly(editor)) {
                observer.observe(editor.getBody(), {
                    characterData: true,
                    childList: true,
                    subtree: true
                });
            }
        });
        editor.on('compositionend', () => {
            if (isReadOnly(editor)) {
                const records = observer.takeRecords();
                handleMutations(records);
            }
            observer.disconnect();
        });
    };

    const defaultModes = ['design', 'readonly'];
    const switchToMode = (editor, activeMode, availableModes, mode) => {
        const oldMode = availableModes[activeMode.get()];
        const newMode = availableModes[mode];
        // if activate fails, hope nothing bad happened and abort
        try {
            newMode.activate();
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.error(`problem while activating editor mode ${mode}:`, e);
            return;
        }
        oldMode.deactivate();
        if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
            toggleReadOnly(editor, newMode.editorReadOnly);
        }
        activeMode.set(mode);
        fireSwitchMode(editor, mode);
    };
    const setMode = (editor, availableModes, activeMode, mode) => {
        if (mode === activeMode.get() || (editor.initialized && isDisabled(editor))) {
            return;
        }
        else if (!has$2(availableModes, mode)) {
            throw new Error(`Editor mode '${mode}' is invalid`);
        }
        if (editor.initialized) {
            switchToMode(editor, activeMode, availableModes, mode);
        }
        else {
            editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));
        }
    };
    const registerMode = (availableModes, mode, api) => {
        if (contains$2(defaultModes, mode)) {
            throw new Error(`Cannot override default mode ${mode}`);
        }
        return {
            ...availableModes,
            [mode]: {
                ...api,
                deactivate: () => {
                    // wrap custom deactivate APIs so they can't break the editor
                    try {
                        api.deactivate();
                    }
                    catch (e) {
                        // eslint-disable-next-line no-console
                        console.error(`problem while deactivating editor mode ${mode}:`, e);
                    }
                }
            }
        };
    };

    const create$3 = (editor) => {
        const activeMode = Cell('design');
        const availableModes = Cell({
            design: {
                activate: noop,
                deactivate: noop,
                editorReadOnly: false
            },
            readonly: {
                activate: noop,
                deactivate: noop,
                editorReadOnly: true
            }
        });
        registerReadOnlyInputBlockers(editor);
        registerEventsAndFilters$1(editor);
        return {
            isReadOnly: () => isReadOnly(editor),
            set: (mode) => setMode(editor, availableModes.get(), activeMode, mode),
            get: () => activeMode.get(),
            register: (mode, api) => {
                availableModes.set(registerMode(availableModes.get(), mode, api));
            }
        };
    };

    /**
     * Contains logic for handling keyboard shortcuts.
     *
     * @class tinymce.Shortcuts
     * @example
     * editor.shortcuts.add('ctrl+a', 'description of the shortcut', () => {});
     * editor.shortcuts.add('ctrl+alt+a', 'description of the shortcut', () => {});
     * // "meta" maps to Command on Mac and Ctrl on PC
     * editor.shortcuts.add('meta+a', 'description of the shortcut', () => {});
     * // "access" maps to Control+Option on Mac and shift+alt on PC
     * editor.shortcuts.add('access+a', 'description of the shortcut', () => {});
     *
     * editor.shortcuts.add('meta+access+c', 'Opens the code editor dialog.', () => {
     *   editor.execCommand('mceCodeEditor');
     * });
     *
     * editor.shortcuts.add('meta+shift+32', 'Inserts "Hello, World!" for meta+shift+space', () => {
     *   editor.execCommand('mceInsertContent', false, 'Hello, World!');
     * });
     */
    const each$2 = Tools.each, explode = Tools.explode;
    const keyCodeLookup = {
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123
    };
    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');
    const isModifier = (key) => key in modifierNames;
    const parseShortcut = (pattern) => {
        const shortcut = {};
        const isMac = Env.os.isMacOS() || Env.os.isiOS();
        // Parse modifiers and keys ctrl+alt+b for example
        each$2(explode(pattern.toLowerCase(), '+'), (value) => {
            if (isModifier(value)) {
                shortcut[value] = true;
            }
            else {
                // Allow numeric keycodes like ctrl+219 for ctrl+[
                if (/^[0-9]{2,}$/.test(value)) {
                    shortcut.keyCode = parseInt(value, 10);
                }
                else {
                    shortcut.charCode = value.charCodeAt(0);
                    shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
                }
            }
        });
        // Generate unique id for modifier combination and set default state for unused modifiers
        const id = [shortcut.keyCode];
        let key;
        for (key in modifierNames) {
            if (shortcut[key]) {
                id.push(key);
            }
            else {
                shortcut[key] = false;
            }
        }
        shortcut.id = id.join(',');
        // Handle special access modifier differently depending on Mac/Win
        if (shortcut.access) {
            shortcut.alt = true;
            if (isMac) {
                shortcut.ctrl = true;
            }
            else {
                shortcut.shift = true;
            }
        }
        // Handle special meta modifier differently depending on Mac/Win
        if (shortcut.meta) {
            if (isMac) {
                shortcut.meta = true;
            }
            else {
                shortcut.ctrl = true;
                shortcut.meta = false;
            }
        }
        return shortcut;
    };
    class Shortcuts {
        constructor(editor) {
            this.shortcuts = {};
            this.pendingPatterns = [];
            this.editor = editor;
            const self = this;
            editor.on('keyup keypress keydown', (e) => {
                if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {
                    each$2(self.shortcuts, (shortcut) => {
                        if (self.matchShortcut(e, shortcut)) {
                            self.pendingPatterns = shortcut.subpatterns.slice(0);
                            if (e.type === 'keydown') {
                                self.executeShortcutAction(shortcut);
                            }
                        }
                    });
                    if (self.matchShortcut(e, self.pendingPatterns[0])) {
                        if (self.pendingPatterns.length === 1) {
                            if (e.type === 'keydown') {
                                self.executeShortcutAction(self.pendingPatterns[0]);
                            }
                        }
                        self.pendingPatterns.shift();
                    }
                }
            });
        }
        /**
         * Adds a keyboard shortcut for some command or function.
         *
         * @method add
         * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
         * @param {String} desc Text description for the command.
         * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
         * @param {Object} scope Optional scope to execute the function in.
         * @return {Boolean} true/false state if the shortcut was added or not.
         */
        add(pattern, desc, cmdFunc, scope) {
            const self = this;
            const func = self.normalizeCommandFunc(cmdFunc);
            each$2(explode(Tools.trim(pattern)), (pattern) => {
                const shortcut = self.createShortcut(pattern, desc, func, scope);
                self.shortcuts[shortcut.id] = shortcut;
            });
            return true;
        }
        /**
         * Remove a keyboard shortcut by pattern.
         *
         * @method remove
         * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
         * @return {Boolean} true/false state if the shortcut was removed or not.
         */
        remove(pattern) {
            const shortcut = this.createShortcut(pattern);
            if (this.shortcuts[shortcut.id]) {
                delete this.shortcuts[shortcut.id];
                return true;
            }
            return false;
        }
        normalizeCommandFunc(cmdFunc) {
            const self = this;
            const cmd = cmdFunc;
            if (typeof cmd === 'string') {
                return () => {
                    self.editor.execCommand(cmd, false, null);
                };
            }
            else if (Tools.isArray(cmd)) {
                return () => {
                    self.editor.execCommand(cmd[0], cmd[1], cmd[2]);
                };
            }
            else {
                return cmd;
            }
        }
        createShortcut(pattern, desc, cmdFunc, scope) {
            const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);
            shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
                func: cmdFunc,
                scope: scope || this.editor
            });
            return Tools.extend(shortcuts[0], {
                desc: this.editor.translate(desc),
                subpatterns: shortcuts.slice(1)
            });
        }
        hasModifier(e) {
            return e.altKey || e.ctrlKey || e.metaKey;
        }
        isFunctionKey(e) {
            return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;
        }
        matchShortcut(e, shortcut) {
            if (!shortcut) {
                return false;
            }
            if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
                return false;
            }
            if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
                return false;
            }
            if (e.keyCode === shortcut.keyCode || (e.charCode && e.charCode === shortcut.charCode)) {
                e.preventDefault();
                return true;
            }
            return false;
        }
        executeShortcutAction(shortcut) {
            return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
        }
    }

    /**
     * TinyMCE UI registration API.
     *
     * @class tinymce.editor.ui.Registry
     */
    const registry = () => {
        const bridge = create$6();
        return {
            /**
             * Registers a new auto completer component. When a configured string pattern
             * is matched in the content while typing, the autocompleter will be triggered.
             * Emoticons and Charmap use an autocompleter.
             * <br>
             * For information on creating an autocompleter, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/autocompleter/">
             * UI Components - Autocompleter</a>.
             *
             * @method addAutocompleter
             * @param {String} name Unique name identifying this autocomplete configuration.
             * @param {InlineContent.AutocompleterSpec} obj The autocomplete configuration object.
             */
            addAutocompleter: bridge.addAutocompleter,
            /**
             * Registers a new toolbar button that executes a command when clicked or activated
             * via keyboard navigation controls.
             * <br>
             * For information on creating a basic toolbar button, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-basic-toolbar-button/">
             * UI Components - Types of toolbar buttons: Basic button</a>.
             *
             * @method addButton
             * @param {String} name Unique name identifying the button, this button name will be used in the toolbar configuration to reference the button.
             * @param {Toolbar.ToolbarButtonSpec} obj the button configuration object.
             */
            addButton: bridge.addButton,
            /**
             * Registers a new contextual form item.
             * Similar to a context menu item, a contextual form is an item with an input
             * form element appearing when a content predicate is matched. An example
             * of a contextual form is the link plugin when the configuration
             * { link_context_toolbar: true } is used. When the cursor is on a link, a
             * contextual input form appears allowing for quick changes to the url field.
             * <br>
             * For information on creating context forms, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/contextform/">
             * UI Components - Context forms</a>.
             *
             * @method addContextForm
             * @param {String} name Unique name identifying the new contextual form item.
             * @param {Toolbar.ContextFormSpec} obj the context form configuration object.
             */
            addContextForm: bridge.addContextForm,
            /**
             * Registers a new context menu section that only appears when a content predicate is matched,
             * for example, the cursor is inside a table.
             * <br>
             * For information on creating context menus, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/contextmenu/">
             * UI Components - Context Menu</a>.
             *
             * @method addContextMenu
             * @param {String} name Unique name identifying the new context menu.
             * @param {Menu.ContextMenuSpec} obj The context menu configuration object.
             */
            addContextMenu: bridge.addContextMenu,
            /**
             * Registers a new context toolbar that only appears when a content predicate is matched for example
             * the cursor is on an image element.
             * <br>
             * For information on creating context toolbars, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/contexttoolbar/">
             * UI Components - Context Toolbar</a>.
             *
             * @method addContextToolbar
             * @param {String} name Unique name identifying the new context toolbar.
             * @param {Toolbar.ContextToolbarSpec} obj The context menu configuration object.
             */
            addContextToolbar: bridge.addContextToolbar,
            /**
             * Registers a new SVG icon. The icon name reference can be configured by any
             * TinyMCE UI components that can display an icon. The icon is only available
             * to the editor instance it was configured for.
             *
             * @method addIcon
             * @param {String} name Unique name identifying the new icon.
             * @param {String} svgData The SVG data string the browser will use to render the SVG icon.
             * @example
             * //To add a simple triangle icon:
             * editor.ui.registry.addIcon('triangleUp', '<svg height="24" width="24"><path d="M12 0 L24 24 L0 24 Z" /></svg>');
             */
            addIcon: bridge.addIcon,
            /**
             * Registers a new menu button. Adds a toolbar button that opens a menu when
             * clicked. The menu can be populated by items created by addMenuItem,
             * addNestedMenuItem or addToggleMenuItem.
             * <br>
             * For information on creating a toolbar menu button, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-menu-toolbar-button/">
             * UI Components - Types of toolbar buttons: Menu button</a>.
             *
             * @method addMenuButton
             * @param {String} name Unique name identifying the new menu button.
             * @param {Toolbar.ToolbarMenuButtonSpec} obj The menu button configuration object.
             */
            addMenuButton: bridge.addMenuButton,
            /**
             * Registers a new menu item that executes a command when clicked or activated
             * via keyboard navigation controls.
             * <br>
             * For information on creating a basic menu item, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/creating-custom-menu-items/">
             * UI Components - Custom menu items: Basic menu items</a>.
             *
             * @method addMenuItem
             * @param {String} name Unique name identifying the new menu item.
             * @param {Menu.MenuItemSpec} obj The menu item configuration object.
             */
            addMenuItem: bridge.addMenuItem,
            /**
             * Registers a new menu item that reveals a submenu when clicked or activated
             * by keyboard navigation controls.The submenu can be populated by items
             * created by addMenuItem, addNestedMenuItem or addToggleMenuItem.
             * <br>
             * For information on creating a nested menu item, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-nested-menu-items/">
             * UI Components - Custom menu items: Nested menu items</a>.
             *
             * @method addNestedMenuItem
             * @param {String} name Unique name identifying the new nested menu item.
             * @param {Menu.NestedMenuItemSpec} obj The nested menu item configuration object.
             */
            addNestedMenuItem: bridge.addNestedMenuItem,
            /**
             * Registers a new sidebar container.
             * This sidebar container is attached to the right side of the editor and
             * can be toggled open or closed. When registered, a new toolbar toggle
             * button with the same sidebar name is created. Additionally there is a
             * ToggleSidebar command and a 'ToggleSidebar' event that can used to
             * manage the sidebar open/closed state. The tinycomments plugin uses a
             * sidebar for its Ui components.
             * <br>
             * For information on creating a custom sidebar, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/customsidebar/">
             * UI Components - Custom sidebar</a>.
             *
             * @method addSidebar
             * @param {String} name Unique name identifying the new sidebar.
             * @param {Sidebar.SidebarSpec} obj The sidebar configuration object.
             */
            addSidebar: bridge.addSidebar,
            /**
             * Registers a new split button for the toolbar. The list styles plugin uses
             * a split button to simplify its functionality.
             * <br>
             * For information on creating a split toolbar button, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-split-toolbar-button/">
             * UI Components - Types of toolbar buttons: Split button</a>.
             *
             * @method addSplitButton
             * @param {String} name Unique name identifying the new split button.
             * @param {Toolbar.ToolbarSplitButtonSpec} obj The split button configuration object.
             */
            addSplitButton: bridge.addSplitButton,
            /**
             * Registers a new toggle button for the toolbar. A toggle buttons state can
             * be set in the configuration.
             * <br>
             * For information on creating a toggle toolbar button, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-toggle-toolbar-button/">
             * UI Components - Types of toolbar buttons: Toggle button</a>.
             *
             * @method addToggleButton
             * @param {String} name Unique name identifying the new split button.
             * @param {Toolbar.ToolbarToggleButtonSpec} obj The toggle button configuration object.
             */
            addToggleButton: bridge.addToggleButton,
            /**
             * Registers a new group toolbar button for the toolbar. Renders a toolbar button that opens a floating toolbar when
             * clicked.
             * <br>
             * <strong>Note:</strong> Group toolbar buttons can only be used when using the floating toolbar mode.
             * <br>
             * For information on creating a group toolbar button, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-group-toolbar-button/">
             * UI Components - Types of toolbar buttons: Group toolbar button</a>.
             *
             * @method addGroupToolbarButton
             * @param {String} name Unique name identifying the new group toolbar button.
             * @param {Toolbar.GroupToolbarButtonSpec} obj The group toolbar button configuration object.
             */
            addGroupToolbarButton: bridge.addGroupToolbarButton,
            /**
             * Registers a new menu item that will act like a toggle button,
             * showing a tick in the menu item to represent state.
             * <br>
             * For information on creating a toggle menu item, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-toggle-menu-items/">
             * UI Components - Custom menu items: Toggle menu items</a>.
             *
             * @method addToggleMenuItem
             * @param {String} name Unique name identifying the new menu item.
             * @param {Menu.ToggleMenuItemSpec} obj The menu item configuration object.
             */
            addToggleMenuItem: bridge.addToggleMenuItem,
            /**
             * Registers a new view container.
             * This view container is hidden (off) by default and attached next to the main view.
             * It can be toggled on or off.
             * When it is on, the main editor view is hidden and the specific view is shown.
             * When it is off, the specific view is hidden and the main view is shown.
             * There is also a ToggleView command.
             * The ToggleView command can toggle the view visibility.
             * The ToggleView command can be queried for its current state.
             * <br>
             * For information on creating a custom view, see:
             * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-view/">
             * UI Components - Custom view</a>.
             *
             * @method addView
             * @param {String} name Unique name identifying the new view.
             * @param {View.ViewSpec} obj The view configuration object.
             */
            addView: bridge.addView,
            /**
             * Registers a new context configuration in the registry.
             * The registry stores all context configurations.
             * The buttons in editor configuration object can contain a context property.
             * These button specifications can use the registered contexts to determine
             * whether to enable or disable the buttons based on the current context.
             *
             * @method addContext
             * @param {String} name Unique name identifying the new context configuration.
             * @param {Function} pred A predicate function that determines if the context is active
             */
            addContext: bridge.addContext,
            /* note getAll is an internal method and may not be supported in future revisions */
            getAll: bridge.getAll
        };
    };

    // Shorten these names
    const DOM$1 = DOMUtils.DOM;
    const extend = Tools.extend, each$1 = Tools.each;
    /**
     * Include Editor API docs.
     *
     * @include ../../../../../tools/docs/tinymce.Editor.js
     */
    class Editor {
        /**
         * Constructs a editor instance by id.
         *
         * @constructor
         * @method Editor
         * @param {String} id Unique id for the editor.
         * @param {Object} options Options for the editor.
         * @param {tinymce.EditorManager} editorManager EditorManager instance.
         */
        constructor(id, options, editorManager) {
            /**
             * Name/Value object containing plugin instances.
             *
             * @property plugins
             * @type Object
             * @example
             * // Execute a method inside a plugin directly
             * tinymce.activeEditor.plugins.someplugin.someMethod();
             */
            this.plugins = {};
            /**
             * Array with CSS files to load into the iframe.
             *
             * @property contentCSS
             * @type Array
             */
            this.contentCSS = [];
            /**
             * Array of CSS styles to add to head of document when the editor loads.
             *
             * @property contentStyles
             * @type Array
             */
            this.contentStyles = [];
            this.loadedCSS = {};
            this.isNotDirty = false;
            this.composing = false;
            this.destroyed = false;
            this.hasHiddenInput = false;
            this.iframeElement = null;
            this.initialized = false;
            this.readonly = false;
            this.removed = false;
            this.startContent = '';
            this._pendingNativeEvents = [];
            this._skinLoaded = false;
            this._editableRoot = true;
            this.editorManager = editorManager;
            // Patch in the EditorObservable functions
            extend(this, EditorObservable);
            const self = this;
            this.id = id;
            this.editorUid = uuidV4();
            this.hidden = false;
            const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);
            this.options = create$4(self, normalizedOptions, options);
            register$7(self);
            this.userLookup = createUserLookup(this);
            const getOption = this.options.get;
            if (getOption('deprecation_warnings')) {
                logWarnings(options, normalizedOptions);
            }
            const suffix = getOption('suffix');
            if (suffix) {
                editorManager.suffix = suffix;
            }
            this.suffix = editorManager.suffix;
            const baseUrl = getOption('base_url');
            if (baseUrl) {
                editorManager._setBaseUrl(baseUrl);
            }
            this.baseUri = editorManager.baseURI;
            const referrerPolicy = getReferrerPolicy(self);
            if (referrerPolicy) {
                ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);
                DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);
            }
            ScriptLoader.ScriptLoader._setCrossOrigin((url) => {
                const crossOrigin = getCrossOrigin(self);
                return crossOrigin(url, 'script');
            });
            DOMUtils.DOM.styleSheetLoader._setCrossOrigin((url) => {
                const crossOrigin = getCrossOrigin(self);
                return crossOrigin(url, 'stylesheet');
            });
            const contentCssCors = hasContentCssCors(self);
            if (isNonNullable(contentCssCors)) {
                DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);
            }
            AddOnManager.languageLoad = getOption('language_load');
            AddOnManager.baseURL = editorManager.baseURL;
            this.setDirty(false);
            this.documentBaseURI = new URI(getDocumentBaseUrl(self), {
                base_uri: this.baseUri
            });
            this.baseURI = this.baseUri;
            this.inline = isInline$2(self);
            this.hasVisual = isVisualAidsEnabled(self);
            this.shortcuts = new Shortcuts(this);
            this.editorCommands = new EditorCommands(this);
            registerCommands(this);
            const cacheSuffix = getOption('cache_suffix');
            if (cacheSuffix) {
                Env.cacheSuffix = cacheSuffix.replace(/^[\?\&]+/, '');
            }
            this.ui = {
                registry: registry(),
                styleSheetLoader: undefined,
                show: noop,
                hide: noop,
                setEnabled: noop,
                isEnabled: always
            };
            this.mode = create$3(self);
            // Lock certain properties to reduce misuse
            Object.defineProperty(this, 'editorUid', {
                writable: false,
                configurable: false,
                enumerable: true,
            });
            // Call setup
            editorManager.dispatch('SetupEditor', { editor: this });
            const setupCallback = getSetupCallback(self);
            if (isFunction(setupCallback)) {
                setupCallback.call(self, self);
            }
        }
        /**
         * Renders the editor/adds it to the page.
         *
         * @method render
         */
        render() {
            render(this);
        }
        /**
         * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection
         * it will also place DOM focus inside the editor.
         *
         * @method focus
         * @param {Boolean} skipFocus Skip DOM focus. Just set is as the active editor.
         */
        focus(skipFocus) {
            this.execCommand('mceFocus', false, skipFocus);
        }
        /**
         * Returns true/false if the editor has real keyboard focus.
         *
         * @method hasFocus
         * @return {Boolean} Current focus state of the editor.
         */
        hasFocus() {
            return hasFocus(this);
        }
        /**
         * Translates the specified string by replacing variables with language pack items it will also check if there is
         * a key matching the input.
         *
         * @method translate
         * @param {String} text String to translate by the language pack data.
         * @return {String} Translated string.
         */
        translate(text) {
            return I18n.translate(text);
        }
        getParam(name, defaultVal, type) {
            const options = this.options;
            // To keep the legacy API we need to register the option if it's not already been registered
            if (!options.isRegistered(name)) {
                if (isNonNullable(type)) {
                    options.register(name, { processor: type, default: defaultVal });
                }
                else {
                    options.register(name, { processor: always, default: defaultVal });
                }
            }
            // Attempt to use the passed default value if nothing has been set already
            return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);
        }
        /**
         * Checks that the plugin is in the editor configuration and can optionally check if the plugin has been loaded.
         *
         * @method hasPlugin
         * @param {String} name The name of the plugin, as specified for the TinyMCE `plugins` option.
         * @param {Boolean} loaded If `true`, will also check that the plugin has been loaded.
         * @return {Boolean} If `loaded` is `true`, returns `true` if the plugin is in the configuration and has been loaded. If `loaded` is `false`, returns `true` if the plugin is in the configuration, regardless of plugin load status.
         * @example
         * // Returns `true` if the Comments plugin is in the editor configuration and has loaded successfully:
         * tinymce.activeEditor.hasPlugin('tinycomments', true);
         * // Returns `true` if the Table plugin is in the editor configuration, regardless of whether or not it loads:
         * tinymce.activeEditor.hasPlugin('table');
         */
        hasPlugin(name, loaded) {
            const hasPlugin = contains$2(getPlugins(this), name);
            if (hasPlugin) {
                return loaded ? PluginManager.get(name) !== undefined : true;
            }
            else {
                return false;
            }
        }
        /**
         * Dispatches out a onNodeChange event to all observers. This method should be called when you
         * need to update the UI states or element path etc.
         *
         * @method nodeChanged
         * @param {Object} args Optional args to pass to NodeChange event handlers.
         */
        nodeChanged(args) {
            this._nodeChangeDispatcher.nodeChanged(args);
        }
        addCommand(name, callback, scope) {
            /**
             * Callback function that gets called when a command is executed.
             *
             * @callback addCommandCallback
             * @param {Boolean} ui Display UI state true/false.
             * @param {Object} value Optional value for command.
             * @return {Boolean} True/false state if the command was handled or not.
             */
            this.editorCommands.addCommand(name, callback, scope);
        }
        addQueryStateHandler(name, callback, scope) {
            /**
             * Callback function that gets called when a queryCommandState is executed.
             *
             * @callback addQueryStateHandlerCallback
             * @return {Boolean} True/false state if the command is enabled or not like is it bold.
             */
            this.editorCommands.addQueryStateHandler(name, callback, scope);
        }
        addQueryValueHandler(name, callback, scope) {
            /**
             * Callback function that gets called when a queryCommandValue is executed.
             *
             * @callback addQueryValueHandlerCallback
             * @return {Object} Value of the command or undefined.
             */
            this.editorCommands.addQueryValueHandler(name, callback, scope);
        }
        /**
         * Adds a keyboard shortcut for some command or function.
         *
         * @method addShortcut
         * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
         * @param {String} desc Text description for the command.
         * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
         * @param {Object} scope Optional scope to execute the function in.
         * @return {Boolean} true/false state if the shortcut was added or not.
         * @example
         * editor.addShortcut('ctrl+a', 'description of the shortcut', () => {});
         * editor.addShortcut('ctrl+alt+a', 'description of the shortcut', () => {});
         * // "meta" maps to Command on Mac and Ctrl on PC
         * editor.addShortcut('meta+a', 'description of the shortcut', () => {});
         * // "access" maps to Control+Option on Mac and shift+alt on PC
         * editor.addShortcut('access+a', 'description of the shortcut', () => {});
         *
         * editor.addShortcut('meta+access+c', 'Opens the code editor dialog.', () => {
         *   editor.execCommand('mceCodeEditor');
         * });
         *
         * editor.addShortcut('meta+shift+32', 'Inserts "Hello, World!" for meta+shift+space', () => {
         *   editor.execCommand('mceInsertContent', false, 'Hello, World!');
         * });
         */
        addShortcut(pattern, desc, cmdFunc, scope) {
            this.shortcuts.add(pattern, desc, cmdFunc, scope);
        }
        /**
         * Executes a registered command on the current instance. A list of available commands can be found in
         * the tinymce command identifiers documentation.
         *
         * @method execCommand
         * @param {String} cmd Command name to execute, for example mceLink or Bold.
         * @param {Boolean} ui Specifies if a UI (dialog) should be presented or not.
         * @param {Object/Array/String/Number/Boolean} value Optional command value, this can be anything.
         * @param {Object} args Optional arguments object.
         * @return {Boolean} true or false if the command was supported or not.
         */
        execCommand(cmd, ui, value, args) {
            return this.editorCommands.execCommand(cmd, ui, value, args);
        }
        /**
         * Returns a command specific state, for example if bold is enabled or not.
         *
         * @method queryCommandState
         * @param {String} cmd Command to query state from.
         * @return {Boolean} Command specific state, for example if bold is enabled or not.
         */
        queryCommandState(cmd) {
            return this.editorCommands.queryCommandState(cmd);
        }
        /**
         * Returns a command specific value, for example the current font size.
         *
         * @method queryCommandValue
         * @param {String} cmd Command to query value from.
         * @return {String} Command value, for example the current font size or an empty string (`""`) if the query command is not found.
         */
        queryCommandValue(cmd) {
            return this.editorCommands.queryCommandValue(cmd);
        }
        /**
         * Returns true/false if the command is supported or not.
         *
         * @method queryCommandSupported
         * @param {String} cmd Command that we check support for.
         * @return {Boolean} true/false if the command is supported or not.
         */
        queryCommandSupported(cmd) {
            return this.editorCommands.queryCommandSupported(cmd);
        }
        /**
         * Shows the editor and hides any textarea/div that the editor is supposed to replace.
         *
         * @method show
         */
        show() {
            const self = this;
            if (self.hidden) {
                self.hidden = false;
                if (self.inline) {
                    self.getBody().contentEditable = 'true';
                }
                else {
                    DOM$1.show(self.getContainer());
                    DOM$1.hide(self.id);
                }
                self.load();
                self.dispatch('show');
            }
        }
        /**
         * Hides the editor and shows any textarea/div that the editor is supposed to replace.
         *
         * @method hide
         */
        hide() {
            const self = this;
            if (!self.hidden) {
                // We must save before we hide so Safari doesn't crash
                self.save();
                if (self.inline) {
                    self.getBody().contentEditable = 'false';
                    // Make sure the editor gets blurred
                    if (self === self.editorManager.focusedEditor) {
                        self.editorManager.focusedEditor = null;
                    }
                }
                else {
                    DOM$1.hide(self.getContainer());
                    DOM$1.setStyle(self.id, 'display', self.orgDisplay);
                }
                self.hidden = true;
                self.dispatch('hide');
            }
        }
        /**
         * Returns true/false if the editor is hidden or not.
         *
         * @method isHidden
         * @return {Boolean} True/false if the editor is hidden or not.
         */
        isHidden() {
            return this.hidden;
        }
        /**
         * Sets the progress state, this will display a throbber/progess for the editor.
         * This is ideal for asynchronous operations like an AJAX save call.
         *
         * @method setProgressState
         * @param {Boolean} state Boolean state if the progress should be shown or hidden.
         * @param {Number} time Optional time to wait before the progress gets shown.
         * @return {Boolean} Same as the input state.
         * @example
         * // Show progress for the active editor
         * tinymce.activeEditor.setProgressState(true);
         *
         * // Hide progress for the active editor
         * tinymce.activeEditor.setProgressState(false);
         *
         * // Show progress after 3 seconds
         * tinymce.activeEditor.setProgressState(true, 3000);
         */
        setProgressState(state, time) {
            this.dispatch('ProgressState', { state, time });
        }
        /**
         * Loads contents from the textarea, input or other element that got converted into an editor instance.
         * This method will move the contents from that textarea, input or other element into the editor by using setContent
         * so all events etc that method has will get dispatched as well.
         *
         * @method load
         * @param {Object} args Optional content object, this gets passed around through the whole load process.
         */
        load(args = {}) {
            const self = this;
            const elm = self.getElement();
            if (self.removed) {
                return;
            }
            if (elm) {
                const loadArgs = {
                    ...args,
                    load: true
                };
                const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
                self.setContent(value, loadArgs);
                if (!loadArgs.no_events) {
                    self.dispatch('LoadContent', {
                        ...loadArgs,
                        element: elm
                    });
                }
            }
        }
        /**
         * Saves the contents from an editor out to the textarea or div element that got converted into an editor instance.
         * This method will move the HTML contents from the editor into that textarea or div by getContent
         * so all events etc that method has will get dispatched as well.
         *
         * @method save
         * @param {Object} args Optional content object, this gets passed around through the whole save process.
         * @return {String} HTML string that got set into the textarea/div.
         */
        save(args = {}) {
            const self = this;
            let elm = self.getElement();
            if (!elm || !self.initialized || self.removed) {
                return '';
            }
            const getArgs = {
                ...args,
                save: true,
                element: elm
            };
            let html = self.getContent(getArgs);
            const saveArgs = { ...getArgs, content: html };
            if (!saveArgs.no_events) {
                self.dispatch('SaveContent', saveArgs);
            }
            // Always run this internal event
            if (saveArgs.format === 'raw') {
                self.dispatch('RawSaveContent', saveArgs);
            }
            html = saveArgs.content;
            if (!isTextareaOrInput(elm)) {
                if (args.is_removing || !self.inline) {
                    elm.innerHTML = html;
                }
                // Update hidden form element
                const form = DOM$1.getParent(self.id, 'form');
                if (form) {
                    each$1(form.elements, (elm) => {
                        if (elm.name === self.id) {
                            elm.value = html;
                            return false;
                        }
                        else {
                            return true;
                        }
                    });
                }
            }
            else {
                elm.value = html;
            }
            saveArgs.element = getArgs.element = elm = null;
            if (saveArgs.set_dirty !== false) {
                self.setDirty(false);
            }
            return html;
        }
        setContent(content, args) {
            setContent(this, content, args);
        }
        getContent(args) {
            return getContent(this, args);
        }
        /**
         * Inserts content at caret position.
         *
         * @method insertContent
         * @param {String} content Content to insert.
         * @param {Object} args Optional args to pass to insert call.
         */
        insertContent(content, args) {
            if (args) {
                content = extend({ content }, args);
            }
            this.execCommand('mceInsertContent', false, content);
        }
        /**
         * Resets the editors content, undo/redo history and dirty state. If `initialContent` isn't specified, then
         * the editor is reset back to the initial start content.
         *
         * @method resetContent
         * @param {String} initialContent An optional string to use as the initial content of the editor.
         */
        resetContent(initialContent) {
            // Set the editor content
            if (initialContent === undefined) {
                // editor.startContent is generated by using the `raw` format, so we should set it the same way
                setContent(this, this.startContent, { initial: true, format: 'raw' });
            }
            else {
                setContent(this, initialContent, { initial: true });
            }
            // Update the editor/undo manager state
            this.undoManager.reset();
            this.setDirty(false);
            // Fire a node change event
            this.nodeChanged();
        }
        /**
         * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
         *
         * The dirty state is automatically set to `true` when the user modifies editor content after initialization or the
         * last `editor.save()` call. This includes changes made using undo or redo.
         *
         * @method isDirty
         * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
         * @example
         * if (tinymce.activeEditor.isDirty()) {
         *   alert("You must save your contents.");
         * }
         */
        isDirty() {
            return !this.isNotDirty;
        }
        /**
         * Explicitly sets the dirty state. This will fire the dirty event if the editor dirty state is changed from false to true
         * by invoking this method.
         *
         * @method setDirty
         * @param {Boolean} state True/false if the editor is considered dirty.
         * @example
         * const ajaxSave = () => {
         *   const editor = tinymce.get('elm1');
         *
         *   // Save contents using some XHR call
         *   alert(editor.getContent());
         *
         *   editor.setDirty(false); // Force not dirty state
         * }
         */
        setDirty(state) {
            const oldState = !this.isNotDirty;
            this.isNotDirty = !state;
            if (state && state !== oldState) {
                this.dispatch('dirty');
            }
        }
        /**
         * Returns the container element of the editor. The container element includes
         * all the elements added to the page for the editor. Such as UI, iframe, etc.
         *
         * @method getContainer
         * @return {Element} HTML DOM element for the editor container.
         */
        getContainer() {
            const self = this;
            if (!self.container) {
                self.container = self.editorContainer || DOM$1.get(self.id + '_parent');
            }
            return self.container;
        }
        /**
         * Returns the content area container element of the editor. This element
         * holds the iframe or the editable element.
         *
         * @method getContentAreaContainer
         * @return {Element} HTML DOM element for the editor area container.
         */
        getContentAreaContainer() {
            return this.contentAreaContainer;
        }
        /**
         * Returns the target element/textarea that got replaced with a TinyMCE editor instance.
         *
         * @method getElement
         * @return {Element} HTML DOM element for the replaced element.
         */
        getElement() {
            if (!this.targetElm) {
                this.targetElm = DOM$1.get(this.id);
            }
            return this.targetElm;
        }
        /**
         * Returns the iframes window object.
         *
         * @method getWin
         * @return {Window} Iframe DOM window object.
         */
        getWin() {
            const self = this;
            if (!self.contentWindow) {
                const elm = self.iframeElement;
                if (elm) {
                    self.contentWindow = elm.contentWindow;
                }
            }
            return self.contentWindow;
        }
        /**
         * Returns the iframes document object.
         *
         * @method getDoc
         * @return {Document} Iframe DOM document object.
         */
        getDoc() {
            const self = this;
            if (!self.contentDocument) {
                const win = self.getWin();
                if (win) {
                    self.contentDocument = win.document;
                }
            }
            return self.contentDocument;
        }
        /**
         * Returns the root element of the editable area.
         * For a non-inline iframe-based editor, returns the iframe's body element.
         *
         * @method getBody
         * @return {Element} The root element of the editable area.
         */
        getBody() {
            var _a, _b;
            const doc = this.getDoc();
            return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;
        }
        /**
         * URL converter function this gets executed each time a user adds an img, a or
         * any other element that has a URL in it. This will be called both by the DOM and HTML
         * manipulation functions.
         *
         * @method convertURL
         * @param {String} url URL to convert.
         * @param {String} name Attribute name src, href etc.
         * @param {String/HTMLElement} elm Tag name or HTML DOM element depending on HTML or DOM insert.
         * @return {String} Converted URL string.
         */
        convertURL(url, name, elm) {
            const self = this, getOption = self.options.get;
            // Use callback instead
            const urlConverterCallback = getUrlConverterCallback(self);
            if (isFunction(urlConverterCallback)) {
                return urlConverterCallback.call(self, url, elm, true, name);
            }
            // Don't convert link href since that's the CSS files that gets loaded into the editor also skip local file URLs
            if (!getOption('convert_urls') ||
                elm === 'link' ||
                (isObject(elm) && elm.nodeName === 'LINK') ||
                url.indexOf('file:') === 0 ||
                url.length === 0) {
                return url;
            }
            const urlObject = new URI(url);
            if (urlObject.protocol !== 'http' && urlObject.protocol !== 'https' && urlObject.protocol !== '') {
                return url;
            }
            // Convert to relative
            if (getOption('relative_urls')) {
                return self.documentBaseURI.toRelative(url);
            }
            // Convert to absolute
            url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));
            return url;
        }
        /**
         * Adds visual aids for tables, anchors, etc so they can be more easily edited inside the editor.
         *
         * @method addVisual
         * @param {Element} elm Optional root element to loop though to find tables, etc that needs the visual aid.
         */
        addVisual(elm) {
            addVisual(this, elm);
        }
        /**
         * Changes the editable state of the editor's root element.
         *
         * @method setEditableRoot
         * @param {Boolean} state State to set true for editable and false for non-editable.
         */
        setEditableRoot(state) {
            setEditableRoot(this, state);
        }
        /**
         * Returns the current editable state of the editor's root element.
         *
         * @method hasEditableRoot
         * @return {Boolean} True if the root element is editable, false if it is not editable.
         */
        hasEditableRoot() {
            return hasEditableRoot(this);
        }
        /**
         * Removes the editor from the dom and tinymce collection.
         *
         * @method remove
         */
        remove() {
            remove$1(this);
        }
        /**
         * Destroys the editor instance by removing all events, element references or other resources
         * that could leak memory. This method will be called automatically when the page is unloaded
         * but you can also call it directly if you know what you are doing.
         *
         * @method destroy
         * @param {Boolean} automatic Optional state if the destroy is an automatic destroy or user called one.
         */
        destroy(automatic) {
            destroy(this, automatic);
        }
        /**
         * Uploads all data uri/blob uri images in the editor contents to server.
         *
         * @method uploadImages
         * @return {Promise} Promise instance with images and status for each image.
         */
        uploadImages() {
            return this.editorUpload.uploadImages();
        }
        // Internal functions
        _scanForImages() {
            return this.editorUpload.scanForImages();
        }
    }

    const DOM = DOMUtils.DOM;
    const each = Tools.each;
    let boundGlobalEvents = false;
    let beforeUnloadDelegate;
    let editors = [];
    const globalEventDelegate = (e) => {
        const type = e.type;
        each(EditorManager.get(), (editor) => {
            switch (type) {
                case 'scroll':
                    editor.dispatch('ScrollWindow', e);
                    break;
                case 'resize':
                    editor.dispatch('ResizeWindow', e);
                    break;
            }
        });
    };
    const toggleGlobalEvents = (state) => {
        if (state !== boundGlobalEvents) {
            const DOM = DOMUtils.DOM;
            if (state) {
                DOM.bind(window, 'resize', globalEventDelegate);
                DOM.bind(window, 'scroll', globalEventDelegate);
            }
            else {
                DOM.unbind(window, 'resize', globalEventDelegate);
                DOM.unbind(window, 'scroll', globalEventDelegate);
            }
            boundGlobalEvents = state;
        }
    };
    const removeEditorFromList = (targetEditor) => {
        const oldEditors = editors;
        editors = filter$5(editors, (editor) => {
            return targetEditor !== editor;
        });
        // Select another editor since the active one was removed
        if (EditorManager.activeEditor === targetEditor) {
            EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
        }
        // Clear focusedEditor if necessary, so that we don't try to blur the destroyed editor
        if (EditorManager.focusedEditor === targetEditor) {
            EditorManager.focusedEditor = null;
        }
        return oldEditors.length !== editors.length;
    };
    const purgeDestroyedEditor = (editor) => {
        // User has manually destroyed the editor lets clean up the mess
        if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
            removeEditorFromList(editor);
            editor.unbindAllNativeEvents();
            editor.destroy(true);
            editor.removed = true;
        }
    };
    const isQuirksMode = document.compatMode !== 'CSS1Compat';
    const EditorManager = {
        ...Observable,
        baseURI: null,
        baseURL: null,
        /**
         * Object containing the options that will be passed by default to the <code>init</code> method upon each initialization of an editor. These defaults will be shallow merged with other options passed to <code>init</code>.
         *
         * @property defaultOptions
         * @type Object
         */
        defaultOptions: {},
        documentBaseURL: null,
        suffix: null,
        /**
         * A uuid string to anonymously identify the page tinymce is loaded in
         *
         * @property pageUid
         * @type String
         */
        pageUid: uuidV4(),
        /**
         * Major version of TinyMCE build.
         *
         * @property majorVersion
         * @type String
         */
        majorVersion: '8',
        /**
         * Minor version of TinyMCE build.
         *
         * @property minorVersion
         * @type String
         */
        minorVersion: '0.2',
        /**
         * Release date of TinyMCE build.
         *
         * @property releaseDate
         * @type String
         */
        releaseDate: '2025-08-14',
        /**
         * Collection of language pack data.
         *
         * @property i18n
         * @type Object
         */
        i18n: I18n,
        /**
         * Currently active editor instance.
         *
         * @property activeEditor
         * @type tinymce.Editor
         * @example
         * tinyMCE.activeEditor.selection.getContent();
         * tinymce.EditorManager.activeEditor.selection.getContent();
         */
        activeEditor: null,
        focusedEditor: null,
        setup() {
            const self = this;
            let baseURL = '';
            let suffix = '';
            // Get base URL for the current document
            let documentBaseURL = URI.getDocumentBaseUrl(document.location);
            // Check if the URL is a document based format like: http://site/dir/file and file:///
            // leave other formats like applewebdata://... intact
            if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
                documentBaseURL = documentBaseURL.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
                if (!/[\/\\]$/.test(documentBaseURL)) {
                    documentBaseURL += '/';
                }
            }
            // If tinymce is defined and has a base use that or use the old tinyMCEPreInit
            const preInit = window.tinymce || window.tinyMCEPreInit;
            if (preInit) {
                baseURL = preInit.base || preInit.baseURL;
                suffix = preInit.suffix;
            }
            else {
                // Get base where the tinymce script is located
                const scripts = document.getElementsByTagName('script');
                for (let i = 0; i < scripts.length; i++) {
                    const src = scripts[i].src || '';
                    if (src === '') {
                        continue;
                    }
                    // Script types supported:
                    // tinymce.js tinymce.min.js tinymce.dev.js
                    // tinymce.jquery.js tinymce.jquery.min.js tinymce.jquery.dev.js
                    // tinymce.full.js tinymce.full.min.js tinymce.full.dev.js
                    const srcScript = src.substring(src.lastIndexOf('/'));
                    if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
                        if (srcScript.indexOf('.min') !== -1) {
                            suffix = '.min';
                        }
                        baseURL = src.substring(0, src.lastIndexOf('/'));
                        break;
                    }
                }
                // We didn't find any baseURL by looking at the script elements
                // Try to use the document.currentScript as a fallback
                if (!baseURL && document.currentScript) {
                    const src = document.currentScript.src;
                    if (src.indexOf('.min') !== -1) {
                        suffix = '.min';
                    }
                    baseURL = src.substring(0, src.lastIndexOf('/'));
                }
            }
            /**
             * Base URL where the root directory if TinyMCE is located.
             *
             * @property baseURL
             * @type String
             */
            self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
            /**
             * Document base URL where the current document is located.
             *
             * @property documentBaseURL
             * @type String
             */
            self.documentBaseURL = documentBaseURL;
            /**
             * Absolute baseURI for the installation path of TinyMCE.
             *
             * @property baseURI
             * @type tinymce.util.URI
             */
            self.baseURI = new URI(self.baseURL);
            /**
             * Current suffix to add to each plugin/theme that gets loaded for example ".min".
             *
             * @property suffix
             * @type String
             */
            self.suffix = suffix;
            setup$C(self);
            // Lock certain properties to reduce misuse
            each$e(['majorVersion', 'minorVersion', 'releaseDate', 'pageUid', '_addLicenseKeyManager'], (property) => Object.defineProperty(self, property, {
                writable: false,
                configurable: false,
                enumerable: true,
            }));
        },
        /**
         * Overrides the default options for editor instances. The <code>overrideDefaults</code> method replaces the <code>defaultOptions</code>, including any set by a previous call to the <code>overrideDefaults</code> method.
         * <br /><br />
         * When using the Tiny Cloud, some of these defaults are required for the cloud-based editor to function.
         * <br /><br />
         * Therefore, when using <code>overrideDefaults</code> with the cloud-based editor, any newly integrated options must be combined with the options in <code>tinymce.defaultOptions</code>.
         *
         * @method overrideDefaults
         * @param {Object} defaultOptions Default options object.
         * @example
         * const customOptions = {
         *   toolbar_sticky: true
         * };
         *
         * tinymce.overrideDefaults({
         *   ...tinymce.defaultOptions,
         *   ...customOptions
         * });
         */
        overrideDefaults(defaultOptions) {
            const baseUrl = defaultOptions.base_url;
            if (baseUrl) {
                this._setBaseUrl(baseUrl);
            }
            const suffix = defaultOptions.suffix;
            if (suffix) {
                this.suffix = suffix;
            }
            this.defaultOptions = defaultOptions;
            const pluginBaseUrls = defaultOptions.plugin_base_urls;
            if (pluginBaseUrls !== undefined) {
                each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {
                    AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
                });
            }
        },
        /**
         * Initializes a set of editors. This method will create editors based on various settings.
         * <br /><br />
         * For information on basic usage of <code>init</code>, see: <a href="https://www.tiny.cloud/docs/tinymce/8/basic-setup/">Basic setup</a>.
         *
         * @method init
         * @param {Object} options Options object to be passed to each editor instance.
         * @return {Promise} Promise that gets resolved with an array of editors when all editor instances are initialized.
         * @example
         * // Initializes a editor using the longer method
         * tinymce.EditorManager.init({
         *    some_settings : 'some value'
         * });
         *
         * // Initializes a editor instance using the shorter version and with a promise
         * tinymce.init({
         *   some_settings : 'some value'
         * }).then((editors) => {
         *   ...
         * });
         */
        init(options) {
            const self = this;
            let result;
            const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' +
                'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');
            const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
            const createId = (elm) => {
                let id = elm.id;
                if (!id) {
                    id = get$a(elm, 'name').filter((name) => !DOM.get(name)).getOrThunk(DOM.uniqueId);
                    elm.setAttribute('id', id);
                }
                return id;
            };
            const execCallback = (name) => {
                const callback = options[name];
                if (!callback) {
                    return;
                }
                return callback.apply(self, []);
            };
            const findTargets = (options) => {
                if (Env.browser.isIE() || Env.browser.isEdge()) {
                    initError('TinyMCE does not support the browser you are using. For a list of supported' +
                        ' browsers please see: https://www.tiny.cloud/docs/tinymce/8/support/#supportedwebbrowsers');
                    return [];
                }
                else if (isQuirksMode) {
                    initError('Failed to initialize the editor as the document is not in standards mode. ' +
                        'TinyMCE requires standards mode.');
                    return [];
                }
                else if (isString(options.selector)) {
                    return DOM.select(options.selector);
                }
                else if (isNonNullable(options.target)) {
                    return [options.target];
                }
                else {
                    return [];
                }
            };
            let provideResults = (editors) => {
                result = editors;
            };
            const initEditors = () => {
                let initCount = 0;
                const editors = [];
                let targets;
                const createEditor = (id, options, targetElm) => {
                    const editor = new Editor(id, options, self);
                    editors.push(editor);
                    editor.on('init', () => {
                        if (++initCount === targets.length) {
                            provideResults(editors);
                        }
                    });
                    editor.targetElm = editor.targetElm || targetElm;
                    editor.render();
                };
                DOM.unbind(window, 'ready', initEditors);
                execCallback('onpageload');
                targets = unique$1(findTargets(options));
                Tools.each(targets, (elm) => {
                    purgeDestroyedEditor(self.get(elm.id));
                });
                targets = Tools.grep(targets, (elm) => {
                    return !self.get(elm.id);
                });
                if (targets.length === 0) {
                    provideResults([]);
                }
                else {
                    each(targets, (elm) => {
                        if (isInvalidInlineTarget(options, elm)) {
                            initError('Could not initialize inline editor on invalid inline target element', elm);
                        }
                        else {
                            createEditor(createId(elm), options, elm);
                        }
                    });
                }
            };
            DOM.bind(window, 'ready', initEditors);
            return new Promise((resolve) => {
                if (result) {
                    resolve(result);
                }
                else {
                    provideResults = (editors) => {
                        resolve(editors);
                    };
                }
            });
        },
        /**
         * Returns an editor instance for a given id.
         *
         * @method get
         * @param {String/Number} id The id or index of the editor instance to return.
         * @return {tinymce.Editor/Array} Editor instance or an array of editor instances.
         * @example
         * // Adds an onclick event to an editor by id
         * tinymce.get('mytextbox').on('click', (e) => {
         *   ed.windowManager.alert('Hello world!');
         * });
         *
         * // Adds an onclick event to an editor by index
         * tinymce.get(0).on('click', (e) => {
         *   ed.windowManager.alert('Hello world!');
         * });
         *
         * // Adds an onclick event to an editor by id (longer version)
         * tinymce.EditorManager.get('mytextbox').on('click', (e) => {
         *   ed.windowManager.alert('Hello world!');
         * });
         */
        get(id) {
            if (arguments.length === 0) {
                return editors.slice(0);
            }
            else if (isString(id)) {
                return find$2(editors, (editor) => {
                    return editor.id === id;
                }).getOr(null);
            }
            else if (isNumber(id)) {
                return editors[id] ? editors[id] : null;
            }
            else {
                return null;
            }
        },
        /**
         * Adds an editor instance to the editor collection. This will also set it as the active editor.
         *
         * @method add
         * @param {tinymce.Editor} editor Editor instance to add to the collection.
         * @return {tinymce.Editor} The same instance that got passed in.
         */
        add(editor) {
            const self = this;
            // Prevent existing editors from being added again this could happen
            // if a user calls createEditor then render or add multiple times.
            const existingEditor = self.get(editor.id);
            if (existingEditor === editor) {
                return editor;
            }
            if (existingEditor === null) {
                editors.push(editor);
            }
            toggleGlobalEvents(true);
            // Doesn't call setActive method since we don't want
            // to fire a bunch of activate/deactivate calls while initializing
            self.activeEditor = editor;
            self.dispatch('AddEditor', { editor });
            if (!beforeUnloadDelegate) {
                beforeUnloadDelegate = (e) => {
                    const event = self.dispatch('BeforeUnload');
                    if (event.returnValue) {
                        // browsers are all a little bit special about this: https://developer.mozilla.org/en-US/docs/Web/API/BeforeUnloadEvent
                        e.preventDefault();
                        e.returnValue = event.returnValue;
                        return event.returnValue;
                    }
                };
                window.addEventListener('beforeunload', beforeUnloadDelegate);
            }
            return editor;
        },
        /**
         * Creates an editor instance and adds it to the EditorManager collection.
         *
         * @method createEditor
         * @param {String} id Instance id to use for editor.
         * @param {Object} options Editor instance options.
         * @return {tinymce.Editor} Editor instance that got created.
         */
        createEditor(id, options) {
            return this.add(new Editor(id, options, this));
        },
        /**
         * Removes a editor or editors form page.
         *
         * @example
         * // Remove all editors bound to divs
         * tinymce.remove('div');
         *
         * // Remove all editors bound to textareas
         * tinymce.remove('textarea');
         *
         * // Remove all editors
         * tinymce.remove();
         *
         * // Remove specific instance by id
         * tinymce.remove('#id');
         *
         * @method remove
         * @param {tinymce.Editor/String/Object} [selector] CSS selector or editor instance to remove.
         * @return {tinymce.Editor} The editor that got passed in will be return if it was found otherwise null.
         */
        remove(selector) {
            const self = this;
            let editor;
            // Remove all editors
            if (!selector) {
                for (let i = editors.length - 1; i >= 0; i--) {
                    self.remove(editors[i]);
                }
                return;
            }
            // Remove editors by selector
            if (isString(selector)) {
                each(DOM.select(selector), (elm) => {
                    editor = self.get(elm.id);
                    if (editor) {
                        self.remove(editor);
                    }
                });
                return;
            }
            // Remove specific editor
            editor = selector;
            // Not in the collection
            if (isNull(self.get(editor.id))) {
                return null;
            }
            if (removeEditorFromList(editor)) {
                self.dispatch('RemoveEditor', { editor });
            }
            if (editors.length === 0) {
                window.removeEventListener('beforeunload', beforeUnloadDelegate);
            }
            editor.remove();
            toggleGlobalEvents(editors.length > 0);
            return editor;
        },
        /**
         * Executes a specific command on the currently active editor.
         *
         * @method execCommand
         * @param {String} cmd Command to perform for example Bold.
         * @param {Boolean} ui Optional boolean state if a UI should be presented for the command or not.
         * @param {Object/String/Number/Boolean} value Optional value parameter like for example an URL to a link.
         * @return {Boolean} true/false if the command was executed or not.
         */
        execCommand(cmd, ui, value) {
            var _a;
            const self = this;
            const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;
            // Manager commands
            switch (cmd) {
                case 'mceAddEditor': {
                    if (!self.get(editorId)) {
                        const editorOptions = value.options;
                        new Editor(editorId, editorOptions, self).render();
                    }
                    return true;
                }
                case 'mceRemoveEditor': {
                    const editor = self.get(editorId);
                    if (editor) {
                        editor.remove();
                    }
                    return true;
                }
                case 'mceToggleEditor': {
                    const editor = self.get(editorId);
                    if (!editor) {
                        self.execCommand('mceAddEditor', false, value);
                        return true;
                    }
                    if (editor.isHidden()) {
                        editor.show();
                    }
                    else {
                        editor.hide();
                    }
                    return true;
                }
            }
            // Run command on active editor
            if (self.activeEditor) {
                return self.activeEditor.execCommand(cmd, ui, value);
            }
            return false;
        },
        /**
         * Calls the save method on all editor instances in the collection. This can be useful when a form is to be submitted.
         *
         * @method triggerSave
         * @example
         * // Saves all contents
         * tinyMCE.triggerSave();
         */
        triggerSave: () => {
            each(editors, (editor) => {
                editor.save();
            });
        },
        /**
         * Adds a language pack, this gets called by the loaded language files like en.js.
         *
         * @method addI18n
         * @param {String} code Optional language code.
         * @param {Object} items Name/value object with translations.
         */
        addI18n: (code, items) => {
            I18n.add(code, items);
        },
        /**
         * Translates the specified string using the language pack items.
         *
         * @method translate
         * @param {String/Array/Object} text String to translate
         * @return {String} Translated string.
         */
        translate: (text) => {
            return I18n.translate(text);
        },
        /**
         * Sets the active editor instance and fires the deactivate/activate events.
         *
         * @method setActive
         * @param {tinymce.Editor} editor Editor instance to set as the active instance.
         */
        setActive(editor) {
            const activeEditor = this.activeEditor;
            if (this.activeEditor !== editor) {
                if (activeEditor) {
                    activeEditor.dispatch('deactivate', { relatedTarget: editor });
                }
                editor.dispatch('activate', { relatedTarget: activeEditor });
            }
            this.activeEditor = editor;
        },
        _setBaseUrl(baseUrl) {
            this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ''));
            this.baseURI = new URI(this.baseURL);
        },
        _addLicenseKeyManager: (addOn) => LicenseKeyManagerLoader.add(addOn),
    };
    EditorManager.setup();

    // The FakeClipboard has been designed to match the native Clipboard API as closely as possible
    const setup = () => {
        const dataValue = value$1();
        const FakeClipboardItem = (items) => ({
            items,
            types: keys(items),
            getType: (type) => get$a(items, type).getOrUndefined()
        });
        const write = (data) => {
            dataValue.set(data);
        };
        const read = () => dataValue.get().getOrUndefined();
        const clear = dataValue.clear;
        return {
            FakeClipboardItem,
            write,
            read,
            clear
        };
    };
    const FakeClipboard = setup();

    /**
     * Contains various tools for rect/position calculation.
     *
     * @class tinymce.geom.Rect
     */
    const min = Math.min, max = Math.max, round = Math.round;
    /**
     * Returns the rect positioned based on the relative position name
     * to the target rect.
     *
     * @method relativePosition
     * @param {Rect} rect Source rect to modify into a new rect.
     * @param {Rect} targetRect Rect to move relative to based on the rel option.
     * @param {String} rel Relative position. For example: tr-bl.
     */
    const relativePosition = (rect, targetRect, rel) => {
        let x = targetRect.x;
        let y = targetRect.y;
        const w = rect.w;
        const h = rect.h;
        const targetW = targetRect.w;
        const targetH = targetRect.h;
        const relChars = (rel || '').split('');
        if (relChars[0] === 'b') {
            y += targetH;
        }
        if (relChars[1] === 'r') {
            x += targetW;
        }
        if (relChars[0] === 'c') {
            y += round(targetH / 2);
        }
        if (relChars[1] === 'c') {
            x += round(targetW / 2);
        }
        if (relChars[3] === 'b') {
            y -= h;
        }
        if (relChars[4] === 'r') {
            x -= w;
        }
        if (relChars[3] === 'c') {
            y -= round(h / 2);
        }
        if (relChars[4] === 'c') {
            x -= round(w / 2);
        }
        return create$2(x, y, w, h);
    };
    /**
     * Tests various positions to get the most suitable one.
     *
     * @method findBestRelativePosition
     * @param {Rect} rect Rect to use as source.
     * @param {Rect} targetRect Rect to move relative to.
     * @param {Rect} constrainRect Rect to constrain within.
     * @param {Array} rels Array of relative positions to test against.
     */
    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {
        for (let i = 0; i < rels.length; i++) {
            const pos = relativePosition(rect, targetRect, rels[i]);
            if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x &&
                pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
                return rels[i];
            }
        }
        return null;
    };
    /**
     * Inflates the rect in all directions.
     *
     * @method inflate
     * @param {Rect} rect Rect to expand.
     * @param {Number} w Relative width to expand by.
     * @param {Number} h Relative height to expand by.
     * @return {Rect} New expanded rect.
     */
    const inflate = (rect, w, h) => {
        return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
    };
    /**
     * Returns the intersection of the specified rectangles.
     *
     * @method intersect
     * @param {Rect} rect The first rectangle to compare.
     * @param {Rect} cropRect The second rectangle to compare.
     * @return {Rect} The intersection of the two rectangles or null if they don't intersect.
     */
    const intersect = (rect, cropRect) => {
        const x1 = max(rect.x, cropRect.x);
        const y1 = max(rect.y, cropRect.y);
        const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
        const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
        if (x2 - x1 < 0 || y2 - y1 < 0) {
            return null;
        }
        return create$2(x1, y1, x2 - x1, y2 - y1);
    };
    /**
     * Returns a rect clamped within the specified clamp rect. This forces the
     * rect to be inside the clamp rect.
     *
     * @method clamp
     * @param {Rect} rect Rectangle to force within clamp rect.
     * @param {Rect} clampRect Rectable to force within.
     * @param {Boolean} fixedSize True/false if size should be fixed.
     * @return {Rect} Clamped rect.
     */
    const clamp = (rect, clampRect, fixedSize) => {
        let x1 = rect.x;
        let y1 = rect.y;
        let x2 = rect.x + rect.w;
        let y2 = rect.y + rect.h;
        const cx2 = clampRect.x + clampRect.w;
        const cy2 = clampRect.y + clampRect.h;
        const underflowX1 = max(0, clampRect.x - x1);
        const underflowY1 = max(0, clampRect.y - y1);
        const overflowX2 = max(0, x2 - cx2);
        const overflowY2 = max(0, y2 - cy2);
        x1 += underflowX1;
        y1 += underflowY1;
        if (fixedSize) {
            x2 += underflowX1;
            y2 += underflowY1;
            x1 -= overflowX2;
            y1 -= overflowY2;
        }
        x2 -= overflowX2;
        y2 -= overflowY2;
        return create$2(x1, y1, x2 - x1, y2 - y1);
    };
    /**
     * Creates a new rectangle object.
     *
     * @method create
     * @param {Number} x Rectangle x location.
     * @param {Number} y Rectangle y location.
     * @param {Number} w Rectangle width.
     * @param {Number} h Rectangle height.
     * @return {Rect} New rectangle object.
     */
    const create$2 = (x, y, w, h) => {
        return { x, y, w, h };
    };
    /**
     * Creates a new rectangle object form a clientRects object.
     *
     * @method fromClientRect
     * @param {ClientRect} clientRect DOM ClientRect object.
     * @return {Rect} New rectangle object.
     */
    const fromClientRect = (clientRect) => {
        return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
    };
    const Rect = {
        inflate,
        relativePosition,
        findBestRelativePosition,
        intersect,
        clamp,
        create: create$2,
        fromClientRect
    };

    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {
        let done = false;
        let timer = null;
        const complete = (completer) => (...args) => {
            if (!done) {
                done = true;
                if (timer !== null) {
                    window.clearTimeout(timer);
                    timer = null;
                }
                completer.apply(null, args);
            }
        };
        const resolve = complete(resolveCb);
        const reject = complete(rejectCb);
        const start = (...args) => {
            if (!done && timer === null) {
                timer = window.setTimeout(() => reject.apply(null, args), timeout);
            }
        };
        return {
            start,
            resolve,
            reject
        };
    };
    const create$1 = () => {
        const tasks = {};
        const resultFns = {};
        const resources = {};
        const load = (id, url) => {
            const loadErrMsg = `Script at URL "${url}" failed to load`;
            const runErrMsg = `Script at URL "${url}" did not call \`tinymce.Resource.add('${id}', data)\` within 1 second`;
            if (tasks[id] !== undefined) {
                return tasks[id];
            }
            else {
                const task = new Promise((resolve, reject) => {
                    const waiter = awaiter(resolve, reject);
                    resultFns[id] = waiter.resolve;
                    ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));
                });
                tasks[id] = task;
                return task;
            }
        };
        const add = (id, data) => {
            if (resultFns[id] !== undefined) {
                resultFns[id](data);
                delete resultFns[id];
            }
            tasks[id] = Promise.resolve(data);
            resources[id] = data;
        };
        const has = (id) => {
            return id in resources;
        };
        const unload = (id) => {
            delete tasks[id];
            delete resources[id];
        };
        const get = (id) => resources[id];
        return {
            load,
            add,
            has,
            get,
            unload
        };
    };
    const Resource = create$1();

    // Simple stub of localstorage with strict security settings #TINY-1782
    const create = () => (() => {
        let data = {};
        let keys = [];
        const storage = {
            getItem: (key) => {
                const item = data[key];
                return item ? item : null;
            },
            setItem: (key, value) => {
                keys.push(key);
                data[key] = String(value);
            },
            key: (index) => {
                return keys[index];
            },
            removeItem: (key) => {
                keys = keys.filter((k) => k === key);
                delete data[key];
            },
            clear: () => {
                keys = [];
                data = {};
            },
            length: 0
        };
        Object.defineProperty(storage, 'length', {
            get: () => keys.length,
            configurable: false,
            enumerable: false
        });
        return storage;
    })();

    /**
     * @class tinymce.util.LocalStorage
     * @static
     * @version 4.0
     * @private
     * @example
     * tinymce.util.LocalStorage.setItem('key', 'value');
     * const value = tinymce.util.LocalStorage.getItem('key');
     */
    let localStorage;
    // Browsers with certain strict security settings will explode when trying to access localStorage
    // so we need to do a try/catch and a simple stub here. #TINY-1782 & #TINY-5935
    try {
        const test = '__storage_test__';
        localStorage = window.localStorage;
        // Make sure we can set a value, as storage may also be full
        localStorage.setItem(test, test);
        localStorage.removeItem(test);
    }
    catch (_a) {
        localStorage = create();
    }
    var LocalStorage = localStorage;

    /**
     * @include ../../../../../tools/docs/tinymce.js
     */
    /**
     * @include ../../../../../tools/docs/tinymce.Event.js
     */
    /**
     * @include ../../../../../tools/docs/tinymce.editor.ui.Ui.js
     */
    const publicApi = {
        geom: {
            Rect
        },
        util: {
            Delay,
            Tools,
            VK,
            URI,
            EventDispatcher,
            Observable,
            I18n,
            LocalStorage,
            ImageUploader
        },
        dom: {
            EventUtils,
            TreeWalker: DomTreeWalker,
            TextSeeker,
            DOMUtils,
            ScriptLoader,
            RangeUtils,
            Serializer: DomSerializer,
            StyleSheetLoader,
            ControlSelection,
            BookmarkManager,
            Selection: EditorSelection,
            Event: EventUtils.Event
        },
        html: {
            Styles,
            Entities,
            Node: AstNode,
            Schema,
            DomParser,
            Writer,
            Serializer: HtmlSerializer
        },
        Env,
        AddOnManager,
        Annotator,
        Formatter,
        UndoManager,
        EditorCommands,
        WindowManager,
        NotificationManager,
        EditorObservable,
        Shortcuts,
        Editor,
        FocusManager,
        EditorManager,
        // Global instances
        DOM: DOMUtils.DOM,
        ScriptLoader: ScriptLoader.ScriptLoader,
        PluginManager,
        ThemeManager,
        ModelManager,
        IconManager,
        Resource,
        FakeClipboard,
        // Global utility functions
        trim: Tools.trim,
        isArray: Tools.isArray,
        is: Tools.is,
        toArray: Tools.toArray,
        makeMap: Tools.makeMap,
        each: Tools.each,
        map: Tools.map,
        grep: Tools.grep,
        inArray: Tools.inArray,
        extend: Tools.extend,
        walk: Tools.walk,
        resolve: Tools.resolve,
        explode: Tools.explode,
        _addCacheSuffix: Tools._addCacheSuffix
    };
    const tinymce$1 = Tools.extend(EditorManager, publicApi);

    const exportToModuleLoaders = (tinymce) => {
        if (typeof module === 'object') {
            try {
                module.exports = tinymce;
            }
            catch (_a) {
                // It will thrown an error when running this module
                // within webpack where the module.exports object is sealed
            }
        }
    };
    const exportToWindowGlobal = (tinymce) => {
        window.tinymce = tinymce;
        window.tinyMCE = tinymce;
    };
    exportToWindowGlobal(tinymce$1);
    exportToModuleLoaders(tinymce$1);

})();

/**
 * TinyMCE version 8.0.2 (2025-08-14)
 */

(function () {
    'use strict';

    /* eslint-disable @typescript-eslint/no-wrapper-object-types */
    const getPrototypeOf$2 = Object.getPrototypeOf;
    const hasProto = (v, constructor, predicate) => {
        var _a;
        if (predicate(v, constructor.prototype)) {
            return true;
        }
        else {
            // String-based fallback time
            return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
        }
    };
    const typeOf = (x) => {
        const t = typeof x;
        if (x === null) {
            return 'null';
        }
        else if (t === 'object' && Array.isArray(x)) {
            return 'array';
        }
        else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {
            return 'string';
        }
        else {
            return t;
        }
    };
    const isType$1 = (type) => (value) => typeOf(value) === type;
    const isSimpleType = (type) => (value) => typeof value === type;
    const eq$1 = (t) => (a) => t === a;
    const is$2 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);
    const isString = isType$1('string');
    const isObject = isType$1('object');
    const isPlainObject = (value) => is$2(value, Object);
    const isArray = isType$1('array');
    const isNull = eq$1(null);
    const isBoolean = isSimpleType('boolean');
    const isUndefined = eq$1(undefined);
    const isNullable = (a) => a === null || a === undefined;
    const isNonNullable = (a) => !isNullable(a);
    const isFunction = isSimpleType('function');
    const isNumber = isSimpleType('number');
    const isArrayOf = (value, pred) => {
        if (isArray(value)) {
            for (let i = 0, len = value.length; i < len; ++i) {
                if (!(pred(value[i]))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };

    const noop = () => { };
    const noarg = (f) => () => f();
    /** Compose a unary function with an n-ary function */
    const compose = (fa, fb) => {
        return (...args) => {
            return fa(fb.apply(null, args));
        };
    };
    /** Compose two unary functions. Similar to compose, but avoids using Function.prototype.apply. */
    const compose1 = (fbc, fab) => (a) => fbc(fab(a));
    const constant$1 = (value) => {
        return () => {
            return value;
        };
    };
    const identity = (x) => {
        return x;
    };
    const tripleEquals = (a, b) => {
        return a === b;
    };
    function curry(fn, ...initialArgs) {
        return (...restArgs) => {
            const all = initialArgs.concat(restArgs);
            return fn.apply(null, all);
        };
    }
    const not = (f) => (t) => !f(t);
    const die = (msg) => {
        return () => {
            throw new Error(msg);
        };
    };
    const apply$1 = (f) => {
        return f();
    };
    const never = constant$1(false);
    const always = constant$1(true);

    /**
     * The `Optional` type represents a value (of any type) that potentially does
     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the
     * value does exist) or a `None` (in which case the value does not exist). This
     * module defines a whole lot of FP-inspired utility functions for dealing with
     * `Optional` objects.
     *
     * Comparison with null or undefined:
     * - We don't get fancy null coalescing operators with `Optional`
     * - We do get fancy helper functions with `Optional`
     * - `Optional` support nesting, and allow for the type to still be nullable (or
     * another `Optional`)
     * - There is no option to turn off strict-optional-checks like there is for
     * strict-null-checks
     */
    class Optional {
        // The internal representation has a `tag` and a `value`, but both are
        // private: able to be console.logged, but not able to be accessed by code
        constructor(tag, value) {
            this.tag = tag;
            this.value = value;
        }
        // --- Identities ---
        /**
         * Creates a new `Optional<T>` that **does** contain a value.
         */
        static some(value) {
            return new Optional(true, value);
        }
        /**
         * Create a new `Optional<T>` that **does not** contain a value. `T` can be
         * any type because we don't actually have a `T`.
         */
        static none() {
            return Optional.singletonNone;
        }
        /**
         * Perform a transform on an `Optional` type. Regardless of whether this
         * `Optional` contains a value or not, `fold` will return a value of type `U`.
         * If this `Optional` does not contain a value, the `U` will be created by
         * calling `onNone`. If this `Optional` does contain a value, the `U` will be
         * created by calling `onSome`.
         *
         * For the FP enthusiasts in the room, this function:
         * 1. Could be used to implement all of the functions below
         * 2. Forms a catamorphism
         */
        fold(onNone, onSome) {
            if (this.tag) {
                return onSome(this.value);
            }
            else {
                return onNone();
            }
        }
        /**
         * Determine if this `Optional` object contains a value.
         */
        isSome() {
            return this.tag;
        }
        /**
         * Determine if this `Optional` object **does not** contain a value.
         */
        isNone() {
            return !this.tag;
        }
        // --- Functor (name stolen from Haskell / maths) ---
        /**
         * Perform a transform on an `Optional` object, **if** there is a value. If
         * you provide a function to turn a T into a U, this is the function you use
         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
         * a value then the output will also contain a value (that value being the
         * output of `mapper(this.value)`), and if this **does not** contain a value
         * then neither will the output.
         */
        map(mapper) {
            if (this.tag) {
                return Optional.some(mapper(this.value));
            }
            else {
                return Optional.none();
            }
        }
        // --- Monad (name stolen from Haskell / maths) ---
        /**
         * Perform a transform on an `Optional` object, **if** there is a value.
         * Unlike `map`, here the transform itself also returns an `Optional`.
         */
        bind(binder) {
            if (this.tag) {
                return binder(this.value);
            }
            else {
                return Optional.none();
            }
        }
        // --- Traversable (name stolen from Haskell / maths) ---
        /**
         * For a given predicate, this function finds out if there **exists** a value
         * inside this `Optional` object that meets the predicate. In practice, this
         * means that for `Optional`s that do not contain a value it returns false (as
         * no predicate-meeting value exists).
         */
        exists(predicate) {
            return this.tag && predicate(this.value);
        }
        /**
         * For a given predicate, this function finds out if **all** the values inside
         * this `Optional` object meet the predicate. In practice, this means that
         * for `Optional`s that do not contain a value it returns true (as all 0
         * objects do meet the predicate).
         */
        forall(predicate) {
            return !this.tag || predicate(this.value);
        }
        filter(predicate) {
            if (!this.tag || predicate(this.value)) {
                return this;
            }
            else {
                return Optional.none();
            }
        }
        // --- Getters ---
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value.
         */
        getOr(replacement) {
            return this.tag ? this.value : replacement;
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value.  Unlike `getOr`, in this method the `replacement` object is also
         * `Optional` - meaning that this method will always return an `Optional`.
         */
        or(replacement) {
            return this.tag ? this : replacement;
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value. Unlike `getOr`, in this method the `replacement` value is
         * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
         * pass a function which (if called) will **return** the `value` you want to
         * use.
         */
        getOrThunk(thunk) {
            return this.tag ? this.value : thunk();
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided Optional object does not contain a
         * value.
         *
         * Unlike `or`, in this method the `replacement` value is "thunked" - that is
         * to say that you don't pass a value to `orThunk`, you pass a function which
         * (if called) will **return** the `value` you want to use.
         *
         * Unlike `getOrThunk`, in this method the `replacement` value is also
         * `Optional`, meaning that this method will always return an `Optional`.
         */
        orThunk(thunk) {
            return this.tag ? this : thunk();
        }
        /**
         * Get the value out of the inside of the `Optional` object, throwing an
         * exception if the provided `Optional` object does not contain a value.
         *
         * WARNING:
         * You should only be using this function if you know that the `Optional`
         * object **is not** empty (otherwise you're throwing exceptions in production
         * code, which is bad).
         *
         * In tests this is more acceptable.
         *
         * Prefer other methods to this, such as `.each`.
         */
        getOrDie(message) {
            if (!this.tag) {
                throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');
            }
            else {
                return this.value;
            }
        }
        // --- Interop with null and undefined ---
        /**
         * Creates an `Optional` value from a nullable (or undefined-able) input.
         * Null, or undefined, is converted to `None`, and anything else is converted
         * to `Some`.
         */
        static from(value) {
            return isNonNullable(value) ? Optional.some(value) : Optional.none();
        }
        /**
         * Converts an `Optional` to a nullable type, by getting the value if it
         * exists, or returning `null` if it does not.
         */
        getOrNull() {
            return this.tag ? this.value : null;
        }
        /**
         * Converts an `Optional` to an undefined-able type, by getting the value if
         * it exists, or returning `undefined` if it does not.
         */
        getOrUndefined() {
            return this.value;
        }
        // --- Utilities ---
        /**
         * If the `Optional` contains a value, perform an action on that value.
         * Unlike the rest of the methods on this type, `.each` has side-effects. If
         * you want to transform an `Optional<T>` **into** something, then this is not
         * the method for you. If you want to use an `Optional<T>` to **do**
         * something, then this is the method for you - provided you're okay with not
         * doing anything in the case where the `Optional` doesn't have a value inside
         * it. If you're not sure whether your use-case fits into transforming
         * **into** something or **doing** something, check whether it has a return
         * value. If it does, you should be performing a transform.
         */
        each(worker) {
            if (this.tag) {
                worker(this.value);
            }
        }
        /**
         * Turn the `Optional` object into an array that contains all of the values
         * stored inside the `Optional`. In practice, this means the output will have
         * either 0 or 1 elements.
         */
        toArray() {
            return this.tag ? [this.value] : [];
        }
        /**
         * Turn the `Optional` object into a string for debugging or printing. Not
         * recommended for production code, but good for debugging. Also note that
         * these days an `Optional` object can be logged to the console directly, and
         * its inner value (if it exists) will be visible.
         */
        toString() {
            return this.tag ? `some(${this.value})` : 'none()';
        }
    }
    // Sneaky optimisation: every instance of Optional.none is identical, so just
    // reuse the same object
    Optional.singletonNone = new Optional(false);

    const nativeSlice = Array.prototype.slice;
    const nativeIndexOf = Array.prototype.indexOf;
    const nativePush = Array.prototype.push;
    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
    const indexOf = (xs, x) => {
        // The rawIndexOf method does not wrap up in an option. This is for performance reasons.
        const r = rawIndexOf(xs, x);
        return r === -1 ? Optional.none() : Optional.some(r);
    };
    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
    const exists = (xs, pred) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return true;
            }
        }
        return false;
    };
    const range$2 = (num, f) => {
        const r = [];
        for (let i = 0; i < num; i++) {
            r.push(f(i));
        }
        return r;
    };
    // It's a total micro optimisation, but these do make some difference.
    // Particularly for browsers other than Chrome.
    // - length caching
    // http://jsperf.com/browser-diet-jquery-each-vs-for-loop/69
    // - not using push
    // http://jsperf.com/array-direct-assignment-vs-push/2
    const chunk$1 = (array, size) => {
        const r = [];
        for (let i = 0; i < array.length; i += size) {
            const s = nativeSlice.call(array, i, i + size);
            r.push(s);
        }
        return r;
    };
    const map$2 = (xs, f) => {
        // pre-allocating array size when it's guaranteed to be known
        // http://jsperf.com/push-allocated-vs-dynamic/22
        const len = xs.length;
        const r = new Array(len);
        for (let i = 0; i < len; i++) {
            const x = xs[i];
            r[i] = f(x, i);
        }
        return r;
    };
    // Unwound implementing other functions in terms of each.
    // The code size is roughly the same, and it should allow for better optimisation.
    // const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {
    const each$1 = (xs, f) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            f(x, i);
        }
    };
    const eachr = (xs, f) => {
        for (let i = xs.length - 1; i >= 0; i--) {
            const x = xs[i];
            f(x, i);
        }
    };
    const partition$3 = (xs, pred) => {
        const pass = [];
        const fail = [];
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            const arr = pred(x, i) ? pass : fail;
            arr.push(x);
        }
        return { pass, fail };
    };
    const filter$2 = (xs, pred) => {
        const r = [];
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                r.push(x);
            }
        }
        return r;
    };
    const foldr = (xs, f, acc) => {
        eachr(xs, (x, i) => {
            acc = f(acc, x, i);
        });
        return acc;
    };
    const foldl = (xs, f, acc) => {
        each$1(xs, (x, i) => {
            acc = f(acc, x, i);
        });
        return acc;
    };
    const findUntil = (xs, pred, until) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return Optional.some(x);
            }
            else if (until(x, i)) {
                break;
            }
        }
        return Optional.none();
    };
    const find$5 = (xs, pred) => {
        return findUntil(xs, pred, never);
    };
    const findIndex$1 = (xs, pred) => {
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            if (pred(x, i)) {
                return Optional.some(i);
            }
        }
        return Optional.none();
    };
    const flatten = (xs) => {
        // Note, this is possible because push supports multiple arguments:
        // http://jsperf.com/concat-push/6
        // Note that in the past, concat() would silently work (very slowly) for array-like objects.
        // With this change it will throw an error.
        const r = [];
        for (let i = 0, len = xs.length; i < len; ++i) {
            // Ensure that each value is an array itself
            if (!isArray(xs[i])) {
                throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
            }
            nativePush.apply(r, xs[i]);
        }
        return r;
    };
    const bind$3 = (xs, f) => flatten(map$2(xs, f));
    const forall = (xs, pred) => {
        for (let i = 0, len = xs.length; i < len; ++i) {
            const x = xs[i];
            if (pred(x, i) !== true) {
                return false;
            }
        }
        return true;
    };
    const reverse = (xs) => {
        const r = nativeSlice.call(xs, 0);
        r.reverse();
        return r;
    };
    const difference = (a1, a2) => filter$2(a1, (x) => !contains$2(a2, x));
    const mapToObject = (xs, f) => {
        const r = {};
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            r[String(x)] = f(x, i);
        }
        return r;
    };
    const pure$2 = (x) => [x];
    const sort = (xs, comparator) => {
        const copy = nativeSlice.call(xs, 0);
        copy.sort(comparator);
        return copy;
    };
    const get$i = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    const head = (xs) => get$i(xs, 0);
    const last$1 = (xs) => get$i(xs, xs.length - 1);
    const from = isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);
    const findMap = (arr, f) => {
        for (let i = 0; i < arr.length; i++) {
            const r = f(arr[i], i);
            if (r.isSome()) {
                return r;
            }
        }
        return Optional.none();
    };

    // There are many variations of Object iteration that are faster than the 'for-in' style:
    // http://jsperf.com/object-keys-iteration/107
    //
    // Use the native keys if it is available (IE9+), otherwise fall back to manually filtering
    const keys = Object.keys;
    const hasOwnProperty = Object.hasOwnProperty;
    const each = (obj, f) => {
        const props = keys(obj);
        for (let k = 0, len = props.length; k < len; k++) {
            const i = props[k];
            const x = obj[i];
            f(x, i);
        }
    };
    const map$1 = (obj, f) => {
        return tupleMap(obj, (x, i) => ({
            k: i,
            v: f(x, i)
        }));
    };
    const tupleMap = (obj, f) => {
        const r = {};
        each(obj, (x, i) => {
            const tuple = f(x, i);
            r[tuple.k] = tuple.v;
        });
        return r;
    };
    const objAcc = (r) => (x, i) => {
        r[i] = x;
    };
    const internalFilter = (obj, pred, onTrue, onFalse) => {
        each(obj, (x, i) => {
            (pred(x, i) ? onTrue : onFalse)(x, i);
        });
    };
    const bifilter = (obj, pred) => {
        const t = {};
        const f = {};
        internalFilter(obj, pred, objAcc(t), objAcc(f));
        return { t, f };
    };
    const filter$1 = (obj, pred) => {
        const t = {};
        internalFilter(obj, pred, objAcc(t), noop);
        return t;
    };
    const mapToArray = (obj, f) => {
        const r = [];
        each(obj, (value, name) => {
            r.push(f(value, name));
        });
        return r;
    };
    const find$4 = (obj, pred) => {
        const props = keys(obj);
        for (let k = 0, len = props.length; k < len; k++) {
            const i = props[k];
            const x = obj[i];
            if (pred(x, i, obj)) {
                return Optional.some(x);
            }
        }
        return Optional.none();
    };
    const values = (obj) => {
        return mapToArray(obj, identity);
    };
    const get$h = (obj, key) => {
        return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    const has$2 = (obj, key) => hasOwnProperty.call(obj, key);
    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;

    /*
     * Generates a church encoded ADT (https://en.wikipedia.org/wiki/Church_encoding)
     * For syntax and use, look at the test code.
     */
    const generate$7 = (cases) => {
        // validation
        if (!isArray(cases)) {
            throw new Error('cases must be an array');
        }
        if (cases.length === 0) {
            throw new Error('there must be at least one case');
        }
        const constructors = [];
        // adt is mutated to add the individual cases
        const adt = {};
        each$1(cases, (acase, count) => {
            const keys$1 = keys(acase);
            // validation
            if (keys$1.length !== 1) {
                throw new Error('one and only one name per case');
            }
            const key = keys$1[0];
            const value = acase[key];
            // validation
            if (adt[key] !== undefined) {
                throw new Error('duplicate key detected:' + key);
            }
            else if (key === 'cata') {
                throw new Error('cannot have a case named cata (sorry)');
            }
            else if (!isArray(value)) {
                // this implicitly checks if acase is an object
                throw new Error('case arguments must be an array');
            }
            constructors.push(key);
            //
            // constructor for key
            //
            adt[key] = (...args) => {
                const argLength = args.length;
                // validation
                if (argLength !== value.length) {
                    throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
                }
                const match = (branches) => {
                    const branchKeys = keys(branches);
                    if (constructors.length !== branchKeys.length) {
                        throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
                    }
                    const allReqd = forall(constructors, (reqKey) => {
                        return contains$2(branchKeys, reqKey);
                    });
                    if (!allReqd) {
                        throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
                    }
                    return branches[key].apply(null, args);
                };
                //
                // the fold function for key
                //
                return {
                    fold: (...foldArgs) => {
                        // runtime validation
                        if (foldArgs.length !== cases.length) {
                            throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);
                        }
                        const target = foldArgs[count];
                        return target.apply(null, args);
                    },
                    match,
                    // NOTE: Only for debugging.
                    log: (label) => {
                        // eslint-disable-next-line no-console
                        console.log(label, {
                            constructors,
                            constructor: key,
                            params: args
                        });
                    }
                };
            };
        });
        return adt;
    };
    const Adt = {
        generate: generate$7
    };

    const Cell = (initial) => {
        let value = initial;
        const get = () => {
            return value;
        };
        const set = (v) => {
            value = v;
        };
        return {
            get,
            set
        };
    };

    const nu$d = (baseFn) => {
        let data = Optional.none();
        let callbacks = [];
        /** map :: this LazyValue a -> (a -> b) -> LazyValue b */
        const map = (f) => nu$d((nCallback) => {
            get((data) => {
                nCallback(f(data));
            });
        });
        const get = (nCallback) => {
            if (isReady()) {
                call(nCallback);
            }
            else {
                callbacks.push(nCallback);
            }
        };
        const set = (x) => {
            if (!isReady()) {
                data = Optional.some(x);
                run(callbacks);
                callbacks = [];
            }
        };
        const isReady = () => data.isSome();
        const run = (cbs) => {
            each$1(cbs, call);
        };
        const call = (cb) => {
            data.each((x) => {
                setTimeout(() => {
                    cb(x);
                }, 0);
            });
        };
        // Lazy values cache the value and kick off immediately
        baseFn(set);
        return {
            get,
            map,
            isReady
        };
    };
    const pure$1 = (a) => nu$d((callback) => {
        callback(a);
    });
    const LazyValue = {
        nu: nu$d,
        pure: pure$1
    };

    const errorReporter = (err) => {
        // we can not throw the error in the reporter as it will just be black-holed
        // by the Promise so we use a setTimeout to escape the Promise.
        setTimeout(() => {
            throw err;
        }, 0);
    };
    const make$8 = (run) => {
        const get = (callback) => {
            run().then(callback, errorReporter);
        };
        /** map :: this Future a -> (a -> b) -> Future b */
        const map = (fab) => {
            return make$8(() => run().then(fab));
        };
        /** bind :: this Future a -> (a -> Future b) -> Future b */
        const bind = (aFutureB) => {
            return make$8(() => run().then((v) => aFutureB(v).toPromise()));
        };
        /** anonBind :: this Future a -> Future b -> Future b
         *  Returns a future, which evaluates the first future, ignores the result, then evaluates the second.
         */
        const anonBind = (futureB) => {
            return make$8(() => run().then(() => futureB.toPromise()));
        };
        const toLazy = () => {
            return LazyValue.nu(get);
        };
        const toCached = () => {
            let cache = null;
            return make$8(() => {
                if (cache === null) {
                    cache = run();
                }
                return cache;
            });
        };
        const toPromise = run;
        return {
            map,
            bind,
            anonBind,
            toLazy,
            toCached,
            toPromise,
            get
        };
    };
    const nu$c = (baseFn) => {
        return make$8(() => new Promise(baseFn));
    };
    /** a -> Future a */
    const pure = (a) => {
        return make$8(() => Promise.resolve(a));
    };
    const Future = {
        nu: nu$c,
        pure
    };

    /**
     * Creates a new `Result<T, E>` that **does** contain a value.
     */
    const value$4 = (value) => {
        const applyHelper = (fn) => fn(value);
        const constHelper = constant$1(value);
        const outputHelper = () => output;
        const output = {
            // Debug info
            tag: true,
            inner: value,
            // Actual Result methods
            fold: (_onError, onValue) => onValue(value),
            isValue: always,
            isError: never,
            map: (mapper) => Result.value(mapper(value)),
            mapError: outputHelper,
            bind: applyHelper,
            exists: applyHelper,
            forall: applyHelper,
            getOr: constHelper,
            or: outputHelper,
            getOrThunk: constHelper,
            orThunk: outputHelper,
            getOrDie: constHelper,
            each: (fn) => {
                // Can't write the function inline because we don't want to return something by mistake
                fn(value);
            },
            toOptional: () => Optional.some(value),
        };
        return output;
    };
    /**
     * Creates a new `Result<T, E>` that **does not** contain a value, and therefore
     * contains an error.
     */
    const error$1 = (error) => {
        const outputHelper = () => output;
        const output = {
            // Debug info
            tag: false,
            inner: error,
            // Actual Result methods
            fold: (onError, _onValue) => onError(error),
            isValue: never,
            isError: always,
            map: outputHelper,
            mapError: (mapper) => Result.error(mapper(error)),
            bind: outputHelper,
            exists: never,
            forall: always,
            getOr: identity,
            or: identity,
            getOrThunk: apply$1,
            orThunk: apply$1,
            getOrDie: die(String(error)),
            each: noop,
            toOptional: Optional.none,
        };
        return output;
    };
    /**
     * Creates a new `Result<T, E>` from an `Optional<T>` and an `E`. If the
     * `Optional` contains a value, so will the outputted `Result`. If it does not,
     * the outputted `Result` will contain an error (and that error will be the
     * error passed in).
     */
    const fromOption = (optional, err) => optional.fold(() => error$1(err), value$4);
    const Result = {
        value: value$4,
        error: error$1,
        fromOption
    };

    const wrap$2 = (delegate) => {
        const toCached = () => {
            return wrap$2(delegate.toCached());
        };
        const bindFuture = (f) => {
            return wrap$2(delegate.bind((resA) => resA.fold((err) => (Future.pure(Result.error(err))), (a) => f(a))));
        };
        const bindResult = (f) => {
            return wrap$2(delegate.map((resA) => resA.bind(f)));
        };
        const mapResult = (f) => {
            return wrap$2(delegate.map((resA) => resA.map(f)));
        };
        const mapError = (f) => {
            return wrap$2(delegate.map((resA) => resA.mapError(f)));
        };
        const foldResult = (whenError, whenValue) => {
            return delegate.map((res) => res.fold(whenError, whenValue));
        };
        const withTimeout = (timeout, errorThunk) => {
            return wrap$2(Future.nu((callback) => {
                let timedOut = false;
                const timer = setTimeout(() => {
                    timedOut = true;
                    callback(Result.error(errorThunk()));
                }, timeout);
                delegate.get((result) => {
                    if (!timedOut) {
                        clearTimeout(timer);
                        callback(result);
                    }
                });
            }));
        };
        return {
            ...delegate,
            toCached,
            bindFuture,
            bindResult,
            mapResult,
            mapError,
            foldResult,
            withTimeout
        };
    };
    const nu$b = (worker) => {
        return wrap$2(Future.nu(worker));
    };
    const value$3 = (value) => {
        return wrap$2(Future.pure(Result.value(value)));
    };
    const error = (error) => {
        return wrap$2(Future.pure(Result.error(error)));
    };
    const fromResult$1 = (result) => {
        return wrap$2(Future.pure(result));
    };
    const fromFuture = (future) => {
        return wrap$2(future.map(Result.value));
    };
    const fromPromise = (promise) => {
        return nu$b((completer) => {
            promise.then((value) => {
                completer(Result.value(value));
            }, (error) => {
                completer(Result.error(error));
            });
        });
    };
    const FutureResult = {
        nu: nu$b,
        wrap: wrap$2,
        pure: value$3,
        value: value$3,
        error,
        fromResult: fromResult$1,
        fromFuture,
        fromPromise
    };

    // Use window object as the global if it's available since CSP will block script evals
    // eslint-disable-next-line @typescript-eslint/no-implied-eval
    const Global = typeof window !== 'undefined' ? window : Function('return this;')();

    /**
     * Adds two numbers, and wrap to a range.
     * If the result overflows to the right, snap to the left.
     * If the result overflows to the left, snap to the right.
     */
    const cycleBy = (value, delta, min, max) => {
        const r = value + delta;
        if (r > max) {
            return min;
        }
        else if (r < min) {
            return max;
        }
        else {
            return r;
        }
    };
    // ASSUMPTION: Max will always be larger than min
    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    // the division is meant to get a number between 0 and 1 for more information check this discussion: https://stackoverflow.com/questions/58285941/how-to-replace-math-random-with-crypto-getrandomvalues-and-keep-same-result
    const random = () => window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;

    /**
     * Generate a unique identifier.
     *
     * The unique portion of the identifier only contains an underscore
     * and digits, so that it may safely be used within HTML attributes.
     *
     * The chance of generating a non-unique identifier has been minimized
     * by combining the current time, a random number and a one-up counter.
     *
     * generate :: String -> String
     */
    let unique = 0;
    const generate$6 = (prefix) => {
        const date = new Date();
        const time = date.getTime();
        const random$1 = Math.floor(random() * 1000000000);
        unique++;
        return prefix + '_' + random$1 + unique + String(time);
    };

    const shallow$1 = (old, nu) => {
        return nu;
    };
    const deep$1 = (old, nu) => {
        const bothObjects = isPlainObject(old) && isPlainObject(nu);
        return bothObjects ? deepMerge(old, nu) : nu;
    };
    const baseMerge = (merger) => {
        return (...objects) => {
            if (objects.length === 0) {
                throw new Error(`Can't merge zero objects`);
            }
            const ret = {};
            for (let j = 0; j < objects.length; j++) {
                const curObject = objects[j];
                for (const key in curObject) {
                    if (has$2(curObject, key)) {
                        ret[key] = merger(ret[key], curObject[key]);
                    }
                }
            }
            return ret;
        };
    };
    const deepMerge = baseMerge(deep$1);
    const merge$1 = baseMerge(shallow$1);

    /**
     * **Is** the value stored inside this Optional object equal to `rhs`?
     */
    const is$1 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));
    /**
     * Are these two Optional objects equal? Equality here means either they're both
     * `Some` (and the values are equal under the comparator) or they're both `None`.
     */
    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
    const cat = (arr) => {
        const r = [];
        const push = (x) => {
            r.push(x);
        };
        for (let i = 0; i < arr.length; i++) {
            arr[i].each(push);
        }
        return r;
    };
    const sequence = (arr) => {
        const r = [];
        for (let i = 0; i < arr.length; i++) {
            const x = arr[i];
            if (x.isSome()) {
                r.push(x.getOrDie());
            }
            else {
                return Optional.none();
            }
        }
        return Optional.some(r);
    };
    /*
    Notes on the lift functions:
    - We used to have a generic liftN, but we were concerned about its type-safety, and the below variants were faster in microbenchmarks.
    - The getOrDie calls are partial functions, but are checked beforehand. This is faster and more convenient (but less safe) than folds.
    - && is used instead of a loop for simplicity and performance.
    */
    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
    const mapFrom = (a, f) => (a !== undefined && a !== null) ? Optional.some(f(a)) : Optional.none();
    // This can help with type inference, by specifying the type param on the none case, so the caller doesn't have to.
    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping
    const escape = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    /** path :: ([String], JsObj?) -> JsObj */
    const path$1 = (parts, scope) => {
        let o = scope !== undefined && scope !== null ? scope : Global;
        for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {
            o = o[parts[i]];
        }
        return o;
    };
    /** resolve :: (String, JsObj?) -> JsObj */
    const resolve = (p, scope) => {
        const parts = p.split('.');
        return path$1(parts, scope);
    };

    Adt.generate([
        { bothErrors: ['error1', 'error2'] },
        { firstError: ['error1', 'value2'] },
        { secondError: ['value1', 'error2'] },
        { bothValues: ['value1', 'value2'] }
    ]);
    /** partition :: [Result a] -> { errors: [String], values: [a] } */
    const partition$2 = (results) => {
        const errors = [];
        const values = [];
        each$1(results, (result) => {
            result.fold((err) => {
                errors.push(err);
            }, (value) => {
                values.push(value);
            });
        });
        return { errors, values };
    };

    const singleton$1 = (doRevoke) => {
        const subject = Cell(Optional.none());
        const revoke = () => subject.get().each(doRevoke);
        const clear = () => {
            revoke();
            subject.set(Optional.none());
        };
        const isSet = () => subject.get().isSome();
        const get = () => subject.get();
        const set = (s) => {
            revoke();
            subject.set(Optional.some(s));
        };
        return {
            clear,
            isSet,
            get,
            set
        };
    };
    const destroyable = () => singleton$1((s) => s.destroy());
    const unbindable = () => singleton$1((s) => s.unbind());
    const value$2 = () => {
        const subject = singleton$1(noop);
        const on = (f) => subject.get().each(f);
        return {
            ...subject,
            on
        };
    };

    const addToEnd = (str, suffix) => {
        return str + suffix;
    };
    const removeFromStart = (str, numChars) => {
        return str.substring(numChars);
    };

    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    const removeLeading = (str, prefix) => {
        return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    const ensureTrailing = (str, suffix) => {
        return endsWith(str, suffix) ? str : addToEnd(str, suffix);
    };
    const contains$1 = (str, substr, start = 0, end) => {
        const idx = str.indexOf(substr, start);
        if (idx !== -1) {
            return isUndefined(end) ? true : idx + substr.length <= end;
        }
        else {
            return false;
        }
    };
    /** Does 'str' start with 'prefix'?
     *  Note: all strings start with the empty string.
     *        More formally, for all strings x, startsWith(x, "").
     *        This is so that for all strings x and y, startsWith(y + x, y)
     */
    const startsWith = (str, prefix) => {
        return checkRange(str, prefix, 0);
    };
    /** Does 'str' end with 'suffix'?
     *  Note: all strings end with the empty string.
     *        More formally, for all strings x, endsWith(x, "").
     *        This is so that for all strings x and y, endsWith(x + y, y)
     */
    const endsWith = (str, suffix) => {
        return checkRange(str, suffix, str.length - suffix.length);
    };
    const blank = (r) => (s) => s.replace(r, '');
    /** removes all leading and trailing spaces */
    const trim$1 = blank(/^\s+|\s+$/g);
    const isNotEmpty = (s) => s.length > 0;
    const isEmpty = (s) => !isNotEmpty(s);
    const toFloat = (value) => {
        const num = parseFloat(value);
        return isNaN(num) ? Optional.none() : Optional.some(num);
    };

    // Run a function fn after rate ms. If another invocation occurs
    // during the time it is waiting, update the arguments f will run
    // with (but keep the current schedule)
    const adaptable = (fn, rate) => {
        let timer = null;
        let args = null;
        const cancel = () => {
            if (!isNull(timer)) {
                clearTimeout(timer);
                timer = null;
                args = null;
            }
        };
        const throttle = (...newArgs) => {
            args = newArgs;
            if (isNull(timer)) {
                timer = setTimeout(() => {
                    const tempArgs = args;
                    timer = null;
                    args = null;
                    fn.apply(null, tempArgs);
                }, rate);
            }
        };
        return {
            cancel,
            throttle
        };
    };
    // Run a function fn after rate ms. If another invocation occurs
    // during the time it is waiting, ignore it completely.
    const first$1 = (fn, rate) => {
        let timer = null;
        const cancel = () => {
            if (!isNull(timer)) {
                clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = (...args) => {
            if (isNull(timer)) {
                timer = setTimeout(() => {
                    timer = null;
                    fn.apply(null, args);
                }, rate);
            }
        };
        return {
            cancel,
            throttle
        };
    };
    // Run a function fn after rate ms. If another invocation occurs
    // during the time it is waiting, reschedule the function again
    // with the new arguments.
    const last = (fn, rate) => {
        let timer = null;
        const cancel = () => {
            if (!isNull(timer)) {
                clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = (...args) => {
            cancel();
            timer = setTimeout(() => {
                timer = null;
                fn.apply(null, args);
            }, rate);
        };
        return {
            cancel,
            throttle
        };
    };

    const cached = (f) => {
        let called = false;
        let r;
        return (...args) => {
            if (!called) {
                called = true;
                r = f.apply(null, args);
            }
            return r;
        };
    };

    const zeroWidth = '\uFEFF';
    const nbsp = '\u00A0';

    const fromHtml$2 = (html, scope) => {
        const doc = scope || document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        if (!div.hasChildNodes() || div.childNodes.length > 1) {
            const message = 'HTML does not have a single root node';
            // eslint-disable-next-line no-console
            console.error(message, html);
            throw new Error(message);
        }
        return fromDom(div.childNodes[0]);
    };
    const fromTag = (tag, scope) => {
        const doc = scope || document;
        const node = doc.createElement(tag);
        return fromDom(node);
    };
    const fromText = (text, scope) => {
        const doc = scope || document;
        const node = doc.createTextNode(text);
        return fromDom(node);
    };
    const fromDom = (node) => {
        // TODO: Consider removing this check, but left atm for safety
        if (node === null || node === undefined) {
            throw new Error('Node cannot be null or undefined');
        }
        return {
            dom: node
        };
    };
    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
    // tslint:disable-next-line:variable-name
    const SugarElement = {
        fromHtml: fromHtml$2,
        fromTag,
        fromText,
        fromDom,
        fromPoint
    };

    // NOTE: Mutates the range.
    const setStart = (rng, situ) => {
        situ.fold((e) => {
            rng.setStartBefore(e.dom);
        }, (e, o) => {
            rng.setStart(e.dom, o);
        }, (e) => {
            rng.setStartAfter(e.dom);
        });
    };
    const setFinish = (rng, situ) => {
        situ.fold((e) => {
            rng.setEndBefore(e.dom);
        }, (e, o) => {
            rng.setEnd(e.dom, o);
        }, (e) => {
            rng.setEndAfter(e.dom);
        });
    };
    const relativeToNative = (win, startSitu, finishSitu) => {
        const range = win.document.createRange();
        setStart(range, startSitu);
        setFinish(range, finishSitu);
        return range;
    };
    const exactToNative = (win, start, soffset, finish, foffset) => {
        const rng = win.document.createRange();
        rng.setStart(start.dom, soffset);
        rng.setEnd(finish.dom, foffset);
        return rng;
    };
    const toRect = (rect) => ({
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height
    });
    const getFirstRect$1 = (rng) => {
        const rects = rng.getClientRects();
        // ASSUMPTION: The first rectangle is the start of the selection
        const rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
        return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();
    };
    const getBounds$3 = (rng) => {
        const rect = rng.getBoundingClientRect();
        return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();
    };

    const adt$a = Adt.generate([
        { ltr: ['start', 'soffset', 'finish', 'foffset'] },
        { rtl: ['start', 'soffset', 'finish', 'foffset'] }
    ]);
    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);
    const getRanges = (win, selection) => selection.match({
        domRange: (rng) => {
            return {
                ltr: constant$1(rng),
                rtl: Optional.none
            };
        },
        relative: (startSitu, finishSitu) => {
            return {
                ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
                rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))
            };
        },
        exact: (start, soffset, finish, foffset) => {
            return {
                ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),
                rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))
            };
        }
    });
    const doDiagnose = (win, ranges) => {
        // If we cannot create a ranged selection from start > finish, it could be RTL
        const rng = ranges.ltr();
        if (rng.collapsed) {
            // Let's check if it's RTL ... if it is, then reversing the direction will not be collapsed
            const reversed = ranges.rtl().filter((rev) => rev.collapsed === false);
            return reversed.map((rev) => 
            // We need to use "reversed" here, because the original only has one point (collapsed)
            adt$a.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$a.ltr, rng));
        }
        else {
            return fromRange(win, adt$a.ltr, rng);
        }
    };
    const diagnose = (win, selection) => {
        const ranges = getRanges(win, selection);
        return doDiagnose(win, ranges);
    };
    const asLtrRange = (win, selection) => {
        const diagnosis = diagnose(win, selection);
        return diagnosis.match({
            ltr: (start, soffset, finish, foffset) => {
                const rng = win.document.createRange();
                rng.setStart(start.dom, soffset);
                rng.setEnd(finish.dom, foffset);
                return rng;
            },
            rtl: (start, soffset, finish, foffset) => {
                // NOTE: Reversing start and finish
                const rng = win.document.createRange();
                rng.setStart(finish.dom, foffset);
                rng.setEnd(start.dom, soffset);
                return rng;
            }
        });
    };
    adt$a.ltr;
    adt$a.rtl;

    const DOCUMENT = 9;
    const DOCUMENT_FRAGMENT = 11;
    const ELEMENT = 1;
    const TEXT = 3;

    const is = (element, selector) => {
        const dom = element.dom;
        if (dom.nodeType !== ELEMENT) {
            return false;
        }
        else {
            const elem = dom;
            if (elem.matches !== undefined) {
                return elem.matches(selector);
            }
            else if (elem.msMatchesSelector !== undefined) {
                return elem.msMatchesSelector(selector);
            }
            else if (elem.webkitMatchesSelector !== undefined) {
                return elem.webkitMatchesSelector(selector);
            }
            else if (elem.mozMatchesSelector !== undefined) {
                // cast to any as mozMatchesSelector doesn't exist in TS DOM lib
                return elem.mozMatchesSelector(selector);
            }
            else {
                throw new Error('Browser lacks native selectors');
            } // unfortunately we can't throw this on startup :(
        }
    };
    const bypassSelector = (dom) => 
    // Only elements, documents and shadow roots support querySelector
    // shadow root element type is DOCUMENT_FRAGMENT
    dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT ||
        // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/
        dom.childElementCount === 0;
    const all$3 = (selector, scope) => {
        const base = scope === undefined ? document : scope.dom;
        return bypassSelector(base) ? [] : map$2(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    const one = (selector, scope) => {
        const base = scope === undefined ? document : scope.dom;
        return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };

    const eq = (e1, e2) => e1.dom === e2.dom;
    // Returns: true if node e1 contains e2, otherwise false.
    // (returns false if e1===e2: A node does not contain itself).
    const contains = (e1, e2) => {
        const d1 = e1.dom;
        const d2 = e2.dom;
        return d1 === d2 ? false : d1.contains(d2);
    };

    const DeviceType = (os, browser, userAgent, mediaMatch) => {
        const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
        const isiPhone = os.isiOS() && !isiPad;
        const isMobile = os.isiOS() || os.isAndroid();
        const isTouch = isMobile || mediaMatch('(pointer:coarse)');
        const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
        const isPhone = isiPhone || isMobile && !isTablet;
        const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
        const isDesktop = !isPhone && !isTablet && !iOSwebview;
        return {
            isiPad: constant$1(isiPad),
            isiPhone: constant$1(isiPhone),
            isTablet: constant$1(isTablet),
            isPhone: constant$1(isPhone),
            isTouch: constant$1(isTouch),
            isAndroid: os.isAndroid,
            isiOS: os.isiOS,
            isWebView: constant$1(iOSwebview),
            isDesktop: constant$1(isDesktop)
        };
    };

    const firstMatch = (regexes, s) => {
        for (let i = 0; i < regexes.length; i++) {
            const x = regexes[i];
            if (x.test(s)) {
                return x;
            }
        }
        return undefined;
    };
    const find$3 = (regexes, agent) => {
        const r = firstMatch(regexes, agent);
        if (!r) {
            return { major: 0, minor: 0 };
        }
        const group = (i) => {
            return Number(agent.replace(r, '$' + i));
        };
        return nu$a(group(1), group(2));
    };
    const detect$4 = (versionRegexes, agent) => {
        const cleanedAgent = String(agent).toLowerCase();
        if (versionRegexes.length === 0) {
            return unknown$3();
        }
        return find$3(versionRegexes, cleanedAgent);
    };
    const unknown$3 = () => {
        return nu$a(0, 0);
    };
    const nu$a = (major, minor) => {
        return { major, minor };
    };
    const Version = {
        nu: nu$a,
        detect: detect$4,
        unknown: unknown$3
    };

    const detectBrowser$1 = (browsers, userAgentData) => {
        return findMap(userAgentData.brands, (uaBrand) => {
            const lcBrand = uaBrand.brand.toLowerCase();
            return find$5(browsers, (browser) => { var _a; return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase()); })
                .map((info) => ({
                current: info.name,
                version: Version.nu(parseInt(uaBrand.version, 10), 0)
            }));
        });
    };

    const detect$3 = (candidates, userAgent) => {
        const agent = String(userAgent).toLowerCase();
        return find$5(candidates, (candidate) => {
            return candidate.search(agent);
        });
    };
    // They (browser and os) are the same at the moment, but they might
    // not stay that way.
    const detectBrowser = (browsers, userAgent) => {
        return detect$3(browsers, userAgent).map((browser) => {
            const version = Version.detect(browser.versionRegexes, userAgent);
            return {
                current: browser.name,
                version
            };
        });
    };
    const detectOs = (oses, userAgent) => {
        return detect$3(oses, userAgent).map((os) => {
            const version = Version.detect(os.versionRegexes, userAgent);
            return {
                current: os.name,
                version
            };
        });
    };

    const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    const checkContains = (target) => {
        return (uastring) => {
            return contains$1(uastring, target);
        };
    };
    const browsers = [
        // This is legacy Edge
        {
            name: 'Edge',
            versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
            search: (uastring) => {
                return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');
            }
        },
        // This is Google Chrome and Chromium Edge
        {
            name: 'Chromium',
            brand: 'Chromium',
            versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, normalVersionRegex],
            search: (uastring) => {
                return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');
            }
        },
        {
            name: 'IE',
            versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
            search: (uastring) => {
                return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');
            }
        },
        // INVESTIGATE: Is this still the Opera user agent?
        {
            name: 'Opera',
            versionRegexes: [normalVersionRegex, /.*?opera\/([0-9]+)\.([0-9]+).*/],
            search: checkContains('opera')
        },
        {
            name: 'Firefox',
            versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
            search: checkContains('firefox')
        },
        {
            name: 'Safari',
            versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],
            search: (uastring) => {
                return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');
            }
        }
    ];
    const oses = [
        {
            name: 'Windows',
            search: checkContains('win'),
            versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
            name: 'iOS',
            search: (uastring) => {
                return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');
            },
            versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
        },
        {
            name: 'Android',
            search: checkContains('android'),
            versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
            name: 'macOS',
            search: checkContains('mac os x'),
            versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
        },
        {
            name: 'Linux',
            search: checkContains('linux'),
            versionRegexes: []
        },
        { name: 'Solaris',
            search: checkContains('sunos'),
            versionRegexes: []
        },
        {
            name: 'FreeBSD',
            search: checkContains('freebsd'),
            versionRegexes: []
        },
        {
            name: 'ChromeOS',
            search: checkContains('cros'),
            versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
        }
    ];
    const PlatformInfo = {
        browsers: constant$1(browsers),
        oses: constant$1(oses)
    };

    const edge = 'Edge';
    const chromium = 'Chromium';
    const ie = 'IE';
    const opera = 'Opera';
    const firefox = 'Firefox';
    const safari = 'Safari';
    const unknown$2 = () => {
        return nu$9({
            current: undefined,
            version: Version.unknown()
        });
    };
    const nu$9 = (info) => {
        const current = info.current;
        const version = info.version;
        const isBrowser = (name) => () => current === name;
        return {
            current,
            version,
            isEdge: isBrowser(edge),
            isChromium: isBrowser(chromium),
            // NOTE: isIe just looks too weird
            isIE: isBrowser(ie),
            isOpera: isBrowser(opera),
            isFirefox: isBrowser(firefox),
            isSafari: isBrowser(safari)
        };
    };
    const Browser = {
        unknown: unknown$2,
        nu: nu$9,
        edge: constant$1(edge),
        chromium: constant$1(chromium),
        ie: constant$1(ie),
        opera: constant$1(opera),
        firefox: constant$1(firefox),
        safari: constant$1(safari)
    };

    const windows = 'Windows';
    const ios = 'iOS';
    const android = 'Android';
    const linux = 'Linux';
    const macos = 'macOS';
    const solaris = 'Solaris';
    const freebsd = 'FreeBSD';
    const chromeos = 'ChromeOS';
    // Though there is a bit of dupe with this and Browser, trying to
    // reuse code makes it much harder to follow and change.
    const unknown$1 = () => {
        return nu$8({
            current: undefined,
            version: Version.unknown()
        });
    };
    const nu$8 = (info) => {
        const current = info.current;
        const version = info.version;
        const isOS = (name) => () => current === name;
        return {
            current,
            version,
            isWindows: isOS(windows),
            // TODO: Fix capitalisation
            isiOS: isOS(ios),
            isAndroid: isOS(android),
            isMacOS: isOS(macos),
            isLinux: isOS(linux),
            isSolaris: isOS(solaris),
            isFreeBSD: isOS(freebsd),
            isChromeOS: isOS(chromeos)
        };
    };
    const OperatingSystem = {
        unknown: unknown$1,
        nu: nu$8,
        windows: constant$1(windows),
        ios: constant$1(ios),
        android: constant$1(android),
        linux: constant$1(linux),
        macos: constant$1(macos),
        solaris: constant$1(solaris),
        freebsd: constant$1(freebsd),
        chromeos: constant$1(chromeos)
    };

    const detect$2 = (userAgent, userAgentDataOpt, mediaMatch) => {
        const browsers = PlatformInfo.browsers();
        const oses = PlatformInfo.oses();
        const browser = userAgentDataOpt.bind((userAgentData) => detectBrowser$1(browsers, userAgentData))
            .orThunk(() => detectBrowser(browsers, userAgent))
            .fold(Browser.unknown, Browser.nu);
        const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
        const deviceType = DeviceType(os, browser, userAgent, mediaMatch);
        return {
            browser,
            os,
            deviceType
        };
    };
    const PlatformDetection = {
        detect: detect$2
    };

    const mediaMatch = (query) => window.matchMedia(query).matches;
    // IMPORTANT: Must be in a thunk, otherwise rollup thinks calling this immediately
    // causes side effects and won't tree shake this away
    // Note: navigator.userAgentData is not part of the native typescript types yet
    let platform = cached(() => PlatformDetection.detect(window.navigator.userAgent, Optional.from((window.navigator.userAgentData)), mediaMatch));
    const detect$1 = () => platform();

    const unsafe = (name, scope) => {
        return resolve(name, scope);
    };
    const getOrDie$1 = (name, scope) => {
        const actual = unsafe(name, scope);
        if (actual === undefined || actual === null) {
            throw new Error(name + ' not available on this browser');
        }
        return actual;
    };

    const getPrototypeOf$1 = Object.getPrototypeOf;
    /*
     * IE9 and above
     *
     * MDN no use on this one, but here's the link anyway:
     * https://developer.mozilla.org/en/docs/Web/API/HTMLElement
     */
    const sandHTMLElement = (scope) => {
        return getOrDie$1('HTMLElement', scope);
    };
    const isPrototypeOf = (x) => {
        // use Resolve to get the window object for x and just return undefined if it can't find it.
        // undefined scope later triggers using the global window.
        const scope = resolve('ownerDocument.defaultView', x);
        // TINY-7374: We can't rely on looking at the owner window HTMLElement as the element may have
        // been constructed in a different window and then appended to the current window document.
        return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf$1(x).constructor.name));
    };

    const name$3 = (element) => {
        const r = element.dom.nodeName;
        return r.toLowerCase();
    };
    const type$1 = (element) => element.dom.nodeType;
    const isType = (t) => (element) => type$1(element) === t;
    const isHTMLElement = (element) => isElement$1(element) && isPrototypeOf(element.dom);
    const isElement$1 = isType(ELEMENT);
    const isText = isType(TEXT);
    const isDocument = isType(DOCUMENT);
    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);
    const isTag = (tag) => (e) => isElement$1(e) && name$3(e) === tag;

    /**
     * The document associated with the current element
     * NOTE: this will throw if the owner is null.
     */
    const owner$4 = (element) => SugarElement.fromDom(element.dom.ownerDocument);
    /**
     * If the element is a document, return it. Otherwise, return its ownerDocument.
     * @param dos
     */
    const documentOrOwner = (dos) => isDocument(dos) ? dos : owner$4(dos);
    const documentElement = (element) => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
    /**
     * The window element associated with the element
     * NOTE: this will throw if the defaultView is null.
     */
    const defaultView = (element) => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
    const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    // Cast down to just be SugarElement<Node>
    const parentNode = (element) => parent(element);
    const parentElement = (element) => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
    const parents = (element, isRoot) => {
        const stop = isFunction(isRoot) ? isRoot : never;
        // This is used a *lot* so it needs to be performant, not recursive
        let dom = element.dom;
        const ret = [];
        while (dom.parentNode !== null && dom.parentNode !== undefined) {
            const rawParent = dom.parentNode;
            const p = SugarElement.fromDom(rawParent);
            ret.push(p);
            if (stop(p) === true) {
                break;
            }
            else {
                dom = rawParent;
            }
        }
        return ret;
    };
    const offsetParent = (element) => Optional.from(element.dom.offsetParent).map(SugarElement.fromDom);
    const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
    const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
    const children = (element) => map$2(element.dom.childNodes, SugarElement.fromDom);
    const child$2 = (element, index) => {
        const cs = element.dom.childNodes;
        return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    const firstChild = (element) => child$2(element, 0);
    const spot = (element, offset) => ({
        element,
        offset
    });
    const leaf = (element, offset) => {
        const cs = children(element);
        return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);
    };

    const makeRange = (start, soffset, finish, foffset) => {
        const doc = owner$4(start);
        // TODO: We need to think about a better place to put native range creation code. Does it even belong in sugar?
        // Could the `Compare` checks (node.compareDocumentPosition) handle these situations better?
        const rng = doc.dom.createRange();
        rng.setStart(start.dom, soffset);
        rng.setEnd(finish.dom, foffset);
        return rng;
    };
    const after$2 = (start, soffset, finish, foffset) => {
        const r = makeRange(start, soffset, finish, foffset);
        const same = eq(start, finish) && soffset === foffset;
        return r.collapsed && !same;
    };

    /**
     * Is the element a ShadowRoot?
     *
     * Note: this is insufficient to test if any element is a shadow root, but it is sufficient to differentiate between
     * a Document and a ShadowRoot.
     */
    const isShadowRoot = (dos) => isDocumentFragment(dos) && isNonNullable(dos.dom.host);
    const getRootNode = (e) => SugarElement.fromDom(e.dom.getRootNode());
    /** Where content needs to go. ShadowRoot or document body */
    const getContentContainer = (dos) => 
    // Can't use SugarBody.body without causing a circular module reference (since SugarBody.inBody uses SugarShadowDom)
    isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
    /** Is this element either a ShadowRoot or a descendent of a ShadowRoot. */
    const isInShadowRoot = (e) => getShadowRoot(e).isSome();
    /** If this element is in a ShadowRoot, return it. */
    const getShadowRoot = (e) => {
        const r = getRootNode(e);
        return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    /** Return the host of a ShadowRoot.
     *
     * This function will throw if Shadow DOM is unsupported in the browser, or if the host is null.
     * If you actually have a ShadowRoot, this shouldn't happen.
     */
    const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
    /**
     * When Events bubble up through a ShadowRoot, the browser changes the target to be the shadow host.
     * This function gets the "original" event target if possible.
     * This only works if the shadow tree is open - if the shadow tree is closed, event.target is returned.
     * See: https://developers.google.com/web/fundamentals/web-components/shadowdom#events
     */
    const getOriginalEventTarget = (event) => {
        if (isNonNullable(event.target)) {
            const el = SugarElement.fromDom(event.target);
            if (isElement$1(el) && isOpenShadowHost(el)) {
                // When target element is inside Shadow DOM we need to take first element from composedPath
                // otherwise we'll get Shadow Root parent, not actual target element.
                if (event.composed && event.composedPath) {
                    const composedPath = event.composedPath();
                    if (composedPath) {
                        return head(composedPath);
                    }
                }
            }
        }
        return Optional.from(event.target);
    };
    /** Return true if the element is a host of an open shadow root.
     *  Return false if the element is a host of a closed shadow root, or if the element is not a host.
     */
    const isOpenShadowHost = (element) => isNonNullable(element.dom.shadowRoot);

    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({
        target,
        x,
        y,
        stop,
        prevent,
        kill,
        raw
    });
    /** Wraps an Event in an EventArgs structure.
     * The returned EventArgs structure has its target set to the "original" target if possible.
     * See SugarShadowDom.getOriginalEventTarget
     */
    const fromRawEvent$1 = (rawEvent) => {
        const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
        const stop = () => rawEvent.stopPropagation();
        const prevent = () => rawEvent.preventDefault();
        const kill = compose(prevent, stop); // more of a sequence than a compose, but same effect
        // FIX: Don't just expose the raw event. Need to identify what needs standardisation.
        return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    const handle = (filter, handler) => (rawEvent) => {
        if (filter(rawEvent)) {
            handler(fromRawEvent$1(rawEvent));
        }
    };
    const binder = (element, event, filter, handler, useCapture) => {
        const wrapped = handle(filter, handler);
        // IE9 minimum
        element.dom.addEventListener(event, wrapped, useCapture);
        return {
            unbind: curry(unbind, element, event, wrapped, useCapture)
        };
    };
    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);
    const capture$1 = (element, event, filter, handler) => binder(element, event, filter, handler, true);
    const unbind = (element, event, handler, useCapture) => {
        // IE9 minimum
        element.dom.removeEventListener(event, handler, useCapture);
    };

    const filter = always; // no filter on plain DomEvents
    const bind$1 = (element, event, handler) => bind$2(element, event, filter, handler);
    const capture = (element, event, handler) => capture$1(element, event, filter, handler);
    const fromRawEvent = fromRawEvent$1;

    const getDocument = () => SugarElement.fromDom(document);

    const focus$4 = (element, preventScroll = false) => element.dom.focus({ preventScroll });
    const blur$1 = (element) => element.dom.blur();
    const hasFocus = (element) => {
        const root = getRootNode(element).dom;
        return element.dom === root.activeElement;
    };
    // Note: assuming that activeElement will always be a HTMLElement (maybe we should add a runtime check?)
    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
    /**
     * Return the descendant element that has focus.
     * Use instead of SelectorFind.descendant(container, ':focus')
     *  because the :focus selector relies on keyboard focus.
     */
    const search = (element) => active$1(getRootNode(element))
        .filter((e) => element.dom.contains(e.dom));

    const before$1 = (marker, element) => {
        const parent$1 = parent(marker);
        parent$1.each((v) => {
            v.dom.insertBefore(element.dom, marker.dom);
        });
    };
    const after$1 = (marker, element) => {
        const sibling = nextSibling(marker);
        sibling.fold(() => {
            const parent$1 = parent(marker);
            parent$1.each((v) => {
                append$2(v, element);
            });
        }, (v) => {
            before$1(v, element);
        });
    };
    const prepend$1 = (parent, element) => {
        const firstChild$1 = firstChild(parent);
        firstChild$1.fold(() => {
            append$2(parent, element);
        }, (v) => {
            parent.dom.insertBefore(element.dom, v.dom);
        });
    };
    const append$2 = (parent, element) => {
        parent.dom.appendChild(element.dom);
    };
    const appendAt = (parent, element, index) => {
        child$2(parent, index).fold(() => {
            append$2(parent, element);
        }, (v) => {
            before$1(v, element);
        });
    };

    const append$1 = (parent, elements) => {
        each$1(elements, (x) => {
            append$2(parent, x);
        });
    };

    const rawSet = (dom, key, value) => {
        /*
         * JQuery coerced everything to a string, and silently did nothing on text node/null/undefined.
         *
         * We fail on those invalid cases, only allowing numbers and booleans.
         */
        if (isString(value) || isBoolean(value) || isNumber(value)) {
            dom.setAttribute(key, value + '');
        }
        else {
            // eslint-disable-next-line no-console
            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
            throw new Error('Attribute value was not simple');
        }
    };
    const set$9 = (element, key, value) => {
        rawSet(element.dom, key, value);
    };
    const setAll$1 = (element, attrs) => {
        const dom = element.dom;
        each(attrs, (v, k) => {
            rawSet(dom, k, v);
        });
    };
    const get$g = (element, key) => {
        const v = element.dom.getAttribute(key);
        // undefined is the more appropriate value for JS, and this matches JQuery
        return v === null ? undefined : v;
    };
    const getOpt = (element, key) => Optional.from(get$g(element, key));
    const has$1 = (element, key) => {
        const dom = element.dom;
        // return false for non-element nodes, no point in throwing an error
        return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
    };
    const remove$8 = (element, key) => {
        element.dom.removeAttribute(key);
    };
    const clone$2 = (element) => foldl(element.dom.attributes, (acc, attr) => {
        acc[attr.name] = attr.value;
        return acc;
    }, {});

    const empty = (element) => {
        // shortcut "empty node" trick. Requires IE 9.
        element.dom.textContent = '';
        // If the contents was a single empty text node, the above doesn't remove it. But, it's still faster in general
        // than removing every child node manually.
        // The following is (probably) safe for performance as 99.9% of the time the trick works and
        // Traverse.children will return an empty array.
        each$1(children(element), (rogue) => {
            remove$7(rogue);
        });
    };
    const remove$7 = (element) => {
        const dom = element.dom;
        if (dom.parentNode !== null) {
            dom.parentNode.removeChild(dom);
        }
    };

    const clone$1 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
    /** Shallow clone - just the tag, no children */
    const shallow = (original) => clone$1(original, false);
    /** Deep clone - everything copied including children */
    const deep = (original) => clone$1(original, true);

    const fromHtml$1 = (html, scope) => {
        const doc = scope || document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        return children(SugarElement.fromDom(div));
    };

    const get$f = (element) => element.dom.innerHTML;
    const set$8 = (element, content) => {
        const owner = owner$4(element);
        const docDom = owner.dom;
        // FireFox has *terrible* performance when using innerHTML = x
        const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
        const contentElements = fromHtml$1(content, docDom);
        append$1(fragment, contentElements);
        empty(element);
        append$2(element, fragment);
    };
    const getOuter$2 = (element) => {
        const container = SugarElement.fromTag('div');
        const clone = SugarElement.fromDom(element.dom.cloneNode(true));
        append$2(container, clone);
        return get$f(container);
    };

    const getHtml = (element) => {
        if (isShadowRoot(element)) {
            return '#shadow-root';
        }
        else {
            const clone = shallow(element);
            return getOuter$2(clone);
        }
    };

    const image = (image) => new Promise((resolve, reject) => {
        const loaded = () => {
            destroy();
            resolve(image);
        };
        const listeners = [
            bind$1(image, 'load', loaded),
            bind$1(image, 'error', () => {
                destroy();
                reject('Unable to load data from image: ' + image.dom.src);
            }),
        ];
        const destroy = () => each$1(listeners, (l) => l.unbind());
        if (image.dom.complete) {
            loaded();
        }
    });

    // some elements, such as mathml, don't have style attributes
    // others, such as angular elements, have style attributes that aren't a CSSStyleDeclaration
    const isSupported = (dom) => dom.style !== undefined && isFunction(dom.style.getPropertyValue);

    // Node.contains() is very, very, very good performance
    // http://jsperf.com/closest-vs-contains/5
    const inBody = (element) => {
        // Technically this is only required on IE, where contains() returns false for text nodes.
        // But it's cheap enough to run everywhere and Sugar doesn't have platform detection (yet).
        const dom = isText(element) ? element.dom.parentNode : element.dom;
        // use ownerDocument.body to ensure this works inside iframes.
        // Normally contains is bad because an element "contains" itself, but here we want that.
        if (dom === undefined || dom === null || dom.ownerDocument === null) {
            return false;
        }
        const doc = dom.ownerDocument;
        return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));
    };
    const body = () => getBody(SugarElement.fromDom(document));
    const getBody = (doc) => {
        const b = doc.dom.body;
        if (b === null || b === undefined) {
            throw new Error('Body is not available yet');
        }
        return SugarElement.fromDom(b);
    };

    const internalSet = (dom, property, value) => {
        // This is going to hurt. Apologies.
        // JQuery coerces numbers to pixels for certain property names, and other times lets numbers through.
        // we're going to be explicit; strings only.
        if (!isString(value)) {
            // eslint-disable-next-line no-console
            console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
            throw new Error('CSS value must be a string: ' + value);
        }
        // removed: support for dom().style[property] where prop is camel case instead of normal property name
        if (isSupported(dom)) {
            dom.style.setProperty(property, value);
        }
    };
    const internalRemove = (dom, property) => {
        /*
         * IE9 and above - MDN doesn't have details, but here's a couple of random internet claims
         *
         * http://help.dottoro.com/ljopsjck.php
         * http://stackoverflow.com/a/7901886/7546
         */
        if (isSupported(dom)) {
            dom.style.removeProperty(property);
        }
    };
    const set$7 = (element, property, value) => {
        const dom = element.dom;
        internalSet(dom, property, value);
    };
    const setAll = (element, css) => {
        const dom = element.dom;
        each(css, (v, k) => {
            internalSet(dom, k, v);
        });
    };
    const setOptions = (element, css) => {
        const dom = element.dom;
        each(css, (v, k) => {
            v.fold(() => {
                internalRemove(dom, k);
            }, (value) => {
                internalSet(dom, k, value);
            });
        });
    };
    /*
     * NOTE: For certain properties, this returns the "used value" which is subtly different to the "computed value" (despite calling getComputedStyle).
     * Blame CSS 2.0.
     *
     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     */
    const get$e = (element, property) => {
        const dom = element.dom;
        /*
         * IE9 and above per
         * https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle
         *
         * Not in numerosity, because it doesn't memoize and looking this up dynamically in performance critical code would be horrendous.
         *
         * JQuery has some magic here for IE popups, but we don't really need that.
         * It also uses element.ownerDocument.defaultView to handle iframes but that hasn't been required since FF 3.6.
         */
        const styles = window.getComputedStyle(dom);
        const r = styles.getPropertyValue(property);
        // jquery-ism: If r is an empty string, check that the element is not in a document. If it isn't, return the raw value.
        // Turns out we do this a lot.
        return (r === '' && !inBody(element)) ? getUnsafeProperty(dom, property) : r;
    };
    // removed: support for dom().style[property] where prop is camel case instead of normal property name
    // empty string is what the browsers (IE11 and Chrome) return when the propertyValue doesn't exists.
    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';
    /*
     * Gets the raw value from the style attribute. Useful for retrieving "used values" from the DOM:
     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     *
     * Returns NONE if the property isn't set, or the value is an empty string.
     */
    const getRaw = (element, property) => {
        const dom = element.dom;
        const raw = getUnsafeProperty(dom, property);
        return Optional.from(raw).filter((r) => r.length > 0);
    };
    const getAllRaw = (element) => {
        const css = {};
        const dom = element.dom;
        if (isSupported(dom)) {
            for (let i = 0; i < dom.style.length; i++) {
                const ruleName = dom.style.item(i);
                css[ruleName] = dom.style[ruleName];
            }
        }
        return css;
    };
    const isValidValue$1 = (tag, property, value) => {
        const element = SugarElement.fromTag(tag);
        set$7(element, property, value);
        const style = getRaw(element, property);
        return style.isSome();
    };
    const remove$6 = (element, property) => {
        const dom = element.dom;
        internalRemove(dom, property);
        if (is$1(getOpt(element, 'style').map(trim$1), '')) {
            // No more styles left, remove the style attribute as well
            remove$8(element, 'style');
        }
    };
    /* NOTE: This function is here for the side effect it triggers.
    The value itself is not used.
    Be sure to not use the return value, and that it is not removed by a minifier.
     */
    const reflow = (e) => e.dom.offsetWidth;

    const Dimension = (name, getOffset) => {
        const set = (element, h) => {
            if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
                throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
            }
            const dom = element.dom;
            if (isSupported(dom)) {
                dom.style[name] = h + 'px';
            }
        };
        /*
         * jQuery supports querying width and height on the document and window objects.
         *
         * TBIO doesn't do this, so the code is removed to save space, but left here just in case.
         */
        /*
        var getDocumentWidth = (element) => {
          var dom = element.dom;
          if (Node.isDocument(element)) {
            var body = dom.body;
            var doc = dom.documentElement;
            return Math.max(
              body.scrollHeight,
              doc.scrollHeight,
              body.offsetHeight,
              doc.offsetHeight,
              doc.clientHeight
            );
          }
        };
      
        var getWindowWidth = (element) => {
          var dom = element.dom;
          if (dom.window === dom) {
            // There is no offsetHeight on a window, so use the clientHeight of the document
            return dom.document.documentElement.clientHeight;
          }
        };
      */
        const get = (element) => {
            const r = getOffset(element);
            // zero or null means non-standard or disconnected, fall back to CSS
            if (r <= 0 || r === null) {
                const css = get$e(element, name);
                // ugh this feels dirty, but it saves cycles
                return parseFloat(css) || 0;
            }
            return r;
        };
        // in jQuery, getOuter replicates (or uses) box-sizing: border-box calculations
        // although these calculations only seem relevant for quirks mode, and edge cases TBIO doesn't rely on
        const getOuter = get;
        const aggregate = (element, properties) => foldl(properties, (acc, property) => {
            const val = get$e(element, property);
            const value = val === undefined ? 0 : parseInt(val, 10);
            return isNaN(value) ? acc : acc + value;
        }, 0);
        const max = (element, value, properties) => {
            const cumulativeInclusions = aggregate(element, properties);
            // if max-height is 100px and your cumulativeInclusions is 150px, there is no way max-height can be 100px, so we return 0.
            const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
            return absoluteMax;
        };
        return {
            set,
            get,
            getOuter,
            aggregate,
            max
        };
    };

    const api$2 = Dimension('height', (element) => {
        // getBoundingClientRect gives better results than offsetHeight for tables with captions on Firefox
        const dom = element.dom;
        return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    const get$d = (element) => api$2.get(element);
    const getOuter$1 = (element) => api$2.getOuter(element);
    const setMax$1 = (element, value) => {
        // These properties affect the absolute max-height, they are not counted natively, we want to include these properties.
        const inclusions = ['margin-top', 'border-top-width', 'padding-top', 'padding-bottom', 'border-bottom-width', 'margin-bottom'];
        const absMax = api$2.max(element, value, inclusions);
        set$7(element, 'max-height', absMax + 'px');
    };

    const isHidden$1 = (dom) => dom.offsetWidth <= 0 && dom.offsetHeight <= 0;
    const isVisible = (element) => !isHidden$1(element.dom);

    const api$1 = Dimension('width', (element) => {
        const dom = element.dom;
        return inBody(element) ? dom.getBoundingClientRect().width : dom.offsetWidth;
    });
    const set$6 = (element, h) => api$1.set(element, h);
    const get$c = (element) => api$1.get(element);
    const getOuter = (element) => api$1.getOuter(element);
    const setMax = (element, value) => {
        // These properties affect the absolute max-height, they are not counted natively, we want to include these properties.
        const inclusions = ['margin-left', 'border-left-width', 'padding-left', 'padding-right', 'border-right-width', 'margin-right'];
        const absMax = api$1.max(element, value, inclusions);
        set$7(element, 'max-width', absMax + 'px');
    };

    const r$1 = (left, top) => {
        const translate = (x, y) => r$1(left + x, top + y);
        return {
            left,
            top,
            translate
        };
    };
    // tslint:disable-next-line:variable-name
    const SugarPosition = r$1;

    const boxPosition = (dom) => {
        const box = dom.getBoundingClientRect();
        return SugarPosition(box.left, box.top);
    };
    // Avoids falsy false fallthrough
    const firstDefinedOrZero = (a, b) => {
        if (a !== undefined) {
            return a;
        }
        else {
            return b !== undefined ? b : 0;
        }
    };
    const absolute$3 = (element) => {
        const doc = element.dom.ownerDocument;
        const body = doc.body;
        const win = doc.defaultView;
        const html = doc.documentElement;
        if (body === element.dom) {
            return SugarPosition(body.offsetLeft, body.offsetTop);
        }
        const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
        const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
        const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
        const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
        return viewport$1(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    const viewport$1 = (element) => {
        const dom = element.dom;
        const doc = dom.ownerDocument;
        const body = doc.body;
        if (body === dom) {
            return SugarPosition(body.offsetLeft, body.offsetTop);
        }
        if (!inBody(element)) {
            return SugarPosition(0, 0);
        }
        return boxPosition(dom);
    };

    // get scroll position (x,y) relative to document _doc (or global if not supplied)
    const get$b = (_DOC) => {
        const doc = _DOC !== undefined ? _DOC.dom : document;
        // ASSUMPTION: This is for cross-browser support, body works for Safari & EDGE, and when we have an iframe body scroller
        const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
        const y = doc.body.scrollTop || doc.documentElement.scrollTop;
        return SugarPosition(x, y);
    };
    // Scroll content to (x,y) relative to document _doc (or global if not supplied)
    const to = (x, y, _DOC) => {
        const doc = _DOC !== undefined ? _DOC.dom : document;
        const win = doc.defaultView;
        if (win) {
            win.scrollTo(x, y);
        }
    };

    const NodeValue = (is, name) => {
        const get = (element) => {
            if (!is(element)) {
                throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
            }
            return getOption(element).getOr('');
        };
        const getOption = (element) => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
        const set = (element, value) => {
            if (!is(element)) {
                throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
            }
            element.dom.nodeValue = value;
        };
        return {
            get,
            getOption,
            set
        };
    };

    const api = NodeValue(isText, 'text');
    const get$a = (element) => api.get(element);

    const onDirection = (isLtr, isRtl) => (element) => getDirection(element) === 'rtl' ? isRtl : isLtr;
    const getDirection = (element) => get$e(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';

    // Methods for handling attributes that contain a list of values <div foo="alpha beta theta">
    const read$2 = (element, attr) => {
        const value = get$g(element, attr);
        return value === undefined || value === '' ? [] : value.split(' ');
    };
    const add$4 = (element, attr, id) => {
        const old = read$2(element, attr);
        const nu = old.concat([id]);
        set$9(element, attr, nu.join(' '));
        return true;
    };
    const remove$5 = (element, attr, id) => {
        const nu = filter$2(read$2(element, attr), (v) => v !== id);
        if (nu.length > 0) {
            set$9(element, attr, nu.join(' '));
        }
        else {
            remove$8(element, attr);
        }
        return false;
    };

    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {
        if (is(scope, a)) {
            return Optional.some(scope);
        }
        else if (isFunction(isRoot) && isRoot(scope)) {
            return Optional.none();
        }
        else {
            return ancestor(scope, a, isRoot);
        }
    };

    const ancestor$2 = (scope, predicate, isRoot) => {
        let element = scope.dom;
        const stop = isFunction(isRoot) ? isRoot : never;
        while (element.parentNode) {
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            if (predicate(el)) {
                return Optional.some(el);
            }
            else if (stop(el)) {
                break;
            }
        }
        return Optional.none();
    };
    const closest$4 = (scope, predicate, isRoot) => {
        // This is required to avoid ClosestOrAncestor passing the predicate to itself
        const is = (s, test) => test(s);
        return ClosestOrAncestor(is, ancestor$2, scope, predicate, isRoot);
    };
    const sibling$1 = (scope, predicate) => {
        const element = scope.dom;
        if (!element.parentNode) {
            return Optional.none();
        }
        return child$1(SugarElement.fromDom(element.parentNode), (x) => !eq(scope, x) && predicate(x));
    };
    const child$1 = (scope, predicate) => {
        const pred = (node) => predicate(SugarElement.fromDom(node));
        const result = find$5(scope.dom.childNodes, pred);
        return result.map(SugarElement.fromDom);
    };
    const descendant$1 = (scope, predicate) => {
        const descend = (node) => {
            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < node.childNodes.length; i++) {
                const child = SugarElement.fromDom(node.childNodes[i]);
                if (predicate(child)) {
                    return Optional.some(child);
                }
                const res = descend(node.childNodes[i]);
                if (res.isSome()) {
                    return res;
                }
            }
            return Optional.none();
        };
        return descend(scope.dom);
    };

    // TODO: An internal SelectorFilter module that doesn't SugarElement.fromDom() everything
    const first = (selector) => one(selector);
    const ancestor$1 = (scope, selector, isRoot) => ancestor$2(scope, (e) => is(e, selector), isRoot);
    const sibling = (scope, selector) => sibling$1(scope, (e) => is(e, selector));
    const child = (scope, selector) => child$1(scope, (e) => is(e, selector));
    const descendant = (scope, selector) => one(selector, scope);
    // Returns Some(closest ancestor element (sugared)) matching 'selector' up to isRoot, or None() otherwise
    const closest$3 = (scope, selector, isRoot) => {
        const is$1 = (element, selector) => is(element, selector);
        return ClosestOrAncestor(is$1, ancestor$1, scope, selector, isRoot);
    };

    const set$5 = (element, status) => {
        element.dom.checked = status;
    };
    const get$9 = (element) => element.dom.checked;

    // IE11 Can return undefined for a classList on elements such as math, so we make sure it's not undefined before attempting to use it.
    const supports = (element) => element.dom.classList !== undefined;
    const get$8 = (element) => read$2(element, 'class');
    const add$3 = (element, clazz) => add$4(element, 'class', clazz);
    const remove$4 = (element, clazz) => remove$5(element, 'class', clazz);
    const toggle$5 = (element, clazz) => {
        if (contains$2(get$8(element), clazz)) {
            return remove$4(element, clazz);
        }
        else {
            return add$3(element, clazz);
        }
    };

    /*
     * ClassList is IE10 minimum:
     * https://developer.mozilla.org/en-US/docs/Web/API/Element.classList
     *
     * Note that IE doesn't support the second argument to toggle (at all).
     * If it did, the toggler could be better.
     */
    const add$2 = (element, clazz) => {
        if (supports(element)) {
            element.dom.classList.add(clazz);
        }
        else {
            add$3(element, clazz);
        }
    };
    const cleanClass = (element) => {
        const classList = supports(element) ? element.dom.classList : get$8(element);
        // classList is a "live list", so this is up to date already
        if (classList.length === 0) {
            // No more classes left, remove the class attribute as well
            remove$8(element, 'class');
        }
    };
    const remove$3 = (element, clazz) => {
        if (supports(element)) {
            const classList = element.dom.classList;
            classList.remove(clazz);
        }
        else {
            remove$4(element, clazz);
        }
        cleanClass(element);
    };
    const toggle$4 = (element, clazz) => {
        const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$5(element, clazz);
        cleanClass(element);
        return result;
    };
    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);

    /*
     * ClassList is IE10 minimum:
     * https://developer.mozilla.org/en-US/docs/Web/API/Element.classList
     */
    const add$1 = (element, classes) => {
        each$1(classes, (x) => {
            add$2(element, x);
        });
    };
    const remove$2 = (element, classes) => {
        each$1(classes, (x) => {
            remove$3(element, x);
        });
    };
    const toggle$3 = (element, classes) => {
        each$1(classes, (x) => {
            toggle$4(element, x);
        });
    };
    const hasAll = (element, classes) => forall(classes, (clazz) => has(element, clazz));
    const getNative = (element) => {
        const classList = element.dom.classList;
        const r = new Array(classList.length);
        for (let i = 0; i < classList.length; i++) {
            const item = classList.item(i);
            if (item !== null) {
                r[i] = item;
            }
        }
        return r;
    };
    const get$7 = (element) => supports(element) ? getNative(element) : get$8(element);

    const get$6 = (element) => element.dom.textContent;

    const get$5 = (element) => element.dom.value;
    const set$4 = (element, value) => {
        if (value === undefined) {
            throw new Error('Value.set was undefined');
        }
        element.dom.value = value;
    };

    const ancestors = (scope, predicate, isRoot) => filter$2(parents(scope, isRoot), predicate);

    const descendants = (scope, selector) => all$3(selector, scope);

    const closest$2 = (scope, predicate, isRoot) => closest$4(scope, predicate, isRoot).isSome();

    const closest$1 = (scope, selector, isRoot) => closest$3(scope, selector, isRoot).isSome();

    const ensureIsRoot = (isRoot) => isFunction(isRoot) ? isRoot : never;
    const ancestor = (scope, transform, isRoot) => {
        let element = scope.dom;
        const stop = ensureIsRoot(isRoot);
        while (element.parentNode) {
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            const transformed = transform(el);
            if (transformed.isSome()) {
                return transformed;
            }
            else if (stop(el)) {
                break;
            }
        }
        return Optional.none();
    };
    const closest = (scope, transform, isRoot) => {
        const current = transform(scope);
        const stop = ensureIsRoot(isRoot);
        return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));
    };

    const create$5 = (start, soffset, finish, foffset) => ({
        start,
        soffset,
        finish,
        foffset
    });
    // tslint:disable-next-line:variable-name
    const SimRange = {
        create: create$5
    };

    const adt$9 = Adt.generate([
        { before: ['element'] },
        { on: ['element', 'offset'] },
        { after: ['element'] }
    ]);
    // Probably don't need this given that we now have "match"
    const cata$2 = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
    const getStart$1 = (situ) => situ.fold(identity, identity, identity);
    const before = adt$9.before;
    const on$1 = adt$9.on;
    const after = adt$9.after;
    // tslint:disable-next-line:variable-name
    const Situ = {
        before,
        on: on$1,
        after,
        cata: cata$2,
        getStart: getStart$1
    };

    // Consider adding a type for "element"
    const adt$8 = Adt.generate([
        { domRange: ['rng'] },
        { relative: ['startSitu', 'finishSitu'] },
        { exact: ['start', 'soffset', 'finish', 'foffset'] }
    ]);
    const exactFromRange = (simRange) => adt$8.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
    const getStart = (selection) => selection.match({
        domRange: (rng) => SugarElement.fromDom(rng.startContainer),
        relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
        exact: (start, _soffset, _finish, _foffset) => start
    });
    const domRange = adt$8.domRange;
    const relative$1 = adt$8.relative;
    const exact = adt$8.exact;
    const getWin = (selection) => {
        const start = getStart(selection);
        return defaultView(start);
    };
    // This is out of place but it's API so I can't remove it
    const range$1 = SimRange.create;
    // tslint:disable-next-line:variable-name
    const SimSelection = {
        domRange,
        relative: relative$1,
        exact,
        exactFromRange,
        getWin,
        range: range$1
    };

    const getNativeSelection = (win) => Optional.from(win.getSelection());
    // NOTE: We are still reading the range because it gives subtly different behaviour
    // than using the anchorNode and focusNode. I'm not sure if this behaviour is any
    // better or worse; it's just different.
    const readRange = (selection) => {
        if (selection.rangeCount > 0) {
            const firstRng = selection.getRangeAt(0);
            const lastRng = selection.getRangeAt(selection.rangeCount - 1);
            return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));
        }
        else {
            return Optional.none();
        }
    };
    const doGetExact = (selection) => {
        if (selection.anchorNode === null || selection.focusNode === null) {
            return readRange(selection);
        }
        else {
            const anchor = SugarElement.fromDom(selection.anchorNode);
            const focus = SugarElement.fromDom(selection.focusNode);
            // if this returns true anchor is _after_ focus, so we need a custom selection object to maintain the RTL selection
            return after$2(anchor, selection.anchorOffset, focus, selection.focusOffset) ? Optional.some(SimRange.create(anchor, selection.anchorOffset, focus, selection.focusOffset)) : readRange(selection);
        }
    };
    const getExact = (win) => 
    // We want to retrieve the selection as it is.
    getNativeSelection(win)
        .filter((sel) => sel.rangeCount > 0)
        .bind(doGetExact);
    const getFirstRect = (win, selection) => {
        const rng = asLtrRange(win, selection);
        return getFirstRect$1(rng);
    };
    const getBounds$2 = (win, selection) => {
        const rng = asLtrRange(win, selection);
        return getBounds$3(rng);
    };

    const units = {
        // we don't really support all of these different ways to express a length
        unsupportedLength: [
            'em',
            'ex',
            'cap',
            'ch',
            'ic',
            'rem',
            'lh',
            'rlh',
            'vw',
            'vh',
            'vi',
            'vb',
            'vmin',
            'vmax',
            'cm',
            'mm',
            'Q',
            'in',
            'pc',
            'pt',
            'px'
        ],
        // these are the length values we do support
        fixed: ['px', 'pt'],
        relative: ['%'],
        empty: ['']
    };
    // Built from https://tc39.es/ecma262/#prod-StrDecimalLiteral
    // Matches a float followed by a trailing set of characters
    const pattern = (() => {
        const decimalDigits = '[0-9]+';
        const signedInteger = '[+-]?' + decimalDigits;
        const exponentPart = '[eE]' + signedInteger;
        const dot = '\\.';
        const opt = (input) => `(?:${input})?`;
        const unsignedDecimalLiteral = [
            'Infinity',
            decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),
            dot + decimalDigits + opt(exponentPart),
            decimalDigits + opt(exponentPart)
        ].join('|');
        const float = `[+-]?(?:${unsignedDecimalLiteral})`;
        return new RegExp(`^(${float})(.*)$`);
    })();
    const isUnit = (unit, accepted) => exists(accepted, (acc) => exists(units[acc], (check) => unit === check));
    const parse = (input, accepted) => {
        const match = Optional.from(pattern.exec(input));
        return match.bind((array) => {
            const value = Number(array[1]);
            const unitRaw = array[2];
            if (isUnit(unitRaw, accepted)) {
                return Optional.some({
                    value,
                    unit: unitRaw
                });
            }
            else {
                return Optional.none();
            }
        });
    };
    const normalise = (input, accepted) => parse(input, accepted).map(({ value, unit }) => value + unit);

    const get$4 = (_win) => {
        const win = _win === undefined ? window : _win;
        if (detect$1().browser.isFirefox()) {
            // TINY-7984: Firefox 91 is returning incorrect values for visualViewport.pageTop, so disable it for now
            return Optional.none();
        }
        else {
            return Optional.from(win.visualViewport);
        }
    };
    const bounds$1 = (x, y, width, height) => ({
        x,
        y,
        width,
        height,
        right: x + width,
        bottom: y + height
    });
    const getBounds$1 = (_win) => {
        const win = _win === undefined ? window : _win;
        const doc = win.document;
        const scroll = get$b(SugarElement.fromDom(doc));
        return get$4(win).fold(() => {
            const html = win.document.documentElement;
            // Don't use window.innerWidth/innerHeight here, as we don't want to include scrollbars
            // since the right/bottom position is based on the edge of the scrollbar not the window
            const width = html.clientWidth;
            const height = html.clientHeight;
            return bounds$1(scroll.left, scroll.top, width, height);
        }, (visualViewport) => 
        // iOS doesn't update the pageTop/pageLeft when element.scrollIntoView() is called, so we need to fallback to the
        // scroll position which will always be less than the page top/left values when page top/left are accurate/correct.
        bounds$1(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));
    };

    const walkUp = (navigation, doc) => {
        const frame = navigation.view(doc);
        return frame.fold(constant$1([]), (f) => {
            const parent = navigation.owner(f);
            const rest = walkUp(navigation, parent);
            return [f].concat(rest);
        });
    };
    // TODO: Why is this an option if it is always some?
    const pathTo = (element, navigation) => {
        const d = navigation.owner(element);
        const paths = walkUp(navigation, d);
        return Optional.some(paths);
    };

    const view = (doc) => {
        var _a;
        // Only walk up to the document this script is defined in.
        // This prevents walking up to the parent window when the editor is in an iframe.
        const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
        return element.map(SugarElement.fromDom);
    };
    const owner$3 = (element) => owner$4(element);

    var Navigation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        view: view,
        owner: owner$3
    });

    const find$2 = (element) => {
        const doc = getDocument();
        const scroll = get$b(doc);
        // Get the path of iframe elements to this element.
        const path = pathTo(element, Navigation);
        return path.fold(curry(absolute$3, element), (frames) => {
            const offset = viewport$1(element);
            const r = foldr(frames, (b, a) => {
                const loc = viewport$1(a);
                return {
                    left: b.left + loc.left,
                    top: b.top + loc.top
                };
            }, { left: 0, top: 0 });
            return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);
        });
    };

    const pointed = (point, width, height) => ({
        point,
        width,
        height
    });
    const rect = (x, y, width, height) => ({
        x,
        y,
        width,
        height
    });
    const bounds = (x, y, width, height) => ({
        x,
        y,
        width,
        height,
        right: x + width,
        bottom: y + height
    });
    const box$1 = (element) => {
        const xy = absolute$3(element);
        const w = getOuter(element);
        const h = getOuter$1(element);
        return bounds(xy.left, xy.top, w, h);
    };
    // NOTE: We used to use AriaFocus.preserve here, but there is no reason to do that now that
    // we are not changing the visibility of the element. Hopefully (2015-09-29).
    const absolute$2 = (element) => {
        const position = find$2(element);
        const width = getOuter(element);
        const height = getOuter$1(element);
        return bounds(position.left, position.top, width, height);
    };
    const constrain = (original, constraint) => {
        const left = Math.max(original.x, constraint.x);
        const top = Math.max(original.y, constraint.y);
        const right = Math.min(original.right, constraint.right);
        const bottom = Math.min(original.bottom, constraint.bottom);
        const width = right - left;
        const height = bottom - top;
        return bounds(left, top, width, height);
    };
    const constrainByMany = (original, constraints) => {
        return foldl(constraints, (acc, c) => constrain(acc, c), original);
    };
    const win = () => getBounds$1(window);

    const isSource = (component, simulatedEvent) => eq(component.element, simulatedEvent.event.target);

    const getOffsetParent = (element) => {
        // Firefox sets the offsetParent to the body when fixed instead of null like
        // all other browsers. So we need to check if the element is fixed and if so then
        // disregard the elements offsetParent.
        const isFixed = is$1(getRaw(element, 'position'), 'fixed');
        const offsetParent$1 = isFixed ? Optional.none() : offsetParent(element);
        return offsetParent$1.orThunk(() => {
            const marker = SugarElement.fromTag('span');
            // PERFORMANCE: Append the marker to the parent element, as adding it before the current element will
            // trigger the styles to be recalculated which is a little costly (particularly in scroll/resize events)
            return parent(element).bind((parent) => {
                append$2(parent, marker);
                const offsetParent$1 = offsetParent(marker);
                remove$7(marker);
                return offsetParent$1;
            });
        });
    };
    /*
     * This allows the absolute coordinates to be obtained by adding the
     * origin to the offset coordinates and not needing to know scroll.
     */
    const getOrigin = (element) => getOffsetParent(element).map(absolute$3).getOrThunk(() => SugarPosition(0, 0));

    const describedBy = (describedElement, describeElement) => {
        const describeId = Optional.from(get$g(describedElement, 'id'))
            .getOrThunk(() => {
            const id = generate$6('aria');
            set$9(describeElement, 'id', id);
            return id;
        });
        set$9(describedElement, 'aria-describedby', describeId);
    };
    const remove$1 = (describedElement) => {
        remove$8(describedElement, 'aria-describedby');
    };

    var SimpleResultType;
    (function (SimpleResultType) {
        SimpleResultType[SimpleResultType["Error"] = 0] = "Error";
        SimpleResultType[SimpleResultType["Value"] = 1] = "Value";
    })(SimpleResultType || (SimpleResultType = {}));
    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);
    const partition$1 = (results) => {
        const values = [];
        const errors = [];
        each$1(results, (obj) => {
            fold$1(obj, (err) => errors.push(err), (val) => values.push(val));
        });
        return { values, errors };
    };
    const mapError = (res, f) => {
        if (res.stype === SimpleResultType.Error) {
            return { stype: SimpleResultType.Error, serror: f(res.serror) };
        }
        else {
            return res;
        }
    };
    const map = (res, f) => {
        if (res.stype === SimpleResultType.Value) {
            return { stype: SimpleResultType.Value, svalue: f(res.svalue) };
        }
        else {
            return res;
        }
    };
    const bind = (res, f) => {
        if (res.stype === SimpleResultType.Value) {
            return f(res.svalue);
        }
        else {
            return res;
        }
    };
    const bindError = (res, f) => {
        if (res.stype === SimpleResultType.Error) {
            return f(res.serror);
        }
        else {
            return res;
        }
    };
    const svalue = (v) => ({ stype: SimpleResultType.Value, svalue: v });
    const serror = (e) => ({ stype: SimpleResultType.Error, serror: e });
    const toResult$1 = (res) => fold$1(res, Result.error, Result.value);
    const fromResult = (res) => res.fold(serror, svalue);
    const SimpleResult = {
        fromResult,
        toResult: toResult$1,
        svalue,
        partition: partition$1,
        serror,
        bind,
        bindError,
        map,
        mapError,
        fold: fold$1
    };

    const formatObj = (input) => {
        return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);
    };
    const formatErrors = (errors) => {
        const es = errors.length > 10 ? errors.slice(0, 10).concat([
            {
                path: [],
                getErrorInfo: constant$1('... (only showing first ten failures)')
            }
        ]) : errors;
        // TODO: Work out a better split between PrettyPrinter and SchemaError
        return map$2(es, (e) => {
            return 'Failed path: (' + e.path.join(' > ') + ')\n' + e.getErrorInfo();
        });
    };

    const nu$7 = (path, getErrorInfo) => {
        return SimpleResult.serror([{
                path,
                // This is lazy so that it isn't calculated unnecessarily
                getErrorInfo
            }]);
    };
    const missingRequired = (path, key, obj) => nu$7(path, () => 'Could not find valid *required* value for "' + key + '" in ' + formatObj(obj));
    const missingKey = (path, key) => nu$7(path, () => 'Choice schema did not contain choice key: "' + key + '"');
    const missingBranch = (path, branches, branch) => nu$7(path, () => 'The chosen schema: "' + branch + '" did not exist in branches: ' + formatObj(branches));
    const unsupportedFields = (path, unsupported) => nu$7(path, () => 'There are unsupported fields: [' + unsupported.join(', ') + '] specified');
    const custom = (path, err) => nu$7(path, constant$1(err));

    const value$1 = (validator) => {
        const extract = (path, val) => {
            return SimpleResult.bindError(validator(val), (err) => custom(path, err));
        };
        const toString = constant$1('val');
        return {
            extract,
            toString
        };
    };
    const anyValue$1 = value$1(SimpleResult.svalue);

    const anyValue = constant$1(anyValue$1);
    const typedValue = (validator, expectedType) => value$1((a) => {
        const actualType = typeof a;
        return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);
    });
    const number = typedValue(isNumber, 'number');
    const string = typedValue(isString, 'string');
    const boolean = typedValue(isBoolean, 'boolean');
    const functionProcessor = typedValue(isFunction, 'function');
    // Test if a value can be copied by the structured clone algorithm and hence sendable via postMessage
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
    // from https://stackoverflow.com/a/32673910/7377237 with adjustments for typescript
    const isPostMessageable = (val) => {
        if (Object(val) !== val) { // Primitive value
            return true;
        }
        switch ({}.toString.call(val).slice(8, -1)) { // Class
            case 'Boolean':
            case 'Number':
            case 'String':
            case 'Date':
            case 'RegExp':
            case 'Blob':
            case 'FileList':
            case 'ImageData':
            case 'ImageBitmap':
            case 'ArrayBuffer':
                return true;
            case 'Array':
            case 'Object':
                return Object.keys(val).every((prop) => isPostMessageable(val[prop]));
            default:
                return false;
        }
    };
    const postMessageable = value$1((a) => {
        if (isPostMessageable(a)) {
            return SimpleResult.svalue(a);
        }
        else {
            return SimpleResult.serror('Expected value to be acceptable for sending via postMessage');
        }
    });

    const required$2 = () => ({ tag: "required" /* FieldPresenceTag.Required */, process: {} });
    const defaultedThunk = (fallbackThunk) => ({ tag: "defaultedThunk" /* FieldPresenceTag.DefaultedThunk */, process: fallbackThunk });
    const defaulted$1 = (fallback) => defaultedThunk(constant$1(fallback));
    const asOption = () => ({ tag: "option" /* FieldPresenceTag.Option */, process: {} });
    const mergeWithThunk = (baseThunk) => ({ tag: "mergeWithThunk" /* FieldPresenceTag.MergeWithThunk */, process: baseThunk });
    const mergeWith = (base) => mergeWithThunk(constant$1(base));

    const field$2 = (key, newKey, presence, prop) => ({ tag: "field" /* FieldTag.Field */, key, newKey, presence, prop });
    const customField$1 = (newKey, instantiator) => ({ tag: "custom" /* FieldTag.CustomField */, newKey, instantiator });
    const fold = (value, ifField, ifCustom) => {
        switch (value.tag) {
            case "field" /* FieldTag.Field */:
                return ifField(value.key, value.newKey, value.presence, value.prop);
            case "custom" /* FieldTag.CustomField */:
                return ifCustom(value.newKey, value.instantiator);
        }
    };

    const mergeValues$1 = (values, base) => {
        return SimpleResult.svalue(deepMerge(base, merge$1.apply(undefined, values)));
    };
    const mergeErrors$1 = (errors) => compose(SimpleResult.serror, flatten)(errors);
    const consolidateObj = (objects, base) => {
        const partition = SimpleResult.partition(objects);
        return partition.errors.length > 0 ? mergeErrors$1(partition.errors) : mergeValues$1(partition.values, base);
    };
    const consolidateArr = (objects) => {
        const partitions = SimpleResult.partition(objects);
        return partitions.errors.length > 0 ? mergeErrors$1(partitions.errors) : SimpleResult.svalue(partitions.values);
    };
    const ResultCombine = {
        consolidateObj,
        consolidateArr
    };

    const requiredAccess = (path, obj, key, bundle) => 
    // In required mode, if it is undefined, it is an error.
    get$h(obj, key).fold(() => missingRequired(path, key, obj), bundle);
    const fallbackAccess = (obj, key, fallback, bundle) => {
        const v = get$h(obj, key).getOrThunk(() => fallback(obj));
        return bundle(v);
    };
    const optionAccess = (obj, key, bundle) => bundle(get$h(obj, key));
    const optionDefaultedAccess = (obj, key, fallback, bundle) => {
        const opt = get$h(obj, key).map((val) => val === true ? fallback(obj) : val);
        return bundle(opt);
    };
    const extractField = (field, path, obj, key, prop) => {
        const bundle = (av) => prop.extract(path.concat([key]), av);
        const bundleAsOption = (optValue) => optValue.fold(() => SimpleResult.svalue(Optional.none()), (ov) => {
            const result = prop.extract(path.concat([key]), ov);
            return SimpleResult.map(result, Optional.some);
        });
        switch (field.tag) {
            case "required" /* FieldPresenceTag.Required */:
                return requiredAccess(path, obj, key, bundle);
            case "defaultedThunk" /* FieldPresenceTag.DefaultedThunk */:
                return fallbackAccess(obj, key, field.process, bundle);
            case "option" /* FieldPresenceTag.Option */:
                return optionAccess(obj, key, bundleAsOption);
            case "defaultedOptionThunk" /* FieldPresenceTag.DefaultedOptionThunk */:
                return optionDefaultedAccess(obj, key, field.process, bundleAsOption);
            case "mergeWithThunk" /* FieldPresenceTag.MergeWithThunk */: {
                return fallbackAccess(obj, key, constant$1({}), (v) => {
                    const result = deepMerge(field.process(obj), v);
                    return bundle(result);
                });
            }
        }
    };
    const extractFields = (path, obj, fields) => {
        const success = {};
        const errors = [];
        // PERFORMANCE: We use a for loop here instead of Arr.each as this is a hot code path
        for (const field of fields) {
            fold(field, (key, newKey, presence, prop) => {
                const result = extractField(presence, path, obj, key, prop);
                SimpleResult.fold(result, (err) => {
                    errors.push(...err);
                }, (res) => {
                    success[newKey] = res;
                });
            }, (newKey, instantiator) => {
                success[newKey] = instantiator(obj);
            });
        }
        return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
    };
    const valueThunk = (getDelegate) => {
        const extract = (path, val) => getDelegate().extract(path, val);
        const toString = () => getDelegate().toString();
        return {
            extract,
            toString
        };
    };
    // This is because Obj.keys can return things where the key is set to undefined.
    const getSetKeys = (obj) => keys(filter$1(obj, isNonNullable));
    const objOfOnly = (fields) => {
        const delegate = objOf(fields);
        const fieldNames = foldr(fields, (acc, value) => {
            return fold(value, (key) => deepMerge(acc, { [key]: true }), constant$1(acc));
        }, {});
        const extract = (path, o) => {
            const keys = isBoolean(o) ? [] : getSetKeys(o);
            const extra = filter$2(keys, (k) => !hasNonNullableKey(fieldNames, k));
            return extra.length === 0 ? delegate.extract(path, o) : unsupportedFields(path, extra);
        };
        return {
            extract,
            toString: delegate.toString
        };
    };
    const objOf = (values) => {
        const extract = (path, o) => extractFields(path, o, values);
        const toString = () => {
            const fieldStrings = map$2(values, (value) => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));
            return 'obj{\n' + fieldStrings.join('\n') + '}';
        };
        return {
            extract,
            toString
        };
    };
    const arrOf = (prop) => {
        const extract = (path, array) => {
            const results = map$2(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));
            return ResultCombine.consolidateArr(results);
        };
        const toString = () => 'array(' + prop.toString() + ')';
        return {
            extract,
            toString
        };
    };
    const oneOf = (props, rawF) => {
        // If f is not supplied, then use identity.
        const f = rawF !== undefined ? rawF : identity;
        const extract = (path, val) => {
            const errors = [];
            // Return on first match
            for (const prop of props) {
                const res = prop.extract(path, val);
                if (res.stype === SimpleResultType.Value) {
                    return {
                        stype: SimpleResultType.Value,
                        svalue: f(res.svalue)
                    };
                }
                errors.push(res);
            }
            // All failed, return errors
            return ResultCombine.consolidateArr(errors);
        };
        const toString = () => 'oneOf(' + map$2(props, (prop) => prop.toString()).join(', ') + ')';
        return {
            extract,
            toString
        };
    };
    const setOf$1 = (validator, prop) => {
        const validateKeys = (path, keys) => arrOf(value$1(validator)).extract(path, keys);
        const extract = (path, o) => {
            //
            const keys$1 = keys(o);
            const validatedKeys = validateKeys(path, keys$1);
            return SimpleResult.bind(validatedKeys, (validKeys) => {
                const schema = map$2(validKeys, (vk) => {
                    return field$2(vk, vk, required$2(), prop);
                });
                return objOf(schema).extract(path, o);
            });
        };
        const toString = () => 'setOf(' + prop.toString() + ')';
        return {
            extract,
            toString
        };
    };
    const thunk = (_desc, processor) => {
        const getP = cached(processor);
        const extract = (path, val) => getP().extract(path, val);
        const toString = () => getP().toString();
        return {
            extract,
            toString
        };
    };
    const arrOfObj = compose(arrOf, objOf);

    const chooseFrom = (path, input, branches, ch) => {
        const fields = get$h(branches, ch);
        return fields.fold(() => missingBranch(path, branches, ch), (vp) => vp.extract(path.concat(['branch: ' + ch]), input));
    };
    // The purpose of choose is to have a key which picks which of the schemas to follow.
    // The key will index into the object of schemas: branches
    const choose$2 = (key, branches) => {
        const extract = (path, input) => {
            const choice = get$h(input, key);
            return choice.fold(() => missingKey(path, key), (chosen) => chooseFrom(path, input, branches, chosen));
        };
        const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);
        return {
            extract,
            toString
        };
    };

    const arrOfVal = () => arrOf(anyValue$1);
    const valueOf = (validator) => value$1((v) => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));
    const setOf = (validator, prop) => setOf$1((v) => SimpleResult.fromResult(validator(v)), prop);
    const extractValue = (label, prop, obj) => {
        const res = prop.extract([label], obj);
        return SimpleResult.mapError(res, (errs) => ({ input: obj, errors: errs }));
    };
    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));
    const getOrDie = (extraction) => {
        return extraction.fold((errInfo) => {
            // A readable version of the error.
            throw new Error(formatError(errInfo));
        }, identity);
    };
    const asRawOrDie$1 = (label, prop, obj) => getOrDie(asRaw(label, prop, obj));
    const formatError = (errInfo) => {
        return 'Errors: \n' + formatErrors(errInfo.errors).join('\n') +
            '\n\nInput object: ' + formatObj(errInfo.input);
    };
    const choose$1 = (key, branches) => choose$2(key, map$1(branches, objOf));
    const thunkOf = (desc, schema) => thunk(desc, schema);

    const field$1 = field$2;
    const customField = customField$1;
    const validateEnum = (values) => valueOf((value) => contains$2(values, value) ?
        Result.value(value) :
        Result.error(`Unsupported value: "${value}", choose one of "${values.join(', ')}".`));
    const required$1 = (key) => field$1(key, key, required$2(), anyValue());
    const requiredOf = (key, schema) => field$1(key, key, required$2(), schema);
    const requiredNumber = (key) => requiredOf(key, number);
    const requiredString = (key) => requiredOf(key, string);
    const requiredStringEnum = (key, values) => field$1(key, key, required$2(), validateEnum(values));
    const requiredFunction = (key) => requiredOf(key, functionProcessor);
    const forbid = (key, message) => field$1(key, key, asOption(), value$1((_v) => SimpleResult.serror('The field: ' + key + ' is forbidden. ' + message)));
    const requiredObjOf = (key, objSchema) => field$1(key, key, required$2(), objOf(objSchema));
    const requiredArrayOfObj = (key, objFields) => field$1(key, key, required$2(), arrOfObj(objFields));
    const requiredArrayOf = (key, schema) => field$1(key, key, required$2(), arrOf(schema));
    const option$3 = (key) => field$1(key, key, asOption(), anyValue());
    const optionOf = (key, schema) => field$1(key, key, asOption(), schema);
    const optionNumber = (key) => optionOf(key, number);
    const optionString = (key) => optionOf(key, string);
    const optionStringEnum = (key, values) => optionOf(key, validateEnum(values));
    const optionBoolean = (key) => optionOf(key, boolean);
    const optionFunction = (key) => optionOf(key, functionProcessor);
    const optionArrayOf = (key, schema) => optionOf(key, arrOf(schema));
    const optionObjOf = (key, objSchema) => optionOf(key, objOf(objSchema));
    const optionObjOfOnly = (key, objSchema) => optionOf(key, objOfOnly(objSchema));
    const defaulted = (key, fallback) => field$1(key, key, defaulted$1(fallback), anyValue());
    const defaultedOf = (key, fallback, schema) => field$1(key, key, defaulted$1(fallback), schema);
    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);
    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);
    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));
    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);
    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);
    const defaultedPostMsg = (key, fallback) => defaultedOf(key, fallback, postMessageable);
    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));
    const defaultedObjOf = (key, fallback, objSchema) => defaultedOf(key, fallback, objOf(objSchema));

    const exclude$1 = (obj, fields) => {
        const r = {};
        each(obj, (v, k) => {
            if (!contains$2(fields, k)) {
                r[k] = v;
            }
        });
        return r;
    };

    const wrap$1 = (key, value) => ({ [key]: value });
    const wrapAll$1 = (keyvalues) => {
        const r = {};
        each$1(keyvalues, (kv) => {
            r[kv.key] = kv.value;
        });
        return r;
    };

    const exclude = (obj, fields) => exclude$1(obj, fields);
    const wrap = (key, value) => wrap$1(key, value);
    const wrapAll = (keyvalues) => wrapAll$1(keyvalues);
    const mergeValues = (values, base) => {
        return values.length === 0 ? Result.value(base) : Result.value(deepMerge(base, merge$1.apply(undefined, values))
        // Merger.deepMerge.apply(undefined, [ base ].concat(values))
        );
    };
    const mergeErrors = (errors) => Result.error(flatten(errors));
    const consolidate = (objs, base) => {
        const partitions = partition$2(objs);
        return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : mergeValues(partitions.values, base);
    };

    const constant = constant$1;
    const touchstart = constant('touchstart');
    const touchmove = constant('touchmove');
    const touchend = constant('touchend');
    const touchcancel = constant('touchcancel');
    const mousedown = constant('mousedown');
    const mousemove = constant('mousemove');
    const mouseout = constant('mouseout');
    const mouseup = constant('mouseup');
    const mouseover = constant('mouseover');
    // Not really a native event as it has to be simulated
    const focusin = constant('focusin');
    const focusout = constant('focusout');
    const keydown = constant('keydown');
    const keyup = constant('keyup');
    const input = constant('input');
    const change = constant('change');
    const click = constant('click');
    const transitioncancel = constant('transitioncancel');
    const transitionend = constant('transitionend');
    const transitionstart = constant('transitionstart');
    const selectstart = constant('selectstart');

    const prefixName = (name) => constant$1('alloy.' + name);
    const alloy = { tap: prefixName('tap') };
    // This is used to pass focus to a component. A component might interpret
    // this event and pass the DOM focus to one of its children, depending on its
    // focus model.
    const focus$3 = prefixName('focus');
    // This event is fired a small amount of time after the blur has fired. This
    // allows the handler to know what was the focused element, and what is now.
    const postBlur = prefixName('blur.post');
    // This event is fired a small amount of time after the paste event has fired.
    const postPaste = prefixName('paste.post');
    // This event is fired by gui.broadcast*. It is defined by 'receivers'
    const receive = prefixName('receive');
    // This event is for executing buttons and things that have (mostly) enter actions
    const execute$5 = prefixName('execute');
    // This event is used by a menu to tell an item to focus itself because it has been
    // selected. This might automatically focus inside the item, it might focus the outer
    // part of the widget etc.
    const focusItem = prefixName('focus.item');
    // This event represents a touchstart and touchend on the same location, and fires on
    // the touchend
    const tap = alloy.tap;
    // This event represents a longpress on the same location
    const longpress = prefixName('longpress');
    // Fire by a child element to tell the outer element to close
    const sandboxClose = prefixName('sandbox.close');
    // Tell the typeahead to cancel any pending fetches (that haven't already executed)
    const typeaheadCancel = prefixName('typeahead.cancel');
    // Fired when adding to a world
    const systemInit = prefixName('system.init');
    // Fired when a touchmove on the document happens
    const documentTouchmove = prefixName('system.touchmove');
    // Fired when a touchend on the document happens
    const documentTouchend = prefixName('system.touchend');
    // Fired when the window scrolls
    const windowScroll = prefixName('system.scroll');
    // Fired when the window resizes
    const windowResize = prefixName('system.resize');
    const attachedToDom = prefixName('system.attached');
    const detachedFromDom = prefixName('system.detached');
    const dismissRequested = prefixName('system.dismissRequested');
    const repositionRequested = prefixName('system.repositionRequested');
    const focusShifted = prefixName('focusmanager.shifted');
    // Fired when slots are made hidden/shown
    const slotVisibility = prefixName('slotcontainer.visibility');
    // Used for containers outside the mothership that scroll. Used by docking.
    const externalElementScroll = prefixName('system.external.element.scroll');
    const changeTab = prefixName('change.tab');
    const dismissTab = prefixName('dismiss.tab');
    const highlight$1 = prefixName('highlight');
    const dehighlight$1 = prefixName('dehighlight');

    const element = (elem) => getHtml(elem);

    const unknown = 'unknown';
    /*
      typescipt qwerk:
      const debugging: boolean = true;
      if (boolean === false) {  -> this throws a type error! // TS2365:Operator '===' cannot be applied to types 'false' and 'true'
        https://www.typescriptlang.org/play/#src=const%20foo%3A%20boolean%20%3D%20true%3B%0D%0A%0D%0Aif%20(foo%20%3D%3D%3D%20false)%20%7B%0D%0A%20%20%20%20%0D%0A%7D
      }
    */
    const debugging = true;
    var EventConfiguration;
    (function (EventConfiguration) {
        EventConfiguration[EventConfiguration["STOP"] = 0] = "STOP";
        EventConfiguration[EventConfiguration["NORMAL"] = 1] = "NORMAL";
        EventConfiguration[EventConfiguration["LOGGING"] = 2] = "LOGGING";
    })(EventConfiguration || (EventConfiguration = {}));
    const eventConfig = Cell({});
    const makeEventLogger = (eventName, initialTarget) => {
        const sequence = [];
        const startTime = new Date().getTime();
        return {
            logEventCut: (_name, target, purpose) => {
                sequence.push({ outcome: 'cut', target, purpose });
            },
            logEventStopped: (_name, target, purpose) => {
                sequence.push({ outcome: 'stopped', target, purpose });
            },
            logNoParent: (_name, target, purpose) => {
                sequence.push({ outcome: 'no-parent', target, purpose });
            },
            logEventNoHandlers: (_name, target) => {
                sequence.push({ outcome: 'no-handlers-left', target });
            },
            logEventResponse: (_name, target, purpose) => {
                sequence.push({ outcome: 'response', purpose, target });
            },
            write: () => {
                const finishTime = new Date().getTime();
                if (contains$2(['mousemove', 'mouseover', 'mouseout', systemInit()], eventName)) {
                    return;
                }
                // eslint-disable-next-line no-console
                console.log(eventName, {
                    event: eventName,
                    time: finishTime - startTime,
                    target: initialTarget.dom,
                    sequence: map$2(sequence, (s) => {
                        if (!contains$2(['cut', 'stopped', 'response'], s.outcome)) {
                            return s.outcome;
                        }
                        else {
                            return '{' + s.purpose + '} ' + s.outcome + ' at (' + element(s.target) + ')';
                        }
                    })
                });
            }
        };
    };
    const processEvent = (eventName, initialTarget, f) => {
        const status = get$h(eventConfig.get(), eventName).orThunk(() => {
            const patterns = keys(eventConfig.get());
            return findMap(patterns, (p) => eventName.indexOf(p) > -1 ? Optional.some(eventConfig.get()[p]) : Optional.none());
        }).getOr(EventConfiguration.NORMAL);
        switch (status) {
            case EventConfiguration.NORMAL:
                return f(noLogger());
            case EventConfiguration.LOGGING: {
                const logger = makeEventLogger(eventName, initialTarget);
                const output = f(logger);
                logger.write();
                return output;
            }
            case EventConfiguration.STOP:
                // Does not even run the function to trigger event and listen to handlers
                return true;
        }
    };
    // Ignore these files in the error stack
    const path = [
        'alloy/data/Fields',
        'alloy/debugging/Debugging'
    ];
    const getTrace = () => {
        if (debugging === false) {
            return unknown;
        }
        const err = new Error();
        if (err.stack !== undefined) {
            const lines = err.stack.split('\n');
            return find$5(lines, (line) => line.indexOf('alloy') > 0 && !exists(path, (p) => line.indexOf(p) > -1)).getOr(unknown);
        }
        else {
            return unknown;
        }
    };
    const ignoreEvent = {
        logEventCut: noop,
        logEventStopped: noop,
        logNoParent: noop,
        logEventNoHandlers: noop,
        logEventResponse: noop,
        write: noop
    };
    const monitorEvent = (eventName, initialTarget, f) => processEvent(eventName, initialTarget, f);
    const noLogger = constant$1(ignoreEvent);

    const menuFields = constant$1([
        required$1('menu'),
        required$1('selectedMenu')
    ]);
    const itemFields = constant$1([
        required$1('item'),
        required$1('selectedItem')
    ]);
    constant$1(objOf(itemFields().concat(menuFields())));
    const itemSchema$3 = constant$1(objOf(itemFields()));

    const _initSize = requiredObjOf('initSize', [
        required$1('numColumns'),
        required$1('numRows')
    ]);
    const itemMarkers = () => requiredOf('markers', itemSchema$3());
    const tieredMenuMarkers = () => requiredObjOf('markers', [
        required$1('backgroundMenu')
    ].concat(menuFields()).concat(itemFields()));
    const markers$1 = (required) => requiredObjOf('markers', map$2(required, required$1));
    const onPresenceHandler = (label, fieldName, presence) => {
        // We care about where the handler was declared (in terms of which schema)
        getTrace();
        return field$1(fieldName, fieldName, presence, 
        // Apply some wrapping to their supplied function
        valueOf((f) => Result.value((...args) => {
            return f.apply(undefined, args);
        })));
    };
    const onHandler = (fieldName) => onPresenceHandler('onHandler', fieldName, defaulted$1(noop));
    const onKeyboardHandler = (fieldName) => onPresenceHandler('onKeyboardHandler', fieldName, defaulted$1(Optional.none));
    const onStrictHandler = (fieldName) => onPresenceHandler('onHandler', fieldName, required$2());
    const onStrictKeyboardHandler = (fieldName) => onPresenceHandler('onKeyboardHandler', fieldName, required$2());
    const output$1 = (name, value) => customField(name, constant$1(value));
    const snapshot = (name) => customField(name, identity);
    const initSize = constant$1(_initSize);

    const markAsBehaviourApi = (f, apiName, apiFunction) => {
        const delegate = apiFunction.toString();
        const endIndex = delegate.indexOf(')') + 1;
        const openBracketIndex = delegate.indexOf('(');
        const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
        f.toFunctionAnnotation = () => ({
            name: apiName,
            parameters: cleanParameters(parameters.slice(0, 1).concat(parameters.slice(3)))
        });
        return f;
    };
    // Remove any comment (/*) at end of parameter names
    const cleanParameters = (parameters) => map$2(parameters, (p) => endsWith(p, '/*') ? p.substring(0, p.length - '/*'.length) : p);
    const markAsExtraApi = (f, extraName) => {
        const delegate = f.toString();
        const endIndex = delegate.indexOf(')') + 1;
        const openBracketIndex = delegate.indexOf('(');
        const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
        f.toFunctionAnnotation = () => ({
            name: extraName,
            parameters: cleanParameters(parameters)
        });
        return f;
    };
    const markAsSketchApi = (f, apiFunction) => {
        const delegate = apiFunction.toString();
        const endIndex = delegate.indexOf(')') + 1;
        const openBracketIndex = delegate.indexOf('(');
        const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
        f.toFunctionAnnotation = () => ({
            name: 'OVERRIDE',
            parameters: cleanParameters(parameters.slice(1))
        });
        return f;
    };

    const DelayedFunction = (fun, delay) => {
        let ref = null;
        const schedule = (...args) => {
            ref = setTimeout(() => {
                fun.apply(null, args);
                ref = null;
            }, delay);
        };
        const cancel = () => {
            if (ref !== null) {
                clearTimeout(ref);
                ref = null;
            }
        };
        return {
            cancel,
            schedule
        };
    };

    const SIGNIFICANT_MOVE = 5;
    const LONGPRESS_DELAY = 400;
    const getTouch = (event) => {
        const raw = event.raw;
        if (raw.touches === undefined || raw.touches.length !== 1) {
            return Optional.none();
        }
        return Optional.some(raw.touches[0]);
    };
    // Check to see if the touch has changed a *significant* amount
    const isFarEnough = (touch, data) => {
        const distX = Math.abs(touch.clientX - data.x);
        const distY = Math.abs(touch.clientY - data.y);
        return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    const monitor = (settings) => {
        /* A tap event is a combination of touchstart and touchend on the same element
         * without a *significant* touchmove in between.
         */
        const startData = value$2();
        const longpressFired = Cell(false);
        const longpress$1 = DelayedFunction((event) => {
            settings.triggerEvent(longpress(), event);
            longpressFired.set(true);
        }, LONGPRESS_DELAY);
        const handleTouchstart = (event) => {
            getTouch(event).each((touch) => {
                longpress$1.cancel();
                const data = {
                    x: touch.clientX,
                    y: touch.clientY,
                    target: event.target
                };
                longpress$1.schedule(event);
                longpressFired.set(false);
                startData.set(data);
            });
            return Optional.none();
        };
        const handleTouchmove = (event) => {
            longpress$1.cancel();
            getTouch(event).each((touch) => {
                startData.on((data) => {
                    if (isFarEnough(touch, data)) {
                        startData.clear();
                    }
                });
            });
            return Optional.none();
        };
        const handleTouchend = (event) => {
            longpress$1.cancel();
            const isSame = (data) => eq(data.target, event.target);
            return startData.get().filter(isSame).map((_data) => {
                if (longpressFired.get()) {
                    event.prevent();
                    return false;
                }
                else {
                    return settings.triggerEvent(tap(), event);
                }
            });
        };
        const handlers = wrapAll([
            { key: touchstart(), value: handleTouchstart },
            { key: touchmove(), value: handleTouchmove },
            { key: touchend(), value: handleTouchend }
        ]);
        const fireIfReady = (event, type) => get$h(handlers, type).bind((handler) => handler(event));
        return {
            fireIfReady
        };
    };

    var FocusInsideModes;
    (function (FocusInsideModes) {
        FocusInsideModes["OnFocusMode"] = "onFocus";
        FocusInsideModes["OnEnterOrSpaceMode"] = "onEnterOrSpace";
        FocusInsideModes["OnApiMode"] = "onApi";
    })(FocusInsideModes || (FocusInsideModes = {}));

    const _placeholder = 'placeholder';
    const adt$7 = Adt.generate([
        { single: ['required', 'valueThunk'] },
        { multiple: ['required', 'valueThunks'] }
    ]);
    const isSubstituted = (spec) => has$2(spec, 'uiType');
    const subPlaceholder = (owner, detail, compSpec, placeholders) => {
        if (owner.exists((o) => o !== compSpec.owner)) {
            return adt$7.single(true, constant$1(compSpec));
        }
        // Ignore having to find something for the time being.
        return get$h(placeholders, compSpec.name).fold(() => {
            throw new Error('Unknown placeholder component: ' + compSpec.name + '\nKnown: [' +
                keys(placeholders) + ']\nNamespace: ' + owner.getOr('none') + '\nSpec: ' + JSON.stringify(compSpec, null, 2));
        }, (newSpec) => 
        // Must return a single/multiple type
        newSpec.replace());
    };
    const scan = (owner, detail, compSpec, placeholders) => {
        if (isSubstituted(compSpec) && compSpec.uiType === _placeholder) {
            return subPlaceholder(owner, detail, compSpec, placeholders);
        }
        else {
            return adt$7.single(false, constant$1(compSpec));
        }
    };
    const substitute = (owner, detail, compSpec, placeholders) => {
        const base = scan(owner, detail, compSpec, placeholders);
        return base.fold((req, valueThunk) => {
            const value = isSubstituted(compSpec) ? valueThunk(detail, compSpec.config, compSpec.validated) : valueThunk(detail);
            const childSpecs = get$h(value, 'components').getOr([]);
            const substituted = bind$3(childSpecs, (c) => substitute(owner, detail, c, placeholders));
            return [
                {
                    ...value,
                    components: substituted
                }
            ];
        }, (req, valuesThunk) => {
            if (isSubstituted(compSpec)) {
                const values = valuesThunk(detail, compSpec.config, compSpec.validated);
                // Allow a preprocessing step for groups before returning the components
                const preprocessor = compSpec.validated.preprocess.getOr(identity);
                return preprocessor(values);
            }
            else {
                return valuesThunk(detail);
            }
        });
    };
    const substituteAll = (owner, detail, components, placeholders) => bind$3(components, (c) => substitute(owner, detail, c, placeholders));
    const oneReplace = (label, replacements) => {
        let called = false;
        const used = () => called;
        const replace = () => {
            if (called) {
                throw new Error('Trying to use the same placeholder more than once: ' + label);
            }
            called = true;
            return replacements;
        };
        const required = () => replacements.fold((req, _) => req, (req, _) => req);
        return {
            name: constant$1(label),
            required,
            used,
            replace
        };
    };
    const substitutePlaces = (owner, detail, components, placeholders) => {
        const ps = map$1(placeholders, (ph, name) => oneReplace(name, ph));
        const outcome = substituteAll(owner, detail, components, ps);
        each(ps, (p) => {
            if (p.used() === false && p.required()) {
                throw new Error('Placeholder: ' + p.name() + ' was not found in components list\nNamespace: ' + owner.getOr('none') + '\nComponents: ' +
                    JSON.stringify(detail.components, null, 2));
            }
        });
        return outcome;
    };
    const single$2 = adt$7.single;
    const multiple = adt$7.multiple;
    const placeholder = constant$1(_placeholder);

    const adt$6 = Adt.generate([
        { required: ['data'] },
        { external: ['data'] },
        { optional: ['data'] },
        { group: ['data'] }
    ]);
    const fFactory = defaulted('factory', { sketch: identity });
    const fSchema = defaulted('schema', []);
    const fName = required$1('name');
    const fPname = field$1('pname', 'pname', defaultedThunk((typeSpec) => '<alloy.' + generate$6(typeSpec.name) + '>'), anyValue());
    // Groups cannot choose their schema.
    const fGroupSchema = customField('schema', () => [
        option$3('preprocess')
    ]);
    const fDefaults = defaulted('defaults', constant$1({}));
    const fOverrides = defaulted('overrides', constant$1({}));
    const requiredSpec = objOf([
        fFactory, fSchema, fName, fPname, fDefaults, fOverrides
    ]);
    const externalSpec = objOf([
        fFactory, fSchema, fName, fDefaults, fOverrides
    ]);
    const optionalSpec = objOf([
        fFactory, fSchema, fName, fPname, fDefaults, fOverrides
    ]);
    const groupSpec = objOf([
        fFactory, fGroupSchema, fName,
        required$1('unit'),
        fPname, fDefaults, fOverrides
    ]);
    const asNamedPart = (part) => {
        return part.fold(Optional.some, Optional.none, Optional.some, Optional.some);
    };
    const name$2 = (part) => {
        const get = (data) => data.name;
        return part.fold(get, get, get, get);
    };
    const asCommon = (part) => {
        return part.fold(identity, identity, identity, identity);
    };
    const convert = (adtConstructor, partSchema) => (spec) => {
        const data = asRawOrDie$1('Converting part type', partSchema, spec);
        return adtConstructor(data);
    };
    const required = convert(adt$6.required, requiredSpec);
    const external$1 = convert(adt$6.external, externalSpec);
    const optional = convert(adt$6.optional, optionalSpec);
    const group = convert(adt$6.group, groupSpec);
    const original = constant$1('entirety');

    var PartType = /*#__PURE__*/Object.freeze({
        __proto__: null,
        required: required,
        external: external$1,
        optional: optional,
        group: group,
        asNamedPart: asNamedPart,
        name: name$2,
        asCommon: asCommon,
        original: original
    });

    const combine$2 = (detail, data, partSpec, partValidated) => 
    // Extremely confusing names and types :(
    deepMerge(data.defaults(detail, partSpec, partValidated), partSpec, { uid: detail.partUids[data.name] }, data.overrides(detail, partSpec, partValidated));
    const subs = (owner, detail, parts) => {
        const internals = {};
        const externals = {};
        each$1(parts, (part) => {
            part.fold(
            // Internal
            (data) => {
                internals[data.pname] = single$2(true, (detail, partSpec, partValidated) => data.factory.sketch(combine$2(detail, data, partSpec, partValidated)));
            }, 
            // External
            (data) => {
                const partSpec = detail.parts[data.name];
                externals[data.name] = constant$1(data.factory.sketch(combine$2(detail, data, partSpec[original()]), partSpec) // This is missing partValidated
                );
                // no placeholders
            }, 
            // Optional
            (data) => {
                internals[data.pname] = single$2(false, (detail, partSpec, partValidated) => data.factory.sketch(combine$2(detail, data, partSpec, partValidated)));
            }, 
            // Group
            (data) => {
                internals[data.pname] = multiple(true, (detail, _partSpec, _partValidated) => {
                    const units = detail[data.name];
                    return map$2(units, (u) => 
                    // Group multiples do not take the uid because there is more than one.
                    data.factory.sketch(deepMerge(data.defaults(detail, u, _partValidated), u, data.overrides(detail, u))));
                });
            });
        });
        return {
            internals: constant$1(internals),
            externals: constant$1(externals)
        };
    };

    // TODO: Make more functional if performance isn't an issue.
    const generate$5 = (owner, parts) => {
        const r = {};
        each$1(parts, (part) => {
            asNamedPart(part).each((np) => {
                const g = doGenerateOne(owner, np.pname);
                r[np.name] = (config) => {
                    const validated = asRawOrDie$1('Part: ' + np.name + ' in ' + owner, objOf(np.schema), config);
                    return {
                        ...g,
                        config,
                        validated
                    };
                };
            });
        });
        return r;
    };
    // Does not have the config.
    const doGenerateOne = (owner, pname) => ({
        uiType: placeholder(),
        owner,
        name: pname
    });
    const generateOne$1 = (owner, pname, config) => ({
        uiType: placeholder(),
        owner,
        name: pname,
        config,
        validated: {}
    });
    const schemas = (parts) => 
    // This actually has to change. It needs to return the schemas for things that will
    // not appear in the components list, which is only externals
    bind$3(parts, (part) => part.fold(Optional.none, Optional.some, Optional.none, Optional.none).map((data) => requiredObjOf(data.name, data.schema.concat([
        snapshot(original())
    ]))).toArray());
    const names = (parts) => map$2(parts, name$2);
    const substitutes = (owner, detail, parts) => subs(owner, detail, parts);
    const components$1 = (owner, detail, internals) => substitutePlaces(Optional.some(owner), detail, detail.components, internals);
    const getPart = (component, detail, partKey) => {
        const uid = detail.partUids[partKey];
        return component.getSystem().getByUid(uid).toOptional();
    };
    const getPartOrDie = (component, detail, partKey) => getPart(component, detail, partKey).getOrDie('Could not find part: ' + partKey);
    const getParts = (component, detail, partKeys) => {
        const r = {};
        const uids = detail.partUids;
        const system = component.getSystem();
        each$1(partKeys, (pk) => {
            r[pk] = constant$1(system.getByUid(uids[pk]));
        });
        return r;
    };
    const getAllParts = (component, detail) => {
        const system = component.getSystem();
        return map$1(detail.partUids, (pUid, _k) => constant$1(system.getByUid(pUid)));
    };
    const getAllPartNames = (detail) => keys(detail.partUids);
    const getPartsOrDie = (component, detail, partKeys) => {
        const r = {};
        const uids = detail.partUids;
        const system = component.getSystem();
        each$1(partKeys, (pk) => {
            r[pk] = constant$1(system.getByUid(uids[pk]).getOrDie());
        });
        return r;
    };
    const defaultUids = (baseUid, partTypes) => {
        const partNames = names(partTypes);
        return wrapAll(map$2(partNames, (pn) => ({ key: pn, value: baseUid + '-' + pn })));
    };
    const defaultUidsSchema = (partTypes) => field$1('partUids', 'partUids', mergeWithThunk((spec) => defaultUids(spec.uid, partTypes)), anyValue());

    var AlloyParts = /*#__PURE__*/Object.freeze({
        __proto__: null,
        generate: generate$5,
        generateOne: generateOne$1,
        schemas: schemas,
        names: names,
        substitutes: substitutes,
        components: components$1,
        defaultUids: defaultUids,
        defaultUidsSchema: defaultUidsSchema,
        getAllParts: getAllParts,
        getAllPartNames: getAllPartNames,
        getPart: getPart,
        getPartOrDie: getPartOrDie,
        getParts: getParts,
        getPartsOrDie: getPartsOrDie
    });

    const allAlignments = [
        'valignCentre',
        'alignLeft',
        'alignRight',
        'alignCentre',
        'top',
        'bottom',
        'left',
        'right',
        'inset'
    ];
    const nu$6 = (xOffset, yOffset, classes, insetModifier = 1) => {
        const insetXOffset = xOffset * insetModifier;
        const insetYOffset = yOffset * insetModifier;
        const getClasses = (prop) => get$h(classes, prop).getOr([]);
        const make = (xDelta, yDelta, alignmentsOn) => {
            const alignmentsOff = difference(allAlignments, alignmentsOn);
            return {
                offset: SugarPosition(xDelta, yDelta),
                classesOn: bind$3(alignmentsOn, getClasses),
                classesOff: bind$3(alignmentsOff, getClasses)
            };
        };
        return {
            southeast: () => make(-xOffset, yOffset, ['top', 'alignLeft']),
            southwest: () => make(xOffset, yOffset, ['top', 'alignRight']),
            south: () => make(-xOffset / 2, yOffset, ['top', 'alignCentre']),
            northeast: () => make(-xOffset, -yOffset, ['bottom', 'alignLeft']),
            northwest: () => make(xOffset, -yOffset, ['bottom', 'alignRight']),
            north: () => make(-xOffset / 2, -yOffset, ['bottom', 'alignCentre']),
            east: () => make(xOffset, -yOffset / 2, ['valignCentre', 'left']),
            west: () => make(-xOffset, -yOffset / 2, ['valignCentre', 'right']),
            insetNortheast: () => make(insetXOffset, insetYOffset, ['top', 'alignLeft', 'inset']),
            insetNorthwest: () => make(-insetXOffset, insetYOffset, ['top', 'alignRight', 'inset']),
            insetNorth: () => make(-insetXOffset / 2, insetYOffset, ['top', 'alignCentre', 'inset']),
            insetSoutheast: () => make(insetXOffset, -insetYOffset, ['bottom', 'alignLeft', 'inset']),
            insetSouthwest: () => make(-insetXOffset, -insetYOffset, ['bottom', 'alignRight', 'inset']),
            insetSouth: () => make(-insetXOffset / 2, -insetYOffset, ['bottom', 'alignCentre', 'inset']),
            insetEast: () => make(-insetXOffset, -insetYOffset / 2, ['valignCentre', 'right', 'inset']),
            insetWest: () => make(insetXOffset, -insetYOffset / 2, ['valignCentre', 'left', 'inset'])
        };
    };
    const fallback = () => nu$6(0, 0, {});

    const nu$5 = (x, y, bubble, direction, placement, boundsRestriction, labelPrefix, alwaysFit = false) => ({
        x,
        y,
        bubble,
        direction,
        placement,
        restriction: boundsRestriction,
        label: `${labelPrefix}-${placement}`,
        alwaysFit
    });

    const adt$5 = Adt.generate([
        { southeast: [] },
        { southwest: [] },
        { northeast: [] },
        { northwest: [] },
        { south: [] },
        { north: [] },
        { east: [] },
        { west: [] }
    ]);
    const cata$1 = (subject, southeast, southwest, northeast, northwest, south, north, east, west) => subject.fold(southeast, southwest, northeast, northwest, south, north, east, west);
    const cataVertical = (subject, south, middle, north) => subject.fold(south, south, north, north, south, north, middle, middle);
    const cataHorizontal = (subject, east, middle, west) => subject.fold(east, west, east, west, middle, middle, east, west);
    // TODO: Simplify with the typescript approach.
    const southeast$3 = adt$5.southeast;
    const southwest$3 = adt$5.southwest;
    const northeast$3 = adt$5.northeast;
    const northwest$3 = adt$5.northwest;
    const south$3 = adt$5.south;
    const north$3 = adt$5.north;
    const east$3 = adt$5.east;
    const west$3 = adt$5.west;

    const getRestriction = (anchor, restriction) => {
        switch (restriction) {
            case 1 /* AnchorBoxBounds.LeftEdge */:
                return anchor.x;
            case 0 /* AnchorBoxBounds.RightEdge */:
                return anchor.x + anchor.width;
            case 2 /* AnchorBoxBounds.TopEdge */:
                return anchor.y;
            case 3 /* AnchorBoxBounds.BottomEdge */:
                return anchor.y + anchor.height;
        }
    };
    const boundsRestriction = (anchor, restrictions) => mapToObject(['left', 'right', 'top', 'bottom'], (dir) => get$h(restrictions, dir).map((restriction) => getRestriction(anchor, restriction)));
    const adjustBounds = (bounds$1, restriction, bubbleOffset) => {
        const applyRestriction = (dir, current) => restriction[dir].map((pos) => {
            const isVerticalAxis = dir === 'top' || dir === 'bottom';
            const offset = isVerticalAxis ? bubbleOffset.top : bubbleOffset.left;
            const comparator = dir === 'left' || dir === 'top' ? Math.max : Math.min;
            const newPos = comparator(pos, current) + offset;
            // Ensure the new restricted position is within the current bounds
            return isVerticalAxis ? clamp(newPos, bounds$1.y, bounds$1.bottom) : clamp(newPos, bounds$1.x, bounds$1.right);
        }).getOr(current);
        const adjustedLeft = applyRestriction('left', bounds$1.x);
        const adjustedTop = applyRestriction('top', bounds$1.y);
        const adjustedRight = applyRestriction('right', bounds$1.right);
        const adjustedBottom = applyRestriction('bottom', bounds$1.bottom);
        return bounds(adjustedLeft, adjustedTop, adjustedRight - adjustedLeft, adjustedBottom - adjustedTop);
    };

    /*
      Layout for menus and inline context dialogs;
      Either above or below. Never left or right.
      Aligned to the left or right of the anchor as appropriate.
     */
    const labelPrefix$2 = 'layout';
    // display element to the right, left edge against the anchor
    const eastX$1 = (anchor) => anchor.x;
    // element centre aligned horizontally with the anchor
    const middleX$1 = (anchor, element) => anchor.x + (anchor.width / 2) - (element.width / 2);
    // display element to the left, right edge against the right of the anchor
    const westX$1 = (anchor, element) => anchor.x + anchor.width - element.width;
    // display element above, bottom edge against the top of the anchor
    const northY$2 = (anchor, element) => anchor.y - element.height;
    // display element below, top edge against the bottom of the anchor
    const southY$2 = (anchor) => anchor.y + anchor.height;
    // display element below, top edge against the bottom of the anchor
    const centreY$1 = (anchor, element) => anchor.y + (anchor.height / 2) - (element.height / 2);
    const eastEdgeX$1 = (anchor) => anchor.x + anchor.width;
    const westEdgeX$1 = (anchor, element) => anchor.x - element.width;
    const southeast$2 = (anchor, element, bubbles) => nu$5(eastX$1(anchor), southY$2(anchor), bubbles.southeast(), southeast$3(), "southeast" /* Placement.Southeast */, boundsRestriction(anchor, { left: 1 /* AnchorBoxBounds.LeftEdge */, top: 3 /* AnchorBoxBounds.BottomEdge */ }), labelPrefix$2);
    const southwest$2 = (anchor, element, bubbles) => nu$5(westX$1(anchor, element), southY$2(anchor), bubbles.southwest(), southwest$3(), "southwest" /* Placement.Southwest */, boundsRestriction(anchor, { right: 0 /* AnchorBoxBounds.RightEdge */, top: 3 /* AnchorBoxBounds.BottomEdge */ }), labelPrefix$2);
    const northeast$2 = (anchor, element, bubbles) => nu$5(eastX$1(anchor), northY$2(anchor, element), bubbles.northeast(), northeast$3(), "northeast" /* Placement.Northeast */, boundsRestriction(anchor, { left: 1 /* AnchorBoxBounds.LeftEdge */, bottom: 2 /* AnchorBoxBounds.TopEdge */ }), labelPrefix$2);
    const northwest$2 = (anchor, element, bubbles) => nu$5(westX$1(anchor, element), northY$2(anchor, element), bubbles.northwest(), northwest$3(), "northwest" /* Placement.Northwest */, boundsRestriction(anchor, { right: 0 /* AnchorBoxBounds.RightEdge */, bottom: 2 /* AnchorBoxBounds.TopEdge */ }), labelPrefix$2);
    const north$2 = (anchor, element, bubbles) => nu$5(middleX$1(anchor, element), northY$2(anchor, element), bubbles.north(), north$3(), "north" /* Placement.North */, boundsRestriction(anchor, { bottom: 2 /* AnchorBoxBounds.TopEdge */ }), labelPrefix$2);
    const south$2 = (anchor, element, bubbles) => nu$5(middleX$1(anchor, element), southY$2(anchor), bubbles.south(), south$3(), "south" /* Placement.South */, boundsRestriction(anchor, { top: 3 /* AnchorBoxBounds.BottomEdge */ }), labelPrefix$2);
    const east$2 = (anchor, element, bubbles) => nu$5(eastEdgeX$1(anchor), centreY$1(anchor, element), bubbles.east(), east$3(), "east" /* Placement.East */, boundsRestriction(anchor, { left: 0 /* AnchorBoxBounds.RightEdge */ }), labelPrefix$2);
    const west$2 = (anchor, element, bubbles) => nu$5(westEdgeX$1(anchor, element), centreY$1(anchor, element), bubbles.west(), west$3(), "west" /* Placement.West */, boundsRestriction(anchor, { right: 1 /* AnchorBoxBounds.LeftEdge */ }), labelPrefix$2);
    const all$2 = () => [southeast$2, southwest$2, northeast$2, northwest$2, south$2, north$2, east$2, west$2];
    const allRtl$1 = () => [southwest$2, southeast$2, northwest$2, northeast$2, south$2, north$2, east$2, west$2];
    const aboveOrBelow = () => [northeast$2, northwest$2, southeast$2, southwest$2, north$2, south$2];
    const aboveOrBelowRtl = () => [northwest$2, northeast$2, southwest$2, southeast$2, north$2, south$2];
    const belowOrAbove = () => [southeast$2, southwest$2, northeast$2, northwest$2, south$2, north$2];
    const belowOrAboveRtl = () => [southwest$2, southeast$2, northwest$2, northeast$2, south$2, north$2];

    const placementAttribute = 'data-alloy-placement';
    const setPlacement$1 = (element, placement) => {
        set$9(element, placementAttribute, placement);
    };
    const getPlacement = (element) => getOpt(element, placementAttribute);
    const reset$2 = (element) => remove$8(element, placementAttribute);

    /*
      Layouts for things that overlay over the anchor element/box. These are designed to mirror
      the `Layout` logic.

      As an example `Layout.north` will appear horizontally centered above the anchor, whereas
      `LayoutInset.north` will appear horizontally centered overlapping the top of the anchor.
     */
    const labelPrefix$1 = 'layout-inset';
    // returns left edge of anchor - used to display element to the left, left edge against the anchor
    const westEdgeX = (anchor) => anchor.x;
    // returns middle of anchor minus half the element width - used to horizontally centre element to the anchor
    const middleX = (anchor, element) => anchor.x + (anchor.width / 2) - (element.width / 2);
    // returns right edge of anchor minus element width - used to display element to the right, right edge against the anchor
    const eastEdgeX = (anchor, element) => anchor.x + anchor.width - element.width;
    // returns top edge - used to display element to the top, top edge against the anchor
    const northY$1 = (anchor) => anchor.y;
    // returns bottom edge minus element height - used to display element at the bottom, bottom edge against the anchor
    const southY$1 = (anchor, element) => anchor.y + anchor.height - element.height;
    // returns centre of anchor minus half the element height - used to vertically centre element to the anchor
    const centreY = (anchor, element) => anchor.y + (anchor.height / 2) - (element.height / 2);
    // positions element relative to the bottom right of the anchor
    const southwest$1 = (anchor, element, bubbles) => nu$5(eastEdgeX(anchor, element), southY$1(anchor, element), bubbles.insetSouthwest(), northwest$3(), "southwest" /* Placement.Southwest */, boundsRestriction(anchor, { right: 0 /* AnchorBoxBounds.RightEdge */, bottom: 3 /* AnchorBoxBounds.BottomEdge */ }), labelPrefix$1);
    // positions element relative to the bottom left of the anchor
    const southeast$1 = (anchor, element, bubbles) => nu$5(westEdgeX(anchor), southY$1(anchor, element), bubbles.insetSoutheast(), northeast$3(), "southeast" /* Placement.Southeast */, boundsRestriction(anchor, { left: 1 /* AnchorBoxBounds.LeftEdge */, bottom: 3 /* AnchorBoxBounds.BottomEdge */ }), labelPrefix$1);
    // positions element relative to the top right of the anchor
    const northwest$1 = (anchor, element, bubbles) => nu$5(eastEdgeX(anchor, element), northY$1(anchor), bubbles.insetNorthwest(), southwest$3(), "northwest" /* Placement.Northwest */, boundsRestriction(anchor, { right: 0 /* AnchorBoxBounds.RightEdge */, top: 2 /* AnchorBoxBounds.TopEdge */ }), labelPrefix$1);
    // positions element relative to the top left of the anchor
    const northeast$1 = (anchor, element, bubbles) => nu$5(westEdgeX(anchor), northY$1(anchor), bubbles.insetNortheast(), southeast$3(), "northeast" /* Placement.Northeast */, boundsRestriction(anchor, { left: 1 /* AnchorBoxBounds.LeftEdge */, top: 2 /* AnchorBoxBounds.TopEdge */ }), labelPrefix$1);
    // positions element relative to the top of the anchor, horizontally centered
    const north$1 = (anchor, element, bubbles) => nu$5(middleX(anchor, element), northY$1(anchor), bubbles.insetNorth(), south$3(), "north" /* Placement.North */, boundsRestriction(anchor, { top: 2 /* AnchorBoxBounds.TopEdge */ }), labelPrefix$1);
    // positions element relative to the bottom of the anchor, horizontally centered
    const south$1 = (anchor, element, bubbles) => nu$5(middleX(anchor, element), southY$1(anchor, element), bubbles.insetSouth(), north$3(), "south" /* Placement.South */, boundsRestriction(anchor, { bottom: 3 /* AnchorBoxBounds.BottomEdge */ }), labelPrefix$1);
    // positions element with the right edge against the anchor, vertically centered
    const east$1 = (anchor, element, bubbles) => nu$5(eastEdgeX(anchor, element), centreY(anchor, element), bubbles.insetEast(), west$3(), "east" /* Placement.East */, boundsRestriction(anchor, { right: 0 /* AnchorBoxBounds.RightEdge */ }), labelPrefix$1);
    // positions element with the left each against the anchor, vertically centered
    const west$1 = (anchor, element, bubbles) => nu$5(westEdgeX(anchor), centreY(anchor, element), bubbles.insetWest(), east$3(), "west" /* Placement.West */, boundsRestriction(anchor, { left: 1 /* AnchorBoxBounds.LeftEdge */ }), labelPrefix$1);
    const lookupPreserveLayout = (lastPlacement) => {
        switch (lastPlacement) {
            case "north" /* Placement.North */:
                return north$1;
            case "northeast" /* Placement.Northeast */:
                return northeast$1;
            case "northwest" /* Placement.Northwest */:
                return northwest$1;
            case "south" /* Placement.South */:
                return south$1;
            case "southeast" /* Placement.Southeast */:
                return southeast$1;
            case "southwest" /* Placement.Southwest */:
                return southwest$1;
            case "east" /* Placement.East */:
                return east$1;
            case "west" /* Placement.West */:
                return west$1;
        }
    };
    const preserve$1 = (anchor, element, bubbles, placee, bounds) => {
        const layout = getPlacement(placee).map(lookupPreserveLayout).getOr(north$1);
        return layout(anchor, element, bubbles, placee, bounds);
    };
    const lookupFlippedLayout = (lastPlacement) => {
        switch (lastPlacement) {
            case "north" /* Placement.North */:
                return south$1;
            case "northeast" /* Placement.Northeast */:
                return southeast$1;
            case "northwest" /* Placement.Northwest */:
                return southwest$1;
            case "south" /* Placement.South */:
                return north$1;
            case "southeast" /* Placement.Southeast */:
                return northeast$1;
            case "southwest" /* Placement.Southwest */:
                return northwest$1;
            case "east" /* Placement.East */:
                return west$1;
            case "west" /* Placement.West */:
                return east$1;
        }
    };
    const flip = (anchor, element, bubbles, placee, bounds) => {
        const layout = getPlacement(placee).map(lookupFlippedLayout).getOr(north$1);
        return layout(anchor, element, bubbles, placee, bounds);
    };

    // applies the max-height as determined by Bounder
    const setMaxHeight = (element, maxHeight) => {
        setMax$1(element, Math.floor(maxHeight));
    };
    // adds both max-height and overflow to constrain it
    const anchored = constant$1((element, available) => {
        setMaxHeight(element, available);
        setAll(element, {
            'overflow-x': 'hidden',
            'overflow-y': 'auto'
        });
    });
    /*
     * This adds max height, but not overflow - the effect of this is that elements can grow beyond the max height,
     * but if they run off the top they're pushed down.
     *
     * If the element expands below the screen height it will be cut off, but we were already doing that.
     */
    const expandable$1 = constant$1((element, available) => {
        setMaxHeight(element, available);
    });

    // applies the max-width as determined by Bounder
    const expandable = constant$1((element, available) => {
        setMax(element, Math.floor(available));
    });

    var AttributeValue;
    (function (AttributeValue) {
        AttributeValue["TopToBottom"] = "toptobottom";
        AttributeValue["BottomToTop"] = "bottomtotop";
    })(AttributeValue || (AttributeValue = {}));
    const Attribute = 'data-alloy-vertical-dir';
    const isBottomToTopDir = (el) => closest$2(el, (current) => isElement$1(current) && get$g(current, 'data-alloy-vertical-dir') === AttributeValue.BottomToTop);

    var HighlightOnOpen;
    (function (HighlightOnOpen) {
        HighlightOnOpen[HighlightOnOpen["HighlightMenuAndItem"] = 0] = "HighlightMenuAndItem";
        HighlightOnOpen[HighlightOnOpen["HighlightJustMenu"] = 1] = "HighlightJustMenu";
        HighlightOnOpen[HighlightOnOpen["HighlightNone"] = 2] = "HighlightNone";
    })(HighlightOnOpen || (HighlightOnOpen = {}));

    const NoState = {
        init: () => nu$4({
            readState: constant$1('No State required')
        })
    };
    const nu$4 = (spec) => spec;

    const defaultEventHandler = {
        can: always,
        abort: never,
        run: noop
    };
    const nu$3 = (parts) => {
        if (!hasNonNullableKey(parts, 'can') && !hasNonNullableKey(parts, 'abort') && !hasNonNullableKey(parts, 'run')) {
            throw new Error('EventHandler defined by: ' + JSON.stringify(parts, null, 2) + ' does not have can, abort, or run!');
        }
        return {
            ...defaultEventHandler,
            ...parts
        };
    };
    const all$1 = (handlers, f) => (...args) => foldl(handlers, (acc, handler) => acc && f(handler).apply(undefined, args), true);
    const any = (handlers, f) => (...args) => foldl(handlers, (acc, handler) => acc || f(handler).apply(undefined, args), false);
    const read$1 = (handler) => isFunction(handler) ? {
        can: always,
        abort: never,
        run: handler
    } : handler;
    const fuse$1 = (handlers) => {
        const can = all$1(handlers, (handler) => handler.can);
        const abort = any(handlers, (handler) => handler.abort);
        const run = (...args) => {
            each$1(handlers, (handler) => {
                // ASSUMPTION: Return value is unimportant.
                handler.run.apply(undefined, args);
            });
        };
        return {
            can,
            abort,
            run
        };
    };

    const emit = (component, event) => {
        dispatchWith(component, component.element, event, {});
    };
    const emitWith = (component, event, properties) => {
        dispatchWith(component, component.element, event, properties);
    };
    const emitExecute = (component) => {
        emit(component, execute$5());
    };
    const dispatch = (component, target, event) => {
        dispatchWith(component, target, event, {});
    };
    const dispatchWith = (component, target, event, properties) => {
        // NOTE: The order of spreading here means that it will maintain any target that
        // exists in the current properties. Because this function has been used for situations where
        // properties is either an emulated SugarEvent with no target (see TouchEvent) or
        // for emitting custom events that have no target, this likely hasn't been a problem.
        // But until we verify that nothing is relying on this ordering, there is an alternate
        // function below called retargetAndDispatchWith, which spreads in the other direction.
        const data = {
            target,
            ...properties
        };
        component.getSystem().triggerEvent(event, target, data);
    };
    const retargetAndDispatchWith = (component, target, eventName, properties) => {
        // This is essentially the same as dispatchWith, except the spreading order
        // means that it clobbers anything in the nativeEvent with "target". It also
        // expects what is being passed in to be a real sugar event, not just a data
        // blob
        const data = {
            ...properties,
            target
        };
        component.getSystem().triggerEvent(eventName, target, data);
    };
    const dispatchEvent = (component, target, event, simulatedEvent) => {
        component.getSystem().triggerEvent(event, target, simulatedEvent.event);
    };

    const derive$2 = (configs) => wrapAll(configs);
    // const combine = (configs...);
    const abort = (name, predicate) => {
        return {
            key: name,
            value: nu$3({
                abort: predicate
            })
        };
    };
    const can = (name, predicate) => {
        return {
            key: name,
            value: nu$3({
                can: predicate
            })
        };
    };
    const preventDefault = (name) => {
        return {
            key: name,
            value: nu$3({
                run: (component, simulatedEvent) => {
                    simulatedEvent.event.prevent();
                }
            })
        };
    };
    const run$1 = (name, handler) => {
        return {
            key: name,
            value: nu$3({
                run: handler
            })
        };
    };
    // Extra can be used when your handler needs more context, and is declared in one spot
    // It's really just convenient partial application.
    const runActionExtra = (name, action, extra) => {
        return {
            key: name,
            value: nu$3({
                run: (component, simulatedEvent) => {
                    action.apply(undefined, [component, simulatedEvent].concat(extra));
                }
            })
        };
    };
    const runOnName = (name) => {
        return (handler) => run$1(name, handler);
    };
    const runOnSourceName = (name) => {
        return (handler) => ({
            key: name,
            value: nu$3({
                run: (component, simulatedEvent) => {
                    if (isSource(component, simulatedEvent)) {
                        handler(component, simulatedEvent);
                    }
                }
            })
        });
    };
    const redirectToUid = (name, uid) => {
        return run$1(name, (component, simulatedEvent) => {
            component.getSystem().getByUid(uid).each((redirectee) => {
                dispatchEvent(redirectee, redirectee.element, name, simulatedEvent);
            });
        });
    };
    const redirectToPart = (name, detail, partName) => {
        const uid = detail.partUids[partName];
        return redirectToUid(name, uid);
    };
    const runWithTarget = (name, f) => {
        return run$1(name, (component, simulatedEvent) => {
            const ev = simulatedEvent.event;
            const target = component.getSystem().getByDom(ev.target).getOrThunk(
            // If we don't find an alloy component for the target, I guess we go up the tree
            // until we find an alloy component? Performance concern?
            // TODO: Write tests for this.
            () => {
                const closest$1 = closest(ev.target, (el) => component.getSystem().getByDom(el).toOptional(), never);
                // If we still found nothing ... fire on component itself;
                return closest$1.getOr(component);
            });
            f(component, target, simulatedEvent);
        });
    };
    const cutter = (name) => {
        return run$1(name, (component, simulatedEvent) => {
            simulatedEvent.cut();
        });
    };
    const stopper = (name) => {
        return run$1(name, (component, simulatedEvent) => {
            simulatedEvent.stop();
        });
    };
    const runOnSource = (name, f) => {
        return runOnSourceName(name)(f);
    };
    const runOnAttached = runOnSourceName(attachedToDom());
    const runOnDetached = runOnSourceName(detachedFromDom());
    const runOnInit = runOnSourceName(systemInit());
    const runOnExecute$1 = runOnName(execute$5());

    // Maybe we'll need to allow add/remove
    const nu$2 = (s) => ({
        classes: isUndefined(s.classes) ? [] : s.classes,
        attributes: isUndefined(s.attributes) ? {} : s.attributes,
        styles: isUndefined(s.styles) ? {} : s.styles
    });
    const merge = (defnA, mod) => ({
        ...defnA,
        attributes: { ...defnA.attributes, ...mod.attributes },
        styles: { ...defnA.styles, ...mod.styles },
        classes: defnA.classes.concat(mod.classes)
    });

    const executeEvent = (bConfig, bState, executor) => runOnExecute$1((component) => {
        executor(component, bConfig, bState);
    });
    const loadEvent = (bConfig, bState, f) => runOnInit((component, _simulatedEvent) => {
        f(component, bConfig, bState);
    });
    const create$4 = (schema, name, active, apis, extra, state) => {
        const configSchema = objOfOnly(schema);
        const schemaSchema = optionObjOf(name, [
            optionObjOfOnly('config', schema)
        ]);
        return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);
    };
    const createModes$1 = (modes, name, active, apis, extra, state) => {
        const configSchema = modes;
        const schemaSchema = optionObjOf(name, [
            optionOf('config', modes)
        ]);
        return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);
    };
    const wrapApi = (bName, apiFunction, apiName) => {
        const f = (component, ...rest) => {
            const args = [component].concat(rest);
            return component.config({
                name: constant$1(bName)
            }).fold(() => {
                throw new Error('We could not find any behaviour configuration for: ' + bName + '. Using API: ' + apiName);
            }, (info) => {
                const rest = Array.prototype.slice.call(args, 1);
                return apiFunction.apply(undefined, [component, info.config, info.state].concat(rest));
            });
        };
        return markAsBehaviourApi(f, apiName, apiFunction);
    };
    // I think the "revoke" idea is fragile at best.
    const revokeBehaviour = (name) => ({
        key: name,
        value: undefined
    });
    const doCreate = (configSchema, schemaSchema, name, active, apis, extra, state) => {
        const getConfig = (info) => hasNonNullableKey(info, name) ? info[name]() : Optional.none();
        const wrappedApis = map$1(apis, (apiF, apiName) => wrapApi(name, apiF, apiName));
        const wrappedExtra = map$1(extra, (extraF, extraName) => markAsExtraApi(extraF, extraName));
        const me = {
            ...wrappedExtra,
            ...wrappedApis,
            revoke: curry(revokeBehaviour, name),
            config: (spec) => {
                const prepared = asRawOrDie$1(name + '-config', configSchema, spec);
                return {
                    key: name,
                    value: {
                        config: prepared,
                        me,
                        configAsRaw: cached(() => asRawOrDie$1(name + '-config', configSchema, spec)),
                        initialConfig: spec,
                        state
                    }
                };
            },
            schema: constant$1(schemaSchema),
            exhibit: (info, base) => {
                return lift2(getConfig(info), get$h(active, 'exhibit'), (behaviourInfo, exhibitor) => {
                    return exhibitor(base, behaviourInfo.config, behaviourInfo.state);
                }).getOrThunk(() => nu$2({}));
            },
            name: constant$1(name),
            handlers: (info) => {
                return getConfig(info).map((behaviourInfo) => {
                    const getEvents = get$h(active, 'events').getOr(() => ({}));
                    return getEvents(behaviourInfo.config, behaviourInfo.state);
                }).getOr({});
            }
        };
        return me;
    };

    const derive$1 = (capabilities) => wrapAll(capabilities);
    const simpleSchema = objOfOnly([
        required$1('fields'),
        required$1('name'),
        defaulted('active', {}),
        defaulted('apis', {}),
        defaulted('state', NoState),
        defaulted('extra', {})
    ]);
    const create$3 = (data) => {
        const value = asRawOrDie$1('Creating behaviour: ' + data.name, simpleSchema, data);
        return create$4(value.fields, value.name, value.active, value.apis, value.extra, value.state);
    };
    const modeSchema = objOfOnly([
        required$1('branchKey'),
        required$1('branches'),
        required$1('name'),
        defaulted('active', {}),
        defaulted('apis', {}),
        defaulted('state', NoState),
        defaulted('extra', {})
    ]);
    const createModes = (data) => {
        const value = asRawOrDie$1('Creating behaviour: ' + data.name, modeSchema, data);
        return createModes$1(choose$1(value.branchKey, value.branches), value.name, value.active, value.apis, value.extra, value.state);
    };
    const revoke = constant$1(undefined);

    // AlloyEventKeyAndHandler type argument needs to be any here to satisfy an array of handlers
    // where each item can be any subtype of EventFormat we can't use <T extends EventFormat> since
    // then each item would have to be the same type
    const events$i = (name, eventHandlers) => {
        const events = derive$2(eventHandlers);
        return create$3({
            fields: [
                required$1('enabled')
            ],
            name,
            active: {
                events: constant$1(events)
            }
        });
    };
    const config = (name, eventHandlers) => {
        const me = events$i(name, eventHandlers);
        return {
            key: name,
            value: {
                config: {},
                me,
                configAsRaw: constant$1({}),
                initialConfig: {},
                state: NoState
            }
        };
    };

    const SetupBehaviourCellState = (initialState) => {
        const init = () => {
            const cell = Cell(initialState);
            const get = () => cell.get();
            const set = (newState) => cell.set(newState);
            const clear = () => cell.set(initialState);
            const readState = () => cell.get();
            return {
                get,
                set,
                clear,
                readState
            };
        };
        return {
            init
        };
    };

    const focus$2 = (component, focusConfig) => {
        if (!focusConfig.ignore) {
            focus$4(component.element);
            focusConfig.onFocus(component);
        }
    };
    const blur = (component, focusConfig) => {
        if (!focusConfig.ignore) {
            blur$1(component.element);
        }
    };
    const isFocused = (component) => hasFocus(component.element);

    var FocusApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        focus: focus$2,
        blur: blur,
        isFocused: isFocused
    });

    // TODO: DomModification types
    const exhibit$6 = (base, focusConfig) => {
        const mod = focusConfig.ignore ? {} : {
            attributes: {
                tabindex: '-1'
            }
        };
        return nu$2(mod);
    };
    const events$h = (focusConfig) => derive$2([
        run$1(focus$3(), (component, simulatedEvent) => {
            focus$2(component, focusConfig);
            simulatedEvent.stop();
        })
    ].concat(focusConfig.stopMousedown ? [
        run$1(mousedown(), (_, simulatedEvent) => {
            // This setting is often used in tandem with ignoreFocus. Basically, if you
            // don't prevent default on a menu that has fake focus, then it can transfer
            // focus to the outer body when they click on it, which can break things
            // which dismiss on blur (e.g. typeahead)
            simulatedEvent.event.prevent();
        })
    ] : []));

    var ActiveFocus = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$6,
        events: events$h
    });

    var FocusSchema = [
        // TODO: Work out when we want to  call this. Only when it is has changed?
        onHandler('onFocus'),
        defaulted('stopMousedown', false),
        defaulted('ignore', false)
    ];

    const Focusing = create$3({
        fields: FocusSchema,
        name: 'focusing',
        active: ActiveFocus,
        apis: FocusApis
        // Consider adding isFocused an an extra
    });

    const BACKSPACE = [8];
    const TAB = [9];
    const ENTER = [13];
    const ESCAPE = [27];
    const SPACE = [32];
    const LEFT = [37];
    const UP = [38];
    const RIGHT = [39];
    const DOWN = [40];

    const closeTooltips = constant$1('tooltipping.close.all');
    const dismissPopups = constant$1('dismiss.popups');
    const repositionPopups = constant$1('reposition.popups');
    const mouseReleased = constant$1('mouse.released');

    const cyclePrev = (values, index, predicate) => {
        const before = reverse(values.slice(0, index));
        const after = reverse(values.slice(index + 1));
        return find$5(before.concat(after), predicate);
    };
    const tryPrev = (values, index, predicate) => {
        const before = reverse(values.slice(0, index));
        return find$5(before, predicate);
    };
    const cycleNext = (values, index, predicate) => {
        const before = values.slice(0, index);
        const after = values.slice(index + 1);
        return find$5(after.concat(before), predicate);
    };
    const tryNext = (values, index, predicate) => {
        const after = values.slice(index + 1);
        return find$5(after, predicate);
    };

    const inSet = (keys) => (event) => {
        const raw = event.raw;
        return contains$2(keys, raw.which);
    };
    const and = (preds) => (event) => forall(preds, (pred) => pred(event));
    const isShift$1 = (event) => {
        const raw = event.raw;
        return raw.shiftKey === true;
    };
    const isControl = (event) => {
        const raw = event.raw;
        return raw.ctrlKey === true;
    };
    const isNotShift = not(isShift$1);

    const rule = (matches, action) => ({
        matches,
        classification: action
    });
    const choose = (transitions, event) => {
        const transition = find$5(transitions, (t) => t.matches(event));
        return transition.map((t) => t.classification);
    };

    // THIS IS NOT API YET
    const dehighlightAllExcept = (component, hConfig, hState, skip) => {
        const highlighted = descendants(component.element, '.' + hConfig.highlightClass);
        each$1(highlighted, (h) => {
            // We don't want to dehighlight anything that should be skipped.
            // Generally, this is because we are about to highlight that thing.
            const shouldSkip = exists(skip, (skipComp) => eq(skipComp.element, h));
            if (!shouldSkip) {
                remove$3(h, hConfig.highlightClass);
                component.getSystem().getByDom(h).each((target) => {
                    hConfig.onDehighlight(component, target);
                    emit(target, dehighlight$1());
                });
            }
        });
    };
    const dehighlightAll = (component, hConfig, hState) => dehighlightAllExcept(component, hConfig, hState, []);
    const dehighlight = (component, hConfig, hState, target) => {
        // Only act if it was highlighted.
        if (isHighlighted(component, hConfig, hState, target)) {
            remove$3(target.element, hConfig.highlightClass);
            hConfig.onDehighlight(component, target);
            emit(target, dehighlight$1());
        }
    };
    const highlight = (component, hConfig, hState, target) => {
        // If asked to highlight something, dehighlight everything else first except
        // for the new thing we are going to highlight. It's a rare case, but we don't
        // want to get an onDehighlight, onHighlight for the same item on a highlight call.
        // We also don't want to call onHighlight if it was already highlighted.
        //
        // Note, that there is an important distinction here: highlight is NOT a no-op
        // if target is already highlighted, because it will still dehighlight everything else.
        // However, it won't fire any onHighlight or onDehighlight handlers for the already
        // highlighted item. I'm not sure if this is behaviour we need to maintain, but it is now
        // tested. A simpler approach might just be to not do anything if it's already highlighted,
        // but that could leave us in an inconsistent state, where multiple items have highlights
        // even after a highlight call. This way, highlight validates the highlights in the
        // component, and ensures there is only one thing highlighted.
        dehighlightAllExcept(component, hConfig, hState, [target]);
        if (!isHighlighted(component, hConfig, hState, target)) {
            add$2(target.element, hConfig.highlightClass);
            hConfig.onHighlight(component, target);
            emit(target, highlight$1());
        }
    };
    const highlightFirst = (component, hConfig, hState) => {
        getFirst(component, hConfig).each((firstComp) => {
            highlight(component, hConfig, hState, firstComp);
        });
    };
    const highlightLast = (component, hConfig, hState) => {
        getLast(component, hConfig).each((lastComp) => {
            highlight(component, hConfig, hState, lastComp);
        });
    };
    const highlightAt = (component, hConfig, hState, index) => {
        getByIndex(component, hConfig, hState, index).fold((err) => {
            throw err;
        }, (firstComp) => {
            highlight(component, hConfig, hState, firstComp);
        });
    };
    const highlightBy = (component, hConfig, hState, predicate) => {
        const candidates = getCandidates(component, hConfig);
        const targetComp = find$5(candidates, predicate);
        targetComp.each((c) => {
            highlight(component, hConfig, hState, c);
        });
    };
    const isHighlighted = (component, hConfig, hState, queryTarget) => has(queryTarget.element, hConfig.highlightClass);
    const getHighlighted = (component, hConfig, _hState) => descendant(component.element, '.' + hConfig.highlightClass).bind((e) => component.getSystem().getByDom(e).toOptional());
    const getByIndex = (component, hConfig, hState, index) => {
        const items = descendants(component.element, '.' + hConfig.itemClass);
        return Optional.from(items[index]).fold(() => Result.error(new Error('No element found with index ' + index)), component.getSystem().getByDom);
    };
    const getFirst = (component, hConfig, _hState) => descendant(component.element, '.' + hConfig.itemClass).bind((e) => component.getSystem().getByDom(e).toOptional());
    const getLast = (component, hConfig, _hState) => {
        const items = descendants(component.element, '.' + hConfig.itemClass);
        const last = items.length > 0 ? Optional.some(items[items.length - 1]) : Optional.none();
        return last.bind((c) => component.getSystem().getByDom(c).toOptional());
    };
    const getDelta$2 = (component, hConfig, hState, delta) => {
        const items = descendants(component.element, '.' + hConfig.itemClass);
        const current = findIndex$1(items, (item) => has(item, hConfig.highlightClass));
        return current.bind((selected) => {
            const dest = cycleBy(selected, delta, 0, items.length - 1);
            return component.getSystem().getByDom(items[dest]).toOptional();
        });
    };
    const getPrevious = (component, hConfig, hState) => getDelta$2(component, hConfig, hState, -1);
    const getNext = (component, hConfig, hState) => getDelta$2(component, hConfig, hState, +1);
    const getCandidates = (component, hConfig, _hState) => {
        const items = descendants(component.element, '.' + hConfig.itemClass);
        return cat(map$2(items, (i) => component.getSystem().getByDom(i).toOptional()));
    };

    var HighlightApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        dehighlightAll: dehighlightAll,
        dehighlight: dehighlight,
        highlight: highlight,
        highlightFirst: highlightFirst,
        highlightLast: highlightLast,
        highlightAt: highlightAt,
        highlightBy: highlightBy,
        isHighlighted: isHighlighted,
        getHighlighted: getHighlighted,
        getFirst: getFirst,
        getLast: getLast,
        getPrevious: getPrevious,
        getNext: getNext,
        getCandidates: getCandidates
    });

    var HighlightSchema = [
        required$1('highlightClass'),
        required$1('itemClass'),
        onHandler('onHighlight'),
        onHandler('onDehighlight')
    ];

    const Highlighting = create$3({
        fields: HighlightSchema,
        name: 'highlighting',
        apis: HighlightApis
    });

    const reportFocusShifting = (component, prevFocus, newFocus) => {
        const noChange = prevFocus.exists((p) => newFocus.exists((n) => eq(n, p)));
        if (!noChange) {
            emitWith(component, focusShifted(), {
                prevFocus,
                newFocus
            });
        }
    };
    const dom$2 = () => {
        const get = (component) => search(component.element);
        const set = (component, focusee) => {
            const prevFocus = get(component);
            component.getSystem().triggerFocus(focusee, component.element);
            const newFocus = get(component);
            reportFocusShifting(component, prevFocus, newFocus);
        };
        return {
            get,
            set
        };
    };
    const highlights = () => {
        const get = (component) => Highlighting.getHighlighted(component).map((item) => item.element);
        const set = (component, element) => {
            const prevFocus = get(component);
            component.getSystem().getByDom(element).fold(noop, (item) => {
                Highlighting.highlight(component, item);
            });
            const newFocus = get(component);
            reportFocusShifting(component, prevFocus, newFocus);
        };
        return {
            get,
            set
        };
    };

    const typical = (infoSchema, stateInit, getKeydownRules, getKeyupRules, optFocusIn) => {
        const schema = () => infoSchema.concat([
            defaulted('focusManager', dom$2()),
            defaultedOf('focusInside', 'onFocus', valueOf((val) => contains$2(['onFocus', 'onEnterOrSpace', 'onApi'], val) ? Result.value(val) : Result.error('Invalid value for focusInside'))),
            output$1('handler', me),
            output$1('state', stateInit),
            output$1('sendFocusIn', optFocusIn)
        ]);
        const processKey = (component, simulatedEvent, getRules, keyingConfig, keyingState) => {
            const rules = getRules(component, simulatedEvent, keyingConfig, keyingState);
            return choose(rules, simulatedEvent.event).bind((rule) => rule(component, simulatedEvent, keyingConfig, keyingState));
        };
        const toEvents = (keyingConfig, keyingState) => {
            const onFocusHandler = keyingConfig.focusInside !== FocusInsideModes.OnFocusMode
                ? Optional.none()
                : optFocusIn(keyingConfig).map((focusIn) => run$1(focus$3(), (component, simulatedEvent) => {
                    focusIn(component, keyingConfig, keyingState);
                    simulatedEvent.stop();
                }));
            // On enter or space on root element, if using EnterOrSpace focus mode, fire a focusIn on the component
            const tryGoInsideComponent = (component, simulatedEvent) => {
                const isEnterOrSpace = inSet(SPACE.concat(ENTER))(simulatedEvent.event);
                if (keyingConfig.focusInside === FocusInsideModes.OnEnterOrSpaceMode && isEnterOrSpace && isSource(component, simulatedEvent)) {
                    optFocusIn(keyingConfig).each((focusIn) => {
                        focusIn(component, keyingConfig, keyingState);
                        simulatedEvent.stop();
                    });
                }
            };
            const keyboardEvents = [
                run$1(keydown(), (component, simulatedEvent) => {
                    processKey(component, simulatedEvent, getKeydownRules, keyingConfig, keyingState).fold(() => {
                        // Key wasn't handled ... so see if we should enter into the component (focusIn)
                        tryGoInsideComponent(component, simulatedEvent);
                    }, (_) => {
                        simulatedEvent.stop();
                    });
                }),
                run$1(keyup(), (component, simulatedEvent) => {
                    processKey(component, simulatedEvent, getKeyupRules, keyingConfig, keyingState).each((_) => {
                        simulatedEvent.stop();
                    });
                })
            ];
            return derive$2(onFocusHandler.toArray().concat(keyboardEvents));
        };
        const me = {
            schema,
            processKey,
            toEvents
        };
        return me;
    };

    const create$2 = (cyclicField) => {
        const schema = [
            option$3('onEscape'),
            option$3('onEnter'),
            defaulted('selector', '[data-alloy-tabstop="true"]:not(:disabled)'),
            defaulted('firstTabstop', 0),
            defaulted('useTabstopAt', always),
            // Maybe later we should just expose isVisible
            option$3('visibilitySelector')
        ].concat([
            cyclicField
        ]);
        // TODO: Test this
        const isVisible = (tabbingConfig, element) => {
            const target = tabbingConfig.visibilitySelector
                .bind((sel) => closest$3(element, sel))
                .getOr(element);
            // NOTE: We can't use Visibility.isVisible, because the toolbar has width when it has closed, just not height.
            return get$d(target) > 0;
        };
        const findInitial = (component, tabbingConfig) => {
            const tabstops = descendants(component.element, tabbingConfig.selector);
            const visibles = filter$2(tabstops, (elem) => isVisible(tabbingConfig, elem));
            return Optional.from(visibles[tabbingConfig.firstTabstop]);
        };
        const findCurrent = (component, tabbingConfig) => tabbingConfig.focusManager.get(component)
            .bind((elem) => closest$3(elem, tabbingConfig.selector));
        const isTabstop = (tabbingConfig, element) => isVisible(tabbingConfig, element) && tabbingConfig.useTabstopAt(element);
        // Fire an alloy focus on the first visible element that matches the selector
        const focusIn = (component, tabbingConfig, _tabbingState) => {
            findInitial(component, tabbingConfig).each((target) => {
                tabbingConfig.focusManager.set(component, target);
            });
        };
        const goFromTabstop = (component, tabstops, stopIndex, tabbingConfig, cycle) => cycle(tabstops, stopIndex, (elem) => isTabstop(tabbingConfig, elem))
            .fold(
        // Even if there is only one, still capture the event if cycling
        () => tabbingConfig.cyclic ? Optional.some(true) : Optional.none(), (target) => {
            tabbingConfig.focusManager.set(component, target);
            // Kill the event
            return Optional.some(true);
        });
        const go = (component, _simulatedEvent, tabbingConfig, cycle) => {
            // 1. Find our current tabstop
            // 2. Find the index of that tabstop
            // 3. Cycle the tabstop
            // 4. Fire alloy focus on the resultant tabstop
            const tabstops = filter$2(descendants(component.element, tabbingConfig.selector), (element) => isVisible(tabbingConfig, element));
            return findCurrent(component, tabbingConfig).bind((tabstop) => {
                // focused component
                const optStopIndex = findIndex$1(tabstops, curry(eq, tabstop));
                return optStopIndex.bind((stopIndex) => goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle));
            });
        };
        const goBackwards = (component, simulatedEvent, tabbingConfig) => {
            const navigate = tabbingConfig.cyclic ? cyclePrev : tryPrev;
            return go(component, simulatedEvent, tabbingConfig, navigate);
        };
        const goForwards = (component, simulatedEvent, tabbingConfig) => {
            const navigate = tabbingConfig.cyclic ? cycleNext : tryNext;
            return go(component, simulatedEvent, tabbingConfig, navigate);
        };
        const isFirstChild = (elem) => parentNode(elem).bind(firstChild).exists((child) => eq(child, elem));
        const goFromPseudoTabstop = (component, simulatedEvent, tabbingConfig) => findCurrent(component, tabbingConfig).filter((elem) => !tabbingConfig.useTabstopAt(elem))
            .bind((elem) => (isFirstChild(elem) ? goBackwards : goForwards)(component, simulatedEvent, tabbingConfig));
        const execute = (component, simulatedEvent, tabbingConfig) => tabbingConfig.onEnter.bind((f) => f(component, simulatedEvent));
        const exit = (component, simulatedEvent, tabbingConfig) => {
            component.getSystem().broadcastOn([closeTooltips()], {
                closedTooltip: () => {
                    simulatedEvent.stop();
                }
            });
            if (!simulatedEvent.isStopped()) {
                return tabbingConfig.onEscape.bind((f) => f(component, simulatedEvent));
            }
            else {
                return Optional.none();
            }
        };
        const getKeydownRules = constant$1([
            rule(and([isShift$1, inSet(TAB)]), goBackwards),
            rule(inSet(TAB), goForwards),
            rule(and([isNotShift, inSet(ENTER)]), execute)
        ]);
        const getKeyupRules = constant$1([
            rule(inSet(ESCAPE), exit),
            rule(inSet(TAB), goFromPseudoTabstop),
        ]);
        return typical(schema, NoState.init, getKeydownRules, getKeyupRules, () => Optional.some(focusIn));
    };

    var AcyclicType = create$2(customField('cyclic', never));

    var CyclicType = create$2(customField('cyclic', always));

    const inside = (target) => ((isTag('input')(target) && get$g(target, 'type') !== 'radio') ||
        isTag('textarea')(target));

    const doDefaultExecute = (component, _simulatedEvent, focused) => {
        // Note, we use to pass through simulatedEvent here and make target: component. This simplification
        // may be a problem
        dispatch(component, focused, execute$5());
        return Optional.some(true);
    };
    const defaultExecute = (component, simulatedEvent, focused) => {
        const isComplex = inside(focused) && inSet(SPACE)(simulatedEvent.event);
        return isComplex ? Optional.none() : doDefaultExecute(component, simulatedEvent, focused);
    };
    // On Firefox, pressing space fires a click event if the element maintains focus and fires a keyup. This
    // stops the keyup, which should stop the click. We might want to make this only work for buttons and Firefox etc,
    // but at this stage it's cleaner to just always do it. It makes sense that Keying that handles space should handle
    // keyup also. This does make the name confusing, though.
    const stopEventForFirefox = (_component, _simulatedEvent) => Optional.some(true);

    const schema$y = [
        defaulted('execute', defaultExecute),
        defaulted('useSpace', false),
        defaulted('useEnter', true),
        defaulted('useControlEnter', false),
        defaulted('useDown', false)
    ];
    const execute$4 = (component, simulatedEvent, executeConfig) => executeConfig.execute(component, simulatedEvent, component.element);
    const getKeydownRules$5 = (component, _simulatedEvent, executeConfig, _executeState) => {
        const spaceExec = executeConfig.useSpace && !inside(component.element) ? SPACE : [];
        const enterExec = executeConfig.useEnter ? ENTER : [];
        const downExec = executeConfig.useDown ? DOWN : [];
        const execKeys = spaceExec.concat(enterExec).concat(downExec);
        return [
            rule(inSet(execKeys), execute$4)
        ].concat(executeConfig.useControlEnter ? [
            rule(and([isControl, inSet(ENTER)]), execute$4)
        ] : []);
    };
    const getKeyupRules$5 = (component, _simulatedEvent, executeConfig, _executeState) => executeConfig.useSpace && !inside(component.element) ?
        [rule(inSet(SPACE), stopEventForFirefox)] :
        [];
    var ExecutionType = typical(schema$y, NoState.init, getKeydownRules$5, getKeyupRules$5, () => Optional.none());

    const flatgrid$1 = () => {
        const dimensions = value$2();
        const setGridSize = (numRows, numColumns) => {
            dimensions.set({ numRows, numColumns });
        };
        const getNumRows = () => dimensions.get().map((d) => d.numRows);
        const getNumColumns = () => dimensions.get().map((d) => d.numColumns);
        return nu$4({
            readState: () => dimensions.get().map((d) => ({
                numRows: String(d.numRows),
                numColumns: String(d.numColumns)
            })).getOr({
                numRows: '?',
                numColumns: '?'
            }),
            setGridSize,
            getNumRows,
            getNumColumns
        });
    };
    const init$g = (spec) => spec.state(spec);

    var KeyingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        flatgrid: flatgrid$1,
        init: init$g
    });

    // Looks up direction (considering LTR and RTL), finds the focused element,
    // and tries to move. If it succeeds, triggers focus and kills the event.
    const useH = (movement) => (component, simulatedEvent, config, state) => {
        const move = movement(component.element);
        return use(move, component, simulatedEvent, config, state);
    };
    const west = (moveLeft, moveRight) => {
        const movement = onDirection(moveLeft, moveRight);
        return useH(movement);
    };
    const east = (moveLeft, moveRight) => {
        const movement = onDirection(moveRight, moveLeft);
        return useH(movement);
    };
    const useV = (move) => (component, simulatedEvent, config, state) => use(move, component, simulatedEvent, config, state);
    const use = (move, component, simulatedEvent, config, state) => {
        const outcome = config.focusManager.get(component).bind((focused) => move(component.element, focused, config, state));
        return outcome.map((newFocus) => {
            config.focusManager.set(component, newFocus);
            return true;
        });
    };
    const north = useV;
    const south = useV;
    const move$1 = useV;

    const locate = (candidates, predicate) => findIndex$1(candidates, predicate).map((index) => ({
        index,
        candidates
    }));

    const locateVisible = (container, current, selector) => {
        const predicate = (x) => eq(x, current);
        const candidates = descendants(container, selector);
        const visible = filter$2(candidates, isVisible);
        return locate(visible, predicate);
    };
    const findIndex = (elements, target) => findIndex$1(elements, (elem) => eq(target, elem));

    const withGrid = (values, index, numCols, f) => {
        const oldRow = Math.floor(index / numCols);
        const oldColumn = index % numCols;
        return f(oldRow, oldColumn).bind((address) => {
            const newIndex = address.row * numCols + address.column;
            return newIndex >= 0 && newIndex < values.length ? Optional.some(values[newIndex]) : Optional.none();
        });
    };
    const cycleHorizontal$1 = (values, index, numRows, numCols, delta) => withGrid(values, index, numCols, (oldRow, oldColumn) => {
        const onLastRow = oldRow === numRows - 1;
        const colsInRow = onLastRow ? values.length - (oldRow * numCols) : numCols;
        const newColumn = cycleBy(oldColumn, delta, 0, colsInRow - 1);
        return Optional.some({
            row: oldRow,
            column: newColumn
        });
    });
    const cycleVertical$1 = (values, index, numRows, numCols, delta) => withGrid(values, index, numCols, (oldRow, oldColumn) => {
        const newRow = cycleBy(oldRow, delta, 0, numRows - 1);
        const onLastRow = newRow === numRows - 1;
        const colsInRow = onLastRow ? values.length - (newRow * numCols) : numCols;
        const newCol = clamp(oldColumn, 0, colsInRow - 1);
        return Optional.some({
            row: newRow,
            column: newCol
        });
    });
    const cycleRight$1 = (values, index, numRows, numCols) => cycleHorizontal$1(values, index, numRows, numCols, +1);
    const cycleLeft$1 = (values, index, numRows, numCols) => cycleHorizontal$1(values, index, numRows, numCols, -1);
    const cycleUp$1 = (values, index, numRows, numCols) => cycleVertical$1(values, index, numRows, numCols, -1);
    const cycleDown$1 = (values, index, numRows, numCols) => cycleVertical$1(values, index, numRows, numCols, +1);

    const schema$x = [
        required$1('selector'),
        defaulted('execute', defaultExecute),
        onKeyboardHandler('onEscape'),
        defaulted('captureTab', false),
        initSize()
    ];
    const focusIn$4 = (component, gridConfig, _gridState) => {
        descendant(component.element, gridConfig.selector).each((first) => {
            gridConfig.focusManager.set(component, first);
        });
    };
    const findCurrent$1 = (component, gridConfig) => gridConfig.focusManager.get(component).bind((elem) => closest$3(elem, gridConfig.selector));
    const execute$3 = (component, simulatedEvent, gridConfig, _gridState) => findCurrent$1(component, gridConfig)
        .bind((focused) => gridConfig.execute(component, simulatedEvent, focused));
    const doMove$2 = (cycle) => (element, focused, gridConfig, gridState) => locateVisible(element, focused, gridConfig.selector)
        .bind((identified) => cycle(identified.candidates, identified.index, gridState.getNumRows().getOr(gridConfig.initSize.numRows), gridState.getNumColumns().getOr(gridConfig.initSize.numColumns)));
    const handleTab = (_component, _simulatedEvent, gridConfig) => gridConfig.captureTab ? Optional.some(true) : Optional.none();
    const doEscape$1 = (component, simulatedEvent, gridConfig) => gridConfig.onEscape(component, simulatedEvent);
    const moveLeft$3 = doMove$2(cycleLeft$1);
    const moveRight$3 = doMove$2(cycleRight$1);
    const moveNorth$1 = doMove$2(cycleUp$1);
    const moveSouth$1 = doMove$2(cycleDown$1);
    const getKeydownRules$4 = constant$1([
        rule(inSet(LEFT), west(moveLeft$3, moveRight$3)),
        rule(inSet(RIGHT), east(moveLeft$3, moveRight$3)),
        rule(inSet(UP), north(moveNorth$1)),
        rule(inSet(DOWN), south(moveSouth$1)),
        rule(and([isShift$1, inSet(TAB)]), handleTab),
        rule(and([isNotShift, inSet(TAB)]), handleTab),
        // Probably should make whether space is used configurable
        rule(inSet(SPACE.concat(ENTER)), execute$3)
    ]);
    const getKeyupRules$4 = constant$1([
        rule(inSet(ESCAPE), doEscape$1),
        rule(inSet(SPACE), stopEventForFirefox)
    ]);
    var FlatgridType = typical(schema$x, flatgrid$1, getKeydownRules$4, getKeyupRules$4, () => Optional.some(focusIn$4));

    const f = (container, selector, current, delta, getNewIndex) => {
        const isDisabledButton = (candidate) => name$3(candidate) === 'button' && get$g(candidate, 'disabled') === 'disabled';
        const tryNewIndex = (initial, index, candidates) => getNewIndex(initial, index, delta, 0, candidates.length - 1, candidates[index], (newIndex) => isDisabledButton(candidates[newIndex]) ?
            tryNewIndex(initial, newIndex, candidates) :
            Optional.from(candidates[newIndex]));
        // I wonder if this will be a problem when the focused element is invisible (shouldn't happen)
        return locateVisible(container, current, selector).bind((identified) => {
            const index = identified.index;
            const candidates = identified.candidates;
            return tryNewIndex(index, index, candidates);
        });
    };
    const horizontalWithoutCycles = (container, selector, current, delta) => f(container, selector, current, delta, (prevIndex, v, d, min, max, oldCandidate, onNewIndex) => {
        const newIndex = clamp(v + d, min, max);
        return newIndex === prevIndex ? Optional.from(oldCandidate) : onNewIndex(newIndex);
    });
    const horizontal = (container, selector, current, delta) => f(container, selector, current, delta, (prevIndex, v, d, min, max, _oldCandidate, onNewIndex) => {
        const newIndex = cycleBy(v, d, min, max);
        // If we've cycled back to the original index, we've failed to find a new valid candidate
        return newIndex === prevIndex ? Optional.none() : onNewIndex(newIndex);
    });

    const schema$w = [
        required$1('selector'),
        defaulted('getInitial', Optional.none),
        defaulted('execute', defaultExecute),
        onKeyboardHandler('onEscape'),
        defaulted('executeOnMove', false),
        defaulted('allowVertical', true),
        defaulted('allowHorizontal', true),
        defaulted('cycles', true)
    ];
    // TODO: Remove dupe.
    // TODO: Probably use this for not just execution.
    const findCurrent = (component, flowConfig) => flowConfig.focusManager.get(component).bind((elem) => closest$3(elem, flowConfig.selector));
    const execute$2 = (component, simulatedEvent, flowConfig) => findCurrent(component, flowConfig).bind((focused) => flowConfig.execute(component, simulatedEvent, focused));
    const focusIn$3 = (component, flowConfig, _state) => {
        flowConfig.getInitial(component).orThunk(() => descendant(component.element, flowConfig.selector)).each((first) => {
            flowConfig.focusManager.set(component, first);
        });
    };
    const moveLeft$2 = (element, focused, info) => (info.cycles ? horizontal : horizontalWithoutCycles)(element, info.selector, focused, -1);
    const moveRight$2 = (element, focused, info) => (info.cycles ? horizontal : horizontalWithoutCycles)(element, info.selector, focused, +1);
    const doMove$1 = (movement) => (component, simulatedEvent, flowConfig, flowState) => movement(component, simulatedEvent, flowConfig, flowState).bind(() => flowConfig.executeOnMove ?
        execute$2(component, simulatedEvent, flowConfig) :
        Optional.some(true));
    const doEscape = (component, simulatedEvent, flowConfig) => flowConfig.onEscape(component, simulatedEvent);
    const getKeydownRules$3 = (_component, _se, flowConfig, _flowState) => {
        const westMovers = [...flowConfig.allowHorizontal ? LEFT : []].concat(flowConfig.allowVertical ? UP : []);
        const eastMovers = [...flowConfig.allowHorizontal ? RIGHT : []].concat(flowConfig.allowVertical ? DOWN : []);
        return [
            rule(inSet(westMovers), doMove$1(west(moveLeft$2, moveRight$2))),
            rule(inSet(eastMovers), doMove$1(east(moveLeft$2, moveRight$2))),
            rule(inSet(ENTER), execute$2),
            rule(inSet(SPACE), execute$2)
        ];
    };
    const getKeyupRules$3 = constant$1([
        rule(inSet(SPACE), stopEventForFirefox),
        rule(inSet(ESCAPE), doEscape)
    ]);
    var FlowType = typical(schema$w, NoState.init, getKeydownRules$3, getKeyupRules$3, () => Optional.some(focusIn$3));

    const toCell = (matrix, rowIndex, columnIndex) => Optional.from(matrix[rowIndex]).bind((row) => Optional.from(row[columnIndex]).map((cell) => ({
        rowIndex,
        columnIndex,
        cell
    })));
    const cycleHorizontal = (matrix, rowIndex, startCol, deltaCol) => {
        const row = matrix[rowIndex];
        const colsInRow = row.length;
        const newColIndex = cycleBy(startCol, deltaCol, 0, colsInRow - 1);
        return toCell(matrix, rowIndex, newColIndex);
    };
    const cycleVertical = (matrix, colIndex, startRow, deltaRow) => {
        const nextRowIndex = cycleBy(startRow, deltaRow, 0, matrix.length - 1);
        const colsInNextRow = matrix[nextRowIndex].length;
        const nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);
        return toCell(matrix, nextRowIndex, nextColIndex);
    };
    const moveHorizontal = (matrix, rowIndex, startCol, deltaCol) => {
        const row = matrix[rowIndex];
        const colsInRow = row.length;
        const newColIndex = clamp(startCol + deltaCol, 0, colsInRow - 1);
        return toCell(matrix, rowIndex, newColIndex);
    };
    const moveVertical = (matrix, colIndex, startRow, deltaRow) => {
        const nextRowIndex = clamp(startRow + deltaRow, 0, matrix.length - 1);
        const colsInNextRow = matrix[nextRowIndex].length;
        const nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);
        return toCell(matrix, nextRowIndex, nextColIndex);
    };
    // return address(Math.floor(index / columns), index % columns);
    const cycleRight = (matrix, startRow, startCol) => cycleHorizontal(matrix, startRow, startCol, +1);
    const cycleLeft = (matrix, startRow, startCol) => cycleHorizontal(matrix, startRow, startCol, -1);
    const cycleUp = (matrix, startRow, startCol) => cycleVertical(matrix, startCol, startRow, -1);
    const cycleDown = (matrix, startRow, startCol) => cycleVertical(matrix, startCol, startRow, +1);
    const moveLeft$1 = (matrix, startRow, startCol) => moveHorizontal(matrix, startRow, startCol, -1);
    const moveRight$1 = (matrix, startRow, startCol) => moveHorizontal(matrix, startRow, startCol, +1);
    const moveUp$1 = (matrix, startRow, startCol) => moveVertical(matrix, startCol, startRow, -1);
    const moveDown$1 = (matrix, startRow, startCol) => moveVertical(matrix, startCol, startRow, +1);

    const schema$v = [
        requiredObjOf('selectors', [
            required$1('row'),
            required$1('cell')
        ]),
        // Used to determine whether pressing right/down at the end cycles back to the start/top
        defaulted('cycles', true),
        defaulted('previousSelector', Optional.none),
        defaulted('execute', defaultExecute)
    ];
    const focusIn$2 = (component, matrixConfig, _state) => {
        const focused = matrixConfig.previousSelector(component).orThunk(() => {
            const selectors = matrixConfig.selectors;
            return descendant(component.element, selectors.cell);
        });
        focused.each((cell) => {
            matrixConfig.focusManager.set(component, cell);
        });
    };
    const execute$1 = (component, simulatedEvent, matrixConfig) => search(component.element).bind((focused) => matrixConfig.execute(component, simulatedEvent, focused));
    const toMatrix = (rows, matrixConfig) => map$2(rows, (row) => descendants(row, matrixConfig.selectors.cell));
    const doMove = (ifCycle, ifMove) => (element, focused, matrixConfig) => {
        const move = matrixConfig.cycles ? ifCycle : ifMove;
        return closest$3(focused, matrixConfig.selectors.row).bind((inRow) => {
            const cellsInRow = descendants(inRow, matrixConfig.selectors.cell);
            return findIndex(cellsInRow, focused).bind((colIndex) => {
                const allRows = descendants(element, matrixConfig.selectors.row);
                return findIndex(allRows, inRow).bind((rowIndex) => {
                    // Now, make the matrix.
                    const matrix = toMatrix(allRows, matrixConfig);
                    return move(matrix, rowIndex, colIndex).map((next) => next.cell);
                });
            });
        });
    };
    const moveLeft = doMove(cycleLeft, moveLeft$1);
    const moveRight = doMove(cycleRight, moveRight$1);
    const moveNorth = doMove(cycleUp, moveUp$1);
    const moveSouth = doMove(cycleDown, moveDown$1);
    const getKeydownRules$2 = constant$1([
        rule(inSet(LEFT), west(moveLeft, moveRight)),
        rule(inSet(RIGHT), east(moveLeft, moveRight)),
        rule(inSet(UP), north(moveNorth)),
        rule(inSet(DOWN), south(moveSouth)),
        rule(inSet(SPACE.concat(ENTER)), execute$1)
    ]);
    const getKeyupRules$2 = constant$1([
        rule(inSet(SPACE), stopEventForFirefox)
    ]);
    var MatrixType = typical(schema$v, NoState.init, getKeydownRules$2, getKeyupRules$2, () => Optional.some(focusIn$2));

    const schema$u = [
        required$1('selector'),
        defaulted('execute', defaultExecute),
        defaulted('moveOnTab', false)
    ];
    const execute = (component, simulatedEvent, menuConfig) => menuConfig.focusManager.get(component).bind((focused) => menuConfig.execute(component, simulatedEvent, focused));
    const focusIn$1 = (component, menuConfig, _state) => {
        // Maybe keep selection if it was there before
        descendant(component.element, menuConfig.selector).each((first) => {
            menuConfig.focusManager.set(component, first);
        });
    };
    const moveUp = (element, focused, info) => horizontal(element, info.selector, focused, -1);
    const moveDown = (element, focused, info) => horizontal(element, info.selector, focused, +1);
    const fireShiftTab = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? move$1(moveUp)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
    const fireTab = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? move$1(moveDown)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
    const getKeydownRules$1 = constant$1([
        rule(inSet(UP), move$1(moveUp)),
        rule(inSet(DOWN), move$1(moveDown)),
        rule(and([isShift$1, inSet(TAB)]), fireShiftTab),
        rule(and([isNotShift, inSet(TAB)]), fireTab),
        rule(inSet(ENTER), execute),
        rule(inSet(SPACE), execute)
    ]);
    const getKeyupRules$1 = constant$1([
        rule(inSet(SPACE), stopEventForFirefox)
    ]);
    var MenuType = typical(schema$u, NoState.init, getKeydownRules$1, getKeyupRules$1, () => Optional.some(focusIn$1));

    const schema$t = [
        onKeyboardHandler('onSpace'),
        onKeyboardHandler('onEnter'),
        onKeyboardHandler('onShiftEnter'),
        onKeyboardHandler('onLeft'),
        onKeyboardHandler('onRight'),
        onKeyboardHandler('onTab'),
        onKeyboardHandler('onShiftTab'),
        onKeyboardHandler('onUp'),
        onKeyboardHandler('onDown'),
        onKeyboardHandler('onEscape'),
        defaulted('stopSpaceKeyup', false),
        option$3('focusIn')
    ];
    const getKeydownRules = (component, simulatedEvent, specialInfo) => [
        rule(inSet(SPACE), specialInfo.onSpace),
        rule(and([isNotShift, inSet(ENTER)]), specialInfo.onEnter),
        rule(and([isShift$1, inSet(ENTER)]), specialInfo.onShiftEnter),
        rule(and([isShift$1, inSet(TAB)]), specialInfo.onShiftTab),
        rule(and([isNotShift, inSet(TAB)]), specialInfo.onTab),
        rule(inSet(UP), specialInfo.onUp),
        rule(inSet(DOWN), specialInfo.onDown),
        rule(inSet(LEFT), specialInfo.onLeft),
        rule(inSet(RIGHT), specialInfo.onRight),
        rule(inSet(SPACE), specialInfo.onSpace)
    ];
    const getKeyupRules = (component, simulatedEvent, specialInfo) => [
        ...(specialInfo.stopSpaceKeyup ? [rule(inSet(SPACE), stopEventForFirefox)] : []),
        rule(inSet(ESCAPE), specialInfo.onEscape)
    ];
    var SpecialType = typical(schema$t, NoState.init, getKeydownRules, getKeyupRules, (specialInfo) => specialInfo.focusIn);

    const acyclic = AcyclicType.schema();
    const cyclic = CyclicType.schema();
    const flow = FlowType.schema();
    const flatgrid = FlatgridType.schema();
    const matrix = MatrixType.schema();
    const execution = ExecutionType.schema();
    const menu = MenuType.schema();
    const special = SpecialType.schema();

    var KeyboardBranches = /*#__PURE__*/Object.freeze({
        __proto__: null,
        acyclic: acyclic,
        cyclic: cyclic,
        flow: flow,
        flatgrid: flatgrid,
        matrix: matrix,
        execution: execution,
        menu: menu,
        special: special
    });

    const isFlatgridState = (keyState) => hasNonNullableKey(keyState, 'setGridSize');
    const Keying = createModes({
        branchKey: 'mode',
        branches: KeyboardBranches,
        name: 'keying',
        active: {
            events: (keyingConfig, keyingState) => {
                const handler = keyingConfig.handler;
                return handler.toEvents(keyingConfig, keyingState);
            }
        },
        apis: {
            focusIn: (component, keyConfig, keyState) => {
                // If we have a custom sendFocusIn function, use that.
                // Otherwise, we just trigger focus on the outer element.
                keyConfig.sendFocusIn(keyConfig).fold(() => {
                    component.getSystem().triggerFocus(component.element, component.element);
                }, (sendFocusIn) => {
                    sendFocusIn(component, keyConfig, keyState);
                });
            },
            // These APIs are going to be interesting because they are not
            // available for all keying modes
            setGridSize: (component, keyConfig, keyState, numRows, numColumns) => {
                if (!isFlatgridState(keyState)) {
                    // eslint-disable-next-line no-console
                    console.error('Layout does not support setGridSize');
                }
                else {
                    keyState.setGridSize(numRows, numColumns);
                }
            }
        },
        state: KeyingState
    });

    const premadeTag = generate$6('alloy-premade');
    const premade$1 = (comp) => {
        Object.defineProperty(comp.element.dom, premadeTag, {
            value: comp.uid,
            writable: true
        });
        return wrap(premadeTag, comp);
    };
    const isPremade = (element) => has$2(element.dom, premadeTag);
    const getPremade = (spec) => get$h(spec, premadeTag);
    const makeApi = (f) => markAsSketchApi((component, ...rest) => f(component.getApis(), component, ...rest), f);

    const isConnected = (comp) => comp.getSystem().isConnected();
    const fireDetaching = (component) => {
        emit(component, detachedFromDom());
        const children = component.components();
        each$1(children, fireDetaching);
    };
    const fireAttaching = (component) => {
        const children = component.components();
        each$1(children, fireAttaching);
        emit(component, attachedToDom());
    };
    // Unlike attach, a virtualAttach makes no actual DOM changes.
    // This is because it should only be used in a situation
    // where we are patching an existing element.
    const virtualAttach = (parent, child) => {
        // So we still add it to the world
        parent.getSystem().addToWorld(child);
        // And we fire attaching ONLY if it's already in the DOM
        if (inBody(parent.element)) {
            fireAttaching(child);
        }
    };
    // Unlike detach, a virtualDetach makes no actual DOM changes.
    // This is because it's used in patching circumstances.
    const virtualDetach = (comp) => {
        fireDetaching(comp);
        comp.getSystem().removeFromWorld(comp);
    };
    const attach$1 = (parent, child) => {
        append$2(parent.element, child.element);
    };
    const detachChildren$1 = (component) => {
        // This will not detach the component, but will detach its children and sync at the end.
        each$1(component.components(), (childComp) => remove$7(childComp.element));
        // Clear the component also.
        empty(component.element);
        component.syncComponents();
    };
    const replaceChildren = (component, newSpecs, buildNewChildren) => {
        // Detach all existing children
        const subs = component.components();
        detachChildren$1(component);
        const newChildren = buildNewChildren(newSpecs);
        // Determine which components have been deleted and remove them from the world
        const deleted = difference(subs, newChildren);
        each$1(deleted, (comp) => {
            fireDetaching(comp);
            component.getSystem().removeFromWorld(comp);
        });
        // Add all new components
        each$1(newChildren, (childComp) => {
            // If the component isn't connected, ie is new, then we also need to add it to the world
            if (!isConnected(childComp)) {
                component.getSystem().addToWorld(childComp);
                attach$1(component, childComp);
                if (inBody(component.element)) {
                    fireAttaching(childComp);
                }
            }
            else {
                attach$1(component, childComp);
            }
        });
        component.syncComponents();
    };
    const virtualReplaceChildren = (component, newSpecs, buildNewChildren) => {
        // When replacing we don't want to fire detachedFromDom and attachedToDom again for a premade that has just had its position in the children moved around,
        // so we only detach initially if we aren't a premade. Premades will be detached later, but only if they are no longer in the child list.
        const subs = component.components();
        const existingComps = bind$3(newSpecs, (spec) => getPremade(spec).toArray());
        each$1(subs, (childComp) => {
            if (!contains$2(existingComps, childComp)) {
                virtualDetach(childComp);
            }
        });
        const newChildren = buildNewChildren(newSpecs);
        // Determine which components have been deleted and remove them from the world
        // It's probable the component has already been detached beforehand so only
        // detach what's still attached to the world (i.e removed premades)
        const deleted = difference(subs, newChildren);
        each$1(deleted, (deletedComp) => {
            if (isConnected(deletedComp)) {
                virtualDetach(deletedComp);
            }
        });
        // Add all new components
        each$1(newChildren, (childComp) => {
            // If the component isn't connected, ie is new, then we also need to add it to the world
            if (!isConnected(childComp)) {
                virtualAttach(component, childComp);
            }
        });
        component.syncComponents();
    };

    const attach = (parent, child) => {
        attachWith(parent, child, append$2);
    };
    const attachWith = (parent, child, insertion) => {
        parent.getSystem().addToWorld(child);
        insertion(parent.element, child.element);
        if (inBody(parent.element)) {
            fireAttaching(child);
        }
        parent.syncComponents();
    };
    const doDetach = (component) => {
        fireDetaching(component);
        remove$7(component.element);
        component.getSystem().removeFromWorld(component);
    };
    const detach = (component) => {
        const parent$1 = parent(component.element).bind((p) => component.getSystem().getByDom(p).toOptional());
        doDetach(component);
        parent$1.each((p) => {
            p.syncComponents();
        });
    };
    const detachChildren = (component) => {
        // This will not detach the component, but will detach its children and sync at the end.
        const subs = component.components();
        each$1(subs, doDetach);
        // Clear the component also.
        empty(component.element);
        component.syncComponents();
    };
    const attachSystem = (element, guiSystem) => {
        attachSystemWith(element, guiSystem, append$2);
    };
    const attachSystemAfter = (element, guiSystem) => {
        attachSystemWith(element, guiSystem, after$1);
    };
    const attachSystemWith = (element, guiSystem, inserter) => {
        inserter(element, guiSystem.element);
        const children$1 = children(guiSystem.element);
        each$1(children$1, (child) => {
            guiSystem.getByDom(child).each(fireAttaching);
        });
    };
    const detachSystem = (guiSystem) => {
        const children$1 = children(guiSystem.element);
        each$1(children$1, (child) => {
            guiSystem.getByDom(child).each(fireDetaching);
        });
        remove$7(guiSystem.element);
    };

    const determineObsoleted = (parent, index, oldObsoleted) => {
        // When dealing with premades, the process of building something may have moved existing nodes around, so we see
        // if the child at the index position is still the same. If it isn't, we need to introduce some complex behaviour
        //
        // Example:
        // ```<div><premade></premade><span></span></div>```
        // and then moving the premade inside a blockquote
        // ```<div><blockquote><premade></premade></blockquote><span></span></div>```
        //
        // so when you go to replace the first thing it would think there is only 1 child which would be the span, so in
        // this case we insert a marker to keep the span in the same spot.
        const newObsoleted = child$2(parent, index);
        return newObsoleted.map((newObs) => {
            const elemChanged = oldObsoleted.exists((o) => !eq(o, newObs));
            // Adding a marker prevents the case where a premade is added to something shifting it from where
            // it was. That in turn un-synced all trailing children and made it so they couldn't be patched.
            if (elemChanged) {
                const oldTag = oldObsoleted.map(name$3).getOr('span');
                const marker = SugarElement.fromTag(oldTag);
                before$1(newObs, marker);
                return marker;
            }
            else {
                return newObs;
            }
        });
    };
    const ensureInDom = (parent, child, obsoleted) => {
        obsoleted.fold(
        // There is nothing here, so just append to the parent
        () => append$2(parent, child), (obs) => {
            if (!eq(obs, child)) {
                // This situation occurs when the DOM element that has been patched when building it is no
                // longer the one that we need to replace. This is probably caused by premades.
                before$1(obs, child);
                remove$7(obs);
            }
        });
    };
    const patchChildrenWith = (parent, nu, f) => {
        const builtChildren = map$2(nu, f);
        // Need to regather the children in case some of the previous children have moved
        // to an earlier index. So this just prunes any leftover children in the dom.
        const currentChildren = children(parent);
        each$1(currentChildren.slice(builtChildren.length), remove$7);
        return builtChildren;
    };
    const patchSpecChild = (parent, index, spec, build) => {
        // Before building anything, this is the DOM element we are going to try to use.
        const oldObsoleted = child$2(parent, index);
        const childComp = build(spec, oldObsoleted);
        const obsoleted = determineObsoleted(parent, index, oldObsoleted);
        ensureInDom(parent, childComp.element, obsoleted);
        return childComp;
    };
    const patchSpecChildren = (parent, specs, build) => patchChildrenWith(parent, specs, (spec, index) => patchSpecChild(parent, index, spec, build));
    const patchDomChildren = (parent, nodes) => patchChildrenWith(parent, nodes, (node, index) => {
        const optObsoleted = child$2(parent, index);
        ensureInDom(parent, node, optObsoleted);
        return node;
    });

    const preserve = (f, container) => {
        const dos = getRootNode(container);
        const refocus = active$1(dos).bind((focused) => {
            const hasFocus = (elem) => eq(focused, elem);
            return hasFocus(container) ? Optional.some(container) : descendant$1(container, hasFocus);
        });
        const result = f(container);
        // If there is a focussed element, the F function may cause focus to be lost (such as by hiding elements). Restore it afterwards.
        refocus.each((oldFocus) => {
            active$1(dos).filter((newFocus) => eq(newFocus, oldFocus)).fold(() => {
                // Only refocus if the focus has changed, otherwise we break IE
                focus$4(oldFocus);
            }, noop);
        });
        return result;
    };

    const withoutReuse = (parent, data) => {
        preserve(() => {
            replaceChildren(parent, data, () => map$2(data, parent.getSystem().build));
        }, parent.element);
    };
    const withReuse = (parent, data) => {
        // Note: We shouldn't need AriaPreserve since we're trying to keep the existing elements,
        // but let's just do it for now just to be safe.
        preserve(() => {
            virtualReplaceChildren(parent, data, () => {
                // Build the new children
                return patchSpecChildren(parent.element, data, parent.getSystem().buildOrPatch);
            });
        }, parent.element);
    };

    const virtualReplace = (component, replacee, replaceeIndex, childSpec) => {
        virtualDetach(replacee);
        const child = patchSpecChild(component.element, replaceeIndex, childSpec, component.getSystem().buildOrPatch);
        virtualAttach(component, child);
        component.syncComponents();
    };
    const insert = (component, insertion, childSpec) => {
        const child = component.getSystem().build(childSpec);
        attachWith(component, child, insertion);
    };
    const replace = (component, replacee, replaceeIndex, childSpec) => {
        detach(replacee);
        insert(component, (p, c) => appendAt(p, c, replaceeIndex), childSpec);
    };
    const set$3 = (component, replaceConfig, replaceState, data) => {
        const replacer = replaceConfig.reuseDom ? withReuse : withoutReuse;
        return replacer(component, data);
    };
    const append = (component, replaceConfig, replaceState, appendee) => {
        insert(component, append$2, appendee);
    };
    const prepend = (component, replaceConfig, replaceState, prependee) => {
        insert(component, prepend$1, prependee);
    };
    // NOTE: Removee is going to be a component, not a spec.
    const remove = (component, replaceConfig, replaceState, removee) => {
        const children = contents(component);
        const foundChild = find$5(children, (child) => eq(removee.element, child.element));
        foundChild.each(detach);
    };
    // TODO: Rename
    const contents = (component, _replaceConfig) => component.components();
    const replaceAt = (component, replaceConfig, replaceState, replaceeIndex, replacer) => {
        const children = contents(component);
        return Optional.from(children[replaceeIndex]).map((replacee) => {
            replacer.fold(() => detach(replacee), (r) => {
                const replacer = replaceConfig.reuseDom ? virtualReplace : replace;
                replacer(component, replacee, replaceeIndex, r);
            });
            return replacee;
        });
    };
    const replaceBy = (component, replaceConfig, replaceState, replaceePred, replacer) => {
        const children = contents(component);
        return findIndex$1(children, replaceePred).bind((replaceeIndex) => replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer));
    };

    var ReplaceApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        append: append,
        prepend: prepend,
        remove: remove,
        replaceAt: replaceAt,
        replaceBy: replaceBy,
        set: set$3,
        contents: contents
    });

    const Replacing = create$3({
        fields: [
            defaultedBoolean('reuseDom', true)
        ],
        name: 'replacing',
        apis: ReplaceApis
    });

    // The purpose of this check is to ensure that a simulated focus call is not going
    // to recurse infinitely. Essentially, if the originator of the focus call is the same
    // as the element receiving it, and it wasn't its own target, then stop the focus call
    // and log a warning.
    const isRecursive = (component, originator, target) => eq(originator, component.element) && !eq(originator, target);
    const events$g = derive$2([
        can(focus$3(), (component, simulatedEvent) => {
            // originator may not always be there. Will need to check this.
            const event = simulatedEvent.event;
            const originator = event.originator;
            const target = event.target;
            if (isRecursive(component, originator, target)) {
                // eslint-disable-next-line no-console
                console.warn(focus$3() + ' did not get interpreted by the desired target. ' +
                    '\nOriginator: ' + element(originator) +
                    '\nTarget: ' + element(target) +
                    '\nCheck the ' + focus$3() + ' event handlers');
                return false;
            }
            else {
                return true;
            }
        })
    ]);

    var DefaultEvents = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$g
    });

    const prefix$1 = constant$1('alloy-id-');
    const idAttr$1 = constant$1('data-alloy-id');

    const prefix = prefix$1();
    const idAttr = idAttr$1();
    const write = (label, elem) => {
        const id = generate$6(prefix + label);
        writeOnly(elem, id);
        return id;
    };
    const writeOnly = (elem, uid) => {
        Object.defineProperty(elem.dom, idAttr, {
            value: uid,
            writable: true
        });
    };
    const read = (elem) => {
        const id = isElement$1(elem) ? elem.dom[idAttr] : null;
        return Optional.from(id);
    };
    const generate$4 = (prefix) => generate$6(prefix);

    const make$7 = identity;

    const NoContextApi = (getComp) => {
        const getMessage = (event) => `The component must be in a context to execute: ${event}` +
            (getComp ? '\n' + element(getComp().element) + ' is not in context.' : '');
        const fail = (event) => () => {
            throw new Error(getMessage(event));
        };
        const warn = (event) => () => {
            // eslint-disable-next-line no-console
            console.warn(getMessage(event));
        };
        return {
            debugInfo: constant$1('fake'),
            triggerEvent: warn('triggerEvent'),
            triggerFocus: warn('triggerFocus'),
            triggerEscape: warn('triggerEscape'),
            broadcast: warn('broadcast'),
            broadcastOn: warn('broadcastOn'),
            broadcastEvent: warn('broadcastEvent'),
            build: fail('build'),
            buildOrPatch: fail('buildOrPatch'),
            addToWorld: fail('addToWorld'),
            removeFromWorld: fail('removeFromWorld'),
            addToGui: fail('addToGui'),
            removeFromGui: fail('removeFromGui'),
            getByUid: fail('getByUid'),
            getByDom: fail('getByDom'),
            isConnected: never
        };
    };
    const singleton = NoContextApi();

    const generateFrom$1 = (spec, all) => {
        /*
         * This takes a basic record of configured behaviours, defaults their state
         * and ensures that all the behaviours were valid. Will need to document
         * this entire process. Let's see where this is used.
         */
        const schema = map$2(all, (a) => 
        // Optional here probably just due to ForeignGui listing everything it supports. Can most likely
        // change it to strict once I fix the other errors.
        optionObjOf(a.name(), [
            required$1('config'),
            defaulted('state', NoState)
        ]));
        const validated = asRaw('component.behaviours', objOf(schema), spec.behaviours).fold((errInfo) => {
            throw new Error(formatError(errInfo) + '\nComplete spec:\n' +
                JSON.stringify(spec, null, 2));
        }, identity);
        return {
            list: all,
            data: map$1(validated, (optBlobThunk) => {
                const output = optBlobThunk.map((blob) => ({
                    config: blob.config,
                    state: blob.state.init(blob.config)
                }));
                return constant$1(output);
            })
        };
    };
    const getBehaviours$3 = (bData) => bData.list;
    const getData$2 = (bData) => bData.data;

    const byInnerKey = (data, tuple) => {
        const r = {};
        each(data, (detail, key) => {
            each(detail, (value, indexKey) => {
                const chain = get$h(r, indexKey).getOr([]);
                r[indexKey] = chain.concat([
                    tuple(key, value)
                ]);
            });
        });
        return r;
    };

    // Based on all the behaviour exhibits, and the original dom modification, identify
    // the overall combined dom modification that needs to occur
    const combine$1 = (info, baseMod, behaviours, base) => {
        // Clone the object so we can change it.
        const modsByBehaviour = { ...baseMod };
        each$1(behaviours, (behaviour) => {
            modsByBehaviour[behaviour.name()] = behaviour.exhibit(info, base);
        });
        // byAspect format: { classes: [ { name: Toggling, modification: [ 'selected' ] } ] }
        const byAspect = byInnerKey(modsByBehaviour, (name, modification) => ({ name, modification }));
        const combineObjects = (objects) => foldr(objects, (b, a) => ({ ...a.modification, ...b }), {});
        const combinedClasses = foldr(byAspect.classes, (b, a) => a.modification.concat(b), []);
        const combinedAttributes = combineObjects(byAspect.attributes);
        const combinedStyles = combineObjects(byAspect.styles);
        return nu$2({
            classes: combinedClasses,
            attributes: combinedAttributes,
            styles: combinedStyles
        });
    };

    const sortKeys = (label, keyName, array, order) => {
        try {
            const sorted = sort(array, (a, b) => {
                const aKey = a[keyName];
                const bKey = b[keyName];
                const aIndex = order.indexOf(aKey);
                const bIndex = order.indexOf(bKey);
                if (aIndex === -1) {
                    throw new Error('The ordering for ' + label + ' does not have an entry for ' + aKey +
                        '.\nOrder specified: ' + JSON.stringify(order, null, 2));
                }
                if (bIndex === -1) {
                    throw new Error('The ordering for ' + label + ' does not have an entry for ' + bKey +
                        '.\nOrder specified: ' + JSON.stringify(order, null, 2));
                }
                if (aIndex < bIndex) {
                    return -1;
                }
                else if (bIndex < aIndex) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
            return Result.value(sorted);
        }
        catch (err) {
            return Result.error([err]);
        }
    };

    const uncurried = (handler, purpose) => ({
        handler,
        purpose
    });
    const curried = (handler, purpose) => ({
        cHandler: handler,
        purpose
    });
    const curryArgs = (descHandler, extraArgs) => curried(curry.apply(undefined, [descHandler.handler].concat(extraArgs)), descHandler.purpose);
    const getCurried = (descHandler) => descHandler.cHandler;

    const behaviourTuple = (name, handler) => ({
        name,
        handler
    });
    const nameToHandlers = (behaviours, info) => {
        const r = {};
        each$1(behaviours, (behaviour) => {
            r[behaviour.name()] = behaviour.handlers(info);
        });
        return r;
    };
    const groupByEvents = (info, behaviours, base) => {
        const behaviourEvents = {
            ...base,
            ...nameToHandlers(behaviours, info)
        };
        // Now, with all of these events, we need to index by event name
        return byInnerKey(behaviourEvents, behaviourTuple);
    };
    const combine = (info, eventOrder, behaviours, base) => {
        const byEventName = groupByEvents(info, behaviours, base);
        return combineGroups(byEventName, eventOrder);
    };
    const assemble = (rawHandler) => {
        const handler = read$1(rawHandler);
        return (component, simulatedEvent, ...rest) => {
            const args = [component, simulatedEvent].concat(rest);
            if (handler.abort.apply(undefined, args)) {
                simulatedEvent.stop();
            }
            else if (handler.can.apply(undefined, args)) {
                handler.run.apply(undefined, args);
            }
        };
    };
    const missingOrderError = (eventName, tuples) => Result.error([
        'The event (' + eventName + ') has more than one behaviour that listens to it.\nWhen this occurs, you must ' +
            'specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that ' +
            'can trigger it are: ' + JSON.stringify(map$2(tuples, (c) => c.name), null, 2)
    ]);
    const fuse = (tuples, eventOrder, eventName) => {
        // ASSUMPTION: tuples.length will never be 0, because it wouldn't have an entry if it was 0
        const order = eventOrder[eventName];
        if (!order) {
            return missingOrderError(eventName, tuples);
        }
        else {
            return sortKeys('Event: ' + eventName, 'name', tuples, order).map((sortedTuples) => {
                const handlers = map$2(sortedTuples, (tuple) => tuple.handler);
                return fuse$1(handlers);
            });
        }
    };
    const combineGroups = (byEventName, eventOrder) => {
        const r = mapToArray(byEventName, (tuples, eventName) => {
            const combined = tuples.length === 1 ? Result.value(tuples[0].handler) : fuse(tuples, eventOrder, eventName);
            return combined.map((handler) => {
                const assembled = assemble(handler);
                const purpose = tuples.length > 1 ? filter$2(eventOrder[eventName], (o) => exists(tuples, (t) => t.name === o)).join(' > ') : tuples[0].name;
                return wrap(eventName, uncurried(assembled, purpose));
            });
        });
        return consolidate(r, {});
    };

    const baseBehaviour = 'alloy.base.behaviour';
    const schema$s = objOf([
        field$1('dom', 'dom', required$2(), objOf([
            // Note, no children.
            required$1('tag'),
            defaulted('styles', {}),
            defaulted('classes', []),
            defaulted('attributes', {}),
            option$3('value'),
            option$3('innerHtml')
        ])),
        required$1('components'),
        required$1('uid'),
        defaulted('events', {}),
        defaulted('apis', {}),
        // Use mergeWith in the future when pre-built behaviours conflict
        field$1('eventOrder', 'eventOrder', mergeWith({
            // Note, not using constant behaviour names to avoid code size of unused behaviours
            [execute$5()]: ['disabling', baseBehaviour, 'toggling', 'typeaheadevents'],
            [focus$3()]: [baseBehaviour, 'focusing', 'keying'],
            [systemInit()]: [baseBehaviour, 'disabling', 'toggling', 'representing', 'tooltipping'],
            [input()]: [baseBehaviour, 'representing', 'streaming', 'invalidating'],
            [detachedFromDom()]: [baseBehaviour, 'representing', 'item-events', 'toolbar-button-events', 'tooltipping'],
            [mousedown()]: ['focusing', baseBehaviour, 'item-type-events'],
            [touchstart()]: ['focusing', baseBehaviour, 'item-type-events'],
            [mouseover()]: ['item-type-events', 'tooltipping'],
            [receive()]: ['receiving', 'reflecting', 'tooltipping']
        }), anyValue()),
        option$3('domModification')
    ]);
    const toInfo = (spec) => asRaw('custom.definition', schema$s, spec);
    const toDefinition = (detail) => 
    // EFFICIENCY: Consider not merging here.
    ({
        ...detail.dom,
        uid: detail.uid,
        domChildren: map$2(detail.components, (comp) => comp.element)
    });
    const toModification = (detail) => detail.domModification.fold(() => nu$2({}), nu$2);
    const toEvents = (info) => info.events;

    const diffKeyValueSet = (newObj, oldObj) => {
        const newKeys = keys(newObj);
        const oldKeys = keys(oldObj);
        const toRemove = difference(oldKeys, newKeys);
        const toSet = bifilter(newObj, (v, k) => {
            return !has$2(oldObj, k) || v !== oldObj[k];
        }).t;
        return { toRemove, toSet };
    };
    const reconcileToDom = (definition, obsoleted) => {
        const { class: clazz, style, ...existingAttributes } = clone$2(obsoleted);
        const { toSet: attrsToSet, toRemove: attrsToRemove } = diffKeyValueSet(definition.attributes, existingAttributes);
        const updateAttrs = () => {
            each$1(attrsToRemove, (a) => remove$8(obsoleted, a));
            setAll$1(obsoleted, attrsToSet);
        };
        const existingStyles = getAllRaw(obsoleted);
        const { toSet: stylesToSet, toRemove: stylesToRemove } = diffKeyValueSet(definition.styles, existingStyles);
        const updateStyles = () => {
            each$1(stylesToRemove, (s) => remove$6(obsoleted, s));
            setAll(obsoleted, stylesToSet);
        };
        const existingClasses = get$7(obsoleted);
        const classesToRemove = difference(existingClasses, definition.classes);
        const classesToAdd = difference(definition.classes, existingClasses);
        const updateClasses = () => {
            add$1(obsoleted, classesToAdd);
            remove$2(obsoleted, classesToRemove);
        };
        const updateHtml = (html) => {
            set$8(obsoleted, html);
        };
        const updateChildren = () => {
            const children = definition.domChildren;
            patchDomChildren(obsoleted, children);
        };
        const updateValue = () => {
            const valueElement = obsoleted;
            const value = definition.value.getOrUndefined();
            if (value !== get$5(valueElement)) {
                // TINY-8736: Value.set throws an error in case the value is undefined
                set$4(valueElement, value !== null && value !== void 0 ? value : '');
            }
        };
        updateAttrs();
        updateClasses();
        updateStyles();
        // Patching can only support one form of children, so we only update the html or the children, but never both
        definition.innerHtml.fold(updateChildren, updateHtml);
        updateValue();
        return obsoleted;
    };

    const introduceToDom = (definition) => {
        const subject = SugarElement.fromTag(definition.tag);
        setAll$1(subject, definition.attributes);
        add$1(subject, definition.classes);
        setAll(subject, definition.styles);
        // Remember: Order of innerHtml vs children is important.
        definition.innerHtml.each((html) => set$8(subject, html));
        // Children are already elements.
        const children = definition.domChildren;
        append$1(subject, children);
        definition.value.each((value) => {
            set$4(subject, value);
        });
        return subject;
    };
    const attemptPatch = (definition, obsoleted) => {
        try {
            const e = reconcileToDom(definition, obsoleted);
            return Optional.some(e);
        }
        catch (_a) {
            return Optional.none();
        }
    };
    // If a component has both innerHtml and children then we can't patch it
    const hasMixedChildren = (definition) => definition.innerHtml.isSome() && definition.domChildren.length > 0;
    const renderToDom = (definition, optObsoleted) => {
        // If the current tag doesn't match, let's not try to add anything further down the tree.
        // If it does match though and we don't have mixed children then attempt to patch attributes etc...
        const canBePatched = (candidate) => name$3(candidate) === definition.tag && !hasMixedChildren(definition) && !isPremade(candidate);
        const elem = optObsoleted
            .filter(canBePatched)
            .bind((obsoleted) => attemptPatch(definition, obsoleted))
            .getOrThunk(() => introduceToDom(definition));
        writeOnly(elem, definition.uid);
        return elem;
    };

    // This goes through the list of behaviours defined for a particular spec (removing anything
    // that has been revoked), and returns the BehaviourType (e.g. Sliding)
    const getBehaviours$2 = (spec) => {
        const behaviours = get$h(spec, 'behaviours').getOr({});
        return bind$3(keys(behaviours), (name) => {
            const behaviour = behaviours[name];
            return isNonNullable(behaviour) ? [behaviour.me] : [];
        });
    };
    const generateFrom = (spec, all) => generateFrom$1(spec, all);
    const generate$3 = (spec) => {
        const all = getBehaviours$2(spec);
        return generateFrom(spec, all);
    };

    // This is probably far too complicated. I think DomModification is probably
    // questionable as a concept. Maybe it should be deprecated.
    const getDomDefinition = (info, bList, bData) => {
        // Get the current DOM definition from the spec
        const definition = toDefinition(info);
        // Get the current DOM modification definition from the spec
        const infoModification = toModification(info);
        // Treat the DOM modification like it came from a behaviour
        const baseModification = {
            'alloy.base.modification': infoModification
        };
        // Combine the modifications from any defined behaviours
        const modification = bList.length > 0 ? combine$1(bData, baseModification, bList, definition) : infoModification;
        // Transform the DOM definition with the combined dom modifications to make a new DOM definition
        return merge(definition, modification);
    };
    const getEvents = (info, bList, bData) => {
        const baseEvents = {
            'alloy.base.behaviour': toEvents(info)
        };
        return combine(bData, info.eventOrder, bList, baseEvents).getOrDie();
    };
    const build$2 = (spec, obsoleted) => {
        const getMe = () => me;
        const systemApi = Cell(singleton);
        const info = getOrDie(toInfo(spec));
        const bBlob = generate$3(spec);
        const bList = getBehaviours$3(bBlob);
        const bData = getData$2(bBlob);
        const modDefinition = getDomDefinition(info, bList, bData);
        const item = renderToDom(modDefinition, obsoleted);
        const events = getEvents(info, bList, bData);
        const subcomponents = Cell(info.components);
        const connect = (newApi) => {
            systemApi.set(newApi);
        };
        const disconnect = () => {
            systemApi.set(NoContextApi(getMe));
        };
        const syncComponents = () => {
            // Update the component list with the current children
            const children$1 = children(item);
            // INVESTIGATE: Not sure about how to handle text nodes here.
            const subs = bind$3(children$1, (child) => systemApi.get().getByDom(child).fold(() => [], pure$2));
            subcomponents.set(subs);
        };
        // TYPIFY (any here is for the info.apis() pathway)
        const config = (behaviour) => {
            const b = bData;
            const f = isFunction(b[behaviour.name()]) ? b[behaviour.name()] : () => {
                throw new Error('Could not find ' + behaviour.name() + ' in ' + JSON.stringify(spec, null, 2));
            };
            return f();
        };
        const hasConfigured = (behaviour) => isFunction(bData[behaviour.name()]);
        const getApis = () => info.apis;
        const readState = (behaviourName) => bData[behaviourName]().map((b) => b.state.readState()).getOr('not enabled');
        const me = {
            uid: spec.uid,
            getSystem: systemApi.get,
            config,
            hasConfigured,
            spec,
            readState,
            getApis,
            connect,
            disconnect,
            element: item,
            syncComponents,
            components: subcomponents.get,
            events
        };
        return me;
    };

    const buildSubcomponents = (spec, obsoleted) => {
        const components = get$h(spec, 'components').getOr([]);
        return obsoleted.fold(() => map$2(components, build$1), (obs) => map$2(components, (c, i) => {
            return buildOrPatch(c, child$2(obs, i));
        }));
    };
    const buildFromSpec = (userSpec, obsoleted) => {
        const { events: specEvents, ...spec } = make$7(userSpec);
        // Build the subcomponents. A spec hierarchy is built from the bottom up.
        // obsoleted is used to define which element we are attempting to replace
        // so that it might be used to patch the DOM instead of recreate it.
        const components = buildSubcomponents(spec, obsoleted);
        const completeSpec = {
            ...spec,
            events: { ...DefaultEvents, ...specEvents },
            components
        };
        return Result.value(
        // Note, this isn't a spec any more, because it has built children
        build$2(completeSpec, obsoleted));
    };
    const text$2 = (textContent) => {
        const element = SugarElement.fromText(textContent);
        return external({
            element
        });
    };
    const external = (spec) => {
        const extSpec = asRawOrDie$1('external.component', objOfOnly([
            required$1('element'),
            option$3('uid')
        ]), spec);
        const systemApi = Cell(NoContextApi());
        const connect = (newApi) => {
            systemApi.set(newApi);
        };
        const disconnect = () => {
            systemApi.set(NoContextApi(() => me));
        };
        const uid = extSpec.uid.getOrThunk(() => generate$4('external'));
        writeOnly(extSpec.element, uid);
        const me = {
            uid,
            getSystem: systemApi.get,
            config: Optional.none,
            hasConfigured: never,
            connect,
            disconnect,
            getApis: () => ({}),
            element: extSpec.element,
            spec,
            readState: constant$1('No state'),
            syncComponents: noop,
            components: constant$1([]),
            events: {}
        };
        return premade$1(me);
    };
    // We experimented with just having a counter for efficiency, but that fails for situations
    // where an external JS file is using alloy, and is contained within another
    // alloy root container. The ids can conflict, because the counters do not
    // know about each other (being parts of separate scripts).
    //
    // There are other solutions than this ... not sure if they are going to have better performance, though
    const uids = generate$4;
    const isSketchSpec$1 = (spec) => has$2(spec, 'uid');
    // INVESTIGATE: A better way to provide 'meta-specs'
    const buildOrPatch = (spec, obsoleted) => getPremade(spec).getOrThunk(() => {
        // EFFICIENCY: Consider not merging here, and passing uid through separately
        const userSpecWithUid = isSketchSpec$1(spec) ? spec : {
            uid: uids(''),
            ...spec
        };
        return buildFromSpec(userSpecWithUid, obsoleted).getOrDie();
    });
    const build$1 = (spec) => buildOrPatch(spec, Optional.none());
    const premade = premade$1;

    // Mark this component as busy, or blocked.
    const block = (component, config, state, 
    // This works in conjunction with the 'getRoot' function in the config. To
    // attach a blocker component to the dom, ensure that 'getRoot' returns a
    // component, and this function returns the specification of the component to
    // attach.
    getBusySpec) => {
        set$9(component.element, 'aria-busy', true);
        const root = config.getRoot(component).getOr(component);
        const blockerBehaviours = derive$1([
            // Trap the "Tab" key and don't let it escape.
            Keying.config({
                mode: 'special',
                onTab: () => Optional.some(true),
                onShiftTab: () => Optional.some(true)
            }),
            Focusing.config({})
        ]);
        const blockSpec = getBusySpec(root, blockerBehaviours);
        const blocker = root.getSystem().build(blockSpec);
        Replacing.append(root, premade(blocker));
        if (blocker.hasConfigured(Keying) && config.focus) {
            Keying.focusIn(blocker);
        }
        if (!state.isBlocked()) {
            config.onBlock(component);
        }
        state.blockWith(() => Replacing.remove(root, blocker));
    };
    // Mark this component as unblocked, or not busy. This is a noop on a component
    // that isn't blocked.
    const unblock = (component, config, state) => {
        remove$8(component.element, 'aria-busy');
        if (state.isBlocked()) {
            config.onUnblock(component);
        }
        state.clear();
    };
    const isBlocked = (component, blockingConfig, blockingState) => blockingState.isBlocked();

    var BlockingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        block: block,
        unblock: unblock,
        isBlocked: isBlocked
    });

    var BlockingSchema = [
        // The blocking behaviour places a blocking element over the DOM while the
        // component is in the blocked state. If a function is provided here that
        // returns Some, then the blocking element will be added as a child of the
        // element returned. Otherwise, it will be added as a child of the main
        // component.
        defaultedFunction('getRoot', Optional.none),
        // This boolean, if provided, will specify whether the blocking element is
        // focused when the component is first blocked
        defaultedBoolean('focus', true),
        // This function, if provided, will be called any time the component is
        // blocked (unless it was already blocked).
        onHandler('onBlock'),
        // This function, if provided, will be called any time the component is
        // unblocked (unless it was already unblocked).
        onHandler('onUnblock')
    ];

    const init$f = () => {
        const blocker = destroyable();
        const blockWith = (destroy) => {
            blocker.set({ destroy });
        };
        return nu$4({
            readState: blocker.isSet,
            blockWith,
            clear: blocker.clear,
            isBlocked: blocker.isSet
        });
    };

    var BlockingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$f
    });

    // Mark a component as able to be "Blocked" or able to enter a busy state. See
    // BlockingSchema and BlockingApis for more details on how to configure this.
    const Blocking = create$3({
        fields: BlockingSchema,
        name: 'blocking',
        apis: BlockingApis,
        state: BlockingState
    });

    const getCurrent = (component, composeConfig, _composeState) => composeConfig.find(component);

    var ComposeApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getCurrent: getCurrent
    });

    const ComposeSchema = [
        required$1('find')
    ];

    const Composing = create$3({
        fields: ComposeSchema,
        name: 'composing',
        apis: ComposeApis
    });

    const getCoupled = (component, coupleConfig, coupleState, name) => coupleState.getOrCreate(component, coupleConfig, name);
    const getExistingCoupled = (component, coupleConfig, coupleState, name) => coupleState.getExisting(component, coupleConfig, name);

    var CouplingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getCoupled: getCoupled,
        getExistingCoupled: getExistingCoupled
    });

    var CouplingSchema = [
        requiredOf('others', setOf(Result.value, anyValue()))
    ];

    // Unfortunately, the Coupling APIs currently throw errors when the coupled name
    // is not recognised. This is because if the wrong name is used, it is a
    // non-recoverable error, and the developer should be notified. However, there are
    // better ways to do this: (removing this API and only returning Optionals/Results)
    const init$e = () => {
        const coupled = {};
        const lookupCoupled = (coupleConfig, coupledName) => {
            const available = keys(coupleConfig.others);
            if (available.length === 0) {
                throw new Error('Cannot find any known coupled components');
            }
            else {
                return get$h(coupled, coupledName);
            }
        };
        const getOrCreate = (component, coupleConfig, name) => {
            return lookupCoupled(coupleConfig, name).getOrThunk(() => {
                // TODO: TINY-9014 Likely type error. coupleConfig.others[key] is
                // `() => ((comp: AlloyComponent) => AlloySpec)`,
                // but builder is being treated as a `(comp: AlloyComponent) => AlloySpec`
                const builder = get$h(coupleConfig.others, name).getOrDie('No information found for coupled component: ' + name);
                const spec = builder(component);
                const built = component.getSystem().build(spec);
                coupled[name] = built;
                return built;
            });
        };
        const getExisting = (component, coupleConfig, name) => {
            return lookupCoupled(coupleConfig, name).orThunk(() => {
                // Validate we recognise this coupled component's name.
                get$h(coupleConfig.others, name).getOrDie('No information found for coupled component: ' + name);
                // It's a valid name, so return None, because it hasn't been built yet.
                return Optional.none();
            });
        };
        const readState = constant$1({});
        return nu$4({
            readState,
            getExisting,
            getOrCreate
        });
    };

    var CouplingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$e
    });

    const Coupling = create$3({
        fields: CouplingSchema,
        name: 'coupling',
        apis: CouplingApis,
        state: CouplingState
    });

    // Just use "disabled" attribute for these, not "aria-disabled"
    const nativeDisabled = [
        'input',
        'button',
        'textarea',
        'select'
    ];
    const onLoad$5 = (component, disableConfig, disableState) => {
        const f = disableConfig.disabled() ? disable : enable;
        f(component, disableConfig);
    };
    const hasNative = (component, config) => config.useNative === true && contains$2(nativeDisabled, name$3(component.element));
    const nativeIsDisabled = (component) => has$1(component.element, 'disabled');
    const nativeDisable = (component) => {
        set$9(component.element, 'disabled', 'disabled');
    };
    const nativeEnable = (component) => {
        remove$8(component.element, 'disabled');
    };
    const ariaIsDisabled = (component) => get$g(component.element, 'aria-disabled') === 'true';
    const ariaDisable = (component) => {
        set$9(component.element, 'aria-disabled', 'true');
    };
    const ariaEnable = (component) => {
        set$9(component.element, 'aria-disabled', 'false');
    };
    const disable = (component, disableConfig, _disableState) => {
        disableConfig.disableClass.each((disableClass) => {
            add$2(component.element, disableClass);
        });
        const f = hasNative(component, disableConfig) ? nativeDisable : ariaDisable;
        f(component);
        disableConfig.onDisabled(component);
    };
    const enable = (component, disableConfig, _disableState) => {
        disableConfig.disableClass.each((disableClass) => {
            remove$3(component.element, disableClass);
        });
        const f = hasNative(component, disableConfig) ? nativeEnable : ariaEnable;
        f(component);
        disableConfig.onEnabled(component);
    };
    const isDisabled$1 = (component, disableConfig) => hasNative(component, disableConfig) ? nativeIsDisabled(component) : ariaIsDisabled(component);
    const set$2 = (component, disableConfig, disableState, disabled) => {
        const f = disabled ? disable : enable;
        f(component, disableConfig);
    };

    var DisableApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        enable: enable,
        disable: disable,
        isDisabled: isDisabled$1,
        onLoad: onLoad$5,
        set: set$2
    });

    const exhibit$5 = (base, disableConfig) => nu$2({
        // Do not add the attribute yet, because it will depend on the node name
        // if we use "aria-disabled" or just "disabled"
        classes: disableConfig.disabled() ? disableConfig.disableClass.toArray() : []
    });
    const events$f = (disableConfig, disableState) => derive$2([
        abort(execute$5(), (component, _simulatedEvent) => isDisabled$1(component, disableConfig)),
        loadEvent(disableConfig, disableState, onLoad$5)
    ]);

    var ActiveDisable = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$5,
        events: events$f
    });

    var DisableSchema = [
        defaultedFunction('disabled', never),
        defaulted('useNative', true),
        option$3('disableClass'),
        onHandler('onDisabled'),
        onHandler('onEnabled')
    ];

    const Disabling = create$3({
        fields: DisableSchema,
        name: 'disabling',
        active: ActiveDisable,
        apis: DisableApis
    });

    const NuPositionCss = (position, left, top, right, bottom) => {
        const toPx = (num) => num + 'px';
        return {
            position,
            left: left.map(toPx),
            top: top.map(toPx),
            right: right.map(toPx),
            bottom: bottom.map(toPx)
        };
    };
    const toOptions = (position) => ({
        ...position,
        position: Optional.some(position.position)
    });
    const applyPositionCss = (element, position) => {
        setOptions(element, toOptions(position));
    };

    const appear = (component, contextualInfo) => {
        const elem = component.element;
        add$2(elem, contextualInfo.transitionClass);
        remove$3(elem, contextualInfo.fadeOutClass);
        add$2(elem, contextualInfo.fadeInClass);
        contextualInfo.onShow(component);
    };
    const disappear = (component, contextualInfo) => {
        const elem = component.element;
        add$2(elem, contextualInfo.transitionClass);
        remove$3(elem, contextualInfo.fadeInClass);
        add$2(elem, contextualInfo.fadeOutClass);
        contextualInfo.onHide(component);
    };
    const isPartiallyVisible = (box, bounds) => box.y < bounds.bottom && box.bottom > bounds.y;
    const isTopCompletelyVisible = (box, bounds) => box.y >= bounds.y;
    const isBottomCompletelyVisible = (box, bounds) => box.bottom <= bounds.bottom;
    const forceTopPosition = (winBox, leftX, viewport) => ({
        location: 'top',
        leftX,
        topY: viewport.bounds.y - winBox.y
    });
    const forceBottomPosition = (winBox, leftX, viewport) => ({
        location: 'bottom',
        leftX,
        bottomY: winBox.bottom - viewport.bounds.bottom
    });
    const getDockedLeftPosition = (bounds) => {
        // Essentially, we are just getting the bounding client rect left here,
        // because winBox.x will be the scroll value.
        return bounds.box.x - bounds.win.x;
    };
    const tryDockingPosition = (modes, bounds, viewport) => {
        const winBox = bounds.win;
        const box = bounds.box;
        const leftX = getDockedLeftPosition(bounds);
        return findMap(modes, (mode) => {
            switch (mode) {
                case 'bottom':
                    return !isBottomCompletelyVisible(box, viewport.bounds) ? Optional.some(forceBottomPosition(winBox, leftX, viewport)) : Optional.none();
                case 'top':
                    return !isTopCompletelyVisible(box, viewport.bounds) ? Optional.some(forceTopPosition(winBox, leftX, viewport)) : Optional.none();
                default:
                    return Optional.none();
            }
        }).getOr({
            location: 'no-dock'
        });
    };
    const isVisibleForModes = (modes, box, viewport) => forall(modes, (mode) => {
        switch (mode) {
            case 'bottom':
                return isBottomCompletelyVisible(box, viewport.bounds);
            case 'top':
                return isTopCompletelyVisible(box, viewport.bounds);
        }
    });
    const getXYForRestoring = (pos, viewport) => {
        const priorY = viewport.optScrollEnv.fold(constant$1(pos.bounds.y), (scrollEnv) => scrollEnv.scrollElmTop + (pos.bounds.y - scrollEnv.currentScrollTop));
        return SugarPosition(pos.bounds.x, priorY);
    };
    const getXYForSaving = (box, viewport) => {
        const priorY = viewport.optScrollEnv.fold(constant$1(box.y), (scrollEnv) => box.y + scrollEnv.currentScrollTop - scrollEnv.scrollElmTop);
        return SugarPosition(box.x, priorY);
    };
    const getPrior = (elem, viewport, state) => state.getInitialPos().map((pos) => {
        const xy = getXYForRestoring(pos, viewport);
        return {
            box: bounds(xy.left, xy.top, get$c(elem), get$d(elem)),
            location: pos.location
        };
    });
    const storePrior = (elem, box, viewport, state, decision) => {
        const xy = getXYForSaving(box, viewport);
        const bounds$1 = bounds(xy.left, xy.top, box.width, box.height);
        state.setInitialPos({
            style: getAllRaw(elem),
            position: get$e(elem, 'position') || 'static',
            bounds: bounds$1,
            location: decision.location
        });
    };
    // When we are using APIs like forceDockToTop, then we only want to store the previous position
    // if we weren't already docked. Otherwise, we still want to move the component, but keep its old
    // restore values
    const storePriorIfNone = (elem, box, viewport, state, decision) => {
        state.getInitialPos().fold(() => storePrior(elem, box, viewport, state, decision), () => noop);
    };
    const revertToOriginal = (elem, box, state) => state.getInitialPos().bind((position) => {
        var _a;
        state.clearInitialPos();
        switch (position.position) {
            case 'static':
                return Optional.some({
                    morph: 'static'
                });
            case 'absolute':
                const offsetParent = getOffsetParent(elem).getOr(body());
                const offsetBox = box$1(offsetParent);
                // Adding the scrollDelta here may not be the right solution. The basic problem is that the
                // rest of the code isn't considering whether its absolute or not, and where the offset parent
                // is. In the situation where the offset parent is *inside* the scrolling environment, then
                // we don't need to consider the scroll, and that's what getXYForRestoring does ... it removes
                // the scroll. We don't need to consider the scroll because the sink is already affected by the
                // scroll. However, when the sink IS the scroller, its position is not moved by scrolling. But the
                // positions of everything inside it needs to consider the scroll. So we add the scroll value.
                //
                // This might also be a bit naive. It's possible that we need to check that the offsetParent
                // is THE scroller, not just that it has a scroll value. For example, if the offset parent
                // was the body, and the body had a scroll, this might give unexpected results. That's somewhat
                // countered by the fact that if the offset parent is outside the scroller, then you don't really
                // have a scrolling environment any more, because the offset parent isn't going to be impacted
                // at all by the scroller
                const scrollDelta = (_a = offsetParent.dom.scrollTop) !== null && _a !== void 0 ? _a : 0;
                return Optional.some({
                    morph: 'absolute',
                    positionCss: NuPositionCss('absolute', get$h(position.style, 'left').map((_left) => box.x - offsetBox.x), get$h(position.style, 'top').map((_top) => box.y - offsetBox.y + scrollDelta), get$h(position.style, 'right').map((_right) => offsetBox.right - box.right), get$h(position.style, 'bottom').map((_bottom) => offsetBox.bottom - box.bottom))
                });
            default:
                return Optional.none();
        }
    });
    const tryMorphToOriginal = (elem, viewport, state) => getPrior(elem, viewport, state)
        .filter(({ box }) => isVisibleForModes(state.getModes(), box, viewport))
        .bind(({ box }) => revertToOriginal(elem, box, state));
    const tryDecisionToFixedMorph = (decision) => {
        switch (decision.location) {
            case 'top': {
                // We store our current position so we can revert to it once it's
                // visible again.
                return Optional.some({
                    morph: 'fixed',
                    positionCss: NuPositionCss('fixed', Optional.some(decision.leftX), Optional.some(decision.topY), Optional.none(), Optional.none())
                });
            }
            case 'bottom': {
                // We store our current position so we can revert to it once it's
                // visible again.
                return Optional.some({
                    morph: 'fixed',
                    positionCss: NuPositionCss('fixed', Optional.some(decision.leftX), Optional.none(), Optional.none(), Optional.some(decision.bottomY))
                });
            }
            default:
                return Optional.none();
        }
    };
    const tryMorphToFixed = (elem, viewport, state) => {
        const box = box$1(elem);
        const winBox = win();
        const decision = tryDockingPosition(state.getModes(), {
            win: winBox,
            box
        }, viewport);
        if (decision.location === 'top' || decision.location === 'bottom') {
            // We are moving from undocked to docked, so store the previous location
            // so that we can restore it when we switch out of docking (back to undocked)
            storePrior(elem, box, viewport, state, decision);
            return tryDecisionToFixedMorph(decision);
        }
        else {
            return Optional.none();
        }
    };
    const tryMorphToOriginalOrUpdateFixed = (elem, viewport, state) => {
        // When a "docked" element is docked to the top of a scroll container (due to optScrollEnv in
        // viewport), we need to reposition its fixed if the scroll container has itself moved its top position.
        // This isn't required when the docking is to the top of the window, because the entire window cannot
        // be scrolled up and down the page - it is the page.
        //
        // Imagine a situation where the toolbar has docked to the top of the scroll container, which is at
        // y = 200. Now, when the user scrolls the page another 50px down the page, the top of the scroll
        // container will now be 150px, but the "fixed" toolbar will still be at "200px". So this is a morph
        // from "fixed" to "fixed", but with new coordinates. So if we can't morph to original from "fixed",
        // we try to update our "fixed" position (if we have a scrolling environment in the viewport)
        return tryMorphToOriginal(elem, viewport, state)
            .orThunk(() => {
            // Importantly, we don't update our stored position for the element before "docking", because
            // this is a transition between "docked" and "docked", not "undocked" and "docked". We want to
            // keep our undocked position in our store, not a docked position.
            // So we don't change our stored position. We just improve our fixed.
            return viewport.optScrollEnv
                .bind((_) => getPrior(elem, viewport, state))
                .bind(({ box, location }) => {
                const winBox = win();
                const leftX = getDockedLeftPosition({ win: winBox, box });
                // Keep the same docking location
                const decision = location === 'top'
                    ? forceTopPosition(winBox, leftX, viewport)
                    : forceBottomPosition(winBox, leftX, viewport);
                return tryDecisionToFixedMorph(decision);
            });
        });
    };
    const tryMorph = (component, viewport, state) => {
        const elem = component.element;
        const isDocked = is$1(getRaw(elem, 'position'), 'fixed');
        return isDocked
            ? tryMorphToOriginalOrUpdateFixed(elem, viewport, state)
            : tryMorphToFixed(elem, viewport, state);
    };
    // The difference between the "calculate" functions and the "try" functions is that the "try" functions
    // will first consider whether there is a need to morph, whereas the "calculate" functions will just
    // give you the morph details, bypassing the check to see if it's needed
    const calculateMorphToOriginal = (component, viewport, state) => {
        const elem = component.element;
        return getPrior(elem, viewport, state)
            .bind(({ box }) => revertToOriginal(elem, box, state));
    };
    const forceDockWith = (elem, viewport, state, getDecision) => {
        const box = box$1(elem);
        const winBox = win();
        const leftX = getDockedLeftPosition({ win: winBox, box });
        const decision = getDecision(winBox, leftX, viewport);
        if (decision.location === 'bottom' || decision.location === 'top') {
            // We only want to store the values if we aren't already docking. If we are already docking, then
            // we just want to move the element, without updating where it started originally
            storePriorIfNone(elem, box, viewport, state, decision);
            return tryDecisionToFixedMorph(decision);
        }
        else {
            return Optional.none();
        }
    };

    const morphToStatic = (component, config, state) => {
        state.setDocked(false);
        each$1(['left', 'right', 'top', 'bottom', 'position'], (prop) => remove$6(component.element, prop));
        config.onUndocked(component);
    };
    const morphToCoord = (component, config, state, position) => {
        const isDocked = position.position === 'fixed';
        state.setDocked(isDocked);
        applyPositionCss(component.element, position);
        const method = isDocked ? config.onDocked : config.onUndocked;
        method(component);
    };
    const updateVisibility = (component, config, state, viewport, morphToDocked = false) => {
        config.contextual.each((contextInfo) => {
            // Make the dockable component disappear if the context is outside the viewport
            contextInfo.lazyContext(component).each((box) => {
                const isVisible = isPartiallyVisible(box, viewport.bounds);
                if (isVisible !== state.isVisible()) {
                    state.setVisible(isVisible);
                    // If morphing to docked and the context isn't visible then immediately set
                    // the fadeout class and don't worry about transitioning, as the context
                    // would never have been in view while docked
                    if (morphToDocked && !isVisible) {
                        add$1(component.element, [contextInfo.fadeOutClass]);
                        contextInfo.onHide(component);
                    }
                    else {
                        const method = isVisible ? appear : disappear;
                        method(component, contextInfo);
                    }
                }
            });
        });
    };
    const applyFixedMorph = (component, config, state, viewport, morph) => {
        // This "updateVisibility" call is potentially duplicated with the
        // call in refreshInternal for isDocked. We might want to consolidate them.
        // The difference between them is the "morphToDocked" flag.
        updateVisibility(component, config, state, viewport, true);
        morphToCoord(component, config, state, morph.positionCss);
    };
    const applyMorph = (component, config, state, viewport, morph) => {
        // Apply the morph result depending on its type
        switch (morph.morph) {
            case 'static': {
                return morphToStatic(component, config, state);
            }
            case 'absolute': {
                return morphToCoord(component, config, state, morph.positionCss);
            }
            case 'fixed': {
                return applyFixedMorph(component, config, state, viewport, morph);
            }
        }
    };
    const refreshInternal = (component, config, state) => {
        // Absolute coordinates (considers scroll)
        const viewport = config.lazyViewport(component);
        updateVisibility(component, config, state, viewport);
        tryMorph(component, viewport, state).each((morph) => {
            applyMorph(component, config, state, viewport, morph);
        });
    };
    const resetInternal = (component, config, state) => {
        // Morph back to the original position
        const elem = component.element;
        state.setDocked(false);
        const viewport = config.lazyViewport(component);
        calculateMorphToOriginal(component, viewport, state).each((staticOrAbsoluteMorph) => {
            // This code is very similar to the "applyMorph" function above. The main difference
            // is that it doesn't consider fixed position, because something that is docking
            // can't currently start with fixed position
            switch (staticOrAbsoluteMorph.morph) {
                case 'static': {
                    morphToStatic(component, config, state);
                    break;
                }
                case 'absolute': {
                    morphToCoord(component, config, state, staticOrAbsoluteMorph.positionCss);
                    break;
                }
            }
        });
        // Remove contextual visibility classes
        state.setVisible(true);
        config.contextual.each((contextInfo) => {
            remove$2(elem, [contextInfo.fadeInClass, contextInfo.fadeOutClass, contextInfo.transitionClass]);
            contextInfo.onShow(component);
        });
        // Apply docking again to reset the position
        refresh$4(component, config, state);
    };
    const refresh$4 = (component, config, state) => {
        // Ensure the component is attached to the document/world, if not then do nothing as we can't
        // check if the component should be docked or not when in a detached state
        if (component.getSystem().isConnected()) {
            refreshInternal(component, config, state);
        }
    };
    const reset$1 = (component, config, state) => {
        // If the component is not docked then there's no need to reset the state,
        // so only reset when docked
        if (state.isDocked()) {
            resetInternal(component, config, state);
        }
    };
    const forceDockWithDecision = (getDecision) => (component, config, state) => {
        const viewport = config.lazyViewport(component);
        const optMorph = forceDockWith(component.element, viewport, state, getDecision);
        optMorph.each((morph) => {
            // ASSUMPTION: This "applyFixedMorph" sets state.setDocked to true.
            applyFixedMorph(component, config, state, viewport, morph);
        });
    };
    const forceDockToTop = forceDockWithDecision(forceTopPosition);
    const forceDockToBottom = forceDockWithDecision(forceBottomPosition);
    const isDocked$2 = (component, config, state) => state.isDocked();
    const setModes = (component, config, state, modes) => state.setModes(modes);
    const getModes = (component, config, state) => state.getModes();

    var DockingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        refresh: refresh$4,
        reset: reset$1,
        isDocked: isDocked$2,
        getModes: getModes,
        setModes: setModes,
        forceDockToTop: forceDockToTop,
        forceDockToBottom: forceDockToBottom
    });

    const events$e = (dockInfo, dockState) => derive$2([
        runOnSource(transitionend(), (component, simulatedEvent) => {
            dockInfo.contextual.each((contextInfo) => {
                if (has(component.element, contextInfo.transitionClass)) {
                    remove$2(component.element, [contextInfo.transitionClass, contextInfo.fadeInClass]);
                    const notify = dockState.isVisible() ? contextInfo.onShown : contextInfo.onHidden;
                    notify(component);
                }
                simulatedEvent.stop();
            });
        }),
        run$1(windowScroll(), (component, _) => {
            refresh$4(component, dockInfo, dockState);
        }),
        run$1(externalElementScroll(), (component, _) => {
            refresh$4(component, dockInfo, dockState);
        }),
        run$1(windowResize(), (component, _) => {
            reset$1(component, dockInfo, dockState);
        })
    ]);

    var ActiveDocking = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$e
    });

    var DockingSchema = [
        optionObjOf('contextual', [
            requiredString('fadeInClass'),
            requiredString('fadeOutClass'),
            requiredString('transitionClass'),
            requiredFunction('lazyContext'),
            onHandler('onShow'),
            onHandler('onShown'),
            onHandler('onHide'),
            onHandler('onHidden')
        ]),
        defaultedFunction('lazyViewport', () => ({
            bounds: win(),
            optScrollEnv: Optional.none()
        })),
        defaultedArrayOf('modes', ['top', 'bottom'], string),
        onHandler('onDocked'),
        onHandler('onUndocked')
    ];

    const init$d = (spec) => {
        const docked = Cell(false);
        const visible = Cell(true);
        const initialBounds = value$2();
        const modes = Cell(spec.modes);
        const readState = () => `docked:  ${docked.get()}, visible: ${visible.get()}, modes: ${modes.get().join(',')}`;
        return nu$4({
            isDocked: docked.get,
            setDocked: docked.set,
            getInitialPos: initialBounds.get,
            setInitialPos: initialBounds.set,
            clearInitialPos: initialBounds.clear,
            isVisible: visible.get,
            setVisible: visible.set,
            getModes: modes.get,
            setModes: modes.set,
            readState
        });
    };

    var DockingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$d
    });

    const Docking = create$3({
        fields: DockingSchema,
        name: 'docking',
        active: ActiveDocking,
        apis: DockingApis,
        state: DockingState
    });

    /*
     * origin: the position (without scroll) of the offset parent
     * scroll: the scrolling position of the window
     *
     * fixed: the fixed coordinates to show for css
     * offset: the absolute coordinates to show for css when inside an offset parent
     * absolute: the absolute coordinates to show before considering the offset parent
     */
    const adt$4 = Adt.generate([
        { offset: ['x', 'y'] },
        { absolute: ['x', 'y'] },
        { fixed: ['x', 'y'] }
    ]);
    const subtract = (change) => (point) => point.translate(-change.left, -change.top);
    const add = (change) => (point) => point.translate(change.left, change.top);
    const transform = (changes) => (x, y) => foldl(changes, (rest, f) => f(rest), SugarPosition(x, y));
    const asFixed = (coord, scroll, origin) => coord.fold(
    // offset to fixed
    transform([add(origin), subtract(scroll)]), 
    // absolute to fixed
    transform([subtract(scroll)]), 
    // fixed to fixed
    transform([]));
    const asAbsolute = (coord, scroll, origin) => coord.fold(
    // offset to absolute
    transform([add(origin)]), 
    // absolute to absolute
    transform([]), 
    // fixed to absolute
    transform([add(scroll)]));
    const asOffset = (coord, scroll, origin) => coord.fold(
    // offset to offset
    transform([]), 
    // absolute to offset
    transform([subtract(origin)]), 
    // fixed to offset
    transform([add(scroll), subtract(origin)]));
    const withinRange = (coord1, coord2, xRange, yRange, scroll, origin) => {
        const a1 = asAbsolute(coord1, scroll, origin);
        const a2 = asAbsolute(coord2, scroll, origin);
        // console.log(`a1.left: ${a1.left}, a2.left: ${a2.left}, leftDelta: ${a1.left - a2.left}, xRange: ${xRange}, lD <= xRange: ${Math.abs(a1.left - a2.left) <= xRange}`);
        // console.log(`a1.top: ${a1.top}, a2.top: ${a2.top}, topDelta: ${a1.top - a2.top}, yRange: ${yRange}, lD <= xRange: ${Math.abs(a1.top - a2.top) <= yRange}`);
        return Math.abs(a1.left - a2.left) <= xRange &&
            Math.abs(a1.top - a2.top) <= yRange;
    };
    const getDeltas = (coord1, coord2, xRange, yRange, scroll, origin) => {
        const a1 = asAbsolute(coord1, scroll, origin);
        const a2 = asAbsolute(coord2, scroll, origin);
        const left = Math.abs(a1.left - a2.left);
        const top = Math.abs(a1.top - a2.top);
        return SugarPosition(left, top);
    };
    const toStyles = (coord, scroll, origin) => {
        const stylesOpt = coord.fold((x, y) => ({ position: Optional.some('absolute'), left: Optional.some(x + 'px'), top: Optional.some(y + 'px') }), // offset
        (x, y) => ({ position: Optional.some('absolute'), left: Optional.some((x - origin.left) + 'px'), top: Optional.some((y - origin.top) + 'px') }), // absolute
        (x, y) => ({ position: Optional.some('fixed'), left: Optional.some(x + 'px'), top: Optional.some(y + 'px') }) // fixed
        );
        return { right: Optional.none(), bottom: Optional.none(), ...stylesOpt };
    };
    const translate$2 = (coord, deltaX, deltaY) => coord.fold((x, y) => offset(x + deltaX, y + deltaY), (x, y) => absolute$1(x + deltaX, y + deltaY), (x, y) => fixed$1(x + deltaX, y + deltaY));
    const absorb = (partialCoord, originalCoord, scroll, origin) => {
        const absorbOne = (stencil, nu) => (optX, optY) => {
            const original = stencil(originalCoord, scroll, origin);
            return nu(optX.getOr(original.left), optY.getOr(original.top));
        };
        return partialCoord.fold(absorbOne(asOffset, offset), absorbOne(asAbsolute, absolute$1), absorbOne(asFixed, fixed$1));
    };
    const offset = adt$4.offset;
    const absolute$1 = adt$4.absolute;
    const fixed$1 = adt$4.fixed;

    const parseAttrToInt = (element, name) => {
        const value = get$g(element, name);
        return isUndefined(value) ? NaN : parseInt(value, 10);
    };
    // NOTE: Moved from ego with some parameterisation
    const get$3 = (component, snapsInfo) => {
        const element = component.element;
        const x = parseAttrToInt(element, snapsInfo.leftAttr);
        const y = parseAttrToInt(element, snapsInfo.topAttr);
        return isNaN(x) || isNaN(y) ? Optional.none() : Optional.some(SugarPosition(x, y));
    };
    const set$1 = (component, snapsInfo, pt) => {
        const element = component.element;
        set$9(element, snapsInfo.leftAttr, pt.left + 'px');
        set$9(element, snapsInfo.topAttr, pt.top + 'px');
    };
    const clear = (component, snapsInfo) => {
        const element = component.element;
        remove$8(element, snapsInfo.leftAttr);
        remove$8(element, snapsInfo.topAttr);
    };

    // Types of coordinates
    // SugarLocation: This is the position on the screen including scroll.
    // Absolute: This is the css setting that would be applied. Therefore, it subtracts
    // the origin of the relative offsetParent.
    // Fixed: This is the fixed position.
    /*
     So in attempt to make this more understandable, let's use offset, absolute, and fixed.
     and try and model individual combinators
    */
    /*

     Relationships:
       - location -> absolute: should just need to subtract the position of the offset parent (origin)
       - location -> fixed: subtract the scrolling
       - absolute -> fixed: add the origin, and subtract the scrolling
       - absolute -> location: add the origin
       - fixed -> absolute: add the scrolling, remove the origin
       - fixed -> location: add the scrolling

    /*
     * When the user is dragging around the element, and it snaps into place, it is important
     * for the next movement to be from its pre-snapped location, rather than the snapped location.
     * This is because if it is from the snapped location the next delta movement may not actually
     * be high enough to get it out of the snap area, and hence, it will just snap again (and again).
     */
    // This identifies the position of the draggable element as either its current position, or the position
    // that we put on it before we snapped it into place (before dropping). Once it's dropped, the presnap
    // position will go away. It is used to avoid the situation where you can't escape the snap unless you
    // move the mouse really quickly :)
    const getCoords = (component, snapInfo, coord, delta) => get$3(component, snapInfo).fold(() => coord, (fixed) => 
    // We have a pre-snap position, so we have to apply the delta ourselves
    fixed$1(fixed.left + delta.left, fixed.top + delta.top));
    const moveOrSnap = (component, snapInfo, coord, delta, scroll, origin) => {
        const newCoord = getCoords(component, snapInfo, coord, delta);
        const snap = snapInfo.mustSnap ? findClosestSnap(component, snapInfo, newCoord, scroll, origin) :
            findSnap(component, snapInfo, newCoord, scroll, origin);
        const fixedCoord = asFixed(newCoord, scroll, origin);
        set$1(component, snapInfo, fixedCoord);
        return snap.fold(() => ({
            coord: fixed$1(fixedCoord.left, fixedCoord.top),
            extra: Optional.none()
        })
        // No snap.
        // var newfixed = graph.boundToFixed(theatre, element, loc.left, loc.top, fixed.left, fixed.top, height);
        // presnaps.set(element, 'fixed', newfixed.left, newfixed.top);
        // return { position: 'fixed', left: newfixed.left + 'px', top: newfixed.top + 'px' };
        , (spanned) => ({
            coord: spanned.output,
            extra: spanned.extra
        }));
    };
    const stopDrag = (component, snapInfo) => {
        clear(component, snapInfo);
    };
    const findMatchingSnap = (snaps, newCoord, scroll, origin) => findMap(snaps, (snap) => {
        const sensor = snap.sensor;
        const inRange = withinRange(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);
        return inRange ? Optional.some({
            output: absorb(snap.output, newCoord, scroll, origin),
            extra: snap.extra
        }) : Optional.none();
    });
    const findClosestSnap = (component, snapInfo, newCoord, scroll, origin) => {
        // You need to pass in the absX and absY so that they can be used for things which only care about snapping one axis and keeping the other one.
        const snaps = snapInfo.getSnapPoints(component);
        const matchSnap = findMatchingSnap(snaps, newCoord, scroll, origin);
        return matchSnap.orThunk(() => {
            const bestSnap = foldl(snaps, (acc, snap) => {
                const sensor = snap.sensor;
                const deltas = getDeltas(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);
                return acc.deltas.fold(() => ({
                    deltas: Optional.some(deltas),
                    snap: Optional.some(snap)
                }), (bestDeltas) => {
                    const currAvg = (deltas.left + deltas.top) / 2;
                    const bestAvg = (bestDeltas.left + bestDeltas.top) / 2;
                    if (currAvg <= bestAvg) {
                        return {
                            deltas: Optional.some(deltas),
                            snap: Optional.some(snap)
                        };
                    }
                    else {
                        return acc;
                    }
                });
            }, {
                deltas: Optional.none(),
                snap: Optional.none()
            });
            return bestSnap.snap.map((snap) => ({
                output: absorb(snap.output, newCoord, scroll, origin),
                extra: snap.extra
            }));
        });
    };
    // x: the absolute position.left of the draggable element
    // y: the absolute position.top of the draggable element
    // deltaX: the amount the mouse has moved horizontally
    // deltaY: the amount the mouse has moved vertically
    const findSnap = (component, snapInfo, newCoord, scroll, origin) => {
        // You need to pass in the absX and absY so that they can be used for things which only care about snapping one axis and keeping the other one.
        const snaps = snapInfo.getSnapPoints(component);
        // HERE
        return findMatchingSnap(snaps, newCoord, scroll, origin);
    };
    const snapTo$1 = (snap, scroll, origin) => ({
        // TODO: This looks to be incorrect and needs fixing as DragCoord definitely needs a number
        // based drag coord for the second argument here, so this is probably a bug.
        coord: absorb(snap.output, snap.output, scroll, origin),
        extra: snap.extra
    });

    const snapTo = (component, dragConfig, _state, snap) => {
        const target = dragConfig.getTarget(component.element);
        if (dragConfig.repositionTarget) {
            const doc = owner$4(component.element);
            const scroll = get$b(doc);
            const origin = getOrigin(target);
            const snapPin = snapTo$1(snap, scroll, origin);
            const styles = toStyles(snapPin.coord, scroll, origin);
            setOptions(target, styles);
        }
    };

    var DraggingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        snapTo: snapTo
    });

    const field = (name, forbidden) => defaultedObjOf(name, {}, map$2(forbidden, (f) => forbid(f.name(), 'Cannot configure ' + f.name() + ' for ' + name)).concat([
        customField('dump', identity)
    ]));
    const get$2 = (data) => data.dump;
    const augment = (data, original) => ({
        ...derive$1(original),
        ...data.dump
    });
    // Is this used?
    const SketchBehaviours = {
        field,
        augment,
        get: get$2
    };

    const base = (partSchemas, partUidsSchemas) => {
        const ps = partSchemas.length > 0 ? [
            requiredObjOf('parts', partSchemas)
        ] : [];
        return ps.concat([
            required$1('uid'),
            defaulted('dom', {}), // Maybe get rid of.
            defaulted('components', []),
            snapshot('originalSpec'),
            defaulted('debug.sketcher', {})
        ]).concat(partUidsSchemas);
    };
    const asRawOrDie = (label, schema, spec, partSchemas, partUidsSchemas) => {
        const baseS = base(partSchemas, partUidsSchemas);
        return asRawOrDie$1(label + ' [SpecSchema]', objOfOnly(baseS.concat(schema)), spec);
    };

    const single$1 = (owner, schema, factory, spec) => {
        const specWithUid = supplyUid(spec);
        const detail = asRawOrDie(owner, schema, specWithUid, [], []);
        return factory(detail, specWithUid);
    };
    const composite$1 = (owner, schema, partTypes, factory, spec) => {
        const specWithUid = supplyUid(spec);
        // Identify any information required for external parts
        const partSchemas = schemas(partTypes);
        // Generate partUids for all parts (external and otherwise)
        const partUidsSchema = defaultUidsSchema(partTypes);
        const detail = asRawOrDie(owner, schema, specWithUid, partSchemas, [partUidsSchema]);
        // Create (internals, externals) substitutions
        const subs = substitutes(owner, detail, partTypes);
        // Work out the components by substituting internals
        const components = components$1(owner, detail, subs.internals());
        return factory(detail, components, specWithUid, subs.externals());
    };
    const hasUid = (spec) => has$2(spec, 'uid');
    const supplyUid = (spec) => {
        return hasUid(spec) ? spec : {
            ...spec,
            uid: generate$4('uid')
        };
    };

    const isSketchSpec = (spec) => {
        return spec.uid !== undefined;
    };
    const singleSchema = objOfOnly([
        required$1('name'),
        required$1('factory'),
        required$1('configFields'),
        defaulted('apis', {}),
        defaulted('extraApis', {})
    ]);
    const compositeSchema = objOfOnly([
        required$1('name'),
        required$1('factory'),
        required$1('configFields'),
        required$1('partFields'),
        defaulted('apis', {}),
        defaulted('extraApis', {})
    ]);
    const single = (rawConfig) => {
        const config = asRawOrDie$1('Sketcher for ' + rawConfig.name, singleSchema, rawConfig);
        const sketch = (spec) => single$1(config.name, config.configFields, config.factory, spec);
        const apis = map$1(config.apis, makeApi);
        const extraApis = map$1(config.extraApis, (f, k) => markAsExtraApi(f, k));
        return {
            name: config.name,
            configFields: config.configFields,
            sketch,
            ...apis,
            ...extraApis
        };
    };
    const composite = (rawConfig) => {
        const config = asRawOrDie$1('Sketcher for ' + rawConfig.name, compositeSchema, rawConfig);
        const sketch = (spec) => composite$1(config.name, config.configFields, config.partFields, config.factory, spec);
        // These are constructors that will store their configuration.
        const parts = generate$5(config.name, config.partFields);
        const apis = map$1(config.apis, makeApi);
        const extraApis = map$1(config.extraApis, (f, k) => markAsExtraApi(f, k));
        return {
            name: config.name,
            partFields: config.partFields,
            configFields: config.configFields,
            sketch,
            parts,
            ...apis,
            ...extraApis
        };
    };

    const factory$n = (detail) => {
        const { attributes, ...domWithoutAttributes } = detail.dom;
        return {
            uid: detail.uid,
            dom: {
                tag: 'div',
                attributes: {
                    role: 'presentation',
                    ...attributes
                },
                ...domWithoutAttributes
            },
            components: detail.components,
            behaviours: get$2(detail.containerBehaviours),
            events: detail.events,
            domModification: detail.domModification,
            eventOrder: detail.eventOrder
        };
    };
    const Container = single({
        name: 'Container',
        factory: factory$n,
        configFields: [
            defaulted('components', []),
            field('containerBehaviours', []),
            // TODO: Deprecate
            defaulted('events', {}),
            defaulted('domModification', {}),
            defaulted('eventOrder', {})
        ]
    });

    const initialAttribute = 'data-initial-z-index';
    // We have to alter the z index of the alloy root of the blocker so that
    // it can have a z-index high enough to act as the "blocker". Just before
    // discarding it, we need to reset those z-indices back to what they
    // were. ASSUMPTION: the blocker has been added as a direct child of the root
    const resetZIndex = (blocker) => {
        parent(blocker.element).filter(isElement$1).each((root) => {
            getOpt(root, initialAttribute).fold(() => remove$6(root, 'z-index'), (zIndex) => set$7(root, 'z-index', zIndex));
            remove$8(root, initialAttribute);
        });
    };
    const changeZIndex = (blocker) => {
        parent(blocker.element).filter(isElement$1).each((root) => {
            getRaw(root, 'z-index').each((zindex) => {
                set$9(root, initialAttribute, zindex);
            });
            // Used to be a really high number, but it probably just has
            // to match the blocker
            set$7(root, 'z-index', get$e(blocker.element, 'z-index'));
        });
    };
    const instigate = (anyComponent, blocker) => {
        anyComponent.getSystem().addToGui(blocker);
        changeZIndex(blocker);
    };
    const discard = (blocker) => {
        resetZIndex(blocker);
        blocker.getSystem().removeFromGui(blocker);
    };
    const createComponent = (component, blockerClass, blockerEvents) => component.getSystem().build(Container.sketch({
        dom: {
            // Probably consider doing with classes?
            styles: {
                'left': '0px',
                'top': '0px',
                'width': '100%',
                'height': '100%',
                'position': 'fixed',
                'z-index': '1000000000000000'
            },
            classes: [blockerClass]
        },
        events: blockerEvents
    }));

    var SnapSchema = optionObjOf('snaps', [
        required$1('getSnapPoints'),
        onHandler('onSensor'),
        required$1('leftAttr'),
        required$1('topAttr'),
        defaulted('lazyViewport', win),
        defaulted('mustSnap', false)
    ]);

    const schema$r = [
        // Is this used?
        defaulted('useFixed', never),
        required$1('blockerClass'),
        defaulted('getTarget', identity),
        defaulted('onDrag', noop),
        defaulted('repositionTarget', true),
        defaulted('onDrop', noop),
        defaultedFunction('getBounds', win),
        SnapSchema
    ];

    const getCurrentCoord = (target) => lift3(getRaw(target, 'left'), getRaw(target, 'top'), getRaw(target, 'position'), (left, top, position) => {
        const nu = position === 'fixed' ? fixed$1 : offset;
        return nu(parseInt(left, 10), parseInt(top, 10));
    }).getOrThunk(() => {
        const location = absolute$3(target);
        return absolute$1(location.left, location.top);
    });
    const clampCoords = (component, coords, scroll, origin, startData) => {
        const bounds = startData.bounds;
        const absoluteCoord = asAbsolute(coords, scroll, origin);
        const newX = clamp(absoluteCoord.left, bounds.x, bounds.x + bounds.width - startData.width);
        const newY = clamp(absoluteCoord.top, bounds.y, bounds.y + bounds.height - startData.height);
        const newCoords = absolute$1(newX, newY);
        // Translate the absolute coord back into the previous type
        return coords.fold(
        // offset
        () => {
            const offset$1 = asOffset(newCoords, scroll, origin);
            return offset(offset$1.left, offset$1.top);
        }, 
        // absolute
        constant$1(newCoords), 
        // fixed
        () => {
            const fixed = asFixed(newCoords, scroll, origin);
            return fixed$1(fixed.left, fixed.top);
        });
    };
    const calcNewCoord = (component, optSnaps, currentCoord, scroll, origin, delta, startData) => {
        const newCoord = optSnaps.fold(() => {
            // When not docking, use fixed coordinates.
            const translated = translate$2(currentCoord, delta.left, delta.top);
            const fixedCoord = asFixed(translated, scroll, origin);
            return fixed$1(fixedCoord.left, fixedCoord.top);
        }, (snapInfo) => {
            const snapping = moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);
            snapping.extra.each((extra) => {
                snapInfo.onSensor(component, extra);
            });
            return snapping.coord;
        });
        // Clamp the coords so that they are within the bounds
        return clampCoords(component, newCoord, scroll, origin, startData);
    };
    const dragBy = (component, dragConfig, startData, delta) => {
        const target = dragConfig.getTarget(component.element);
        if (dragConfig.repositionTarget) {
            const doc = owner$4(component.element);
            const scroll = get$b(doc);
            const origin = getOrigin(target);
            const currentCoord = getCurrentCoord(target);
            const newCoord = calcNewCoord(component, dragConfig.snaps, currentCoord, scroll, origin, delta, startData);
            const styles = toStyles(newCoord, scroll, origin);
            setOptions(target, styles);
        }
        // NOTE: On drag just goes with the original delta. It does not know about snapping.
        dragConfig.onDrag(component, target, delta);
    };

    const calcStartData = (dragConfig, comp) => ({
        bounds: dragConfig.getBounds(),
        height: getOuter$1(comp.element),
        width: getOuter(comp.element)
    });
    const move = (component, dragConfig, dragState, dragMode, event) => {
        const delta = dragState.update(dragMode, event);
        const dragStartData = dragState.getStartData().getOrThunk(() => calcStartData(dragConfig, component));
        delta.each((dlt) => {
            dragBy(component, dragConfig, dragStartData, dlt);
        });
    };
    const stop = (component, blocker, dragConfig, dragState) => {
        blocker.each(discard);
        dragConfig.snaps.each((snapInfo) => {
            stopDrag(component, snapInfo);
        });
        const target = dragConfig.getTarget(component.element);
        dragState.reset();
        dragConfig.onDrop(component, target);
    };
    const handlers = (events) => (dragConfig, dragState) => {
        const updateStartState = (comp) => {
            dragState.setStartData(calcStartData(dragConfig, comp));
        };
        return derive$2([
            run$1(windowScroll(), (comp) => {
                // Only update if we have some start data
                dragState.getStartData().each(() => updateStartState(comp));
            }),
            ...events(dragConfig, dragState, updateStartState)
        ]);
    };

    const init$c = (dragApi) => derive$2([
        // When the user clicks on the blocker, something has probably gone slightly
        // wrong, so we'll just drop for safety. The blocker should really only
        // be there when the mouse is already down and not released, so a 'click'
        run$1(mousedown(), dragApi.forceDrop),
        // When the user releases the mouse on the blocker, that is a drop
        run$1(mouseup(), dragApi.drop),
        // As the user moves the mouse around (while pressed down), we move the
        // component around
        run$1(mousemove(), (comp, simulatedEvent) => {
            dragApi.move(simulatedEvent.event);
        }),
        // When the use moves outside the range, schedule a block to occur but
        // give it a chance to be cancelled.
        run$1(mouseout(), dragApi.delayDrop)
    ]);

    const getData$1 = (event) => Optional.from(SugarPosition(event.x, event.y));
    // When dragging with the mouse, the delta is simply the difference
    // between the two position (previous/old and next/nu)
    const getDelta$1 = (old, nu) => SugarPosition(nu.left - old.left, nu.top - old.top);

    var MouseData = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getData: getData$1,
        getDelta: getDelta$1
    });

    const events$d = (dragConfig, dragState, updateStartState) => [
        run$1(mousedown(), (component, simulatedEvent) => {
            const raw = simulatedEvent.event.raw;
            if (raw.button !== 0) {
                return;
            }
            simulatedEvent.stop();
            const stop$1 = () => stop(component, Optional.some(blocker), dragConfig, dragState);
            // If the user has moved something outside the area, and has not come back within
            // 200 ms, then drop
            const delayDrop = DelayedFunction(stop$1, 200);
            const dragApi = {
                drop: stop$1,
                delayDrop: delayDrop.schedule,
                forceDrop: stop$1,
                move: (event) => {
                    // Stop any pending drops caused by mouseout
                    delayDrop.cancel();
                    move(component, dragConfig, dragState, MouseData, event);
                }
            };
            const blocker = createComponent(component, dragConfig.blockerClass, init$c(dragApi));
            const start = () => {
                updateStartState(component);
                instigate(component, blocker);
            };
            start();
        })
    ];
    const schema$q = [
        ...schema$r,
        output$1('dragger', {
            handlers: handlers(events$d)
        })
    ];

    const init$b = (dragApi) => derive$2([
        // When the user taps on the blocker, something has probably gone slightly
        // wrong, so we'll just drop for safety. The blocker should really only
        // be there when their finger is already down and not released, so a 'tap'
        run$1(touchstart(), dragApi.forceDrop),
        // When the user releases their finger on the blocker, that is a drop
        run$1(touchend(), dragApi.drop),
        run$1(touchcancel(), dragApi.drop),
        // As the user moves their finger around (while pressed down), we move the
        // component around
        run$1(touchmove(), (comp, simulatedEvent) => {
            dragApi.move(simulatedEvent.event);
        })
    ]);

    const getDataFrom = (touches) => {
        const touch = touches[0];
        return Optional.some(SugarPosition(touch.clientX, touch.clientY));
    };
    const getData = (event) => {
        const raw = event.raw;
        const touches = raw.touches;
        return touches.length === 1 ? getDataFrom(touches) : Optional.none();
    };
    // When dragging the touch, the delta is simply the difference
    // between the two touch positions (previous/old and next/nu)
    const getDelta = (old, nu) => SugarPosition(nu.left - old.left, nu.top - old.top);

    var TouchData = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getData: getData,
        getDelta: getDelta
    });

    const events$c = (dragConfig, dragState, updateStartState) => {
        const blockerSingleton = value$2();
        const stopBlocking = (component) => {
            stop(component, blockerSingleton.get(), dragConfig, dragState);
            blockerSingleton.clear();
        };
        // Android fires events on the component at all times, while iOS initially fires on the component
        // but once moved off the component then fires on the element behind. As such we need to use
        // a blocker and then listen to both touchmove/touchend on both the component and blocker.
        return [
            run$1(touchstart(), (component, simulatedEvent) => {
                simulatedEvent.stop();
                const stop = () => stopBlocking(component);
                const dragApi = {
                    drop: stop,
                    // delayDrop is not used by touch
                    delayDrop: noop,
                    forceDrop: stop,
                    move: (event) => {
                        move(component, dragConfig, dragState, TouchData, event);
                    }
                };
                const blocker = createComponent(component, dragConfig.blockerClass, init$b(dragApi));
                blockerSingleton.set(blocker);
                const start = () => {
                    updateStartState(component);
                    instigate(component, blocker);
                };
                start();
            }),
            run$1(touchmove(), (component, simulatedEvent) => {
                simulatedEvent.stop();
                move(component, dragConfig, dragState, TouchData, simulatedEvent.event);
            }),
            run$1(touchend(), (component, simulatedEvent) => {
                simulatedEvent.stop();
                stopBlocking(component);
            }),
            run$1(touchcancel(), stopBlocking)
        ];
    };
    const schema$p = [
        ...schema$r,
        output$1('dragger', {
            handlers: handlers(events$c)
        })
    ];

    const events$b = (dragConfig, dragState, updateStartState) => [
        ...events$d(dragConfig, dragState, updateStartState),
        ...events$c(dragConfig, dragState, updateStartState)
    ];
    const schema$o = [
        ...schema$r,
        output$1('dragger', {
            handlers: handlers(events$b)
        })
    ];

    const mouse = schema$q;
    const touch = schema$p;
    const mouseOrTouch = schema$o;

    var DraggingBranches = /*#__PURE__*/Object.freeze({
        __proto__: null,
        mouse: mouse,
        touch: touch,
        mouseOrTouch: mouseOrTouch
    });

    // NOTE: mode refers to the way that information is retrieved from
    // the user interaction. It can be things like MouseData, TouchData etc.
    const init$a = () => {
        // Dragging operates on the difference between the previous user
        // interaction and the next user interaction. Therefore, we store
        // the previous interaction so that we can compare it.
        let previous = Optional.none();
        // Dragging requires calculating the bounds, so we store that data initially
        // to reduce the amount of computation each mouse movement
        let startData = Optional.none();
        const reset = () => {
            previous = Optional.none();
            startData = Optional.none();
        };
        // Return position delta between previous position and nu position,
        // or None if this is the first. Set the previous position to nu.
        const calculateDelta = (mode, nu) => {
            const result = previous.map((old) => mode.getDelta(old, nu));
            previous = Optional.some(nu);
            return result;
        };
        // NOTE: This dragEvent is the DOM touch event or mouse event
        const update = (mode, dragEvent) => mode.getData(dragEvent).bind((nuData) => calculateDelta(mode, nuData));
        const setStartData = (data) => {
            startData = Optional.some(data);
        };
        const getStartData = () => startData;
        const readState = constant$1({});
        return nu$4({
            readState,
            reset,
            update,
            getStartData,
            setStartData
        });
    };

    var DragState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$a
    });

    const Dragging = createModes({
        branchKey: 'mode',
        branches: DraggingBranches,
        name: 'dragging',
        active: {
            events: (dragConfig, dragState) => {
                const dragger = dragConfig.dragger;
                return dragger.handlers(dragConfig, dragState);
            }
        },
        extra: {
            // Extra. Does not need component as input.
            snap: (sConfig) => ({
                sensor: sConfig.sensor,
                range: sConfig.range,
                output: sConfig.output,
                extra: Optional.from(sConfig.extra)
            })
        },
        state: DragState,
        apis: DraggingApis
    });

    const ariaElements = [
        'input',
        'textarea'
    ];
    const isAriaElement = (elem) => {
        const name = name$3(elem);
        return contains$2(ariaElements, name);
    };
    const markValid = (component, invalidConfig) => {
        const elem = invalidConfig.getRoot(component).getOr(component.element);
        remove$3(elem, invalidConfig.invalidClass);
        invalidConfig.notify.each((notifyInfo) => {
            if (isAriaElement(component.element)) {
                set$9(component.element, 'aria-invalid', false);
            }
            notifyInfo.getContainer(component).each((container) => {
                set$8(container, notifyInfo.validHtml);
            });
            notifyInfo.onValid(component);
        });
    };
    const markInvalid = (component, invalidConfig, invalidState, text) => {
        const elem = invalidConfig.getRoot(component).getOr(component.element);
        add$2(elem, invalidConfig.invalidClass);
        invalidConfig.notify.each((notifyInfo) => {
            if (isAriaElement(component.element)) {
                set$9(component.element, 'aria-invalid', true);
            }
            notifyInfo.getContainer(component).each((container) => {
                // TODO: Should we just use Text here, not HTML?
                set$8(container, text);
            });
            notifyInfo.onInvalid(component, text);
        });
    };
    const query = (component, invalidConfig, _invalidState) => invalidConfig.validator.fold(() => Future.pure(Result.value(true)), (validatorInfo) => validatorInfo.validate(component));
    const run = (component, invalidConfig, invalidState) => {
        invalidConfig.notify.each((notifyInfo) => {
            notifyInfo.onValidate(component);
        });
        return query(component, invalidConfig).map((valid) => {
            if (component.getSystem().isConnected()) {
                return valid.fold((err) => {
                    markInvalid(component, invalidConfig, invalidState, err);
                    return Result.error(err);
                }, (v) => {
                    markValid(component, invalidConfig);
                    return Result.value(v);
                });
            }
            else {
                return Result.error('No longer in system');
            }
        });
    };
    const isInvalid = (component, invalidConfig) => {
        const elem = invalidConfig.getRoot(component).getOr(component.element);
        return has(elem, invalidConfig.invalidClass);
    };

    var InvalidateApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        markValid: markValid,
        markInvalid: markInvalid,
        query: query,
        run: run,
        isInvalid: isInvalid
    });

    const events$a = (invalidConfig, invalidState) => invalidConfig.validator.map((validatorInfo) => derive$2([
        run$1(validatorInfo.onEvent, (component) => {
            run(component, invalidConfig, invalidState).get(identity);
        })
    ].concat(validatorInfo.validateOnLoad ? [
        runOnAttached((component) => {
            run(component, invalidConfig, invalidState).get(noop);
        })
    ] : []))).getOr({});

    var ActiveInvalidate = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$a
    });

    var InvalidateSchema = [
        required$1('invalidClass'),
        defaulted('getRoot', Optional.none),
        // TODO: Completely rework the notify API
        optionObjOf('notify', [
            defaulted('aria', 'alert'),
            // Maybe we should use something else.
            defaulted('getContainer', Optional.none),
            defaulted('validHtml', ''),
            onHandler('onValid'),
            onHandler('onInvalid'),
            onHandler('onValidate')
        ]),
        optionObjOf('validator', [
            required$1('validate'),
            defaulted('onEvent', 'input'),
            defaulted('validateOnLoad', true)
        ])
    ];

    const onLoad$4 = (component, repConfig, repState) => {
        repConfig.store.manager.onLoad(component, repConfig, repState);
    };
    const onUnload$2 = (component, repConfig, repState) => {
        repConfig.store.manager.onUnload(component, repConfig, repState);
    };
    const setValue$3 = (component, repConfig, repState, data) => {
        repConfig.store.manager.setValue(component, repConfig, repState, data);
    };
    const getValue$3 = (component, repConfig, repState) => repConfig.store.manager.getValue(component, repConfig, repState);
    const getState$2 = (component, repConfig, repState) => repState;

    var RepresentApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        onLoad: onLoad$4,
        onUnload: onUnload$2,
        setValue: setValue$3,
        getValue: getValue$3,
        getState: getState$2
    });

    const events$9 = (repConfig, repState) => {
        const es = repConfig.resetOnDom ? [
            runOnAttached((comp, _se) => {
                onLoad$4(comp, repConfig, repState);
            }),
            runOnDetached((comp, _se) => {
                onUnload$2(comp, repConfig, repState);
            })
        ] : [
            loadEvent(repConfig, repState, onLoad$4)
        ];
        return derive$2(es);
    };

    var ActiveRepresenting = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$9
    });

    const memory$1 = () => {
        const data = Cell(null);
        const readState = () => ({
            mode: 'memory',
            value: data.get()
        });
        const isNotSet = () => data.get() === null;
        const clear = () => {
            data.set(null);
        };
        return nu$4({
            set: data.set,
            get: data.get,
            isNotSet,
            clear,
            readState
        });
    };
    const manual = () => {
        const readState = noop;
        return nu$4({
            readState
        });
    };
    const dataset = () => {
        const dataByValue = Cell({});
        const dataByText = Cell({});
        const readState = () => ({
            mode: 'dataset',
            dataByValue: dataByValue.get(),
            dataByText: dataByText.get()
        });
        const clear = () => {
            dataByValue.set({});
            dataByText.set({});
        };
        // itemString can be matching value or text.
        // TODO: type problem - impossible to correctly return value when type parameter only exists in return type
        const lookup = (itemString) => get$h(dataByValue.get(), itemString).orThunk(() => get$h(dataByText.get(), itemString));
        const update = (items) => {
            const currentDataByValue = dataByValue.get();
            const currentDataByText = dataByText.get();
            const newDataByValue = {};
            const newDataByText = {};
            each$1(items, (item) => {
                newDataByValue[item.value] = item;
                get$h(item, 'meta').each((meta) => {
                    get$h(meta, 'text').each((text) => {
                        newDataByText[text] = item;
                    });
                });
            });
            dataByValue.set({
                ...currentDataByValue,
                ...newDataByValue
            });
            dataByText.set({
                ...currentDataByText,
                ...newDataByText
            });
        };
        return nu$4({
            readState,
            lookup,
            update,
            clear
        });
    };
    const init$9 = (spec) => spec.store.manager.state(spec);

    var RepresentState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        memory: memory$1,
        dataset: dataset,
        manual: manual,
        init: init$9
    });

    const setValue$2 = (component, repConfig, repState, data) => {
        const store = repConfig.store;
        repState.update([data]);
        store.setValue(component, data);
        repConfig.onSetValue(component, data);
    };
    const getValue$2 = (component, repConfig, repState) => {
        const store = repConfig.store;
        const key = store.getDataKey(component);
        return repState.lookup(key).getOrThunk(() => store.getFallbackEntry(key));
    };
    const onLoad$3 = (component, repConfig, repState) => {
        const store = repConfig.store;
        store.initialValue.each((data) => {
            setValue$2(component, repConfig, repState, data);
        });
    };
    const onUnload$1 = (component, repConfig, repState) => {
        repState.clear();
    };
    var DatasetStore = [
        option$3('initialValue'),
        required$1('getFallbackEntry'),
        required$1('getDataKey'),
        required$1('setValue'),
        output$1('manager', {
            setValue: setValue$2,
            getValue: getValue$2,
            onLoad: onLoad$3,
            onUnload: onUnload$1,
            state: dataset
        })
    ];

    const getValue$1 = (component, repConfig, _repState) => repConfig.store.getValue(component);
    const setValue$1 = (component, repConfig, _repState, data) => {
        repConfig.store.setValue(component, data);
        repConfig.onSetValue(component, data);
    };
    const onLoad$2 = (component, repConfig, _repState) => {
        repConfig.store.initialValue.each((data) => {
            repConfig.store.setValue(component, data);
        });
    };
    var ManualStore = [
        required$1('getValue'),
        defaulted('setValue', noop),
        option$3('initialValue'),
        output$1('manager', {
            setValue: setValue$1,
            getValue: getValue$1,
            onLoad: onLoad$2,
            onUnload: noop,
            state: NoState.init
        })
    ];

    const setValue = (component, repConfig, repState, data) => {
        repState.set(data);
        repConfig.onSetValue(component, data);
    };
    const getValue = (component, repConfig, repState) => repState.get();
    const onLoad$1 = (component, repConfig, repState) => {
        repConfig.store.initialValue.each((initVal) => {
            if (repState.isNotSet()) {
                repState.set(initVal);
            }
        });
    };
    const onUnload = (component, repConfig, repState) => {
        repState.clear();
    };
    var MemoryStore = [
        option$3('initialValue'),
        output$1('manager', {
            setValue,
            getValue,
            onLoad: onLoad$1,
            onUnload,
            state: memory$1
        })
    ];

    var RepresentSchema = [
        defaultedOf('store', { mode: 'memory' }, choose$1('mode', {
            memory: MemoryStore,
            manual: ManualStore,
            dataset: DatasetStore
        })),
        onHandler('onSetValue'),
        defaulted('resetOnDom', false)
    ];

    // The self-reference is clumsy.
    const Representing = create$3({
        fields: RepresentSchema,
        name: 'representing',
        active: ActiveRepresenting,
        apis: RepresentApis,
        extra: {
            setValueFrom: (component, source) => {
                const value = Representing.getValue(source);
                Representing.setValue(component, value);
            }
        },
        state: RepresentState
    });

    const Invalidating = create$3({
        fields: InvalidateSchema,
        name: 'invalidating',
        active: ActiveInvalidate,
        apis: InvalidateApis,
        extra: {
            // Note, this requires representing to be on the validatee
            validation: (validator) => {
                return (component) => {
                    const v = Representing.getValue(component);
                    return Future.pure(validator(v));
                };
            }
        }
    });

    const exhibit$4 = (base, posConfig) => nu$2({
        classes: [],
        styles: posConfig.useFixed() ? {} : { position: 'relative' }
    });

    var ActivePosition = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$4
    });

    const adt$3 = Adt.generate([
        { none: [] },
        { relative: ['x', 'y', 'width', 'height'] },
        { fixed: ['x', 'y', 'width', 'height'] }
    ]);
    const positionWithDirection = (posName, decision, x, y, width, height) => {
        const decisionRect = decision.rect;
        const decisionX = decisionRect.x - x;
        const decisionY = decisionRect.y - y;
        const decisionWidth = decisionRect.width;
        const decisionHeight = decisionRect.height;
        const decisionRight = width - (decisionX + decisionWidth);
        const decisionBottom = height - (decisionY + decisionHeight);
        const left = Optional.some(decisionX);
        const top = Optional.some(decisionY);
        const right = Optional.some(decisionRight);
        const bottom = Optional.some(decisionBottom);
        const none = Optional.none();
        return cata$1(decision.direction, () => NuPositionCss(posName, left, top, none, none), // southeast
        () => NuPositionCss(posName, none, top, right, none), // southwest
        () => NuPositionCss(posName, left, none, none, bottom), // northeast
        () => NuPositionCss(posName, none, none, right, bottom), // northwest
        () => NuPositionCss(posName, left, top, none, none), // south
        () => NuPositionCss(posName, left, none, none, bottom), // north
        () => NuPositionCss(posName, left, top, none, none), // east
        () => NuPositionCss(posName, none, top, right, none) // west
        );
    };
    const reposition = (origin, decision) => origin.fold(() => {
        const decisionRect = decision.rect;
        return NuPositionCss('absolute', Optional.some(decisionRect.x), Optional.some(decisionRect.y), Optional.none(), Optional.none());
    }, (x, y, width, height) => {
        return positionWithDirection('absolute', decision, x, y, width, height);
    }, (x, y, width, height) => {
        return positionWithDirection('fixed', decision, x, y, width, height);
    });
    const toBox = (origin, element) => {
        const rel = curry(find$2, element);
        const position = origin.fold(rel, rel, () => {
            const scroll = get$b();
            // TODO: Make adding the scroll in OuterPosition.find optional.
            return find$2(element).translate(-scroll.left, -scroll.top);
        });
        const width = getOuter(element);
        const height = getOuter$1(element);
        return bounds(position.left, position.top, width, height);
    };
    const viewport = (origin, optBounds) => optBounds.fold(
    /* There are no bounds supplied */
    () => origin.fold(win, win, bounds), (bounds$1) => 
    /* Use any bounds supplied or remove the scroll position of the bounds for fixed. */
    origin.fold(constant$1(bounds$1), constant$1(bounds$1), () => {
        const pos = translate$1(origin, bounds$1.x, bounds$1.y);
        return bounds(pos.left, pos.top, bounds$1.width, bounds$1.height);
    }));
    const translate$1 = (origin, x, y) => {
        const pos = SugarPosition(x, y);
        const removeScroll = () => {
            const outerScroll = get$b();
            return pos.translate(-outerScroll.left, -outerScroll.top);
        };
        // This could use cata if it wasn't a circular reference
        return origin.fold(constant$1(pos), constant$1(pos), removeScroll);
    };
    const cata = (subject, onNone, onRelative, onFixed) => subject.fold(onNone, onRelative, onFixed);
    adt$3.none;
    const relative = adt$3.relative;
    const fixed = adt$3.fixed;

    const anchor = (anchorBox, origin) => ({
        anchorBox,
        origin
    });
    const box = (anchorBox, origin) => anchor(anchorBox, origin);

    const adt$2 = Adt.generate([
        { fit: ['reposition'] },
        { nofit: ['reposition', 'visibleW', 'visibleH', 'isVisible'] }
    ]);
    /**
     * This will attempt to determine if the box will fit within the specified bounds or if it needs to be repositioned.
     * It will return the following details:
     *  - if the original rect was in bounds (originInBounds & sizeInBounds). This is used to determine if we fitted
     *    without having to make adjustments.
     *  - the height and width that would be visible in the original location. (ie the overlap between the rect and
     *    the bounds or the distance between the boxes if there is no overlap)
     */
    const determinePosition = (box, bounds) => {
        const { x: boundsX, y: boundsY, right: boundsRight, bottom: boundsBottom } = bounds;
        const { x, y, right, bottom, width, height } = box;
        // simple checks for "is the top left inside the view"
        const xInBounds = x >= boundsX && x <= boundsRight;
        const yInBounds = y >= boundsY && y <= boundsBottom;
        const originInBounds = xInBounds && yInBounds;
        // simple checks for "is the bottom right inside the view"
        const rightInBounds = right <= boundsRight && right >= boundsX;
        const bottomInBounds = bottom <= boundsBottom && bottom >= boundsY;
        const sizeInBounds = rightInBounds && bottomInBounds;
        // measure how much of the width and height are visible. This should never be larger than the actual width or height
        // however it can be a negative value when offscreen. These values are generally are only needed for the "nofit" case
        const visibleW = Math.min(width, x >= boundsX ? boundsRight - x : right - boundsX);
        const visibleH = Math.min(height, y >= boundsY ? boundsBottom - y : bottom - boundsY);
        return {
            originInBounds,
            sizeInBounds,
            visibleW,
            visibleH
        };
    };
    /**
     * This will attempt to calculate and adjust the position of the box so that is stays within the specified bounds.
     * The end result will be a new restricted box of where it can safely be placed within the bounds.
     */
    const calcReposition = (box, bounds$1) => {
        const { x: boundsX, y: boundsY, right: boundsRight, bottom: boundsBottom } = bounds$1;
        const { x, y, width, height } = box;
        // measure the maximum x and y taking into account the height and width of the box
        const maxX = Math.max(boundsX, boundsRight - width);
        const maxY = Math.max(boundsY, boundsBottom - height);
        // Futz with the X value to ensure that we're not off the left or right of the screen
        const restrictedX = clamp(x, boundsX, maxX);
        // Futz with the Y value to ensure that we're not off the top or bottom of the screen
        const restrictedY = clamp(y, boundsY, maxY);
        // Determine the new height and width based on the restricted X/Y to keep the element in bounds
        const restrictedWidth = Math.min(restrictedX + width, boundsRight) - restrictedX;
        const restrictedHeight = Math.min(restrictedY + height, boundsBottom) - restrictedY;
        return bounds(restrictedX, restrictedY, restrictedWidth, restrictedHeight);
    };
    /**
     * Determine the maximum height and width available for where the box is positioned in the bounds, making sure
     * to account for which direction it's rendering in.
     */
    const calcMaxSizes = (direction, box, bounds) => {
        // Futz with the "height" of the popup to ensure if it doesn't fit it's capped at the available height.
        const upAvailable = constant$1(box.bottom - bounds.y);
        const downAvailable = constant$1(bounds.bottom - box.y);
        const maxHeight = cataVertical(direction, downAvailable, /* middle */ downAvailable, upAvailable);
        // Futz with the "width" of the popup to ensure if it doesn't fit it's capped at the available width.
        const westAvailable = constant$1(box.right - bounds.x);
        const eastAvailable = constant$1(bounds.right - box.x);
        const maxWidth = cataHorizontal(direction, eastAvailable, /* middle */ eastAvailable, westAvailable);
        return {
            maxWidth,
            maxHeight
        };
    };
    const attempt = (candidate, width, height, bounds$1) => {
        const bubble = candidate.bubble;
        const bubbleOffset = bubble.offset;
        // adjust the bounds to account for the layout and bubble restrictions
        const adjustedBounds = adjustBounds(bounds$1, candidate.restriction, bubbleOffset);
        // candidate position is excluding the bubble, so add those values as well
        const newX = candidate.x + bubbleOffset.left;
        const newY = candidate.y + bubbleOffset.top;
        const box = bounds(newX, newY, width, height);
        // determine the position of the box in relation to the bounds
        const { originInBounds, sizeInBounds, visibleW, visibleH } = determinePosition(box, adjustedBounds);
        // restrict the box if it won't fit in the bounds
        const fits = originInBounds && sizeInBounds;
        const fittedBox = fits ? box : calcReposition(box, adjustedBounds);
        // Determine if the box is at least partly visible in the bounds after applying the restrictions
        const isPartlyVisible = fittedBox.width > 0 && fittedBox.height > 0;
        // Determine the maximum height and width available in the bounds
        const { maxWidth, maxHeight } = calcMaxSizes(candidate.direction, fittedBox, bounds$1);
        const reposition = {
            rect: fittedBox,
            maxHeight,
            maxWidth,
            direction: candidate.direction,
            placement: candidate.placement,
            classes: {
                on: bubble.classesOn,
                off: bubble.classesOff
            },
            layout: candidate.label,
            testY: newY
        };
        // useful debugging that I don't want to lose
        // console.log(candidate.label);
        // console.table([{
        //   newY,
        //   limitY: fittedBox.y,
        //   boundsY: bounds.y,
        //   boundsBottom: bounds.bottom,
        //   newX,
        //   limitX: fittedBox.x,
        //   boundsX: bounds.x,
        //   boundsRight: bounds.right,
        //   candidateX: candidate.x,
        //   candidateY: candidate.y,
        //   width,
        //   height,
        //   isPartlyVisible
        // }]);
        // console.log(`maxWidth: ${maxWidth}, visibleW: ${visibleW}`);
        // console.log(`maxHeight: ${maxHeight}, visibleH: ${visibleH}`);
        // console.log('originInBounds:', originInBounds);
        // console.log('sizeInBounds:', sizeInBounds);
        // console.log(originInBounds && sizeInBounds ? 'fit' : 'nofit');
        // Take special note that we don't use the futz values in the nofit case; whether this position is a good fit is separate
        // to ensuring that if we choose it the popup is actually on screen properly.
        return fits || candidate.alwaysFit ? adt$2.fit(reposition) : adt$2.nofit(reposition, visibleW, visibleH, isPartlyVisible);
    };
    /**
     * Attempts to fit a box (generally a menu).
     *
     * candidates: an array of layout generators, generally obtained via api.Layout or api.LinkedLayout
     * anchorBox: the box on screen that triggered the menu, we must touch one of the edges as defined by the candidate layouts
     * elementBox: the popup (only width and height matter)
     * bubbles: the bubbles for the popup (see api.Bubble)
     * bounds: the screen
     */
    const attempts = (element, candidates, anchorBox, elementBox, bubbles, bounds) => {
        const panelWidth = elementBox.width;
        const panelHeight = elementBox.height;
        const attemptBestFit = (layout, reposition, visibleW, visibleH, isVisible) => {
            const next = layout(anchorBox, elementBox, bubbles, element, bounds);
            const attemptLayout = attempt(next, panelWidth, panelHeight, bounds);
            return attemptLayout.fold(constant$1(attemptLayout), (newReposition, newVisibleW, newVisibleH, newIsVisible) => {
                // console.log(`label: ${next.label}, newVisibleW: ${newVisibleW}, visibleW: ${visibleW}, newVisibleH: ${newVisibleH}, visibleH: ${visibleH}, newIsVisible: ${newIsVisible}, isVisible: ${isVisible}`);
                const improved = isVisible === newIsVisible ? (newVisibleH > visibleH || newVisibleW > visibleW) : (!isVisible && newIsVisible);
                // console.log('improved? ', improved);
                return improved ? attemptLayout : adt$2.nofit(reposition, visibleW, visibleH, isVisible);
            });
        };
        const abc = foldl(candidates, (b, a) => {
            const bestNext = curry(attemptBestFit, a);
            return b.fold(constant$1(b), bestNext);
        }, 
        // fold base case: No candidates, it's never going to be correct, so do whatever
        adt$2.nofit({
            rect: anchorBox,
            maxHeight: elementBox.height,
            maxWidth: elementBox.width,
            direction: southeast$3(),
            placement: "southeast" /* Placement.Southeast */,
            classes: {
                on: [],
                off: []
            },
            layout: 'none',
            testY: anchorBox.y
        }, -1, -1, false));
        // unwrapping 'reposition' from the adt, for both fit & nofit the first arg is the one we need,
        // so we can cheat and use Fun.identity
        return abc.fold(identity, identity);
    };

    const properties = ['top', 'bottom', 'right', 'left'];
    const timerAttr = 'data-alloy-transition-timer';
    const isTransitioning$1 = (element, transition) => hasAll(element, transition.classes);
    const shouldApplyTransitionCss = (transition, decision, lastPlacement) => {
        // Don't apply transitions if there was no previous placement as it's transitioning from offscreen
        return lastPlacement.exists((placer) => {
            const mode = transition.mode;
            return mode === 'all' ? true : placer[mode] !== decision[mode];
        });
    };
    const hasChanges = (position, intermediate) => {
        // Round to 3 decimal points
        const round = (value) => parseFloat(value).toFixed(3);
        return find$4(intermediate, (value, key) => {
            const newValue = position[key].map(round);
            const val = value.map(round);
            return !equals(newValue, val);
        }).isSome();
    };
    const getTransitionDuration = (element) => {
        const get = (name) => {
            const style = get$e(element, name);
            const times = style.split(/\s*,\s*/);
            return filter$2(times, isNotEmpty);
        };
        const parse = (value) => {
            if (isString(value) && /^[\d.]+/.test(value)) {
                const num = parseFloat(value);
                return endsWith(value, 'ms') ? num : num * 1000;
            }
            else {
                return 0;
            }
        };
        const delay = get('transition-delay');
        const duration = get('transition-duration');
        return foldl(duration, (acc, dur, i) => {
            const time = parse(delay[i]) + parse(dur);
            return Math.max(acc, time);
        }, 0);
    };
    const setupTransitionListeners = (element, transition) => {
        const transitionEnd = unbindable();
        const transitionCancel = unbindable();
        let timer;
        const isSourceTransition = (e) => {
            var _a;
            // Ensure the transition event isn't from a pseudo element
            const pseudoElement = (_a = e.raw.pseudoElement) !== null && _a !== void 0 ? _a : '';
            return eq(e.target, element) && isEmpty(pseudoElement) && contains$2(properties, e.raw.propertyName);
        };
        const transitionDone = (e) => {
            if (isNullable(e) || isSourceTransition(e)) {
                transitionEnd.clear();
                transitionCancel.clear();
                // Only cleanup the class/timer on transitionend not on a cancel. This is done as cancel
                // means the element has been repositioned and would need to keep transitioning
                const type = e === null || e === void 0 ? void 0 : e.raw.type;
                if (isNullable(type) || type === transitionend()) {
                    clearTimeout(timer);
                    remove$8(element, timerAttr);
                    remove$2(element, transition.classes);
                }
            }
        };
        const transitionStart = bind$1(element, transitionstart(), (e) => {
            if (isSourceTransition(e)) {
                transitionStart.unbind();
                transitionEnd.set(bind$1(element, transitionend(), transitionDone));
                transitionCancel.set(bind$1(element, transitioncancel(), transitionDone));
            }
        });
        // Request the next animation frame so we can roughly determine when the transition starts and then ensure
        // the transition is cleaned up. In addition add ~17ms to the delay as that's about about 1 frame at 60fps
        const duration = getTransitionDuration(element);
        window.requestAnimationFrame(() => {
            timer = setTimeout(transitionDone, duration + 17);
            set$9(element, timerAttr, timer);
        });
    };
    const startTransitioning = (element, transition) => {
        add$1(element, transition.classes);
        // Clear any existing cleanup timers
        getOpt(element, timerAttr).each((timerId) => {
            clearTimeout(parseInt(timerId, 10));
            remove$8(element, timerAttr);
        });
        setupTransitionListeners(element, transition);
    };
    const applyTransitionCss = (element, origin, position, transition, decision, lastPlacement) => {
        const shouldTransition = shouldApplyTransitionCss(transition, decision, lastPlacement);
        if (shouldTransition || isTransitioning$1(element, transition)) {
            // Set the new position first so we can calculate the computed position
            set$7(element, 'position', position.position);
            // Get the computed positions for the current element based on the new position CSS being applied
            const rect = toBox(origin, element);
            const intermediatePosition = reposition(origin, { ...decision, rect });
            const intermediateCssOptions = mapToObject(properties, (prop) => intermediatePosition[prop]);
            // Apply the intermediate styles and transition classes if something has changed
            if (hasChanges(position, intermediateCssOptions)) {
                setOptions(element, intermediateCssOptions);
                if (shouldTransition) {
                    startTransitioning(element, transition);
                }
                reflow(element);
            }
        }
        else {
            remove$2(element, transition.classes);
        }
    };

    /*
     * This is the old repartee API. It is retained in a similar structure to the original form,
     * in case we decide to bring back the flexibility of working with non-standard positioning.
     */
    const elementSize = (p) => ({
        width: Math.ceil(getOuter(p)),
        height: getOuter$1(p)
    });
    const layout = (anchorBox, element, bubbles, options) => {
        // clear the potentially limiting factors before measuring
        remove$6(element, 'max-height');
        remove$6(element, 'max-width');
        const elementBox = elementSize(element);
        return attempts(element, options.preference, anchorBox, elementBox, bubbles, options.bounds);
    };
    const setClasses = (element, decision) => {
        const classInfo = decision.classes;
        remove$2(element, classInfo.off);
        add$1(element, classInfo.on);
    };
    /*
     * maxHeightFunction is a MaxHeight instance.
     * max-height is usually the distance between the edge of the popup and the screen; top of popup to bottom of screen for south, bottom of popup to top of screen for north.
     *
     * There are a few cases where we specifically don't want a max-height, which is why it's optional.
     */
    const setHeight = (element, decision, options) => {
        // The old API enforced MaxHeight.anchored() for fixed position. That no longer seems necessary.
        const maxHeightFunction = options.maxHeightFunction;
        maxHeightFunction(element, decision.maxHeight);
    };
    const setWidth = (element, decision, options) => {
        const maxWidthFunction = options.maxWidthFunction;
        maxWidthFunction(element, decision.maxWidth);
    };
    const position$2 = (element, decision, options) => {
        // This is a point of difference between Alloy and Repartee. Repartee appears to use Measure to calculate the available space for fixed origin
        // That is not ported yet.
        const positionCss = reposition(options.origin, decision);
        options.transition.each((transition) => {
            applyTransitionCss(element, options.origin, positionCss, transition, decision, options.lastPlacement);
        });
        applyPositionCss(element, positionCss);
    };
    const setPlacement = (element, decision) => {
        setPlacement$1(element, decision.placement);
    };

    const defaultOr = (options, key, dephault) => options[key] === undefined ? dephault : options[key];
    // This takes care of everything when you are positioning UI that can go anywhere on the screen
    const simple = (anchor, element, bubble, layouts, lastPlacement, optBounds, overrideOptions, transition) => {
        // the only supported override at the moment. Once relative has been deleted, maybe this can be optional in the bag
        const maxHeightFunction = defaultOr(overrideOptions, 'maxHeightFunction', anchored());
        const maxWidthFunction = defaultOr(overrideOptions, 'maxWidthFunction', noop);
        const anchorBox = anchor.anchorBox;
        const origin = anchor.origin;
        const options = {
            bounds: viewport(origin, optBounds),
            origin,
            preference: layouts,
            maxHeightFunction,
            maxWidthFunction,
            lastPlacement,
            transition
        };
        return go(anchorBox, element, bubble, options);
    };
    // This is the old public API. If we ever need full customisability again, this is how to expose it
    const go = (anchorBox, element, bubble, options) => {
        const decision = layout(anchorBox, element, bubble, options);
        position$2(element, decision, options);
        setPlacement(element, decision);
        setClasses(element, decision);
        setHeight(element, decision, options);
        setWidth(element, decision, options);
        return {
            layout: decision.layout,
            placement: decision.placement
        };
    };

    const nu$1 = identity;

    const schema$n = () => optionObjOf('layouts', [
        required$1('onLtr'),
        required$1('onRtl'),
        option$3('onBottomLtr'),
        option$3('onBottomRtl')
    ]);
    const get$1 = (elem, info, defaultLtr, defaultRtl, defaultBottomLtr, defaultBottomRtl, dirElement) => {
        const isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);
        const customLtr = info.layouts.map((ls) => ls.onLtr(elem));
        const customRtl = info.layouts.map((ls) => ls.onRtl(elem));
        const ltr = isBottomToTop ?
            info.layouts.bind((ls) => ls.onBottomLtr.map((f) => f(elem)))
                .or(customLtr)
                .getOr(defaultBottomLtr) :
            customLtr.getOr(defaultLtr);
        const rtl = isBottomToTop ?
            info.layouts.bind((ls) => ls.onBottomRtl.map((f) => f(elem)))
                .or(customRtl)
                .getOr(defaultBottomRtl) :
            customRtl.getOr(defaultRtl);
        const f = onDirection(ltr, rtl);
        return f(elem);
    };

    const placement$4 = (component, anchorInfo, origin) => {
        const hotspot = anchorInfo.hotspot;
        const anchorBox = toBox(origin, hotspot.element);
        const layouts = get$1(component.element, anchorInfo, belowOrAbove(), belowOrAboveRtl(), aboveOrBelow(), aboveOrBelowRtl(), Optional.some(anchorInfo.hotspot.element));
        return Optional.some(nu$1({
            anchorBox,
            bubble: anchorInfo.bubble.getOr(fallback()),
            overrides: anchorInfo.overrides,
            layouts
        }));
    };
    var HotspotAnchor = [
        required$1('hotspot'),
        option$3('bubble'),
        defaulted('overrides', {}),
        schema$n(),
        output$1('placement', placement$4)
    ];

    const placement$3 = (component, anchorInfo, origin) => {
        const pos = translate$1(origin, anchorInfo.x, anchorInfo.y);
        const anchorBox = bounds(pos.left, pos.top, anchorInfo.width, anchorInfo.height);
        const layouts = get$1(component.element, anchorInfo, all$2(), allRtl$1(), 
        // No default bottomToTop layouts currently needed
        all$2(), allRtl$1(), Optional.none());
        return Optional.some(nu$1({
            anchorBox,
            bubble: anchorInfo.bubble,
            overrides: anchorInfo.overrides,
            layouts
        }));
    };
    var MakeshiftAnchor = [
        required$1('x'),
        required$1('y'),
        defaulted('height', 0),
        defaulted('width', 0),
        defaulted('bubble', fallback()),
        defaulted('overrides', {}),
        schema$n(),
        output$1('placement', placement$3)
    ];

    const adt$1 = Adt.generate([
        { screen: ['point'] },
        { absolute: ['point', 'scrollLeft', 'scrollTop'] }
    ]);
    const toFixed = (pos) => 
    // TODO: Use new ADT methods
    pos.fold(identity, (point, scrollLeft, scrollTop) => point.translate(-scrollLeft, -scrollTop));
    const toAbsolute = (pos) => pos.fold(identity, identity);
    const sum = (points) => foldl(points, (b, a) => b.translate(a.left, a.top), SugarPosition(0, 0));
    const sumAsFixed = (positions) => {
        const points = map$2(positions, toFixed);
        return sum(points);
    };
    const sumAsAbsolute = (positions) => {
        const points = map$2(positions, toAbsolute);
        return sum(points);
    };
    const screen = adt$1.screen;
    const absolute = adt$1.absolute;

    // In one mode, the window is inside an iframe. If that iframe is in the
    // same document as the positioning element (component), then identify the offset
    // difference between the iframe and the component.
    const getOffset = (component, origin, anchorInfo) => {
        const win = defaultView(anchorInfo.root).dom;
        const hasSameOwner = (frame) => {
            const frameOwner = owner$4(frame);
            const compOwner = owner$4(component.element);
            return eq(frameOwner, compOwner);
        };
        return Optional.from(win.frameElement).map(SugarElement.fromDom)
            .filter(hasSameOwner).map(absolute$3);
    };
    const getRootPoint = (component, origin, anchorInfo) => {
        const doc = owner$4(component.element);
        const outerScroll = get$b(doc);
        const offset = getOffset(component, origin, anchorInfo).getOr(outerScroll);
        return absolute(offset, outerScroll.left, outerScroll.top);
    };

    const getBox = (left, top, width, height) => {
        const point = screen(SugarPosition(left, top));
        return Optional.some(pointed(point, width, height));
    };
    const calcNewAnchor = (optBox, rootPoint, anchorInfo, origin, elem) => optBox.map((box) => {
        const points = [rootPoint, box.point];
        const topLeft = cata(origin, () => sumAsAbsolute(points), () => sumAsAbsolute(points), () => sumAsFixed(points));
        const anchorBox = rect(topLeft.left, topLeft.top, box.width, box.height);
        const layoutsLtr = anchorInfo.showAbove ?
            aboveOrBelow() :
            belowOrAbove();
        const layoutsRtl = anchorInfo.showAbove ?
            aboveOrBelowRtl() :
            belowOrAboveRtl();
        const layouts = get$1(elem, anchorInfo, layoutsLtr, layoutsRtl, layoutsLtr, layoutsRtl, Optional.none());
        return nu$1({
            anchorBox,
            bubble: anchorInfo.bubble.getOr(fallback()),
            overrides: anchorInfo.overrides,
            layouts
        });
    });

    const placement$2 = (component, anchorInfo, origin) => {
        const rootPoint = getRootPoint(component, origin, anchorInfo);
        return anchorInfo.node
            // Ensure the node is still attached, otherwise we can't get a valid client rect for a detached node
            .filter(inBody)
            .bind((target) => {
            const rect = target.dom.getBoundingClientRect();
            const nodeBox = getBox(rect.left, rect.top, rect.width, rect.height);
            const elem = anchorInfo.node.getOr(component.element);
            return calcNewAnchor(nodeBox, rootPoint, anchorInfo, origin, elem);
        });
    };
    var NodeAnchor = [
        required$1('node'),
        required$1('root'),
        option$3('bubble'),
        schema$n(),
        // chiefly MaxHeight.expandable()
        defaulted('overrides', {}),
        defaulted('showAbove', false),
        output$1('placement', placement$2)
    ];

    const point = (element, offset) => ({
        element,
        offset
    });
    // NOTE: This only descends once.
    const descendOnce$1 = (element, offset) => {
        const children$1 = children(element);
        if (children$1.length === 0) {
            return point(element, offset);
        }
        else if (offset < children$1.length) {
            return point(children$1[offset], 0);
        }
        else {
            const last = children$1[children$1.length - 1];
            const len = isText(last) ? get$a(last).length : children(last).length;
            return point(last, len);
        }
    };

    // A range from (a, 1) to (body, end) was giving the wrong bounds.
    const descendOnce = (element, offset) => isText(element) ? point(element, offset) : descendOnce$1(element, offset);
    const isSimRange = (detail) => detail.foffset !== undefined;
    const getAnchorSelection = (win, anchorInfo) => {
        // FIX TEST Test both providing a getSelection and not providing a getSelection
        const getSelection = anchorInfo.getSelection.getOrThunk(() => () => getExact(win));
        return getSelection().map((sel) => {
            if (isSimRange(sel)) {
                const modStart = descendOnce(sel.start, sel.soffset);
                const modFinish = descendOnce(sel.finish, sel.foffset);
                return SimSelection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);
            }
            else {
                return sel;
            }
        });
    };
    const placement$1 = (component, anchorInfo, origin) => {
        const win = defaultView(anchorInfo.root).dom;
        const rootPoint = getRootPoint(component, origin, anchorInfo);
        const selectionBox = getAnchorSelection(win, anchorInfo).bind((sel) => {
            // This represents the *visual* rectangle of the selection.
            if (isSimRange(sel)) {
                const optRect = getBounds$2(win, SimSelection.exactFromRange(sel)).orThunk(() => {
                    const zeroWidth$1 = SugarElement.fromText(zeroWidth);
                    before$1(sel.start, zeroWidth$1);
                    // Certain things like <p><br/></p> with (p, 0) or <br>) as collapsed selection do not return a client rectangle
                    const rect = getFirstRect(win, SimSelection.exact(zeroWidth$1, 0, zeroWidth$1, 1));
                    remove$7(zeroWidth$1);
                    return rect;
                });
                return optRect.bind((rawRect) => {
                    return getBox(rawRect.left, rawRect.top, rawRect.width, rawRect.height);
                });
            }
            else {
                const selectionRect = map$1(sel, (cell) => cell.dom.getBoundingClientRect());
                const bounds = {
                    left: Math.min(selectionRect.firstCell.left, selectionRect.lastCell.left),
                    right: Math.max(selectionRect.firstCell.right, selectionRect.lastCell.right),
                    top: Math.min(selectionRect.firstCell.top, selectionRect.lastCell.top),
                    bottom: Math.max(selectionRect.firstCell.bottom, selectionRect.lastCell.bottom)
                };
                return getBox(bounds.left, bounds.top, bounds.right - bounds.left, bounds.bottom - bounds.top);
            }
        });
        const targetElement = getAnchorSelection(win, anchorInfo)
            .bind((sel) => {
            if (isSimRange(sel)) {
                return isElement$1(sel.start) ? Optional.some(sel.start) : parentElement(sel.start);
            }
            else {
                return Optional.some(sel.firstCell);
            }
        });
        const elem = targetElement.getOr(component.element);
        return calcNewAnchor(selectionBox, rootPoint, anchorInfo, origin, elem);
    };
    var SelectionAnchor = [
        option$3('getSelection'),
        required$1('root'),
        option$3('bubble'),
        schema$n(),
        defaulted('overrides', {}),
        defaulted('showAbove', false),
        output$1('placement', placement$1)
    ];

    /*
      Layout for submenus;
      Either left or right of the anchor menu item. Never above or below.
      Aligned to the top or bottom of the anchor as appropriate.
     */
    const labelPrefix = 'link-layout';
    // display element to the right, left edge against the right of the menu
    const eastX = (anchor) => anchor.x + anchor.width;
    // display element to the left, right edge against the left of the menu
    const westX = (anchor, element) => anchor.x - element.width;
    // display element pointing up, bottom edge against the bottom of the menu (usually to one side)
    const northY = (anchor, element) => anchor.y - element.height + anchor.height;
    // display element pointing down, top edge against the top of the menu (usually to one side)
    const southY = (anchor) => anchor.y;
    const southeast = (anchor, element, bubbles) => nu$5(eastX(anchor), southY(anchor), bubbles.southeast(), southeast$3(), "southeast" /* Placement.Southeast */, boundsRestriction(anchor, { left: 0 /* AnchorBoxBounds.RightEdge */, top: 2 /* AnchorBoxBounds.TopEdge */ }), labelPrefix);
    const southwest = (anchor, element, bubbles) => nu$5(westX(anchor, element), southY(anchor), bubbles.southwest(), southwest$3(), "southwest" /* Placement.Southwest */, boundsRestriction(anchor, { right: 1 /* AnchorBoxBounds.LeftEdge */, top: 2 /* AnchorBoxBounds.TopEdge */ }), labelPrefix);
    const northeast = (anchor, element, bubbles) => nu$5(eastX(anchor), northY(anchor, element), bubbles.northeast(), northeast$3(), "northeast" /* Placement.Northeast */, boundsRestriction(anchor, { left: 0 /* AnchorBoxBounds.RightEdge */, bottom: 3 /* AnchorBoxBounds.BottomEdge */ }), labelPrefix);
    const northwest = (anchor, element, bubbles) => nu$5(westX(anchor, element), northY(anchor, element), bubbles.northwest(), northwest$3(), "northwest" /* Placement.Northwest */, boundsRestriction(anchor, { right: 1 /* AnchorBoxBounds.LeftEdge */, bottom: 3 /* AnchorBoxBounds.BottomEdge */ }), labelPrefix);
    const all = () => [southeast, southwest, northeast, northwest];
    const allRtl = () => [southwest, southeast, northwest, northeast];

    const placement = (component, submenuInfo, origin) => {
        const anchorBox = toBox(origin, submenuInfo.item.element);
        const layouts = get$1(component.element, submenuInfo, all(), allRtl(), 
        // No default bottomToTop layouts currently needed
        all(), allRtl(), Optional.none());
        return Optional.some(nu$1({
            anchorBox,
            bubble: fallback(),
            overrides: submenuInfo.overrides,
            layouts
        }));
    };
    var SubmenuAnchor = [
        required$1('item'),
        schema$n(),
        defaulted('overrides', {}),
        output$1('placement', placement)
    ];

    var AnchorSchema = choose$1('type', {
        selection: SelectionAnchor,
        node: NodeAnchor,
        hotspot: HotspotAnchor,
        submenu: SubmenuAnchor,
        makeshift: MakeshiftAnchor
    });

    const TransitionSchema = [
        requiredArrayOf('classes', string),
        defaultedStringEnum('mode', 'all', ['all', 'layout', 'placement'])
    ];
    const PositionSchema = [
        defaulted('useFixed', never),
        option$3('getBounds')
    ];
    const PlacementSchema = [
        requiredOf('anchor', AnchorSchema),
        optionObjOf('transition', TransitionSchema)
    ];

    const getFixedOrigin = () => {
        // Don't use window.innerWidth/innerHeight here, as we don't want to include scrollbars
        // since the right/bottom position is based on the edge of the scrollbar not the window
        const html = document.documentElement;
        return fixed(0, 0, html.clientWidth, html.clientHeight);
    };
    const getRelativeOrigin = (component) => {
        const position = absolute$3(component.element);
        const bounds = component.element.dom.getBoundingClientRect();
        // We think that this just needs to be kept consistent with Boxes.win. If we remove the scroll values from Boxes.win, we
        // should change this to just bounds.left and bounds.top from getBoundingClientRect
        return relative(position.left, position.top, bounds.width, bounds.height);
    };
    const place = (origin, anchoring, optBounds, placee, lastPlace, transition) => {
        const anchor = box(anchoring.anchorBox, origin);
        return simple(anchor, placee.element, anchoring.bubble, anchoring.layouts, lastPlace, optBounds, anchoring.overrides, transition);
    };
    const position$1 = (component, posConfig, posState, placee, placementSpec) => {
        const optWithinBounds = Optional.none();
        positionWithinBounds(component, posConfig, posState, placee, placementSpec, optWithinBounds);
    };
    const positionWithinBounds = (component, posConfig, posState, placee, placementSpec, optWithinBounds) => {
        const placeeDetail = asRawOrDie$1('placement.info', objOf(PlacementSchema), placementSpec);
        const anchorage = placeeDetail.anchor;
        const element = placee.element;
        const placeeState = posState.get(placee.uid);
        // Preserve the focus as IE 11 loses it when setting visibility to hidden
        preserve(() => {
            // We set it to be fixed, so that it doesn't interfere with the layout of anything
            // when calculating anchors
            set$7(element, 'position', 'fixed');
            const oldVisibility = getRaw(element, 'visibility');
            set$7(element, 'visibility', 'hidden');
            // We need to calculate the origin (esp. the bounding client rect) *after* we have done
            // all the preprocessing of the component and placee. Otherwise, the relative positions
            // (bottom and right) will be using the wrong dimensions
            const origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);
            anchorage.placement(component, anchorage, origin).each((anchoring) => {
                // If "within bounds" is specified, it overrides any Positioning config. Otherwise, we
                // use the Positioning config. We don't try to combine automatically here because they are
                // sometimes serving different purposes. If the Positioning config getBounds needs to be
                // combined with the optWithinBounds bounds, then it is the responsibility of the calling
                // code to combine them, and pass in the combined value as optWithinBounds. The optWithinBounds
                // will *always* override the Positioning config.
                const optBounds = optWithinBounds.orThunk(() => posConfig.getBounds.map(apply$1));
                // Place the element and then update the state for the placee
                const newState = place(origin, anchoring, optBounds, placee, placeeState, placeeDetail.transition);
                posState.set(placee.uid, newState);
            });
            oldVisibility.fold(() => {
                remove$6(element, 'visibility');
            }, (vis) => {
                set$7(element, 'visibility', vis);
            });
            // We need to remove position: fixed put on by above code if it is not needed.
            if (getRaw(element, 'left').isNone() &&
                getRaw(element, 'top').isNone() &&
                getRaw(element, 'right').isNone() &&
                getRaw(element, 'bottom').isNone() &&
                is$1(getRaw(element, 'position'), 'fixed')) {
                remove$6(element, 'position');
            }
        }, element);
    };
    const getMode = (component, pConfig, _pState) => pConfig.useFixed() ? 'fixed' : 'absolute';
    const reset = (component, pConfig, posState, placee) => {
        const element = placee.element;
        each$1(['position', 'left', 'right', 'top', 'bottom'], (prop) => remove$6(element, prop));
        reset$2(element);
        posState.clear(placee.uid);
    };

    var PositionApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        position: position$1,
        positionWithinBounds: positionWithinBounds,
        getMode: getMode,
        reset: reset
    });

    const init$8 = () => {
        let state = {};
        const set = (id, data) => {
            state[id] = data;
        };
        const get = (id) => get$h(state, id);
        const clear = (id) => {
            if (isNonNullable(id)) {
                delete state[id];
            }
            else {
                state = {};
            }
        };
        return nu$4({
            readState: () => state,
            clear,
            set,
            get
        });
    };

    var PositioningState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$8
    });

    const Positioning = create$3({
        fields: PositionSchema,
        name: 'positioning',
        active: ActivePosition,
        apis: PositionApis,
        state: PositioningState
    });

    const chooseChannels = (channels, message) => message.universal ? channels : filter$2(channels, (ch) => contains$2(message.channels, ch));
    const events$8 = (receiveConfig) => derive$2([
        run$1(receive(), (component, message) => {
            const channelMap = receiveConfig.channels;
            const channels = keys(channelMap);
            // NOTE: Receiving event ignores the whole simulated event part.
            // TODO: Think about the types for this, or find a better way for this to rely on receiving.
            const receivingData = message;
            const targetChannels = chooseChannels(channels, receivingData);
            each$1(targetChannels, (ch) => {
                const channelInfo = channelMap[ch];
                const channelSchema = channelInfo.schema;
                const data = asRawOrDie$1('channel[' + ch + '] data\nReceiver: ' + element(component.element), channelSchema, receivingData.data);
                channelInfo.onReceive(component, data);
            });
        })
    ]);

    var ActiveReceiving = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$8
    });

    var ReceivingSchema = [
        requiredOf('channels', setOf(
        // Allow any keys.
        Result.value, objOfOnly([
            onStrictHandler('onReceive'),
            defaulted('schema', anyValue())
        ])))
    ];

    const Receiving = create$3({
        fields: ReceivingSchema,
        name: 'receiving',
        active: ActiveReceiving
    });

    const events$7 = (reflectingConfig, reflectingState) => {
        const update = (component, data) => {
            reflectingConfig.updateState.each((updateState) => {
                const newState = updateState(component, data);
                reflectingState.set(newState);
            });
            // FIX: Partial duplication of Replacing + Receiving
            reflectingConfig.renderComponents.each((renderComponents) => {
                const newComponents = renderComponents(data, reflectingState.get());
                const replacer = reflectingConfig.reuseDom ? withReuse : withoutReuse;
                replacer(component, newComponents);
            });
        };
        return derive$2([
            run$1(receive(), (component, message) => {
                // NOTE: Receiving event ignores the whole simulated event part.
                // TODO: Think about the types for this, or find a better way for this to rely on receiving.
                const receivingData = message;
                if (!receivingData.universal) {
                    const channel = reflectingConfig.channel;
                    if (contains$2(receivingData.channels, channel)) {
                        update(component, receivingData.data);
                    }
                }
            }),
            runOnAttached((comp, _se) => {
                reflectingConfig.initialData.each((rawData) => {
                    update(comp, rawData);
                });
            })
        ]);
    };

    var ActiveReflecting = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$7
    });

    const getState$1 = (component, replaceConfig, reflectState) => reflectState;

    var ReflectingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getState: getState$1
    });

    var ReflectingSchema = [
        required$1('channel'),
        option$3('renderComponents'),
        option$3('updateState'),
        option$3('initialData'),
        defaultedBoolean('reuseDom', true)
    ];

    const init$7 = () => {
        const cell = Cell(Optional.none());
        const clear = () => cell.set(Optional.none());
        const readState = () => cell.get().getOr('none');
        return {
            readState,
            get: cell.get,
            set: cell.set,
            clear
        };
    };

    var ReflectingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$7
    });

    const Reflecting = create$3({
        fields: ReflectingSchema,
        name: 'reflecting',
        active: ActiveReflecting,
        apis: ReflectingApis,
        state: ReflectingState
    });

    // NOTE: A sandbox should not start as part of the world. It is expected to be
    // added to the sink on rebuild.
    const rebuild = (sandbox, sConfig, sState, data) => {
        sState.get().each((_data) => {
            // If currently has data, so it hasn't been removed yet. It is
            // being "re-opened"
            detachChildren(sandbox);
        });
        const point = sConfig.getAttachPoint(sandbox);
        attach(point, sandbox);
        // Must be after the sandbox is in the system
        const built = sandbox.getSystem().build(data);
        attach(sandbox, built);
        sState.set(built);
        return built;
    };
    // Open sandbox transfers focus to the opened menu
    const open$1 = (sandbox, sConfig, sState, data) => {
        const newState = rebuild(sandbox, sConfig, sState, data);
        sConfig.onOpen(sandbox, newState);
        return newState;
    };
    const setContent = (sandbox, sConfig, sState, data) => sState.get().map(() => rebuild(sandbox, sConfig, sState, data));
    // TODO AP-191 write a test for openWhileCloaked
    const openWhileCloaked = (sandbox, sConfig, sState, data, transaction) => {
        cloak(sandbox, sConfig);
        open$1(sandbox, sConfig, sState, data);
        transaction();
        decloak(sandbox, sConfig);
    };
    const close$1 = (sandbox, sConfig, sState) => {
        sState.get().each((data) => {
            detachChildren(sandbox);
            detach(sandbox);
            sConfig.onClose(sandbox, data);
            sState.clear();
        });
    };
    const isOpen$1 = (_sandbox, _sConfig, sState) => sState.isOpen();
    const isPartOf$1 = (sandbox, sConfig, sState, queryElem) => isOpen$1(sandbox, sConfig, sState) && sState.get().exists((data) => sConfig.isPartOf(sandbox, data, queryElem));
    const getState = (_sandbox, _sConfig, sState) => sState.get();
    const store = (sandbox, cssKey, attr, newValue) => {
        getRaw(sandbox.element, cssKey).fold(() => {
            remove$8(sandbox.element, attr);
        }, (v) => {
            set$9(sandbox.element, attr, v);
        });
        set$7(sandbox.element, cssKey, newValue);
    };
    const restore = (sandbox, cssKey, attr) => {
        getOpt(sandbox.element, attr).fold(() => remove$6(sandbox.element, cssKey), (oldValue) => set$7(sandbox.element, cssKey, oldValue));
    };
    const cloak = (sandbox, sConfig, _sState) => {
        const sink = sConfig.getAttachPoint(sandbox);
        // Use the positioning mode of the sink, so that it does not interfere with the sink's positioning
        // We add it here to stop it causing layout problems.
        set$7(sandbox.element, 'position', Positioning.getMode(sink));
        store(sandbox, 'visibility', sConfig.cloakVisibilityAttr, 'hidden');
    };
    const hasPosition = (element) => exists(['top', 'left', 'right', 'bottom'], (pos) => getRaw(element, pos).isSome());
    const decloak = (sandbox, sConfig, _sState) => {
        if (!hasPosition(sandbox.element)) {
            // If a position value was not added to the sandbox during cloaking, remove it
            // otherwise certain position values (absolute, relative) will impact the child that _was_ positioned
            remove$6(sandbox.element, 'position');
        }
        restore(sandbox, 'visibility', sConfig.cloakVisibilityAttr);
    };

    var SandboxApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        cloak: cloak,
        decloak: decloak,
        open: open$1,
        openWhileCloaked: openWhileCloaked,
        close: close$1,
        isOpen: isOpen$1,
        isPartOf: isPartOf$1,
        getState: getState,
        setContent: setContent
    });

    const events$6 = (sandboxConfig, sandboxState) => derive$2([
        run$1(sandboxClose(), (sandbox, _simulatedEvent) => {
            close$1(sandbox, sandboxConfig, sandboxState);
        })
    ]);

    var ActiveSandbox = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$6
    });

    var SandboxSchema = [
        onHandler('onOpen'),
        onHandler('onClose'),
        // Maybe this should be optional
        required$1('isPartOf'),
        required$1('getAttachPoint'),
        defaulted('cloakVisibilityAttr', 'data-precloak-visibility')
    ];

    const init$6 = () => {
        const contents = value$2();
        const readState = constant$1('not-implemented');
        return nu$4({
            readState,
            isOpen: contents.isSet,
            clear: contents.clear,
            set: contents.set,
            get: contents.get
        });
    };

    var SandboxState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$6
    });

    const Sandboxing = create$3({
        fields: SandboxSchema,
        name: 'sandboxing',
        active: ActiveSandbox,
        apis: SandboxApis,
        state: SandboxState
    });

    const getAnimationRoot = (component, slideConfig) => slideConfig.getAnimationRoot.fold(() => component.element, (get) => get(component));

    const getDimensionProperty = (slideConfig) => slideConfig.dimension.property;
    const getDimension = (slideConfig, elem) => slideConfig.dimension.getDimension(elem);
    const disableTransitions = (component, slideConfig) => {
        const root = getAnimationRoot(component, slideConfig);
        remove$2(root, [slideConfig.shrinkingClass, slideConfig.growingClass]);
    };
    const setShrunk = (component, slideConfig) => {
        remove$3(component.element, slideConfig.openClass);
        add$2(component.element, slideConfig.closedClass);
        set$7(component.element, getDimensionProperty(slideConfig), '0px');
        reflow(component.element);
    };
    const setGrown = (component, slideConfig) => {
        remove$3(component.element, slideConfig.closedClass);
        add$2(component.element, slideConfig.openClass);
        remove$6(component.element, getDimensionProperty(slideConfig));
    };
    const doImmediateShrink = (component, slideConfig, slideState, _calculatedSize) => {
        slideState.setCollapsed();
        // Force current dimension to begin transition
        set$7(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));
        // TINY-8710: we don't think reflow is required (as has been done elsewhere) as the animation is not needed
        disableTransitions(component, slideConfig);
        setShrunk(component, slideConfig);
        slideConfig.onStartShrink(component);
        slideConfig.onShrunk(component);
    };
    const doStartShrink = (component, slideConfig, slideState, calculatedSize) => {
        const size = calculatedSize.getOrThunk(() => getDimension(slideConfig, component.element));
        slideState.setCollapsed();
        // Force current dimension to begin transition
        set$7(component.element, getDimensionProperty(slideConfig), size);
        reflow(component.element);
        const root = getAnimationRoot(component, slideConfig);
        remove$3(root, slideConfig.growingClass);
        add$2(root, slideConfig.shrinkingClass); // enable transitions
        setShrunk(component, slideConfig);
        slideConfig.onStartShrink(component);
    };
    // A "smartShrink" will do an immediate shrink if no shrinking is scheduled to happen
    const doStartSmartShrink = (component, slideConfig, slideState) => {
        const size = getDimension(slideConfig, component.element);
        const shrinker = size === '0px' ? doImmediateShrink : doStartShrink;
        shrinker(component, slideConfig, slideState, Optional.some(size));
    };
    // Showing is complex due to the inability to transition to "auto".
    // We also can't cache the dimension as the parents may have resized since it was last shown.
    const doStartGrow = (component, slideConfig, slideState) => {
        // Start the growing animation styles
        const root = getAnimationRoot(component, slideConfig);
        // Record whether this is interrupting a shrink and its current size
        const wasShrinking = has(root, slideConfig.shrinkingClass);
        const beforeSize = getDimension(slideConfig, component.element);
        setGrown(component, slideConfig);
        const fullSize = getDimension(slideConfig, component.element);
        // If the grow is interrupting a shrink, use the size from before the grow as the start size
        // And reflow so that the animation works.
        const startPartialGrow = () => {
            set$7(component.element, getDimensionProperty(slideConfig), beforeSize);
            reflow(component.element);
        };
        // If the grow is not interrupting a shrink, start from 0 (shrunk)
        const startCompleteGrow = () => {
            setShrunk(component, slideConfig);
        };
        // Determine what the initial size for the grow operation should be.
        const setStartSize = wasShrinking ? startPartialGrow : startCompleteGrow;
        setStartSize();
        remove$3(root, slideConfig.shrinkingClass);
        add$2(root, slideConfig.growingClass);
        setGrown(component, slideConfig);
        set$7(component.element, getDimensionProperty(slideConfig), fullSize);
        slideState.setExpanded();
        slideConfig.onStartGrow(component);
    };
    const refresh$3 = (component, slideConfig, slideState) => {
        if (slideState.isExpanded()) {
            remove$6(component.element, getDimensionProperty(slideConfig));
            const fullSize = getDimension(slideConfig, component.element);
            set$7(component.element, getDimensionProperty(slideConfig), fullSize);
        }
    };
    const grow = (component, slideConfig, slideState) => {
        if (!slideState.isExpanded()) {
            doStartGrow(component, slideConfig, slideState);
        }
    };
    const shrink = (component, slideConfig, slideState) => {
        if (slideState.isExpanded()) {
            doStartSmartShrink(component, slideConfig, slideState);
        }
    };
    const immediateShrink = (component, slideConfig, slideState) => {
        if (slideState.isExpanded()) {
            doImmediateShrink(component, slideConfig, slideState);
        }
    };
    const hasGrown = (component, slideConfig, slideState) => slideState.isExpanded();
    const hasShrunk = (component, slideConfig, slideState) => slideState.isCollapsed();
    const isGrowing = (component, slideConfig, _slideState) => {
        const root = getAnimationRoot(component, slideConfig);
        return has(root, slideConfig.growingClass) === true;
    };
    const isShrinking = (component, slideConfig, _slideState) => {
        const root = getAnimationRoot(component, slideConfig);
        return has(root, slideConfig.shrinkingClass) === true;
    };
    const isTransitioning = (component, slideConfig, slideState) => isGrowing(component, slideConfig) || isShrinking(component, slideConfig);
    const toggleGrow = (component, slideConfig, slideState) => {
        const f = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;
        f(component, slideConfig, slideState);
    };
    const immediateGrow = (component, slideConfig, slideState) => {
        if (!slideState.isExpanded()) {
            setGrown(component, slideConfig);
            set$7(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));
            // TINY-8710: we don't think reflow is required (as has been done elsewhere) as the animation is not needed
            // Keep disableTransition to handle the case where it's part way through transitioning
            disableTransitions(component, slideConfig);
            slideState.setExpanded();
            slideConfig.onStartGrow(component);
            slideConfig.onGrown(component);
        }
    };

    var SlidingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        refresh: refresh$3,
        grow: grow,
        shrink: shrink,
        immediateShrink: immediateShrink,
        hasGrown: hasGrown,
        hasShrunk: hasShrunk,
        isGrowing: isGrowing,
        isShrinking: isShrinking,
        isTransitioning: isTransitioning,
        toggleGrow: toggleGrow,
        disableTransitions: disableTransitions,
        immediateGrow: immediateGrow
    });

    const exhibit$3 = (base, slideConfig, _slideState) => {
        const expanded = slideConfig.expanded;
        return expanded ? nu$2({
            classes: [slideConfig.openClass],
            styles: {}
        }) : nu$2({
            classes: [slideConfig.closedClass],
            styles: wrap(slideConfig.dimension.property, '0px')
        });
    };
    const events$5 = (slideConfig, slideState) => derive$2([
        runOnSource(transitionend(), (component, simulatedEvent) => {
            const raw = simulatedEvent.event.raw;
            // This will fire for all transitions, we're only interested in the dimension completion on source
            if (raw.propertyName === slideConfig.dimension.property) {
                disableTransitions(component, slideConfig); // disable transitions immediately (Safari animates the dimension removal below)
                if (slideState.isExpanded()) {
                    remove$6(component.element, slideConfig.dimension.property);
                } // when showing, remove the dimension so it is responsive
                const notify = slideState.isExpanded() ? slideConfig.onGrown : slideConfig.onShrunk;
                notify(component);
            }
        })
    ]);

    var ActiveSliding = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$3,
        events: events$5
    });

    var SlidingSchema = [
        required$1('closedClass'),
        required$1('openClass'),
        required$1('shrinkingClass'),
        required$1('growingClass'),
        // Element which shrinking and growing animations
        option$3('getAnimationRoot'),
        onHandler('onShrunk'),
        onHandler('onStartShrink'),
        onHandler('onGrown'),
        onHandler('onStartGrow'),
        defaulted('expanded', false),
        requiredOf('dimension', choose$1('property', {
            width: [
                output$1('property', 'width'),
                output$1('getDimension', (elem) => get$c(elem) + 'px')
            ],
            height: [
                output$1('property', 'height'),
                output$1('getDimension', (elem) => get$d(elem) + 'px')
            ]
        }))
    ];

    const init$5 = (spec) => {
        const state = Cell(spec.expanded);
        const readState = () => 'expanded: ' + state.get();
        return nu$4({
            isExpanded: () => state.get() === true,
            isCollapsed: () => state.get() === false,
            setCollapsed: curry(state.set, false),
            setExpanded: curry(state.set, true),
            readState
        });
    };

    var SlidingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$5
    });

    const Sliding = create$3({
        fields: SlidingSchema,
        name: 'sliding',
        active: ActiveSliding,
        apis: SlidingApis,
        state: SlidingState
    });

    const events$4 = (streamConfig, streamState) => {
        const streams = streamConfig.stream.streams;
        const processor = streams.setup(streamConfig, streamState);
        return derive$2([
            run$1(streamConfig.event, processor),
            runOnDetached(() => streamState.cancel())
        ].concat(streamConfig.cancelEvent.map((e) => [
            run$1(e, () => streamState.cancel())
        ]).getOr([])));
    };

    var ActiveStreaming = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$4
    });

    const throttle = (_config) => {
        const state = Cell(null);
        const readState = () => ({
            timer: state.get() !== null ? 'set' : 'unset'
        });
        const setTimer = (t) => {
            state.set(t);
        };
        const cancel = () => {
            const t = state.get();
            if (t !== null) {
                t.cancel();
            }
        };
        return nu$4({
            readState,
            setTimer,
            cancel
        });
    };
    const init$4 = (spec) => spec.stream.streams.state(spec);

    var StreamingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        throttle: throttle,
        init: init$4
    });

    const setup$e = (streamInfo, streamState) => {
        const sInfo = streamInfo.stream;
        const throttler = last(streamInfo.onStream, sInfo.delay);
        streamState.setTimer(throttler);
        return (component, simulatedEvent) => {
            throttler.throttle(component, simulatedEvent);
            if (sInfo.stopEvent) {
                simulatedEvent.stop();
            }
        };
    };
    var StreamingSchema = [
        requiredOf('stream', choose$1('mode', {
            throttle: [
                required$1('delay'),
                defaulted('stopEvent', true),
                output$1('streams', {
                    setup: setup$e,
                    state: throttle
                })
            ]
        })),
        defaulted('event', 'input'),
        option$3('cancelEvent'),
        onStrictHandler('onStream')
    ];

    const Streaming = create$3({
        fields: StreamingSchema,
        name: 'streaming',
        active: ActiveStreaming,
        state: StreamingState
    });

    const exhibit$2 = (base, tabConfig) => nu$2({
        attributes: wrapAll([
            { key: tabConfig.tabAttr, value: 'true' }
        ])
    });

    var ActiveTabstopping = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$2
    });

    var TabstopSchema = [
        defaulted('tabAttr', 'data-alloy-tabstop')
    ];

    const Tabstopping = create$3({
        fields: TabstopSchema,
        name: 'tabstopping',
        active: ActiveTabstopping
    });

    const updateAriaState = (component, toggleConfig, toggleState) => {
        const ariaInfo = toggleConfig.aria;
        ariaInfo.update(component, ariaInfo, toggleState.get());
    };
    const updateClass = (component, toggleConfig, toggleState) => {
        toggleConfig.toggleClass.each((toggleClass) => {
            if (toggleState.get()) {
                add$2(component.element, toggleClass);
            }
            else {
                remove$3(component.element, toggleClass);
            }
        });
    };
    const set = (component, toggleConfig, toggleState, state) => {
        const initialState = toggleState.get();
        toggleState.set(state);
        updateClass(component, toggleConfig, toggleState);
        updateAriaState(component, toggleConfig, toggleState);
        if (initialState !== state) {
            toggleConfig.onToggled(component, state);
        }
    };
    const toggle$2 = (component, toggleConfig, toggleState) => {
        set(component, toggleConfig, toggleState, !toggleState.get());
    };
    const on = (component, toggleConfig, toggleState) => {
        set(component, toggleConfig, toggleState, true);
    };
    const off = (component, toggleConfig, toggleState) => {
        set(component, toggleConfig, toggleState, false);
    };
    const isOn = (component, toggleConfig, toggleState) => toggleState.get();
    const onLoad = (component, toggleConfig, toggleState) => {
        // There used to be a bit of code in here that would only overwrite
        // the attribute if it didn't have a current value. I can't remember
        // what case that was for, so I'm removing it until it is required.
        set(component, toggleConfig, toggleState, toggleConfig.selected);
    };

    var ToggleApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        onLoad: onLoad,
        toggle: toggle$2,
        isOn: isOn,
        on: on,
        off: off,
        set: set
    });

    const exhibit$1 = () => nu$2({});
    const events$3 = (toggleConfig, toggleState) => {
        const execute = executeEvent(toggleConfig, toggleState, toggle$2);
        const load = loadEvent(toggleConfig, toggleState, onLoad);
        return derive$2(flatten([
            toggleConfig.toggleOnExecute ? [execute] : [],
            [load]
        ]));
    };

    var ActiveToggle = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$1,
        events: events$3
    });

    const updatePressed = (component, ariaInfo, status) => {
        set$9(component.element, 'aria-pressed', status);
        if (ariaInfo.syncWithExpanded) {
            updateExpanded(component, ariaInfo, status);
        }
    };
    const updateSelected = (component, ariaInfo, status) => {
        set$9(component.element, 'aria-selected', status);
    };
    const updateChecked = (component, ariaInfo, status) => {
        set$9(component.element, 'aria-checked', status);
    };
    const updateExpanded = (component, ariaInfo, status) => {
        set$9(component.element, 'aria-expanded', status);
    };

    var ToggleSchema = [
        defaulted('selected', false),
        option$3('toggleClass'),
        defaulted('toggleOnExecute', true),
        onHandler('onToggled'),
        defaultedOf('aria', {
            mode: 'none'
        }, choose$1('mode', {
            pressed: [
                defaulted('syncWithExpanded', false),
                output$1('update', updatePressed)
            ],
            checked: [
                output$1('update', updateChecked)
            ],
            expanded: [
                output$1('update', updateExpanded)
            ],
            selected: [
                output$1('update', updateSelected)
            ],
            none: [
                output$1('update', noop)
            ]
        }))
    ];

    const Toggling = create$3({
        fields: ToggleSchema,
        name: 'toggling',
        active: ActiveToggle,
        apis: ToggleApis,
        state: SetupBehaviourCellState(false)
    });

    const ExclusivityChannel = generate$6('tooltip.exclusive');
    const ShowTooltipEvent = generate$6('tooltip.show');
    const HideTooltipEvent = generate$6('tooltip.hide');
    const ImmediateHideTooltipEvent = generate$6('tooltip.immediateHide');
    const ImmediateShowTooltipEvent = generate$6('tooltip.immediateShow');

    const hideAllExclusive = (component, _tConfig, _tState) => {
        component.getSystem().broadcastOn([ExclusivityChannel], {});
    };
    const setComponents = (_component, _tConfig, tState, specs) => {
        tState.getTooltip().each((tooltip) => {
            if (tooltip.getSystem().isConnected()) {
                Replacing.set(tooltip, specs);
            }
        });
    };
    const isEnabled = (_component, _tConfig, tState) => tState.isEnabled();
    const setEnabled = (_component, _tConfig, tState, enabled) => tState.setEnabled(enabled);
    const immediateOpenClose = (component, _tConfig, _tState, open) => emit(component, open ? ImmediateShowTooltipEvent : ImmediateHideTooltipEvent);

    var TooltippingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        hideAllExclusive: hideAllExclusive,
        immediateOpenClose: immediateOpenClose,
        isEnabled: isEnabled,
        setComponents: setComponents,
        setEnabled: setEnabled
    });

    const events$2 = (tooltipConfig, state) => {
        const hide = (comp) => {
            state.getTooltip().each((p) => {
                if (p.getSystem().isConnected()) {
                    detach(p);
                    tooltipConfig.onHide(comp, p);
                    state.clearTooltip();
                }
            });
            state.clearTimer();
        };
        const show = (comp) => {
            if (!state.isShowing() && state.isEnabled()) {
                hideAllExclusive(comp);
                const sink = tooltipConfig.lazySink(comp).getOrDie();
                const popup = comp.getSystem().build({
                    dom: tooltipConfig.tooltipDom,
                    components: tooltipConfig.tooltipComponents,
                    events: derive$2(tooltipConfig.mode === 'normal'
                        ? [
                            run$1(mouseover(), (_) => {
                                emit(comp, ShowTooltipEvent);
                            }),
                            run$1(mouseout(), (_) => {
                                emit(comp, HideTooltipEvent);
                            })
                        ]
                        : []),
                    behaviours: derive$1([
                        Replacing.config({})
                    ])
                });
                state.setTooltip(popup);
                attach(sink, popup);
                tooltipConfig.onShow(comp, popup);
                Positioning.position(sink, popup, { anchor: tooltipConfig.anchor(comp) });
            }
        };
        const reposition = (comp) => {
            state.getTooltip().each((tooltip) => {
                const sink = tooltipConfig.lazySink(comp).getOrDie();
                Positioning.position(sink, tooltip, { anchor: tooltipConfig.anchor(comp) });
            });
        };
        const getEvents = () => {
            switch (tooltipConfig.mode) {
                case 'normal':
                    return [
                        run$1(focusin(), (comp) => {
                            emit(comp, ImmediateShowTooltipEvent);
                        }),
                        run$1(postBlur(), (comp) => {
                            emit(comp, ImmediateHideTooltipEvent);
                        }),
                        run$1(mouseover(), (comp) => {
                            emit(comp, ShowTooltipEvent);
                        }),
                        run$1(mouseout(), (comp) => {
                            emit(comp, HideTooltipEvent);
                        })
                    ];
                case 'follow-highlight':
                    return [
                        run$1(highlight$1(), (comp, _se) => {
                            emit(comp, ShowTooltipEvent);
                        }),
                        run$1(dehighlight$1(), (comp) => {
                            emit(comp, HideTooltipEvent);
                        })
                    ];
                case 'children-normal':
                    return [
                        run$1(focusin(), (comp, se) => {
                            search(comp.element).each((_) => {
                                if (is(se.event.target, '[data-mce-tooltip]')) {
                                    state.getTooltip().fold(() => {
                                        emit(comp, ImmediateShowTooltipEvent);
                                    }, (tooltip) => {
                                        if (state.isShowing()) {
                                            tooltipConfig.onShow(comp, tooltip);
                                            reposition(comp);
                                        }
                                    });
                                }
                            });
                        }),
                        run$1(postBlur(), (comp) => {
                            search(comp.element).fold(() => {
                                emit(comp, ImmediateHideTooltipEvent);
                            }, noop);
                        }),
                        run$1(mouseover(), (comp) => {
                            descendant(comp.element, '[data-mce-tooltip]:hover').each((_) => {
                                state.getTooltip().fold(() => {
                                    emit(comp, ShowTooltipEvent);
                                }, (tooltip) => {
                                    if (state.isShowing()) {
                                        tooltipConfig.onShow(comp, tooltip);
                                        reposition(comp);
                                    }
                                });
                            });
                        }),
                        run$1(mouseout(), (comp) => {
                            descendant(comp.element, '[data-mce-tooltip]:hover').fold(() => {
                                emit(comp, HideTooltipEvent);
                            }, noop);
                        }),
                    ];
                default:
                    return [
                        run$1(focusin(), (comp, se) => {
                            search(comp.element).each((_) => {
                                if (is(se.event.target, '[data-mce-tooltip]')) {
                                    state.getTooltip().fold(() => {
                                        emit(comp, ImmediateShowTooltipEvent);
                                    }, (tooltip) => {
                                        if (state.isShowing()) {
                                            tooltipConfig.onShow(comp, tooltip);
                                            reposition(comp);
                                        }
                                    });
                                }
                            });
                        }),
                        run$1(postBlur(), (comp) => {
                            search(comp.element).fold(() => {
                                emit(comp, ImmediateHideTooltipEvent);
                            }, noop);
                        }),
                    ];
            }
        };
        return derive$2(flatten([
            [
                runOnInit((component) => {
                    tooltipConfig.onSetup(component);
                }),
                run$1(ShowTooltipEvent, (comp) => {
                    state.resetTimer(() => {
                        show(comp);
                    }, tooltipConfig.delayForShow());
                }),
                run$1(HideTooltipEvent, (comp) => {
                    state.resetTimer(() => {
                        hide(comp);
                    }, tooltipConfig.delayForHide());
                }),
                run$1(ImmediateShowTooltipEvent, (comp) => {
                    state.resetTimer(() => {
                        show(comp);
                    }, 0);
                }),
                run$1(ImmediateHideTooltipEvent, (comp) => {
                    state.resetTimer(() => {
                        hide(comp);
                    }, 0);
                }),
                run$1(receive(), (comp, message) => {
                    // TODO: Think about the types for this, or find a better way for this
                    // to rely on receiving.
                    const receivingData = message;
                    if (!receivingData.universal) {
                        if (contains$2(receivingData.channels, ExclusivityChannel) || contains$2(receivingData.channels, closeTooltips())) {
                            if (receivingData.data.closedTooltip && state.isShowing()) {
                                receivingData.data.closedTooltip();
                            }
                            hide(comp);
                        }
                    }
                }),
                runOnDetached((comp) => {
                    hide(comp);
                })
            ],
            (getEvents())
        ]));
    };

    var ActiveTooltipping = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$2
    });

    var TooltippingSchema = [
        required$1('lazySink'),
        required$1('tooltipDom'),
        defaulted('exclusive', true),
        defaulted('tooltipComponents', []),
        defaultedFunction('delayForShow', constant$1(300)),
        defaultedFunction('delayForHide', constant$1(100)),
        defaultedFunction('onSetup', noop),
        defaultedStringEnum('mode', 'normal', ['normal', 'follow-highlight', 'children-keyboard-focus', 'children-normal']),
        defaulted('anchor', (comp) => ({
            type: 'hotspot',
            hotspot: comp,
            layouts: {
                onLtr: constant$1([south$2, north$2, southeast$2, northeast$2, southwest$2, northwest$2]),
                onRtl: constant$1([south$2, north$2, southeast$2, northeast$2, southwest$2, northwest$2])
            },
            bubble: nu$6(0, -2, {}),
        })),
        onHandler('onHide'),
        onHandler('onShow'),
    ];

    const init$3 = () => {
        const enabled = Cell(true);
        const timer = value$2();
        const popup = value$2();
        const clearTimer = () => {
            timer.on(clearTimeout);
        };
        const resetTimer = (f, delay) => {
            clearTimer();
            timer.set(setTimeout(f, delay));
        };
        const readState = constant$1('not-implemented');
        return nu$4({
            getTooltip: popup.get,
            isShowing: popup.isSet,
            setTooltip: popup.set,
            clearTooltip: popup.clear,
            clearTimer,
            resetTimer,
            readState,
            isEnabled: () => enabled.get(),
            setEnabled: (setToEnabled) => enabled.set(setToEnabled)
        });
    };

    var TooltippingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$3
    });

    const Tooltipping = create$3({
        fields: TooltippingSchema,
        name: 'tooltipping',
        active: ActiveTooltipping,
        state: TooltippingState,
        apis: TooltippingApis
    });

    const exhibit = () => nu$2({
        styles: {
            '-webkit-user-select': 'none',
            'user-select': 'none',
            '-ms-user-select': 'none',
            '-moz-user-select': '-moz-none'
        },
        attributes: {
            unselectable: 'on'
        }
    });
    const events$1 = () => derive$2([
        abort(selectstart(), always)
    ]);

    var ActiveUnselecting = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$1,
        exhibit: exhibit
    });

    const Unselecting = create$3({
        fields: [],
        name: 'unselecting',
        active: ActiveUnselecting
    });

    const getAttrs = (elem) => {
        const attributes = elem.dom.attributes !== undefined ? elem.dom.attributes : [];
        return foldl(attributes, (b, attr) => {
            // Make class go through the class path. Do not list it as an attribute.
            if (attr.name === 'class') {
                return b;
            }
            else {
                return { ...b, [attr.name]: attr.value };
            }
        }, {});
    };
    const getClasses = (elem) => Array.prototype.slice.call(elem.dom.classList, 0);
    const fromHtml = (html) => {
        const elem = SugarElement.fromHtml(html);
        const children$1 = children(elem);
        const attrs = getAttrs(elem);
        const classes = getClasses(elem);
        const contents = children$1.length === 0 ? {} : { innerHtml: get$f(elem) };
        return {
            tag: name$3(elem),
            classes,
            attributes: attrs,
            ...contents
        };
    };

    const record = (spec) => {
        const uid = isSketchSpec(spec) && hasNonNullableKey(spec, 'uid') ? spec.uid : generate$4('memento');
        const get = (anyInSystem) => anyInSystem.getSystem().getByUid(uid).getOrDie();
        const getOpt = (anyInSystem) => anyInSystem.getSystem().getByUid(uid).toOptional();
        const asSpec = () => ({
            ...spec,
            uid
        });
        return {
            get,
            getOpt,
            asSpec
        };
    };

    // TODO: ^ rename the parts/ api to composites, it will break mobile alloy now if we do
    const parts$g = AlloyParts;
    const partType$1 = PartType;

    const fromSource = (event, source) => {
        const stopper = Cell(false);
        const cutter = Cell(false);
        const stop = () => {
            stopper.set(true);
        };
        const cut = () => {
            cutter.set(true);
        };
        return {
            stop,
            cut,
            isStopped: stopper.get,
            isCut: cutter.get,
            event,
            // Used only for tiered menu at the moment. It is an element, not a component
            setSource: source.set,
            getSource: source.get
        };
    };
    // Events that come from outside of the alloy root (e.g. window scroll)
    const fromExternal = (event) => {
        const stopper = Cell(false);
        const stop = () => {
            stopper.set(true);
        };
        return {
            stop,
            cut: noop, // cutting has no meaning for a broadcasted event
            isStopped: stopper.get,
            isCut: never,
            event,
            // Nor do targets really
            setSource: die('Cannot set source of a broadcasted event'),
            getSource: die('Cannot get source of a broadcasted event')
        };
    };

    const isDangerous = (event) => {
        // Will trigger the Back button in the browser
        const keyEv = event.raw;
        return keyEv.which === BACKSPACE[0] && !contains$2(['input', 'textarea'], name$3(event.target)) && !closest$1(event.target, '[contenteditable="true"]');
    };
    const setup$d = (container, rawSettings) => {
        const settings = {
            stopBackspace: true,
            ...rawSettings
        };
        const pointerEvents = [
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel',
            'gesturestart',
            'mousedown',
            'mouseup',
            'mouseover',
            'mousemove',
            'mouseout',
            'click'
        ];
        const tapEvent = monitor(settings);
        // These events are just passed through ... no additional processing
        const simpleEvents = map$2(pointerEvents.concat([
            'selectstart',
            'input',
            'contextmenu',
            'change',
            'transitionend',
            'transitioncancel',
            // Test the drag events
            'drag',
            'dragstart',
            'dragend',
            'dragenter',
            'dragleave',
            'dragover',
            'drop',
            'keyup'
        ]), (type) => bind$1(container, type, (event) => {
            tapEvent.fireIfReady(event, type).each((tapStopped) => {
                if (tapStopped) {
                    event.kill();
                }
            });
            const stopped = settings.triggerEvent(type, event);
            if (stopped) {
                event.kill();
            }
        }));
        const pasteTimeout = value$2();
        const onPaste = bind$1(container, 'paste', (event) => {
            tapEvent.fireIfReady(event, 'paste').each((tapStopped) => {
                if (tapStopped) {
                    event.kill();
                }
            });
            const stopped = settings.triggerEvent('paste', event);
            if (stopped) {
                event.kill();
            }
            pasteTimeout.set(setTimeout(() => {
                settings.triggerEvent(postPaste(), event);
            }, 0));
        });
        const onKeydown = bind$1(container, 'keydown', (event) => {
            // Prevent default of backspace when not in input fields.
            const stopped = settings.triggerEvent('keydown', event);
            if (stopped) {
                event.kill();
            }
            else if (settings.stopBackspace && isDangerous(event)) {
                event.prevent();
            }
        });
        const onFocusIn = bind$1(container, 'focusin', (event) => {
            const stopped = settings.triggerEvent('focusin', event);
            if (stopped) {
                event.kill();
            }
        });
        const focusoutTimeout = value$2();
        const onFocusOut = bind$1(container, 'focusout', (event) => {
            const stopped = settings.triggerEvent('focusout', event);
            if (stopped) {
                event.kill();
            }
            // INVESTIGATE: Come up with a better way of doing this. Related target can be used, but not on FF.
            // It allows the active element to change before firing the blur that we will listen to
            // for things like closing popups
            focusoutTimeout.set(setTimeout(() => {
                settings.triggerEvent(postBlur(), event);
            }, 0));
        });
        const unbind = () => {
            each$1(simpleEvents, (e) => {
                e.unbind();
            });
            onKeydown.unbind();
            onFocusIn.unbind();
            onFocusOut.unbind();
            onPaste.unbind();
            pasteTimeout.on(clearTimeout);
            focusoutTimeout.on(clearTimeout);
        };
        return {
            unbind
        };
    };

    const derive = (rawEvent, rawTarget) => {
        const source = get$h(rawEvent, 'target').getOr(rawTarget);
        return Cell(source);
    };

    const adt = Adt.generate([
        { stopped: [] },
        { resume: ['element'] },
        { complete: [] }
    ]);
    const doTriggerHandler = (lookup, eventType, rawEvent, target, source, logger) => {
        const handler = lookup(eventType, target);
        const simulatedEvent = fromSource(rawEvent, source);
        return handler.fold(() => {
            // No handler, so complete.
            logger.logEventNoHandlers(eventType, target);
            return adt.complete();
        }, (handlerInfo) => {
            const descHandler = handlerInfo.descHandler;
            const eventHandler = getCurried(descHandler);
            eventHandler(simulatedEvent);
            // Now, check if the event was stopped.
            if (simulatedEvent.isStopped()) {
                logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose);
                return adt.stopped();
            }
            else if (simulatedEvent.isCut()) {
                logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose);
                return adt.complete();
            }
            else {
                return parent(handlerInfo.element).fold(() => {
                    logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose);
                    // No parent, so complete.
                    return adt.complete();
                }, (parent) => {
                    logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose);
                    // Resume at parent
                    return adt.resume(parent);
                });
            }
        });
    };
    const doTriggerOnUntilStopped = (lookup, eventType, rawEvent, rawTarget, source, logger) => doTriggerHandler(lookup, eventType, rawEvent, rawTarget, source, logger).fold(
    // stopped.
    always, 
    // Go again.
    (parent) => doTriggerOnUntilStopped(lookup, eventType, rawEvent, parent, source, logger), 
    // completed
    never);
    const triggerHandler = (lookup, eventType, rawEvent, target, logger) => {
        const source = derive(rawEvent, target);
        return doTriggerHandler(lookup, eventType, rawEvent, target, source, logger);
    };
    const broadcast = (listeners, rawEvent, _logger) => {
        const simulatedEvent = fromExternal(rawEvent);
        each$1(listeners, (listener) => {
            const descHandler = listener.descHandler;
            const handler = getCurried(descHandler);
            handler(simulatedEvent);
        });
        return simulatedEvent.isStopped();
    };
    const triggerUntilStopped = (lookup, eventType, rawEvent, logger) => triggerOnUntilStopped(lookup, eventType, rawEvent, rawEvent.target, logger);
    const triggerOnUntilStopped = (lookup, eventType, rawEvent, rawTarget, logger) => {
        const source = derive(rawEvent, rawTarget);
        return doTriggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, source, logger);
    };

    const eventHandler = (element, descHandler) => ({
        element,
        descHandler
    });
    const broadcastHandler = (id, handler) => ({
        id,
        descHandler: handler
    });
    const EventRegistry = () => {
        const registry = {};
        const registerId = (extraArgs, id, events) => {
            each(events, (v, k) => {
                const handlers = registry[k] !== undefined ? registry[k] : {};
                handlers[id] = curryArgs(v, extraArgs);
                registry[k] = handlers;
            });
        };
        const findHandler = (handlers, elem) => read(elem)
            .bind((id) => get$h(handlers, id))
            .map((descHandler) => eventHandler(elem, descHandler));
        // Given just the event type, find all handlers regardless of element
        const filterByType = (type) => get$h(registry, type)
            .map((handlers) => mapToArray(handlers, (f, id) => broadcastHandler(id, f)))
            .getOr([]);
        // Given event type, and element, find the handler.
        const find = (isAboveRoot, type, target) => get$h(registry, type)
            .bind((handlers) => closest(target, (elem) => findHandler(handlers, elem), isAboveRoot));
        const unregisterId = (id) => {
            // INVESTIGATE: Find a better way than mutation if we can.
            each(registry, (handlersById, _eventName) => {
                if (has$2(handlersById, id)) {
                    delete handlersById[id];
                }
            });
        };
        return {
            registerId,
            unregisterId,
            filterByType,
            find
        };
    };

    const Registry = () => {
        const events = EventRegistry();
        // An index of uid -> built components
        const components = {};
        const readOrTag = (component) => {
            const elem = component.element;
            return read(elem).getOrThunk(() => 
            // No existing tag, so add one.
            write('uid-', component.element));
        };
        const failOnDuplicate = (component, tagId) => {
            const conflict = components[tagId];
            if (conflict === component) {
                unregister(component);
            }
            else {
                throw new Error('The tagId "' + tagId + '" is already used by: ' + element(conflict.element) + '\nCannot use it for: ' + element(component.element) + '\n' +
                    'The conflicting element is' + (inBody(conflict.element) ? ' ' : ' not ') + 'already in the DOM');
            }
        };
        const register = (component) => {
            const tagId = readOrTag(component);
            if (hasNonNullableKey(components, tagId)) {
                failOnDuplicate(component, tagId);
            }
            // Component is passed through an an extra argument to all events
            const extraArgs = [component];
            events.registerId(extraArgs, tagId, component.events);
            components[tagId] = component;
        };
        const unregister = (component) => {
            read(component.element).each((tagId) => {
                delete components[tagId];
                events.unregisterId(tagId);
            });
        };
        const filter = (type) => events.filterByType(type);
        const find = (isAboveRoot, type, target) => events.find(isAboveRoot, type, target);
        const getById = (id) => get$h(components, id);
        return {
            find,
            filter,
            register,
            unregister,
            getById
        };
    };

    const takeover = (root) => {
        const isAboveRoot = (el) => parent(root.element).fold(always, (parent) => eq(el, parent));
        const registry = Registry();
        const lookup = (eventName, target) => registry.find(isAboveRoot, eventName, target);
        const domEvents = setup$d(root.element, {
            triggerEvent: (eventName, event) => {
                return monitorEvent(eventName, event.target, (logger) => triggerUntilStopped(lookup, eventName, event, logger));
            }
        });
        const systemApi = {
            // This is a real system
            debugInfo: constant$1('real'),
            triggerEvent: (eventName, target, data) => {
                monitorEvent(eventName, target, (logger) => 
                // The return value is not used because this is a fake event.
                triggerOnUntilStopped(lookup, eventName, data, target, logger));
            },
            triggerFocus: (target, originator) => {
                read(target).fold(() => {
                    // When the target is not within the alloy system, dispatch a normal focus event.
                    focus$4(target);
                }, (_alloyId) => {
                    monitorEvent(focus$3(), target, (logger) => {
                        // NOTE: This will stop at first handler.
                        triggerHandler(lookup, focus$3(), {
                            // originator is used by the default events to ensure that focus doesn't
                            // get called infinitely
                            originator,
                            kill: noop,
                            prevent: noop,
                            target
                        }, target, logger);
                        return false;
                    });
                });
            },
            triggerEscape: (comp, simulatedEvent) => {
                systemApi.triggerEvent('keydown', comp.element, simulatedEvent.event);
            },
            getByUid: (uid) => {
                return getByUid(uid);
            },
            getByDom: (elem) => {
                return getByDom(elem);
            },
            build: build$1,
            buildOrPatch: buildOrPatch,
            addToGui: (c) => {
                add(c);
            },
            removeFromGui: (c) => {
                remove(c);
            },
            addToWorld: (c) => {
                addToWorld(c);
            },
            removeFromWorld: (c) => {
                removeFromWorld(c);
            },
            broadcast: (message) => {
                broadcast$1(message);
            },
            broadcastOn: (channels, message) => {
                broadcastOn(channels, message);
            },
            broadcastEvent: (eventName, event) => {
                broadcastEvent(eventName, event);
            },
            isConnected: always
        };
        const addToWorld = (component) => {
            component.connect(systemApi);
            if (!isText(component.element)) {
                registry.register(component);
                each$1(component.components(), addToWorld);
                systemApi.triggerEvent(systemInit(), component.element, { target: component.element });
            }
        };
        const removeFromWorld = (component) => {
            if (!isText(component.element)) {
                each$1(component.components(), removeFromWorld);
                registry.unregister(component);
            }
            component.disconnect();
        };
        const add = (component) => {
            attach(root, component);
        };
        const remove = (component) => {
            detach(component);
        };
        const destroy = () => {
            // INVESTIGATE: something with registry?
            domEvents.unbind();
            remove$7(root.element);
        };
        const broadcastData = (data) => {
            const receivers = registry.filter(receive());
            each$1(receivers, (receiver) => {
                const descHandler = receiver.descHandler;
                const handler = getCurried(descHandler);
                handler(data);
            });
        };
        const broadcast$1 = (message) => {
            broadcastData({
                universal: true,
                data: message
            });
        };
        const broadcastOn = (channels, message) => {
            broadcastData({
                universal: false,
                channels,
                data: message
            });
        };
        // This doesn't follow usual DOM bubbling. It will just dispatch on all
        // targets that have the event. It is the general case of the more specialised
        // "message". "messages" may actually just go away. This is used for things
        // like window scroll.
        const broadcastEvent = (eventName, event) => {
            const listeners = registry.filter(eventName);
            return broadcast(listeners, event);
        };
        const getByUid = (uid) => registry.getById(uid).fold(() => Result.error(new Error('Could not find component with uid: "' + uid + '" in system.')), Result.value);
        const getByDom = (elem) => {
            const uid = read(elem).getOr('not found');
            return getByUid(uid);
        };
        addToWorld(root);
        return {
            root,
            element: root.element,
            destroy,
            add,
            remove,
            getByUid,
            getByDom,
            addToWorld,
            removeFromWorld,
            broadcast: broadcast$1,
            broadcastOn,
            broadcastEvent
        };
    };

    const pointerEvents = () => {
        const onClick = (component, simulatedEvent) => {
            simulatedEvent.stop();
            emitExecute(component);
        };
        return [
            // Trigger execute when clicked
            run$1(click(), onClick),
            run$1(tap(), onClick),
            // Other mouse down listeners above this one should not get mousedown behaviour (like dragging)
            cutter(touchstart()),
            cutter(mousedown())
        ];
    };
    const events = (optAction) => {
        const executeHandler = (action) => runOnExecute$1((component, simulatedEvent) => {
            action(component);
            simulatedEvent.stop();
        });
        return derive$2(flatten([
            // Only listen to execute if it is supplied
            optAction.map(executeHandler).toArray(),
            pointerEvents()
        ]));
    };

    const factory$m = (detail) => {
        const events$1 = events(detail.action);
        const tag = detail.dom.tag;
        const lookupAttr = (attr) => get$h(detail.dom, 'attributes').bind((attrs) => get$h(attrs, attr));
        // Button tags should not have a default role of button, and only buttons should
        // get a type of button.
        const getModAttributes = () => {
            if (tag === 'button') {
                // Default to type button, unless specified otherwise
                const type = lookupAttr('type').getOr('button');
                // Only use a role if it is specified
                const roleAttrs = lookupAttr('role').map((role) => ({ role })).getOr({});
                return {
                    type,
                    ...roleAttrs
                };
            }
            else {
                // We are not a button, so type is irrelevant (unless specified)
                // Default role to button
                const role = detail.role.getOr(lookupAttr('role').getOr('button'));
                return { role };
            }
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: detail.components,
            events: events$1,
            behaviours: SketchBehaviours.augment(detail.buttonBehaviours, [
                Focusing.config({}),
                Keying.config({
                    mode: 'execution',
                    // Note execution will capture keyup when the focus is on the button
                    // on Firefox, because otherwise it will fire a click event and double
                    // up on the action
                    useSpace: true,
                    useEnter: true
                })
            ]),
            domModification: {
                attributes: getModAttributes()
            },
            eventOrder: detail.eventOrder
        };
    };
    const Button = single({
        name: 'Button',
        factory: factory$m,
        configFields: [
            defaulted('uid', undefined),
            required$1('dom'),
            defaulted('components', []),
            SketchBehaviours.field('buttonBehaviours', [Focusing, Keying]),
            option$3('action'),
            option$3('role'),
            defaulted('eventOrder', {})
        ]
    });

    const schema$m = constant$1([
        defaulted('shell', false),
        required$1('makeItem'),
        defaulted('setupItem', noop),
        SketchBehaviours.field('listBehaviours', [Replacing])
    ]);
    const customListDetail = () => ({
        behaviours: derive$1([
            Replacing.config({})
        ])
    });
    const itemsPart = optional({
        name: 'items',
        overrides: customListDetail
    });
    const parts$f = constant$1([
        itemsPart
    ]);
    const name$1 = constant$1('CustomList');

    const factory$l = (detail, components, _spec, _external) => {
        const setItems = (list, items) => {
            getListContainer(list).fold(() => {
                // check that the group container existed. It may not have if the components
                // did not list anything, and shell was false.
                // eslint-disable-next-line no-console
                console.error('Custom List was defined to not be a shell, but no item container was specified in components');
                throw new Error('Custom List was defined to not be a shell, but no item container was specified in components');
            }, (container) => {
                // Get all the children of container, because they will be items.
                // And then use the item setGroup api
                const itemComps = Replacing.contents(container);
                const numListsRequired = items.length;
                const numListsToAdd = numListsRequired - itemComps.length;
                const itemsToAdd = numListsToAdd > 0 ?
                    range$2(numListsToAdd, () => detail.makeItem()) : [];
                const itemsToRemove = itemComps.slice(numListsRequired);
                each$1(itemsToRemove, (item) => Replacing.remove(container, item));
                each$1(itemsToAdd, (item) => Replacing.append(container, item));
                const builtLists = Replacing.contents(container);
                each$1(builtLists, (item, i) => {
                    detail.setupItem(list, item, items[i], i);
                });
            });
        };
        // In shell mode, the group overrides need to be added to the main container, and there can be no children
        const extra = detail.shell ? { behaviours: [Replacing.config({})], components: [] } : { behaviours: [], components };
        const getListContainer = (component) => detail.shell ? Optional.some(component) : getPart(component, detail, 'items');
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: extra.components,
            behaviours: augment(detail.listBehaviours, extra.behaviours),
            apis: {
                setItems
            }
        };
    };
    const CustomList = composite({
        name: name$1(),
        configFields: schema$m(),
        partFields: parts$f(),
        factory: factory$l,
        apis: {
            setItems: (apis, list, items) => {
                apis.setItems(list, items);
            }
        }
    });

    const attribute = 'aria-controls';
    const find$1 = (queryElem) => {
        const dependent = closest$4(queryElem, (elem) => {
            if (!isElement$1(elem)) {
                return false;
            }
            const id = get$g(elem, 'id');
            return id !== undefined && id.indexOf(attribute) > -1;
        });
        return dependent.bind((dep) => {
            const id = get$g(dep, 'id');
            const dos = getRootNode(dep);
            return descendant(dos, `[${attribute}="${id}"]`);
        });
    };
    const manager = () => {
        const ariaId = generate$6(attribute);
        const link = (elem) => {
            set$9(elem, attribute, ariaId);
        };
        const unlink = (elem) => {
            remove$8(elem, attribute);
        };
        return {
            id: ariaId,
            link,
            unlink,
        };
    };

    const isAriaPartOf = (component, queryElem) => find$1(queryElem).exists((owner) => isPartOf(component, owner));
    const isPartOf = (component, queryElem) => closest$2(queryElem, (el) => eq(el, component.element), never) || isAriaPartOf(component, queryElem);

    const hoverEvent = 'alloy.item-hover';
    const focusEvent = 'alloy.item-focus';
    const toggledEvent = 'alloy.item-toggled';
    const onHover = (item) => {
        // Firstly, check that the focus isn't already inside the item. This
        // is to handle situations like widgets where the widget is inside the item
        // and it has the focus, so as you slightly adjust the mouse, you don't
        // want to lose focus on the widget. Note, that because this isn't API based
        // (i.e. we are manually searching for focus), it may not be that flexible.
        if (search(item.element).isNone() || Focusing.isFocused(item)) {
            if (!Focusing.isFocused(item)) {
                Focusing.focus(item);
            }
            emitWith(item, hoverEvent, { item });
        }
    };
    const onFocus$1 = (item) => {
        emitWith(item, focusEvent, { item });
    };
    const onToggled = (item, state) => {
        emitWith(item, toggledEvent, { item, state });
    };
    const hover = constant$1(hoverEvent);
    const focus$1 = constant$1(focusEvent);
    const toggled = constant$1(toggledEvent);

    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
    const getItemRole = (detail) => detail.role.fold(() => detail.toggling
        .map((toggling) => toggling.exclusive ? 'menuitemradio' : 'menuitemcheckbox')
        .getOr('menuitem'), identity);
    const getTogglingSpec = (tConfig, isOption) => ({
        aria: {
            mode: isOption ? 'selected' : 'checked'
        },
        // Filter out the additional properties that are not in Toggling Behaviour's configuration (e.g. exclusive)
        ...filter$1(tConfig, (_value, name) => name !== 'exclusive'),
        onToggled: (component, state) => {
            if (isFunction(tConfig.onToggled)) {
                tConfig.onToggled(component, state);
            }
            onToggled(component, state);
        }
    });
    const builder$2 = (detail) => ({
        dom: detail.dom,
        domModification: {
            // INVESTIGATE: If more efficient, destructure attributes out
            ...detail.domModification,
            attributes: {
                'role': getItemRole(detail),
                ...detail.domModification.attributes,
                'aria-haspopup': detail.hasSubmenu,
                ...(detail.hasSubmenu ? { 'aria-expanded': false } : {})
            }
        },
        behaviours: SketchBehaviours.augment(detail.itemBehaviours, [
            // Investigate, is the Toggling.revoke still necessary here?
            detail.toggling.fold(Toggling.revoke, (tConfig) => Toggling.config(getTogglingSpec(tConfig, detail.role.exists((role) => role === 'option')))),
            Focusing.config({
                ignore: detail.ignoreFocus,
                // Rationale: because nothing is focusable, when you click
                // on the items to choose them, the focus jumps to the first
                // focusable outer container ... often the body. If we prevent
                // mouseDown ... that doesn't happen. But only tested on Chrome/FF.
                stopMousedown: detail.ignoreFocus,
                onFocus: (component) => {
                    onFocus$1(component);
                }
            }),
            Keying.config({
                mode: 'execution'
            }),
            Representing.config({
                store: {
                    mode: 'memory',
                    initialValue: detail.data
                }
            }),
            config('item-type-events', [
                // Treat clicks the same as a button
                ...pointerEvents(),
                run$1(mouseover(), onHover),
                run$1(focusItem(), Focusing.focus)
            ])
        ]),
        components: detail.components,
        eventOrder: detail.eventOrder
    });
    const schema$l = [
        required$1('data'),
        required$1('components'),
        required$1('dom'),
        defaulted('hasSubmenu', false),
        option$3('toggling'),
        option$3('role'),
        // Maybe this needs to have fewer behaviours
        SketchBehaviours.field('itemBehaviours', [Toggling, Focusing, Keying, Representing]),
        defaulted('ignoreFocus', false),
        defaulted('domModification', {}),
        output$1('builder', builder$2),
        defaulted('eventOrder', {})
    ];
    var ItemType = schema$l;

    const builder$1 = (detail) => ({
        dom: detail.dom,
        components: detail.components,
        events: derive$2([
            stopper(focusItem())
        ])
    });
    const schema$k = [
        required$1('dom'),
        required$1('components'),
        output$1('builder', builder$1)
    ];
    var SeparatorType = schema$k;

    const owner$2 = constant$1('item-widget');
    const parts$e = constant$1([
        required({
            name: 'widget',
            overrides: (detail) => {
                return {
                    behaviours: derive$1([
                        Representing.config({
                            store: {
                                mode: 'manual',
                                getValue: (_component) => {
                                    return detail.data;
                                },
                                setValue: noop
                            }
                        })
                    ])
                };
            }
        })
    ]);

    const builder = (detail) => {
        const subs = substitutes(owner$2(), detail, parts$e());
        const components = components$1(owner$2(), detail, subs.internals());
        const focusWidget = (component) => getPart(component, detail, 'widget').map((widget) => {
            Keying.focusIn(widget);
            return widget;
        });
        const onHorizontalArrow = (component, simulatedEvent) => inside(simulatedEvent.event.target) ? Optional.none() : (() => {
            if (detail.autofocus) {
                simulatedEvent.setSource(component.element);
                return Optional.none();
            }
            else {
                return Optional.none();
            }
        })();
        return {
            dom: detail.dom,
            components,
            domModification: detail.domModification,
            events: derive$2([
                runOnExecute$1((component, simulatedEvent) => {
                    focusWidget(component).each((_widget) => {
                        simulatedEvent.stop();
                    });
                }),
                run$1(mouseover(), onHover),
                run$1(focusItem(), (component, _simulatedEvent) => {
                    if (detail.autofocus) {
                        focusWidget(component);
                    }
                    else {
                        Focusing.focus(component);
                    }
                })
            ]),
            behaviours: SketchBehaviours.augment(detail.widgetBehaviours, [
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: detail.data
                    }
                }),
                Focusing.config({
                    ignore: detail.ignoreFocus,
                    // What about stopMousedown from ItemType?
                    onFocus: (component) => {
                        onFocus$1(component);
                    }
                }),
                Keying.config({
                    mode: 'special',
                    // This is required as long as Highlighting tries to focus the first thing (after focusItem fires)
                    focusIn: detail.autofocus ? (component) => {
                        focusWidget(component);
                    } : revoke(),
                    onLeft: onHorizontalArrow,
                    onRight: onHorizontalArrow,
                    onEscape: (component, simulatedEvent) => {
                        // If the outer list item didn't have focus,
                        // then focus it (i.e. escape the inner widget). Only do if not autofocusing
                        // Autofocusing should treat the widget like it is the only item, so it should
                        // let its outer menu handle escape
                        if (!Focusing.isFocused(component) && !detail.autofocus) {
                            Focusing.focus(component);
                            return Optional.some(true);
                        }
                        else if (detail.autofocus) {
                            simulatedEvent.setSource(component.element);
                            return Optional.none();
                        }
                        else {
                            return Optional.none();
                        }
                    }
                })
            ])
        };
    };
    const schema$j = [
        required$1('uid'),
        required$1('data'),
        required$1('components'),
        required$1('dom'),
        defaulted('autofocus', false),
        defaulted('ignoreFocus', false),
        SketchBehaviours.field('widgetBehaviours', [Representing, Focusing, Keying]),
        defaulted('domModification', {}),
        // We don't have the uid at this point
        defaultUidsSchema(parts$e()),
        output$1('builder', builder)
    ];
    var WidgetType = schema$j;

    const itemSchema$2 = choose$1('type', {
        widget: WidgetType,
        item: ItemType,
        separator: SeparatorType
    });
    const configureGrid = (detail, movementInfo) => ({
        mode: 'flatgrid',
        selector: '.' + detail.markers.item,
        initSize: {
            numColumns: movementInfo.initSize.numColumns,
            numRows: movementInfo.initSize.numRows
        },
        focusManager: detail.focusManager
    });
    const configureMatrix = (detail, movementInfo) => ({
        mode: 'matrix',
        selectors: {
            row: movementInfo.rowSelector,
            cell: '.' + detail.markers.item
        },
        previousSelector: movementInfo.previousSelector,
        focusManager: detail.focusManager
    });
    const configureMenu = (detail, movementInfo) => ({
        mode: 'menu',
        selector: '.' + detail.markers.item,
        moveOnTab: movementInfo.moveOnTab,
        focusManager: detail.focusManager
    });
    const parts$d = constant$1([
        group({
            factory: {
                sketch: (spec) => {
                    const itemInfo = asRawOrDie$1('menu.spec item', itemSchema$2, spec);
                    return itemInfo.builder(itemInfo);
                }
            },
            name: 'items',
            unit: 'item',
            defaults: (detail, u) => {
                // Switch this to a common library
                // The WidgetItemSpec is just because it has uid, and the others don't
                // for some reason. So there is nothing guaranteeing that `u` is a WidgetItemSpec,
                // so we should probably rework this code.
                return has$2(u, 'uid') ? u : {
                    ...u,
                    uid: generate$4('item')
                };
            },
            overrides: (detail, u) => {
                return {
                    type: u.type,
                    ignoreFocus: detail.fakeFocus,
                    domModification: {
                        classes: [detail.markers.item]
                    }
                };
            }
        })
    ]);
    const schema$i = constant$1([
        optionString('role'),
        required$1('value'),
        required$1('items'),
        required$1('dom'),
        required$1('components'),
        defaulted('eventOrder', {}),
        field('menuBehaviours', [Highlighting, Representing, Composing, Keying]),
        defaultedOf('movement', {
            // When you don't specify movement for a Menu, this is what you get
            // a "menu" type of movement that moves on tab. If you want finer-grained
            // control, like disabling moveOnTab, then you need to specify
            // your entire movement configuration when creating your MenuSpec.
            mode: 'menu',
            moveOnTab: true
        }, choose$1('mode', {
            grid: [
                initSize(),
                output$1('config', configureGrid)
            ],
            matrix: [
                output$1('config', configureMatrix),
                required$1('rowSelector'),
                defaulted('previousSelector', Optional.none),
            ],
            menu: [
                defaulted('moveOnTab', true),
                output$1('config', configureMenu)
            ]
        })),
        itemMarkers(),
        defaulted('fakeFocus', false),
        defaulted('focusManager', dom$2()),
        onHandler('onHighlight'),
        onHandler('onDehighlight'),
        defaulted('showMenuRole', true),
    ]);

    const focus = constant$1('alloy.menu-focus');

    const deselectOtherRadioItems = (menu, item) => {
        // TODO: TINY-8812 - This ideally should be done in a way such that a menu can have multiple radio groups.
        const checkedRadioItems = descendants(menu.element, '[role="menuitemradio"][aria-checked="true"]');
        each$1(checkedRadioItems, (ele) => {
            if (!eq(ele, item.element)) {
                menu.getSystem().getByDom(ele).each((c) => {
                    Toggling.off(c);
                });
            }
        });
    };
    const make$6 = (detail, components, _spec, _externals) => ({
        uid: detail.uid,
        dom: detail.dom,
        markers: detail.markers,
        behaviours: augment(detail.menuBehaviours, [
            Highlighting.config({
                // Highlighting for a menu is selecting items inside the menu
                highlightClass: detail.markers.selectedItem,
                itemClass: detail.markers.item,
                onHighlight: detail.onHighlight,
                onDehighlight: detail.onDehighlight
            }),
            Representing.config({
                store: {
                    mode: 'memory',
                    initialValue: detail.value
                }
            }),
            Composing.config({
                find: Optional.some
            }),
            Keying.config(detail.movement.config(detail, detail.movement))
        ]),
        events: derive$2([
            // This is dispatched from a menu to tell an item to be highlighted.
            run$1(focus$1(), (menu, simulatedEvent) => {
                // Highlight the item
                const event = simulatedEvent.event;
                menu.getSystem().getByDom(event.target).each((item) => {
                    Highlighting.highlight(menu, item);
                    simulatedEvent.stop();
                    // Trigger the focus event on the menu.
                    emitWith(menu, focus(), { menu, item });
                });
            }),
            // Highlight the item that the cursor is over. The onHighlight
            // code needs to handle updating focus if required
            run$1(hover(), (menu, simulatedEvent) => {
                const item = simulatedEvent.event.item;
                Highlighting.highlight(menu, item);
            }),
            // Enforce only a single radio menu item is toggled by finding any other toggled
            // radio menu items and untoggling them when a certain item is toggled
            run$1(toggled(), (menu, simulatedEvent) => {
                const { item, state } = simulatedEvent.event;
                if (state && get$g(item.element, 'role') === 'menuitemradio') {
                    deselectOtherRadioItems(menu, item);
                }
            })
        ]),
        components,
        eventOrder: detail.eventOrder,
        ...detail.showMenuRole ? {
            domModification: {
                attributes: {
                    role: detail.role.getOr('menu')
                }
            }
        } : {}
    });

    const Menu = composite({
        name: 'Menu',
        configFields: schema$i(),
        partFields: parts$d(),
        factory: make$6
    });

    const transpose$1 = (obj) => 
    // Assumes no duplicate fields.
    tupleMap(obj, (v, k) => ({ k: v, v: k }));
    const trace = (items, byItem, byMenu, finish) => 
    // Given a finishing submenu (which will be the value of expansions),
    // find the triggering item, find its menu, and repeat the process. If there
    // is no triggering item, we are done.
    get$h(byMenu, finish).bind((triggerItem) => get$h(items, triggerItem).bind((triggerMenu) => {
        const rest = trace(items, byItem, byMenu, triggerMenu);
        return Optional.some([triggerMenu].concat(rest));
    })).getOr([]);
    const generate$2 = (menus, expansions) => {
        const items = {};
        each(menus, (menuItems, menu) => {
            each$1(menuItems, (item) => {
                items[item] = menu;
            });
        });
        const byItem = expansions;
        const byMenu = transpose$1(expansions);
        // For each menu, calculate the backlog of submenus to get to it.
        const menuPaths = map$1(byMenu, (_triggerItem, submenu) => [submenu].concat(trace(items, byItem, byMenu, submenu)));
        return map$1(items, (menu) => get$h(menuPaths, menu).getOr([menu]));
    };

    const init$2 = () => {
        const expansions = Cell({});
        const menus = Cell({});
        const paths = Cell({});
        const primary = value$2();
        // Probably think of a better way to store this information.
        const directory = Cell({});
        const clear = () => {
            expansions.set({});
            menus.set({});
            paths.set({});
            primary.clear();
        };
        const isClear = () => primary.get().isNone();
        const setMenuBuilt = (menuName, built) => {
            menus.set({
                ...menus.get(),
                [menuName]: {
                    type: 'prepared',
                    menu: built
                }
            });
        };
        const setContents = (sPrimary, sMenus, sExpansions, dir) => {
            primary.set(sPrimary);
            expansions.set(sExpansions);
            menus.set(sMenus);
            directory.set(dir);
            const sPaths = generate$2(dir, sExpansions);
            paths.set(sPaths);
        };
        const getTriggeringItem = (menuValue) => find$4(expansions.get(), (v, _k) => v === menuValue);
        const getTriggerData = (menuValue, getItemByValue, path) => getPreparedMenu(menuValue).bind((menu) => getTriggeringItem(menuValue).bind((triggeringItemValue) => getItemByValue(triggeringItemValue).map((triggeredItem) => ({
            triggeredMenu: menu,
            triggeringItem: triggeredItem,
            triggeringPath: path
        }))));
        const getTriggeringPath = (itemValue, getItemByValue) => {
            // Get the path up to the last item
            const extraPath = filter$2(lookupItem(itemValue).toArray(), (menuValue) => getPreparedMenu(menuValue).isSome());
            return get$h(paths.get(), itemValue).bind((path) => {
                // remember the path is [ most-recent-menu, next-most-recent-menu ]
                // convert each menu identifier into { triggeringItem: comp, menu: comp }
                // could combine into a fold ... probably a left to reverse ... but we'll take the
                // straightforward version when prototyping
                const revPath = reverse(extraPath.concat(path));
                const triggers = bind$3(revPath, (menuValue, menuIndex) => 
                // finding menuValue, it should match the trigger
                getTriggerData(menuValue, getItemByValue, revPath.slice(0, menuIndex + 1)).fold(() => is$1(primary.get(), menuValue) ? [] : [Optional.none()], (data) => [Optional.some(data)]));
                // Convert List<Optional<X>> to Optional<List<X>> if ALL are Some
                return sequence(triggers);
            });
        };
        // Given an item, return a list of all menus including the one that it triggered (if there is one)
        const expand = (itemValue) => get$h(expansions.get(), itemValue).map((menu) => {
            const current = get$h(paths.get(), itemValue).getOr([]);
            return [menu].concat(current);
        });
        const collapse = (itemValue) => 
        // Look up which key has the itemValue
        get$h(paths.get(), itemValue).bind((path) => path.length > 1 ? Optional.some(path.slice(1)) : Optional.none());
        const refresh = (itemValue) => get$h(paths.get(), itemValue);
        const getPreparedMenu = (menuValue) => lookupMenu(menuValue).bind(extractPreparedMenu);
        const lookupMenu = (menuValue) => get$h(menus.get(), menuValue);
        const lookupItem = (itemValue) => get$h(expansions.get(), itemValue);
        const otherMenus = (path) => {
            const menuValues = directory.get();
            return difference(keys(menuValues), path);
        };
        const getPrimary = () => primary.get().bind(getPreparedMenu);
        const getMenus = () => menus.get();
        return {
            setMenuBuilt,
            setContents,
            expand,
            refresh,
            collapse,
            lookupMenu,
            lookupItem,
            otherMenus,
            getPrimary,
            getMenus,
            clear,
            isClear,
            getTriggeringPath
        };
    };
    const extractPreparedMenu = (prep) => prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none();
    const LayeredState = {
        init: init$2,
        extractPreparedMenu
    };

    const onMenuItemHighlightedEvent = generate$6('tiered-menu-item-highlight');
    const onMenuItemDehighlightedEvent = generate$6('tiered-menu-item-dehighlight');

    const make$5 = (detail, _rawUiSpec) => {
        const submenuParentItems = value$2();
        // So the way to provide extra configuration for the menus that tiered menus create is just
        // to provide different menu specs when building up the TieredData. The TieredMenu itself
        // does not control it, except to set: markers, fakeFocus, onHighlight, and focusManager
        const buildMenus = (container, primaryName, menus) => map$1(menus, (spec, name) => {
            const makeSketch = () => Menu.sketch({
                ...spec,
                value: name,
                // The TieredMenu markers should be inherited by the Menu. "Markers" are things like
                // what is the class for the currently selected item
                markers: detail.markers,
                // If the TieredMenu has been configured with FakeFocus, it needs the menus that it generates
                // to preserve that configuration. Generally, FakeFocus is used for situations where the user
                // wants to keep focus inside some editable element (like an input, or editor content)
                fakeFocus: detail.fakeFocus,
                // The TieredMenu detail.onHighlight function only relates to selecting an item,
                // not a menu, and the menuComp it is passed is the menu, not the tiered menu.
                // This makes it a difficult handler to use for a tieredmenu, so we are
                // deprecating it.
                onHighlight: (menuComp, itemComp) => {
                    // Trigger an internal event so that we can listen to it at the tieredmenu
                    // level, and call detail.onHighlightItem handler with tmenu, menu, and item.
                    const highlightData = {
                        menuComp,
                        itemComp
                    };
                    emitWith(menuComp, onMenuItemHighlightedEvent, highlightData);
                },
                onDehighlight: (menuComp, itemComp) => {
                    const dehighlightData = {
                        menuComp,
                        itemComp
                    };
                    // Trigger an internal event so that we can listen to it at the tieredmenu
                    // level, and call detail.onDehighlightItem handler with tmenu, menu, and item.
                    emitWith(menuComp, onMenuItemDehighlightedEvent, dehighlightData);
                },
                // The Menu itself doesn't set the focusManager based on the value of fakeFocus. It only uses
                // its fakeFocus configuration for creating items that ignore focus, but it still needs to be
                // told which focusManager to use. Perhaps we should change this, though it does allow for more
                // complex focusManagers in single menus.
                focusManager: detail.fakeFocus ? highlights() : dom$2()
            });
            // Only build the primary at first. Build the others as needed.
            return name === primaryName ? {
                type: 'prepared',
                menu: container.getSystem().build(makeSketch())
            } : {
                type: 'notbuilt',
                nbMenu: makeSketch
            };
        });
        const layeredState = LayeredState.init();
        const setup = (container) => {
            const componentMap = buildMenus(container, detail.data.primary, detail.data.menus);
            const directory = toDirectory();
            layeredState.setContents(detail.data.primary, componentMap, detail.data.expansions, directory);
            return layeredState.getPrimary();
        };
        const getItemValue = (item) => Representing.getValue(item).value;
        // Find the first item with value `itemValue` in any of the menus inside this tiered menu structure
        const getItemByValue = (_container, menus, itemValue) => 
        // Can *greatly* improve the performance of this by calculating things up front.
        findMap(menus, (menu) => {
            if (!menu.getSystem().isConnected()) {
                return Optional.none();
            }
            const candidates = Highlighting.getCandidates(menu);
            return find$5(candidates, (c) => getItemValue(c) === itemValue);
        });
        const toDirectory = (_container) => map$1(detail.data.menus, (data, _menuName) => bind$3(data.items, (item) => item.type === 'separator' ? [] : [item.data.value]));
        // This just sets the active menu. It will not set any active items.
        const setActiveMenu = Highlighting.highlight;
        // The item highlighted as active is either the currently active item in the menu,
        // or the first one.
        const setActiveMenuAndItem = (container, menu) => {
            // Firstly, choose the active menu
            setActiveMenu(container, menu);
            // Then, choose the active item inside the active menu
            Highlighting.getHighlighted(menu).orThunk(() => Highlighting.getFirst(menu)).each((item) => {
                if (detail.fakeFocus) {
                    // When using fakeFocus, the items won't have a tab-index, so calling focusItem on them
                    // won't do anything. So we need to manually call highlighting, which is what fakeFocus
                    // uses. It would probably be better to use the focusManager specified.
                    Highlighting.highlight(menu, item);
                }
                else {
                    // We don't just use Focusing.focus here, because some items can have slightly different
                    // handling when they respond to a focusItem event. Widgets with autofocus, for example,
                    // will trigger a Keying.focusIn instead of Focusing.focus call, because they want to move
                    // the focus _inside_ the widget, not just to its outer level. The focusItem event
                    // performs a similar purpose to SystemEvents.focus() and potentially, could be consolidated.
                    dispatch(container, item.element, focusItem());
                }
            });
        };
        const getMenus = (state, menuValues) => cat(map$2(menuValues, (mv) => state.lookupMenu(mv).bind((prep) => prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none())));
        const closeOthers = (container, state, path) => {
            const others = getMenus(state, state.otherMenus(path));
            each$1(others, (o) => {
                // May not need to do the active menu thing.
                remove$2(o.element, [detail.markers.backgroundMenu]);
                if (!detail.stayInDom) {
                    Replacing.remove(container, o);
                }
            });
        };
        const getSubmenuParents = (container) => submenuParentItems.get().getOrThunk(() => {
            const r = {};
            const items = descendants(container.element, `.${detail.markers.item}`);
            const parentItems = filter$2(items, (i) => get$g(i, 'aria-haspopup') === 'true');
            each$1(parentItems, (i) => {
                container.getSystem().getByDom(i).each((itemComp) => {
                    const key = getItemValue(itemComp);
                    r[key] = itemComp;
                });
            });
            submenuParentItems.set(r);
            return r;
        });
        // Not ideal. Ideally, we would like a map of item keys to components.
        const updateAriaExpansions = (container, path) => {
            const parentItems = getSubmenuParents(container);
            each(parentItems, (v, k) => {
                // Really should turn path into a Set
                const expanded = contains$2(path, k);
                set$9(v.element, 'aria-expanded', expanded);
            });
        };
        const updateMenuPath = (container, state, path) => Optional.from(path[0]).bind((latestMenuName) => state.lookupMenu(latestMenuName).bind((menuPrep) => {
            if (menuPrep.type === 'notbuilt') {
                return Optional.none();
            }
            else {
                const activeMenu = menuPrep.menu;
                const rest = getMenus(state, path.slice(1));
                each$1(rest, (r) => {
                    add$2(r.element, detail.markers.backgroundMenu);
                });
                if (!inBody(activeMenu.element)) {
                    Replacing.append(container, premade(activeMenu));
                }
                // Remove the background-menu class from the active menu
                remove$2(activeMenu.element, [detail.markers.backgroundMenu]);
                setActiveMenuAndItem(container, activeMenu);
                closeOthers(container, state, path);
                return Optional.some(activeMenu);
            }
        }));
        let ExpandHighlightDecision;
        (function (ExpandHighlightDecision) {
            ExpandHighlightDecision[ExpandHighlightDecision["HighlightSubmenu"] = 0] = "HighlightSubmenu";
            ExpandHighlightDecision[ExpandHighlightDecision["HighlightParent"] = 1] = "HighlightParent";
        })(ExpandHighlightDecision || (ExpandHighlightDecision = {}));
        const buildIfRequired = (container, menuName, menuPrep) => {
            if (menuPrep.type === 'notbuilt') {
                const menu = container.getSystem().build(menuPrep.nbMenu());
                layeredState.setMenuBuilt(menuName, menu);
                return menu;
            }
            else {
                return menuPrep.menu;
            }
        };
        const expandRight = (container, item, decision = ExpandHighlightDecision.HighlightSubmenu) => {
            if (item.hasConfigured(Disabling) && Disabling.isDisabled(item)) {
                return Optional.some(item);
            }
            else {
                const value = getItemValue(item);
                return layeredState.expand(value).bind((path) => {
                    // Called when submenus are opened by keyboard AND hovering navigation
                    updateAriaExpansions(container, path);
                    // When expanding, always select the first.
                    return Optional.from(path[0]).bind((menuName) => layeredState.lookupMenu(menuName).bind((activeMenuPrep) => {
                        const activeMenu = buildIfRequired(container, menuName, activeMenuPrep);
                        // DUPE with above. Fix later.
                        if (!inBody(activeMenu.element)) {
                            Replacing.append(container, premade(activeMenu));
                        }
                        // updateMenuPath is the code which changes the active menu. We don't always
                        // want to change the active menu. Sometimes, we just want to show it (e.g. hover)
                        detail.onOpenSubmenu(container, item, activeMenu, reverse(path));
                        if (decision === ExpandHighlightDecision.HighlightSubmenu) {
                            Highlighting.highlightFirst(activeMenu);
                            return updateMenuPath(container, layeredState, path);
                        }
                        else {
                            Highlighting.dehighlightAll(activeMenu);
                            return Optional.some(item);
                        }
                    }));
                });
            }
        };
        const collapseLeft = (container, item) => {
            const value = getItemValue(item);
            return layeredState.collapse(value).bind((path) => {
                // Called when submenus are closed because of KEYBOARD navigation
                updateAriaExpansions(container, path);
                return updateMenuPath(container, layeredState, path).map((activeMenu) => {
                    detail.onCollapseMenu(container, item, activeMenu);
                    return activeMenu;
                });
            });
        };
        const updateView = (container, item) => {
            const value = getItemValue(item);
            return layeredState.refresh(value).bind((path) => {
                // Only this function collapses irrelevant submenus when navigating by HOVERING.
                // Does mean this is called twice when navigating by hovering, since both
                // updateView and expandRight are called by the ItemEvents.hover() handler
                updateAriaExpansions(container, path);
                return updateMenuPath(container, layeredState, path);
            });
        };
        const onRight = (container, item) => inside(item.element) ? Optional.none() : expandRight(container, item, ExpandHighlightDecision.HighlightSubmenu);
        const onLeft = (container, item) => 
        // Exclude inputs, textareas etc.
        inside(item.element) ? Optional.none() : collapseLeft(container, item);
        const onEscape = (container, item) => collapseLeft(container, item).orThunk(() => detail.onEscape(container, item).map(() => container) // This should only fire when the user presses ESC ... not any other close.
        );
        const keyOnItem = (f) => (container, simulatedEvent) => {
            // 2022-08-16 This seems to be the only code in alloy that actually uses
            // the getSource aspect of an event. Remember, that this code is firing
            // when an event bubbles up the tiered menu, e.g. left arrow key.
            // The only current code that sets the source manually is in the Widget item
            // type, and it only sets the source when it is using autofocus. Autofocus
            // is used to essentially treat the widget like it is the top-level item, so
            // when events originate from *within* the widget, their source is changed to
            // the top-level item. Consider removing EventSource from alloy altogether.
            return closest$3(simulatedEvent.getSource(), `.${detail.markers.item}`)
                .bind((target) => container.getSystem().getByDom(target).toOptional().bind((item) => f(container, item).map(always)));
        };
        // NOTE: Many of these events rely on identifying the current item by information
        // sent with the event. However, in situations where you are using fakeFocus, but
        // the real focus is still somewhere in the menu (e.g. search bar), this will lead to
        // an incorrect identification of the active item. Ideally, instead of pulling the
        // item from the event, we should just use Highlighting to identify the active item,
        // and operate on it. However, not all events will necessarily have to happen on the
        // active item, so we need to consider all the cases before making this change. For now,
        // there will be a known limitation that if the real focus is still inside the TieredMenu,
        // but the menu is using fakeFocus, then the actions will operate on the wrong targets.
        // A workaround for that is to stop or cut or redispatch the events in whichever
        // component has the real focus.
        // TODO: TINY-9011 Introduce proper handling of fakeFocus in TieredMenu
        const events = derive$2([
            // Set "active-menu" for the menu with focus
            run$1(focus(), (tmenu, simulatedEvent) => {
                // Ensure the item is actually part of this menu structure, and not part of another menu structure that's bubbling.
                const item = simulatedEvent.event.item;
                layeredState.lookupItem(getItemValue(item)).each(() => {
                    const menu = simulatedEvent.event.menu;
                    Highlighting.highlight(tmenu, menu);
                    const value = getItemValue(simulatedEvent.event.item);
                    layeredState.refresh(value).each((path) => closeOthers(tmenu, layeredState, path));
                });
            }),
            runOnExecute$1((component, simulatedEvent) => {
                // Trigger on execute on the targeted element
                // I.e. clicking on menu item
                const target = simulatedEvent.event.target;
                component.getSystem().getByDom(target).each((item) => {
                    const itemValue = getItemValue(item);
                    // INVESTIGATE: I don't know if this is doing anything any more. Check.
                    if (itemValue.indexOf('collapse-item') === 0) {
                        collapseLeft(component, item);
                    }
                    expandRight(component, item, ExpandHighlightDecision.HighlightSubmenu).fold(() => {
                        detail.onExecute(component, item);
                    }, noop);
                });
            }),
            // Open the menu as soon as it is added to the DOM
            runOnAttached((container, _simulatedEvent) => {
                setup(container).each((primary) => {
                    Replacing.append(container, premade(primary));
                    detail.onOpenMenu(container, primary);
                    if (detail.highlightOnOpen === HighlightOnOpen.HighlightMenuAndItem) {
                        setActiveMenuAndItem(container, primary);
                    }
                    else if (detail.highlightOnOpen === HighlightOnOpen.HighlightJustMenu) {
                        setActiveMenu(container, primary);
                    }
                });
            }),
            // Listen to the events bubbling up from menu about highlighting, and trigger
            // our handlers with tmenu, menu and item
            run$1(onMenuItemHighlightedEvent, (tmenuComp, se) => {
                detail.onHighlightItem(tmenuComp, se.event.menuComp, se.event.itemComp);
            }),
            run$1(onMenuItemDehighlightedEvent, (tmenuComp, se) => {
                detail.onDehighlightItem(tmenuComp, se.event.menuComp, se.event.itemComp);
            }),
            ...(detail.navigateOnHover ? [
                // Hide any irrelevant submenus and expand any submenus based
                // on hovered item
                run$1(hover(), (tmenu, simulatedEvent) => {
                    const item = simulatedEvent.event.item;
                    updateView(tmenu, item);
                    expandRight(tmenu, item, ExpandHighlightDecision.HighlightParent);
                    detail.onHover(tmenu, item);
                })
            ] : [])
        ]);
        const getActiveItem = (container) => Highlighting.getHighlighted(container).bind(Highlighting.getHighlighted);
        const collapseMenuApi = (container) => {
            getActiveItem(container).each((currentItem) => {
                collapseLeft(container, currentItem);
            });
        };
        const highlightPrimary = (container) => {
            layeredState.getPrimary().each((primary) => {
                setActiveMenuAndItem(container, primary);
            });
        };
        const extractMenuFromContainer = (container) => Optional.from(container.components()[0]).filter((comp) => get$g(comp.element, 'role') === 'menu');
        const repositionMenus = (container) => {
            // Get the primary menu
            const maybeActivePrimary = layeredState.getPrimary().bind((primary) => 
            // Get the triggering path (item, menu) up to the active item
            getActiveItem(container).bind((currentItem) => {
                const itemValue = getItemValue(currentItem);
                const allMenus = values(layeredState.getMenus());
                const preparedMenus = cat(map$2(allMenus, LayeredState.extractPreparedMenu));
                return layeredState.getTriggeringPath(itemValue, (v) => getItemByValue(container, preparedMenus, v));
            }).map((triggeringPath) => ({ primary, triggeringPath })));
            maybeActivePrimary.fold(() => {
                // When a menu is open but there is no activeItem, we get the menu from the container.
                extractMenuFromContainer(container).each((primaryMenu) => {
                    detail.onRepositionMenu(container, primaryMenu, []);
                });
            }, ({ primary, triggeringPath }) => {
                // Refresh all the menus up to the active item
                detail.onRepositionMenu(container, primary, triggeringPath);
            });
        };
        const apis = {
            collapseMenu: collapseMenuApi,
            highlightPrimary,
            repositionMenus
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            markers: detail.markers,
            behaviours: augment(detail.tmenuBehaviours, [
                Keying.config({
                    mode: 'special',
                    onRight: keyOnItem(onRight),
                    onLeft: keyOnItem(onLeft),
                    onEscape: keyOnItem(onEscape),
                    focusIn: (container, _keyInfo) => {
                        layeredState.getPrimary().each((primary) => {
                            dispatch(container, primary.element, focusItem());
                        });
                    }
                }),
                // Highlighting is used for highlighting the active menu
                Highlighting.config({
                    highlightClass: detail.markers.selectedMenu,
                    itemClass: detail.markers.menu
                }),
                Composing.config({
                    find: (container) => {
                        return Highlighting.getHighlighted(container);
                    }
                }),
                Replacing.config({})
            ]),
            eventOrder: detail.eventOrder,
            apis,
            events
        };
    };
    const collapseItem$1 = constant$1('collapse-item');

    const tieredData = (primary, menus, expansions) => ({
        primary,
        menus,
        expansions
    });
    const singleData = (name, menu) => ({
        primary: name,
        menus: wrap(name, menu),
        expansions: {}
    });
    const collapseItem = (text) => ({
        value: generate$6(collapseItem$1()),
        meta: {
            text
        }
    });
    const tieredMenu = single({
        name: 'TieredMenu',
        configFields: [
            onStrictKeyboardHandler('onExecute'),
            onStrictKeyboardHandler('onEscape'),
            onStrictHandler('onOpenMenu'),
            onStrictHandler('onOpenSubmenu'),
            onHandler('onRepositionMenu'),
            onHandler('onCollapseMenu'),
            // Ideally, we should validate that this is a valid value, but
            // this is an number-based enum, so it would just be a number.
            defaulted('highlightOnOpen', HighlightOnOpen.HighlightMenuAndItem),
            requiredObjOf('data', [
                required$1('primary'),
                required$1('menus'),
                required$1('expansions')
            ]),
            defaulted('fakeFocus', false),
            onHandler('onHighlightItem'),
            onHandler('onDehighlightItem'),
            onHandler('onHover'),
            tieredMenuMarkers(),
            required$1('dom'),
            defaulted('navigateOnHover', true),
            defaulted('stayInDom', false),
            field('tmenuBehaviours', [Keying, Highlighting, Composing, Replacing]),
            defaulted('eventOrder', {})
        ],
        apis: {
            collapseMenu: (apis, tmenu) => {
                apis.collapseMenu(tmenu);
            },
            // This will highlight the primary menu AND an item in the primary menu
            // Do not use just to set the active menu.
            highlightPrimary: (apis, tmenu) => {
                apis.highlightPrimary(tmenu);
            },
            repositionMenus: (apis, tmenu) => {
                apis.repositionMenus(tmenu);
            }
        },
        factory: make$5,
        extraApis: {
            tieredData,
            singleData,
            collapseItem
        }
    });

    const suffix = constant$1('sink');
    const partType = constant$1(optional({
        name: suffix(),
        overrides: constant$1({
            dom: {
                tag: 'div'
            },
            behaviours: derive$1([
                Positioning.config({
                    // TODO: Make an internal sink also be able to be used with relative layouts
                    useFixed: always
                })
            ]),
            events: derive$2([
                // Sinks should not let keydown or click propagate
                cutter(keydown()),
                cutter(mousedown()),
                cutter(click())
            ])
        })
    }));

    const schema$h = objOfOnly([
        defaulted('isExtraPart', never),
        optionObjOf('fireEventInstead', [
            defaulted('event', dismissRequested())
        ])
    ]);
    const receivingChannel$1 = (rawSpec) => {
        const detail = asRawOrDie$1('Dismissal', schema$h, rawSpec);
        return {
            [dismissPopups()]: {
                schema: objOfOnly([
                    required$1('target')
                ]),
                onReceive: (sandbox, data) => {
                    if (Sandboxing.isOpen(sandbox)) {
                        const isPart = Sandboxing.isPartOf(sandbox, data.target) || detail.isExtraPart(sandbox, data.target);
                        if (!isPart) {
                            detail.fireEventInstead.fold(() => Sandboxing.close(sandbox), (fe) => emit(sandbox, fe.event));
                        }
                    }
                }
            }
        };
    };

    const schema$g = objOfOnly([
        optionObjOf('fireEventInstead', [
            defaulted('event', repositionRequested())
        ]),
        requiredFunction('doReposition')
    ]);
    const receivingChannel = (rawSpec) => {
        const detail = asRawOrDie$1('Reposition', schema$g, rawSpec);
        return {
            [repositionPopups()]: {
                onReceive: (sandbox) => {
                    if (Sandboxing.isOpen(sandbox)) {
                        detail.fireEventInstead.fold(() => detail.doReposition(sandbox), (fe) => emit(sandbox, fe.event));
                    }
                }
            }
        };
    };

    const getAnchor = (detail, component) => {
        const hotspot = detail.getHotspot(component).getOr(component);
        const type = 'hotspot';
        const overrides = detail.getAnchorOverrides();
        return detail.layouts.fold(() => ({ type, hotspot, overrides }), (layouts) => ({ type, hotspot, overrides, layouts }));
    };
    const fetch$1 = (detail, mapFetch, component) => {
        const fetcher = detail.fetch;
        return fetcher(component).map(mapFetch);
    };
    const openF = (detail, mapFetch, anchor, component, sandbox, externals, highlightOnOpen) => {
        const futureData = fetch$1(detail, mapFetch, component);
        const getLazySink = getSink(component, detail);
        // TODO: Make this potentially a single menu also
        return futureData.map((tdata) => tdata.bind((data) => {
            const primaryMenu = data.menus[data.primary];
            Optional.from(primaryMenu).each((menu) => {
                detail.listRole.each((listRole) => {
                    menu.role = listRole;
                });
            });
            return Optional.from(tieredMenu.sketch({
                // Externals are configured by the "menu" part. It's called external because it isn't contained
                // within the DOM descendants of the dropdown. You can configure things like `fakeFocus` here.
                ...externals.menu(),
                uid: generate$4(''),
                data,
                highlightOnOpen,
                onOpenMenu: (tmenu, menu) => {
                    const sink = getLazySink().getOrDie();
                    Positioning.position(sink, menu, { anchor });
                    Sandboxing.decloak(sandbox);
                },
                onOpenSubmenu: (tmenu, item, submenu) => {
                    const sink = getLazySink().getOrDie();
                    Positioning.position(sink, submenu, {
                        anchor: {
                            type: 'submenu',
                            item
                        }
                    });
                    Sandboxing.decloak(sandbox);
                },
                onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {
                    const sink = getLazySink().getOrDie();
                    Positioning.position(sink, primaryMenu, { anchor });
                    each$1(submenuTriggers, (st) => {
                        Positioning.position(sink, st.triggeredMenu, {
                            anchor: { type: 'submenu', item: st.triggeringItem }
                        });
                    });
                },
                onEscape: () => {
                    // Focus the triggering component after escaping the menu
                    Focusing.focus(component);
                    Sandboxing.close(sandbox);
                    return Optional.some(true);
                }
            }));
        }));
    };
    // onOpenSync is because some operations need to be applied immediately, not wrapped in a future
    // It can avoid things like flickering due to asynchronous bouncing
    const open = (detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen) => {
        const anchor = getAnchor(detail, hotspot);
        const processed = openF(detail, mapFetch, anchor, hotspot, sandbox, externals, highlightOnOpen);
        return processed.map((tdata) => {
            // If we have data, display a menu. Else, close the menu if it was open
            tdata.fold(() => {
                if (Sandboxing.isOpen(sandbox)) {
                    Sandboxing.close(sandbox);
                }
            }, (data) => {
                Sandboxing.cloak(sandbox);
                Sandboxing.open(sandbox, data);
                onOpenSync(sandbox);
            });
            return sandbox;
        });
    };
    const close = (detail, mapFetch, component, sandbox, _externals, _onOpenSync, _highlightOnOpen) => {
        Sandboxing.close(sandbox);
        return Future.pure(sandbox);
    };
    const togglePopup = (detail, mapFetch, hotspot, externals, onOpenSync, highlightOnOpen) => {
        const sandbox = Coupling.getCoupled(hotspot, 'sandbox');
        const showing = Sandboxing.isOpen(sandbox);
        const action = showing ? close : open;
        return action(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);
    };
    const matchWidth = (hotspot, container, useMinWidth) => {
        const menu = Composing.getCurrent(container).getOr(container);
        const buttonWidth = get$c(hotspot.element);
        if (useMinWidth) {
            set$7(menu.element, 'min-width', buttonWidth + 'px');
        }
        else {
            set$6(menu.element, buttonWidth);
        }
    };
    const getSink = (anyInSystem, sinkDetail) => anyInSystem
        .getSystem()
        .getByUid(sinkDetail.uid + '-' + suffix())
        .map((internalSink) => () => Result.value(internalSink))
        .getOrThunk(() => sinkDetail.lazySink.fold(() => () => Result.error(new Error('No internal sink is specified, nor could an external sink be found')), (lazySinkFn) => () => lazySinkFn(anyInSystem)));
    const doRepositionMenus = (sandbox) => {
        Sandboxing.getState(sandbox).each((tmenu) => {
            tieredMenu.repositionMenus(tmenu);
        });
    };
    const makeSandbox$1 = (detail, hotspot, extras) => {
        const ariaControls = manager();
        const onOpen = (component, menu) => {
            const anchor = getAnchor(detail, hotspot);
            ariaControls.link(hotspot.element);
            if (detail.matchWidth) {
                matchWidth(anchor.hotspot, menu, detail.useMinWidth);
            }
            detail.onOpen(anchor, component, menu);
            if (extras !== undefined && extras.onOpen !== undefined) {
                extras.onOpen(component, menu);
            }
        };
        const onClose = (component, menu) => {
            ariaControls.unlink(hotspot.element);
            lazySink().getOr(menu).element.dom.dispatchEvent(new window.FocusEvent('focusout'));
            if (extras !== undefined && extras.onClose !== undefined) {
                extras.onClose(component, menu);
            }
        };
        const lazySink = getSink(hotspot, detail);
        return {
            dom: {
                tag: 'div',
                classes: detail.sandboxClasses,
                // TODO: Add aria-selected attribute
                attributes: {
                    id: ariaControls.id,
                }
            },
            behaviours: SketchBehaviours.augment(detail.sandboxBehaviours, [
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: hotspot
                    }
                }),
                Sandboxing.config({
                    onOpen,
                    onClose,
                    isPartOf: (container, data, queryElem) => {
                        return isPartOf(data, queryElem) || isPartOf(hotspot, queryElem);
                    },
                    getAttachPoint: () => {
                        return lazySink().getOrDie();
                    }
                }),
                // The Composing of the dropdown here is the the active menu of the TieredMenu
                // inside the sandbox.
                Composing.config({
                    find: (sandbox) => {
                        return Sandboxing.getState(sandbox).bind((menu) => Composing.getCurrent(menu));
                    }
                }),
                Receiving.config({
                    channels: {
                        ...receivingChannel$1({
                            isExtraPart: never
                        }),
                        ...receivingChannel({
                            doReposition: doRepositionMenus
                        })
                    }
                })
            ])
        };
    };
    const repositionMenus = (comp) => {
        const sandbox = Coupling.getCoupled(comp, 'sandbox');
        doRepositionMenus(sandbox);
    };

    // TODO: Roll this back into Fields at some point
    // Unfortunately there appears to be a cyclical dependency or something that's preventing it, but for now this will do as it's home
    const sandboxFields = () => [
        defaulted('sandboxClasses', []),
        SketchBehaviours.field('sandboxBehaviours', [Composing, Receiving, Sandboxing, Representing])
    ];

    const schema$f = constant$1([
        required$1('dom'),
        required$1('fetch'),
        onHandler('onOpen'),
        onKeyboardHandler('onExecute'),
        defaulted('getHotspot', Optional.some),
        defaulted('getAnchorOverrides', constant$1({})),
        schema$n(),
        field('dropdownBehaviours', [Toggling, Coupling, Keying, Focusing]),
        required$1('toggleClass'),
        defaulted('eventOrder', {}),
        option$3('lazySink'),
        defaulted('matchWidth', false),
        defaulted('useMinWidth', false),
        option$3('role'),
        option$3('listRole'),
    ].concat(sandboxFields()));
    const parts$c = constant$1([
        external$1({
            schema: [
                tieredMenuMarkers(),
                // Defining a defaulted field isn't necessary when dealing with
                // external parts, because the post-boulder part spec is not passed
                // through to any of these functions (defaults, overrides etc.). So all
                // this does is make it a bit clearer what you should expect, but remember
                // that the default value here is irrelevant!
                defaulted('fakeFocus', false)
            ],
            name: 'menu',
            defaults: (detail) => {
                return {
                    onExecute: detail.onExecute
                };
            }
        }),
        partType()
    ]);

    const factory$k = (detail, components, _spec, externals) => {
        const lookupAttr = (attr) => get$h(detail.dom, 'attributes').bind((attrs) => get$h(attrs, attr));
        const switchToMenu = (sandbox) => {
            Sandboxing.getState(sandbox).each((tmenu) => {
                // This will highlight the menu AND the item
                tieredMenu.highlightPrimary(tmenu);
            });
        };
        const togglePopup$1 = (dropdownComp, onOpenSync, highlightOnOpen) => {
            return togglePopup(detail, identity, dropdownComp, externals, onOpenSync, highlightOnOpen);
        };
        const action = (component) => {
            const onOpenSync = switchToMenu;
            togglePopup$1(component, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);
        };
        const apis = {
            expand: (comp) => {
                if (!Toggling.isOn(comp)) {
                    togglePopup$1(comp, noop, HighlightOnOpen.HighlightNone).get(noop);
                }
            },
            open: (comp) => {
                if (!Toggling.isOn(comp)) {
                    togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).get(noop);
                }
            },
            refetch: (comp) => {
                // Generally, the triggers for a refetch should make it so that the
                // sandbox has been created, but it's not guaranteed, so we still handle the
                // case where there isn't yet a sandbox.
                const optSandbox = Coupling.getExistingCoupled(comp, 'sandbox');
                return optSandbox.fold(() => {
                    // If we don't have a sandbox, refetch is the same as open,
                    // except we return when it is completed.
                    return togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem)
                        .map(noop);
                }, (sandboxComp) => {
                    // We are intentionally not preserving the selected items when
                    // triggering a refetch, and will just highlight the first item.
                    // Note: this will mean that submenus will close. If we want to start
                    // preserving the selected items, we can't rely on the components themselves,
                    // so we'd need to use the item and menu values through Representing.
                    // However, be aware that alloy menus and items often have randomised values,
                    // so these might not be reliable either.
                    // NOTE: We use DropdownUtils.open directly, because we want it to 'open',
                    // even if it's already open. If we just used apis.open, it wouldn't do
                    // anything if it was already open, which means we wouldn't see the new
                    // refetched data.
                    return open(detail, identity, comp, 
                    // NOTE: The TieredMenu is inside the sandbox. They aren't the same component.
                    sandboxComp, externals, noop, HighlightOnOpen.HighlightMenuAndItem).map(noop);
                });
            },
            isOpen: Toggling.isOn,
            close: (comp) => {
                if (Toggling.isOn(comp)) {
                    togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).get(noop);
                }
            },
            // If we are open, refresh the menus in the tiered menu system
            repositionMenus: (comp) => {
                if (Toggling.isOn(comp)) {
                    repositionMenus(comp);
                }
            }
        };
        const triggerExecute = (comp, _se) => {
            emitExecute(comp);
            return Optional.some(true);
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.dropdownBehaviours, [
                Toggling.config({
                    toggleClass: detail.toggleClass,
                    aria: {
                        mode: 'expanded'
                    }
                }),
                Coupling.config({
                    others: {
                        sandbox: (hotspot) => {
                            return makeSandbox$1(detail, hotspot, {
                                onOpen: () => Toggling.on(hotspot),
                                onClose: () => Toggling.off(hotspot)
                            });
                        }
                    }
                }),
                Keying.config({
                    mode: 'special',
                    onSpace: triggerExecute,
                    onEnter: triggerExecute,
                    onDown: (comp, _se) => {
                        if (Dropdown.isOpen(comp)) {
                            const sandbox = Coupling.getCoupled(comp, 'sandbox');
                            switchToMenu(sandbox);
                        }
                        else {
                            Dropdown.open(comp);
                        }
                        return Optional.some(true);
                    },
                    onEscape: (comp, _se) => {
                        if (Dropdown.isOpen(comp)) {
                            Dropdown.close(comp);
                            return Optional.some(true);
                        }
                        else {
                            return Optional.none();
                        }
                    }
                }),
                Focusing.config({})
            ]),
            events: events(Optional.some(action)),
            eventOrder: {
                ...detail.eventOrder,
                // Order, the button state is toggled first, so assumed !selected means close.
                [execute$5()]: ['disabling', 'toggling', 'alloy.base.behaviour']
            },
            apis,
            domModification: {
                attributes: {
                    'aria-haspopup': detail.listRole.getOr('true'),
                    ...detail.role.fold(() => ({}), (role) => ({ role })),
                    ...detail.dom.tag === 'button' ? { type: lookupAttr('type').getOr('button') } : {}
                }
            }
        };
    };
    const Dropdown = composite({
        name: 'Dropdown',
        configFields: schema$f(),
        partFields: parts$c(),
        factory: factory$k,
        apis: {
            open: (apis, comp) => apis.open(comp),
            refetch: (apis, comp) => apis.refetch(comp),
            expand: (apis, comp) => apis.expand(comp),
            close: (apis, comp) => apis.close(comp),
            isOpen: (apis, comp) => apis.isOpen(comp),
            repositionMenus: (apis, comp) => apis.repositionMenus(comp)
        }
    });

    const owner$1 = 'form';
    const schema$e = [
        field('formBehaviours', [Representing])
    ];
    const getPartName$1 = (name) => '<alloy.field.' + name + '>';
    const sketch$2 = (fSpec) => {
        const parts = (() => {
            const record = [];
            const field = (name, config) => {
                record.push(name);
                return generateOne$1(owner$1, getPartName$1(name), config);
            };
            return {
                field,
                record: constant$1(record)
            };
        })();
        const spec = fSpec(parts);
        const partNames = parts.record();
        // Unlike other sketches, a form does not know its parts in advance (as they represent each field
        // in a particular form). Therefore, it needs to calculate the part names on the fly
        const fieldParts = map$2(partNames, (n) => required({ name: n, pname: getPartName$1(n) }));
        return composite$1(owner$1, schema$e, fieldParts, make$4, spec);
    };
    const toResult = (o, e) => o.fold(() => Result.error(e), Result.value);
    const make$4 = (detail, components) => ({
        uid: detail.uid,
        dom: detail.dom,
        components,
        // Form has an assumption that every field must have composing, and that the composed element has representing.
        behaviours: augment(detail.formBehaviours, [
            Representing.config({
                store: {
                    mode: 'manual',
                    getValue: (form) => {
                        const resPs = getAllParts(form, detail);
                        return map$1(resPs, (resPThunk, pName) => resPThunk().bind((v) => {
                            const opt = Composing.getCurrent(v);
                            return toResult(opt, new Error(`Cannot find a current component to extract the value from for form part '${pName}': ` + element(v.element)));
                        }).map(Representing.getValue));
                    },
                    setValue: (form, values) => {
                        each(values, (newValue, key) => {
                            getPart(form, detail, key).each((wrapper) => {
                                Composing.getCurrent(wrapper).each((field) => {
                                    Representing.setValue(field, newValue);
                                });
                            });
                        });
                    }
                }
            })
        ]),
        apis: {
            getField: (form, key) => {
                // Returns an Optional (not a result);
                return getPart(form, detail, key).bind(Composing.getCurrent);
            }
        }
    });
    const Form = {
        getField: makeApi((apis, component, key) => apis.getField(component, key)),
        sketch: sketch$2
    };

    const schema$d = constant$1([
        required$1('dom'),
        defaulted('shell', true),
        field('toolbarBehaviours', [Replacing])
    ]);
    // TODO: Dupe with Toolbar
    const enhanceGroups = () => ({
        behaviours: derive$1([
            Replacing.config({})
        ])
    });
    const parts$b = constant$1([
        // Note, is the container for putting all the groups in, not a group itself.
        optional({
            name: 'groups',
            overrides: enhanceGroups
        })
    ]);

    const factory$j = (detail, components, _spec, _externals) => {
        const setGroups = (toolbar, groups) => {
            getGroupContainer(toolbar).fold(() => {
                // check that the group container existed. It may not have if the components
                // did not list anything, and shell was false.
                // eslint-disable-next-line no-console
                console.error('Toolbar was defined to not be a shell, but no groups container was specified in components');
                throw new Error('Toolbar was defined to not be a shell, but no groups container was specified in components');
            }, (container) => {
                Replacing.set(container, groups);
            });
        };
        const getGroupContainer = (component) => detail.shell ? Optional.some(component) : getPart(component, detail, 'groups');
        // In shell mode, the group overrides need to be added to the main container, and there can be no children
        const extra = detail.shell ? { behaviours: [Replacing.config({})], components: [] } : { behaviours: [], components };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: extra.components,
            behaviours: augment(detail.toolbarBehaviours, extra.behaviours),
            apis: {
                setGroups,
                refresh: noop
            },
            domModification: {
                attributes: {
                    role: 'group'
                }
            }
        };
    };
    const Toolbar = composite({
        name: 'Toolbar',
        configFields: schema$d(),
        partFields: parts$b(),
        factory: factory$j,
        apis: {
            setGroups: (apis, toolbar, groups) => {
                apis.setGroups(toolbar, groups);
            }
        }
    });

    const schema$c = constant$1([
        markers$1(['toggledClass']),
        required$1('lazySink'),
        requiredFunction('fetch'),
        optionFunction('getBounds'),
        optionObjOf('fireDismissalEventInstead', [
            defaulted('event', dismissRequested())
        ]),
        schema$n(),
        onHandler('onToggled'),
    ]);
    const parts$a = constant$1([
        external$1({
            name: 'button',
            overrides: (detail) => ({
                dom: {
                    attributes: {
                        'aria-haspopup': 'true'
                    }
                },
                buttonBehaviours: derive$1([
                    Toggling.config({
                        toggleClass: detail.markers.toggledClass,
                        aria: {
                            mode: 'expanded'
                        },
                        toggleOnExecute: false,
                        /**
                         * For FloatingToolbars, we can hook up our `onToggled` handler directly to the Toggling
                         * because we don't have to worry about any animations.
                         *
                         * Unfortunately, for SlidingToolbars, Toggling is more directly hooked into the animation for growing,
                         * so to have an event `onToggled` that doesn't care about the animation, we can't just hook into the Toggling config.
                         */
                        onToggled: detail.onToggled
                    })
                ])
            })
        }),
        external$1({
            factory: Toolbar,
            schema: schema$d(),
            name: 'toolbar',
            overrides: (detail) => {
                return {
                    toolbarBehaviours: derive$1([
                        Keying.config({
                            mode: 'cyclic',
                            onEscape: (comp) => {
                                getPart(comp, detail, 'button').each(Focusing.focus);
                                // Don't return true here, as we need to allow the sandbox to handle the escape to close the overflow
                                return Optional.none();
                            }
                        })
                    ])
                };
            }
        })
    ]);

    const shouldSkipFocus = value$2();
    const toggleWithoutFocusing = (button, externals) => {
        shouldSkipFocus.set(true);
        toggle$1(button, externals);
        shouldSkipFocus.clear();
    };
    const toggle$1 = (button, externals) => {
        const toolbarSandbox = Coupling.getCoupled(button, 'toolbarSandbox');
        if (Sandboxing.isOpen(toolbarSandbox)) {
            Sandboxing.close(toolbarSandbox);
        }
        else {
            Sandboxing.open(toolbarSandbox, externals.toolbar());
        }
    };
    const position = (button, toolbar, detail, layouts) => {
        const bounds = detail.getBounds.map((bounder) => bounder());
        const sink = detail.lazySink(button).getOrDie();
        Positioning.positionWithinBounds(sink, toolbar, {
            anchor: {
                type: 'hotspot',
                hotspot: button,
                layouts,
                overrides: {
                    maxWidthFunction: expandable()
                }
            }
        }, bounds);
    };
    const setGroups$1 = (button, toolbar, detail, layouts, groups) => {
        Toolbar.setGroups(toolbar, groups);
        position(button, toolbar, detail, layouts);
        Toggling.on(button);
    };
    const makeSandbox = (button, spec, detail) => {
        const ariaControls = manager();
        const onOpen = (sandbox, toolbar) => {
            const skipFocus = shouldSkipFocus.get().getOr(false);
            detail.fetch().get((groups) => {
                setGroups$1(button, toolbar, detail, spec.layouts, groups);
                ariaControls.link(button.element);
                if (!skipFocus) {
                    Keying.focusIn(toolbar);
                }
            });
        };
        const onClose = () => {
            // Toggle and focus the button
            Toggling.off(button);
            if (!shouldSkipFocus.get().getOr(false)) {
                Focusing.focus(button);
            }
            ariaControls.unlink(button.element);
        };
        return {
            dom: {
                tag: 'div',
                attributes: {
                    id: ariaControls.id
                }
            },
            behaviours: derive$1([
                Keying.config({
                    mode: 'special',
                    onEscape: (comp) => {
                        Sandboxing.close(comp);
                        return Optional.some(true);
                    }
                }),
                Sandboxing.config({
                    onOpen,
                    onClose,
                    isPartOf: (container, data, queryElem) => {
                        return isPartOf(data, queryElem) || isPartOf(button, queryElem);
                    },
                    getAttachPoint: () => {
                        return detail.lazySink(button).getOrDie();
                    }
                }),
                Receiving.config({
                    channels: {
                        ...receivingChannel$1({
                            isExtraPart: never,
                            ...detail.fireDismissalEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event } })).getOr({})
                        }),
                        ...receivingChannel({
                            doReposition: () => {
                                Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar) => {
                                    position(button, toolbar, detail, spec.layouts);
                                });
                            }
                        })
                    }
                })
            ])
        };
    };
    const factory$i = (detail, components, spec, externals) => ({
        ...Button.sketch({
            ...externals.button(),
            action: (button) => {
                toggle$1(button, externals);
            },
            buttonBehaviours: SketchBehaviours.augment({ dump: externals.button().buttonBehaviours }, [
                Coupling.config({
                    others: {
                        toolbarSandbox: (button) => {
                            return makeSandbox(button, spec, detail);
                        }
                    }
                })
            ])
        }),
        apis: {
            setGroups: (button, groups) => {
                Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar) => {
                    setGroups$1(button, toolbar, detail, spec.layouts, groups);
                });
            },
            reposition: (button) => {
                Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar) => {
                    position(button, toolbar, detail, spec.layouts);
                });
            },
            toggle: (button) => {
                toggle$1(button, externals);
            },
            toggleWithoutFocusing: (button) => {
                toggleWithoutFocusing(button, externals);
            },
            getToolbar: (button) => {
                return Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox'));
            },
            isOpen: (button) => {
                return Sandboxing.isOpen(Coupling.getCoupled(button, 'toolbarSandbox'));
            }
        }
    });
    const FloatingToolbarButton = composite({
        name: 'FloatingToolbarButton',
        factory: factory$i,
        configFields: schema$c(),
        partFields: parts$a(),
        apis: {
            setGroups: (apis, button, groups) => {
                apis.setGroups(button, groups);
            },
            reposition: (apis, button) => {
                apis.reposition(button);
            },
            toggle: (apis, button) => {
                apis.toggle(button);
            },
            toggleWithoutFocusing: (apis, button) => {
                apis.toggleWithoutFocusing(button);
            },
            getToolbar: (apis, button) => apis.getToolbar(button),
            isOpen: (apis, button) => apis.isOpen(button)
        }
    });

    const schema$b = constant$1([
        defaulted('prefix', 'form-field'),
        field('fieldBehaviours', [Composing, Representing])
    ]);
    const parts$9 = constant$1([
        optional({
            schema: [required$1('dom')],
            name: 'label'
        }),
        optional({
            factory: {
                sketch: (spec) => {
                    return {
                        uid: spec.uid,
                        dom: {
                            tag: 'span',
                            styles: {
                                display: 'none'
                            },
                            attributes: {
                                'aria-hidden': 'true'
                            },
                            innerHtml: spec.text
                        }
                    };
                }
            },
            schema: [required$1('text')],
            name: 'aria-descriptor'
        }),
        required({
            factory: {
                sketch: (spec) => {
                    const excludeFactory = exclude(spec, ['factory']);
                    return spec.factory.sketch(excludeFactory);
                }
            },
            schema: [required$1('factory')],
            name: 'field'
        })
    ]);

    const factory$h = (detail, components, _spec, _externals) => {
        const behaviours = augment(detail.fieldBehaviours, [
            Composing.config({
                find: (container) => {
                    return getPart(container, detail, 'field');
                }
            }),
            Representing.config({
                store: {
                    mode: 'manual',
                    getValue: (field) => {
                        return Composing.getCurrent(field).bind(Representing.getValue);
                    },
                    setValue: (field, value) => {
                        Composing.getCurrent(field).each((current) => {
                            Representing.setValue(current, value);
                        });
                    }
                }
            })
        ]);
        const events = derive$2([
            // Used to be systemInit
            runOnAttached((component, _simulatedEvent) => {
                const ps = getParts(component, detail, ['label', 'field', 'aria-descriptor']);
                ps.field().each((field) => {
                    const id = generate$6(detail.prefix);
                    ps.label().each((label) => {
                        // TODO: Find a nicer way of doing this.
                        set$9(label.element, 'for', id);
                        set$9(field.element, 'id', id);
                    });
                    ps['aria-descriptor']().each((descriptor) => {
                        const descriptorId = generate$6(detail.prefix);
                        set$9(descriptor.element, 'id', descriptorId);
                        set$9(field.element, 'aria-describedby', descriptorId);
                    });
                });
            })
        ]);
        const apis = {
            getField: (container) => getPart(container, detail, 'field'),
            getLabel: (container) => 
            // TODO: Use constants for part names
            getPart(container, detail, 'label')
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours,
            events,
            apis
        };
    };
    const FormField = composite({
        name: 'FormField',
        configFields: schema$b(),
        partFields: parts$9(),
        factory: factory$h,
        apis: {
            getField: (apis, comp) => apis.getField(comp),
            getLabel: (apis, comp) => apis.getLabel(comp)
        }
    });

    const schema$a = constant$1([
        defaulted('field1Name', 'field1'),
        defaulted('field2Name', 'field2'),
        onStrictHandler('onLockedChange'),
        markers$1(['lockClass']),
        defaulted('locked', false),
        SketchBehaviours.field('coupledFieldBehaviours', [Composing, Representing]),
        defaultedFunction('onInput', noop)
    ]);
    const getField = (comp, detail, partName) => getPart(comp, detail, partName).bind(Composing.getCurrent);
    const coupledPart = (selfName, otherName) => required({
        factory: FormField,
        name: selfName,
        overrides: (detail) => {
            return {
                fieldBehaviours: derive$1([
                    config('coupled-input-behaviour', [
                        run$1(input(), (me) => {
                            getField(me, detail, otherName).each((other) => {
                                getPart(me, detail, 'lock').each((lock) => {
                                    // TODO IMPROVEMENT: Allow locker to fire onLockedChange if it is turned on after being off.
                                    if (Toggling.isOn(lock)) {
                                        detail.onLockedChange(me, other, lock);
                                    }
                                    detail.onInput(me);
                                });
                            });
                        })
                    ])
                ])
            };
        }
    });
    const parts$8 = constant$1([
        coupledPart('field1', 'field2'),
        coupledPart('field2', 'field1'),
        required({
            factory: Button,
            schema: [
                required$1('dom')
            ],
            name: 'lock',
            overrides: (detail) => {
                return {
                    buttonBehaviours: derive$1([
                        Toggling.config({
                            selected: detail.locked,
                            toggleClass: detail.markers.lockClass,
                            aria: {
                                mode: 'pressed'
                            }
                        })
                    ])
                };
            }
        })
    ]);

    const factory$g = (detail, components, _spec, _externals) => ({
        uid: detail.uid,
        dom: detail.dom,
        components,
        behaviours: SketchBehaviours.augment(detail.coupledFieldBehaviours, [
            Composing.config({ find: Optional.some }),
            Representing.config({
                store: {
                    mode: 'manual',
                    getValue: (comp) => {
                        const parts = getPartsOrDie(comp, detail, ['field1', 'field2']);
                        return {
                            [detail.field1Name]: Representing.getValue(parts.field1()),
                            [detail.field2Name]: Representing.getValue(parts.field2())
                        };
                    },
                    setValue: (comp, value) => {
                        const parts = getPartsOrDie(comp, detail, ['field1', 'field2']);
                        if (hasNonNullableKey(value, detail.field1Name)) {
                            Representing.setValue(parts.field1(), value[detail.field1Name]);
                        }
                        if (hasNonNullableKey(value, detail.field2Name)) {
                            Representing.setValue(parts.field2(), value[detail.field2Name]);
                        }
                    }
                }
            })
        ]),
        apis: {
            getField1: (component) => getPart(component, detail, 'field1'),
            getField2: (component) => getPart(component, detail, 'field2'),
            getLock: (component) => getPart(component, detail, 'lock')
        }
    });
    const FormCoupledInputs = composite({
        name: 'FormCoupledInputs',
        configFields: schema$a(),
        partFields: parts$8(),
        factory: factory$g,
        apis: {
            getField1: (apis, component) => apis.getField1(component),
            getField2: (apis, component) => apis.getField2(component),
            getLock: (apis, component) => apis.getLock(component)
        }
    });

    const factory$f = (detail, _spec) => {
        const options = map$2(detail.options, (option) => ({
            dom: {
                tag: 'option',
                value: option.value,
                innerHtml: option.text
            }
        }));
        const initialValues = detail.data.map((v) => wrap('initialValue', v)).getOr({});
        return {
            uid: detail.uid,
            dom: {
                tag: 'select',
                classes: detail.selectClasses,
                attributes: detail.selectAttributes
            },
            components: options,
            behaviours: augment(detail.selectBehaviours, [
                Focusing.config({}),
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue: (select) => {
                            return get$5(select.element);
                        },
                        setValue: (select, newValue) => {
                            const firstOption = head(detail.options);
                            // This is probably generically useful ... may become a part of Representing.
                            const found = find$5(detail.options, (opt) => opt.value === newValue);
                            if (found.isSome()) {
                                set$4(select.element, newValue);
                            }
                            else if (select.element.dom.selectedIndex === -1 && newValue === '') {
                                /*
                                  Sometimes after a redial alloy tries to set a new value, but if no value has been set in the data this used to fail. Now we set the value to the first option in the list if:
                                    The index is out of range, indicating that the list of options have changed, or was never set.
                                    The user is not trying to set a specific value (which would be user error)
                                */
                                firstOption.each((value) => set$4(select.element, value.value));
                            }
                        },
                        ...initialValues
                    }
                })
            ])
        };
    };
    const HtmlSelect = single({
        name: 'HtmlSelect',
        configFields: [
            required$1('options'),
            field('selectBehaviours', [Focusing, Representing]),
            defaulted('selectClasses', []),
            defaulted('selectAttributes', {}),
            option$3('data')
        ],
        factory: factory$f
    });

    const makeMenu = (detail, menuSandbox, placementSpec, menuSpec, getBounds) => {
        const lazySink = () => detail.lazySink(menuSandbox);
        const layouts = menuSpec.type === 'horizontal' ? { layouts: {
                onLtr: () => belowOrAbove(),
                onRtl: () => belowOrAboveRtl()
            } } : {};
        const isFirstTierSubmenu = (triggeringPaths) => triggeringPaths.length === 2; // primary and first tier menu === 2 items
        const getSubmenuLayouts = (triggeringPaths) => isFirstTierSubmenu(triggeringPaths) ? layouts : {};
        return tieredMenu.sketch({
            dom: {
                tag: 'div'
            },
            data: menuSpec.data,
            markers: menuSpec.menu.markers,
            highlightOnOpen: menuSpec.menu.highlightOnOpen,
            fakeFocus: menuSpec.menu.fakeFocus,
            onEscape: () => {
                // Note for the future: this should possibly also call detail.onHide
                Sandboxing.close(menuSandbox);
                detail.onEscape.map((handler) => handler(menuSandbox));
                return Optional.some(true);
            },
            onExecute: () => {
                return Optional.some(true);
            },
            onOpenMenu: (tmenu, menu) => {
                Positioning.positionWithinBounds(lazySink().getOrDie(), menu, placementSpec, getBounds());
            },
            onOpenSubmenu: (tmenu, item, submenu, triggeringPaths) => {
                const sink = lazySink().getOrDie();
                Positioning.position(sink, submenu, {
                    anchor: {
                        type: 'submenu',
                        item,
                        ...getSubmenuLayouts(triggeringPaths)
                    }
                });
            },
            onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {
                const sink = lazySink().getOrDie();
                Positioning.positionWithinBounds(sink, primaryMenu, placementSpec, getBounds());
                each$1(submenuTriggers, (st) => {
                    const submenuLayouts = getSubmenuLayouts(st.triggeringPath);
                    Positioning.position(sink, st.triggeredMenu, {
                        anchor: { type: 'submenu', item: st.triggeringItem, ...submenuLayouts }
                    });
                });
            }
        });
    };
    const factory$e = (detail, spec) => {
        const isPartOfRelated = (sandbox, queryElem) => {
            const related = detail.getRelated(sandbox);
            return related.exists((rel) => isPartOf(rel, queryElem));
        };
        const setContent = (sandbox, thing) => {
            // Keep the same location, and just change the content.
            Sandboxing.setContent(sandbox, thing);
        };
        const showAt = (sandbox, thing, placementSpec) => {
            const getBounds = Optional.none;
            showWithinBounds(sandbox, thing, placementSpec, getBounds);
        };
        const showWithinBounds = (sandbox, thing, placementSpec, getBounds) => {
            const sink = detail.lazySink(sandbox).getOrDie();
            Sandboxing.openWhileCloaked(sandbox, thing, () => Positioning.positionWithinBounds(sink, sandbox, placementSpec, getBounds()));
            Representing.setValue(sandbox, Optional.some({
                mode: 'position',
                config: placementSpec,
                getBounds
            }));
        };
        // TODO AP-191 write a test for showMenuAt
        const showMenuAt = (sandbox, placementSpec, menuSpec) => {
            showMenuWithinBounds(sandbox, placementSpec, menuSpec, Optional.none);
        };
        const showMenuWithinBounds = (sandbox, placementSpec, menuSpec, getBounds) => {
            const menu = makeMenu(detail, sandbox, placementSpec, menuSpec, getBounds);
            Sandboxing.open(sandbox, menu);
            Representing.setValue(sandbox, Optional.some({
                mode: 'menu',
                menu
            }));
        };
        const hide = (sandbox) => {
            if (Sandboxing.isOpen(sandbox)) {
                Representing.setValue(sandbox, Optional.none());
                Sandboxing.close(sandbox);
            }
        };
        const getContent = (sandbox) => Sandboxing.getState(sandbox);
        const reposition = (sandbox) => {
            if (Sandboxing.isOpen(sandbox)) {
                Representing.getValue(sandbox).each((state) => {
                    switch (state.mode) {
                        case 'menu':
                            Sandboxing.getState(sandbox).each(tieredMenu.repositionMenus);
                            break;
                        case 'position':
                            const sink = detail.lazySink(sandbox).getOrDie();
                            Positioning.positionWithinBounds(sink, sandbox, state.config, state.getBounds());
                            break;
                    }
                });
            }
        };
        const apis = {
            setContent,
            showAt,
            showWithinBounds,
            showMenuAt,
            showMenuWithinBounds,
            hide,
            getContent,
            reposition,
            isOpen: Sandboxing.isOpen
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            behaviours: augment(detail.inlineBehaviours, [
                Sandboxing.config({
                    isPartOf: (sandbox, data, queryElem) => {
                        return isPartOf(data, queryElem) || isPartOfRelated(sandbox, queryElem);
                    },
                    getAttachPoint: (sandbox) => {
                        return detail.lazySink(sandbox).getOrDie();
                    },
                    onOpen: (sandbox) => {
                        detail.onShow(sandbox);
                    },
                    onClose: (sandbox) => {
                        detail.onHide(sandbox);
                    }
                }),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: Optional.none()
                    }
                }),
                Receiving.config({
                    channels: {
                        ...receivingChannel$1({
                            isExtraPart: spec.isExtraPart,
                            ...detail.fireDismissalEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event } })).getOr({})
                        }),
                        ...receivingChannel({
                            ...detail.fireRepositionEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event } })).getOr({}),
                            doReposition: reposition
                        })
                    }
                })
            ]),
            eventOrder: detail.eventOrder,
            apis
        };
    };
    const InlineView = single({
        name: 'InlineView',
        configFields: [
            required$1('lazySink'),
            onHandler('onShow'),
            onHandler('onHide'),
            optionFunction('onEscape'),
            field('inlineBehaviours', [Sandboxing, Representing, Receiving]),
            optionObjOf('fireDismissalEventInstead', [
                defaulted('event', dismissRequested())
            ]),
            optionObjOf('fireRepositionEventInstead', [
                defaulted('event', repositionRequested())
            ]),
            defaulted('getRelated', Optional.none),
            defaulted('isExtraPart', never),
            defaulted('eventOrder', Optional.none)
        ],
        factory: factory$e,
        apis: {
            showAt: (apis, component, anchor, thing) => {
                apis.showAt(component, anchor, thing);
            },
            showWithinBounds: (apis, component, anchor, thing, bounds) => {
                apis.showWithinBounds(component, anchor, thing, bounds);
            },
            showMenuAt: (apis, component, anchor, menuSpec) => {
                apis.showMenuAt(component, anchor, menuSpec);
            },
            showMenuWithinBounds: (apis, component, anchor, menuSpec, bounds) => {
                apis.showMenuWithinBounds(component, anchor, menuSpec, bounds);
            },
            hide: (apis, component) => {
                apis.hide(component);
            },
            isOpen: (apis, component) => apis.isOpen(component),
            getContent: (apis, component) => apis.getContent(component),
            setContent: (apis, component, thing) => {
                apis.setContent(component, thing);
            },
            reposition: (apis, component) => {
                apis.reposition(component);
            }
        }
    });

    const schema$9 = constant$1([
        defaultedString('type', 'text'),
        option$3('data'),
        defaulted('inputAttributes', {}),
        defaulted('inputStyles', {}),
        defaulted('tag', 'input'),
        defaulted('inputClasses', []),
        onHandler('onSetValue'),
        defaultedFunction('fromInputValue', identity),
        defaultedFunction('toInputValue', identity),
        defaulted('styles', {}),
        defaulted('eventOrder', {}),
        field('inputBehaviours', [Representing, Focusing]),
        defaulted('selectOnFocus', true)
    ]);
    const focusBehaviours = (detail) => derive$1([
        Focusing.config({
            onFocus: !detail.selectOnFocus ? noop : (component) => {
                const input = component.element;
                const value = get$5(input);
                // TODO: There are probably more types that can't handle setSelectionRange
                if (detail.type !== 'range') {
                    input.dom.setSelectionRange(0, value.length);
                }
            }
        })
    ]);
    const behaviours = (detail) => ({
        ...focusBehaviours(detail),
        ...augment(detail.inputBehaviours, [
            Representing.config({
                store: {
                    mode: 'manual',
                    // Propagating its Optional
                    ...detail.data.map((data) => ({ initialValue: data })).getOr({}),
                    getValue: (input) => {
                        return detail.fromInputValue(get$5(input.element));
                    },
                    setValue: (input, data) => {
                        const current = get$5(input.element);
                        // Only set it if it has changed ... otherwise the cursor goes to the end.
                        if (current !== data) {
                            set$4(input.element, detail.toInputValue(data));
                        }
                    }
                },
                onSetValue: detail.onSetValue
            })
        ])
    });
    const dom$1 = (detail) => ({
        tag: detail.tag,
        attributes: {
            type: detail.type,
            ...detail.inputAttributes
        },
        styles: detail.inputStyles,
        classes: detail.inputClasses
    });

    const factory$d = (detail, _spec) => ({
        uid: detail.uid,
        dom: dom$1(detail),
        // No children.
        components: [],
        behaviours: behaviours(detail),
        eventOrder: detail.eventOrder
    });
    const Input = single({
        name: 'Input',
        configFields: schema$9(),
        factory: factory$d
    });

    const parts$7 = generate$5(owner$2(), parts$e());

    const labelledBy = (labelledElement, labelElement) => {
        const labelId = getOpt(labelledElement, 'id')
            .fold(() => {
            const id = generate$6('dialog-label');
            set$9(labelElement, 'id', id);
            return id;
        }, identity);
        set$9(labelledElement, 'aria-labelledby', labelId);
    };

    const schema$8 = constant$1([
        required$1('lazySink'),
        option$3('dragBlockClass'),
        defaultedFunction('getBounds', win),
        defaulted('useTabstopAt', always),
        defaulted('firstTabstop', 0),
        defaulted('eventOrder', {}),
        field('modalBehaviours', [Keying]),
        onKeyboardHandler('onExecute'),
        onStrictKeyboardHandler('onEscape')
    ]);
    const basic = { sketch: identity };
    const parts$6 = constant$1([
        optional({
            name: 'draghandle',
            overrides: (detail, spec) => {
                return {
                    behaviours: derive$1([
                        Dragging.config({
                            mode: 'mouse',
                            getTarget: (handle) => {
                                return ancestor$1(handle, '[role="dialog"]').getOr(handle);
                            },
                            blockerClass: detail.dragBlockClass.getOrDie(
                            // TODO: Support errors in Optional getOrDie.
                            new Error('The drag blocker class was not specified for a dialog with a drag handle: \n' +
                                JSON.stringify(spec, null, 2)).message),
                            getBounds: detail.getDragBounds
                        })
                    ])
                };
            }
        }),
        required({
            schema: [required$1('dom')],
            name: 'title'
        }),
        required({
            factory: basic,
            schema: [required$1('dom')],
            name: 'close'
        }),
        required({
            factory: basic,
            schema: [required$1('dom')],
            name: 'body'
        }),
        optional({
            factory: basic,
            schema: [required$1('dom')],
            name: 'footer'
        }),
        external$1({
            factory: {
                sketch: (spec, detail) => 
                // Merging should take care of the uid
                ({
                    ...spec,
                    dom: detail.dom,
                    components: detail.components
                })
            },
            schema: [
                defaulted('dom', {
                    tag: 'div',
                    styles: {
                        position: 'fixed',
                        left: '0px',
                        top: '0px',
                        right: '0px',
                        bottom: '0px'
                    }
                }),
                defaulted('components', [])
            ],
            name: 'blocker'
        })
    ]);

    const factory$c = (detail, components, spec, externals) => {
        const dialogComp = value$2();
        // TODO IMPROVEMENT: Make close actually close the dialog by default!
        const showDialog = (dialog) => {
            dialogComp.set(dialog);
            const sink = detail.lazySink(dialog).getOrDie();
            const externalBlocker = externals.blocker();
            const blocker = sink.getSystem().build({
                ...externalBlocker,
                components: externalBlocker.components.concat([
                    premade(dialog)
                ]),
                behaviours: derive$1([
                    Focusing.config({}),
                    config('dialog-blocker-events', [
                        // Ensure we use runOnSource otherwise this would cause an infinite loop, as `focusIn` would fire a `focusin` which would then get responded to and so forth
                        runOnSource(focusin(), () => {
                            Blocking.isBlocked(dialog) ? noop() : Keying.focusIn(dialog);
                        })
                    ])
                ])
            });
            attach(sink, blocker);
            Keying.focusIn(dialog);
        };
        const hideDialog = (dialog) => {
            dialogComp.clear();
            parent(dialog.element).each((blockerDom) => {
                dialog.getSystem().getByDom(blockerDom).each((blocker) => {
                    detach(blocker);
                });
            });
        };
        const getDialogBody = (dialog) => getPartOrDie(dialog, detail, 'body');
        const getDialogFooter = (dialog) => getPart(dialog, detail, 'footer');
        const setBusy = (dialog, getBusySpec) => {
            Blocking.block(dialog, getBusySpec);
        };
        const setIdle = (dialog) => {
            Blocking.unblock(dialog);
        };
        const modalEventsId = generate$6('modal-events');
        const eventOrder = {
            ...detail.eventOrder,
            [attachedToDom()]: [modalEventsId].concat(detail.eventOrder['alloy.system.attached'] || [])
        };
        const browser = detect$1();
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            apis: {
                show: showDialog,
                hide: hideDialog,
                getBody: getDialogBody,
                getFooter: getDialogFooter,
                setIdle,
                setBusy
            },
            eventOrder,
            domModification: {
                attributes: {
                    'role': 'dialog',
                    'aria-modal': 'true'
                }
            },
            behaviours: augment(detail.modalBehaviours, [
                Replacing.config({}),
                Keying.config({
                    mode: 'cyclic',
                    onEnter: detail.onExecute,
                    onEscape: detail.onEscape,
                    useTabstopAt: detail.useTabstopAt,
                    firstTabstop: detail.firstTabstop
                }),
                Blocking.config({
                    getRoot: dialogComp.get
                }),
                config(modalEventsId, [
                    runOnAttached((c) => {
                        // TINY-10808 - Workaround to address the dialog header not being announced on VoiceOver with aria-labelledby, ideally we should use the aria-labelledby
                        const titleElm = getPartOrDie(c, detail, 'title').element;
                        const title = get$6(titleElm);
                        if (browser.os.isMacOS() && isNonNullable(title)) {
                            set$9(c.element, 'aria-label', title);
                        }
                        else {
                            labelledBy(c.element, titleElm);
                        }
                    })
                ])
            ])
        };
    };
    const ModalDialog = composite({
        name: 'ModalDialog',
        configFields: schema$8(),
        partFields: parts$6(),
        factory: factory$c,
        apis: {
            show: (apis, dialog) => {
                apis.show(dialog);
            },
            hide: (apis, dialog) => {
                apis.hide(dialog);
            },
            getBody: (apis, dialog) => apis.getBody(dialog),
            getFooter: (apis, dialog) => apis.getFooter(dialog),
            setBusy: (apis, dialog, getBusySpec) => {
                apis.setBusy(dialog, getBusySpec);
            },
            setIdle: (apis, dialog) => {
                apis.setIdle(dialog);
            }
        }
    });

    const labelPart = optional({
        schema: [required$1('dom')],
        name: 'label'
    });
    const edgePart = (name) => optional({
        name: '' + name + '-edge',
        overrides: (detail) => {
            const action = detail.model.manager.edgeActions[name];
            // Not all edges have actions for all sliders.
            // A horizontal slider will only have left and right, for instance,
            // ignoring top, bottom and diagonal edges as they don't make sense in context of those sliders.
            return action.fold(() => ({}), (a) => ({
                events: derive$2([
                    runActionExtra(touchstart(), (comp, se, d) => a(comp, d), [detail]),
                    runActionExtra(mousedown(), (comp, se, d) => a(comp, d), [detail]),
                    runActionExtra(mousemove(), (comp, se, det) => {
                        if (det.mouseIsDown.get()) {
                            a(comp, det);
                        }
                    }, [detail])
                ])
            }));
        }
    });
    // When the user touches the top left edge, it should move the thumb
    const tlEdgePart = edgePart('top-left');
    // When the user touches the top edge, it should move the thumb
    const tedgePart = edgePart('top');
    // When the user touches the top right edge, it should move the thumb
    const trEdgePart = edgePart('top-right');
    // When the user touches the right edge, it should move the thumb
    const redgePart = edgePart('right');
    // When the user touches the bottom right edge, it should move the thumb
    const brEdgePart = edgePart('bottom-right');
    // When the user touches the bottom edge, it should move the thumb
    const bedgePart = edgePart('bottom');
    // When the user touches the bottom left edge, it should move the thumb
    const blEdgePart = edgePart('bottom-left');
    // When the user touches the left edge, it should move the thumb
    const ledgePart = edgePart('left');
    // The thumb part needs to have position absolute to be positioned correctly
    const thumbPart = required({
        name: 'thumb',
        defaults: constant$1({
            dom: {
                styles: { position: 'absolute' }
            }
        }),
        overrides: (detail) => {
            return {
                events: derive$2([
                    // If the user touches the thumb itself, pretend they touched the spectrum instead. This
                    // allows sliding even when they touchstart the current value
                    redirectToPart(touchstart(), detail, 'spectrum'),
                    redirectToPart(touchmove(), detail, 'spectrum'),
                    redirectToPart(touchend(), detail, 'spectrum'),
                    redirectToPart(mousedown(), detail, 'spectrum'),
                    redirectToPart(mousemove(), detail, 'spectrum'),
                    redirectToPart(mouseup(), detail, 'spectrum')
                ])
            };
        }
    });
    const isShift = (event) => isShift$1(event.event);
    const spectrumPart = required({
        schema: [
            customField('mouseIsDown', () => Cell(false))
        ],
        name: 'spectrum',
        overrides: (detail) => {
            const modelDetail = detail.model;
            const model = modelDetail.manager;
            const setValueFrom = (component, simulatedEvent) => model.getValueFromEvent(simulatedEvent).map((value) => model.setValueFrom(component, detail, value));
            return {
                behaviours: derive$1([
                    // Move left and right along the spectrum
                    Keying.config({
                        mode: 'special',
                        onLeft: (spectrum, event) => model.onLeft(spectrum, detail, isShift(event)),
                        onRight: (spectrum, event) => model.onRight(spectrum, detail, isShift(event)),
                        onUp: (spectrum, event) => model.onUp(spectrum, detail, isShift(event)),
                        onDown: (spectrum, event) => model.onDown(spectrum, detail, isShift(event))
                    }),
                    Tabstopping.config({}),
                    Focusing.config({})
                ]),
                events: derive$2([
                    run$1(touchstart(), setValueFrom),
                    run$1(touchmove(), setValueFrom),
                    run$1(mousedown(), setValueFrom),
                    run$1(mousemove(), (spectrum, se) => {
                        if (detail.mouseIsDown.get()) {
                            setValueFrom(spectrum, se);
                        }
                    })
                ])
            };
        }
    });
    var SliderParts = [
        labelPart,
        ledgePart,
        redgePart,
        tedgePart,
        bedgePart,
        tlEdgePart,
        trEdgePart,
        blEdgePart,
        brEdgePart,
        thumbPart,
        spectrumPart
    ];

    const _sliderChangeEvent = 'slider.change.value';
    const sliderChangeEvent = constant$1(_sliderChangeEvent);
    const isTouchEvent$2 = (evt) => evt.type.indexOf('touch') !== -1;
    const getEventSource = (simulatedEvent) => {
        const evt = simulatedEvent.event.raw;
        if (isTouchEvent$2(evt)) {
            const touchEvent = evt;
            return touchEvent.touches !== undefined && touchEvent.touches.length === 1 ?
                Optional.some(touchEvent.touches[0]).map((t) => SugarPosition(t.clientX, t.clientY)) : Optional.none();
        }
        else {
            const mouseEvent = evt;
            return mouseEvent.clientX !== undefined ? Optional.some(mouseEvent).map((me) => SugarPosition(me.clientX, me.clientY)) : Optional.none();
        }
    };

    const t = 'top', r = 'right', b = 'bottom', l = 'left';
    // Values
    const minX = (detail) => detail.model.minX;
    const minY = (detail) => detail.model.minY;
    const min1X = (detail) => detail.model.minX - 1;
    const min1Y = (detail) => detail.model.minY - 1;
    const maxX = (detail) => detail.model.maxX;
    const maxY = (detail) => detail.model.maxY;
    const max1X = (detail) => detail.model.maxX + 1;
    const max1Y = (detail) => detail.model.maxY + 1;
    const range = (detail, max, min) => max(detail) - min(detail);
    const xRange = (detail) => range(detail, maxX, minX);
    const yRange = (detail) => range(detail, maxY, minY);
    const halfX = (detail) => xRange(detail) / 2;
    const halfY = (detail) => yRange(detail) / 2;
    const step = (detail, useMultiplier) => useMultiplier ? detail.stepSize * detail.speedMultiplier : detail.stepSize;
    const snap = (detail) => detail.snapToGrid;
    const snapStart = (detail) => detail.snapStart;
    const rounded = (detail) => detail.rounded;
    // Not great but... /shrug
    const hasEdge = (detail, edgeName) => detail[edgeName + '-edge'] !== undefined;
    const hasLEdge = (detail) => hasEdge(detail, l);
    const hasREdge = (detail) => hasEdge(detail, r);
    const hasTEdge = (detail) => hasEdge(detail, t);
    const hasBEdge = (detail) => hasEdge(detail, b);
    // Ew, any
    const currentValue = (detail) => detail.model.value.get();

    const xyValue = (x, y) => ({
        x,
        y
    });
    const fireSliderChange$3 = (component, value) => {
        emitWith(component, sliderChangeEvent(), { value });
    };
    // North West XY
    const setToTLEdgeXY = (edge, detail) => {
        fireSliderChange$3(edge, xyValue(min1X(detail), min1Y(detail)));
    };
    // North
    const setToTEdge = (edge, detail) => {
        fireSliderChange$3(edge, min1Y(detail));
    };
    // North XY
    const setToTEdgeXY = (edge, detail) => {
        fireSliderChange$3(edge, xyValue(halfX(detail), min1Y(detail)));
    };
    // North East XY
    const setToTREdgeXY = (edge, detail) => {
        fireSliderChange$3(edge, xyValue(max1X(detail), min1Y(detail)));
    };
    // East
    const setToREdge = (edge, detail) => {
        fireSliderChange$3(edge, max1X(detail));
    };
    // East XY
    const setToREdgeXY = (edge, detail) => {
        fireSliderChange$3(edge, xyValue(max1X(detail), halfY(detail)));
    };
    // South East XY
    const setToBREdgeXY = (edge, detail) => {
        fireSliderChange$3(edge, xyValue(max1X(detail), max1Y(detail)));
    };
    // South
    const setToBEdge = (edge, detail) => {
        fireSliderChange$3(edge, max1Y(detail));
    };
    // South XY
    const setToBEdgeXY = (edge, detail) => {
        fireSliderChange$3(edge, xyValue(halfX(detail), max1Y(detail)));
    };
    // South West XY
    const setToBLEdgeXY = (edge, detail) => {
        fireSliderChange$3(edge, xyValue(min1X(detail), max1Y(detail)));
    };
    // West
    const setToLEdge = (edge, detail) => {
        fireSliderChange$3(edge, min1X(detail));
    };
    // West XY
    const setToLEdgeXY = (edge, detail) => {
        fireSliderChange$3(edge, xyValue(min1X(detail), halfY(detail)));
    };

    const reduceBy = (value, min, max, step) => {
        if (value < min) {
            return value;
        }
        else if (value > max) {
            return max;
        }
        else if (value === min) {
            return min - 1;
        }
        else {
            return Math.max(min, value - step);
        }
    };
    const increaseBy = (value, min, max, step) => {
        if (value > max) {
            return value;
        }
        else if (value < min) {
            return min;
        }
        else if (value === max) {
            return max + 1;
        }
        else {
            return Math.min(max, value + step);
        }
    };
    const capValue = (value, min, max) => Math.max(min, Math.min(max, value));
    const snapValueOf = (value, min, max, step, snapStart) => 
    // We are snapping by the step size. Therefore, find the nearest multiple of
    // the step
    snapStart.fold(() => {
        // There is no initial snapping start, so just go from the minimum
        const initValue = value - min;
        const extraValue = Math.round(initValue / step) * step;
        return capValue(min + extraValue, min - 1, max + 1);
    }, (start) => {
        // There is an initial snapping start, so using that as the starting point,
        // calculate the nearest snap position based on the value
        const remainder = (value - start) % step;
        const adjustment = Math.round(remainder / step);
        const rawSteps = Math.floor((value - start) / step);
        const maxSteps = Math.floor((max - start) / step);
        const numSteps = Math.min(maxSteps, rawSteps + adjustment);
        const r = start + (numSteps * step);
        return Math.max(start, r);
    });
    const findOffsetOf = (value, min, max) => Math.min(max, Math.max(value, min)) - min;
    const findValueOf = (args) => {
        const { min, max, range, value, step, snap, snapStart, rounded, hasMinEdge, hasMaxEdge, minBound, maxBound, screenRange } = args;
        const capMin = hasMinEdge ? min - 1 : min;
        const capMax = hasMaxEdge ? max + 1 : max;
        if (value < minBound) {
            return capMin;
        }
        else if (value > maxBound) {
            return capMax;
        }
        else {
            const offset = findOffsetOf(value, minBound, maxBound);
            const newValue = capValue(((offset / screenRange) * range) + min, capMin, capMax);
            if (snap && newValue >= min && newValue <= max) {
                return snapValueOf(newValue, min, max, step, snapStart);
            }
            else if (rounded) {
                return Math.round(newValue);
            }
            else {
                return newValue;
            }
        }
    };
    const findOffsetOfValue$2 = (args) => {
        const { min, max, range, value, hasMinEdge, hasMaxEdge, maxBound, maxOffset, centerMinEdge, centerMaxEdge } = args;
        if (value < min) {
            return hasMinEdge ? 0 : centerMinEdge;
        }
        else if (value > max) {
            return hasMaxEdge ? maxBound : centerMaxEdge;
        }
        else {
            // position along the slider
            return (value - min) / range * maxOffset;
        }
    };

    const top = 'top', right = 'right', bottom = 'bottom', left = 'left', width = 'width', height = 'height';
    // Screen offsets from bounding client rect
    const getBounds = (component) => component.element.dom.getBoundingClientRect();
    const getBoundsProperty = (bounds, property) => bounds[property];
    const getMinXBounds = (component) => {
        const bounds = getBounds(component);
        return getBoundsProperty(bounds, left);
    };
    const getMaxXBounds = (component) => {
        const bounds = getBounds(component);
        return getBoundsProperty(bounds, right);
    };
    const getMinYBounds = (component) => {
        const bounds = getBounds(component);
        return getBoundsProperty(bounds, top);
    };
    const getMaxYBounds = (component) => {
        const bounds = getBounds(component);
        return getBoundsProperty(bounds, bottom);
    };
    const getXScreenRange = (component) => {
        const bounds = getBounds(component);
        return getBoundsProperty(bounds, width);
    };
    const getYScreenRange = (component) => {
        const bounds = getBounds(component);
        return getBoundsProperty(bounds, height);
    };
    const getCenterOffsetOf = (componentMinEdge, componentMaxEdge, spectrumMinEdge) => (componentMinEdge + componentMaxEdge) / 2 - spectrumMinEdge;
    const getXCenterOffSetOf = (component, spectrum) => {
        const componentBounds = getBounds(component);
        const spectrumBounds = getBounds(spectrum);
        const componentMinEdge = getBoundsProperty(componentBounds, left);
        const componentMaxEdge = getBoundsProperty(componentBounds, right);
        const spectrumMinEdge = getBoundsProperty(spectrumBounds, left);
        return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);
    };
    const getYCenterOffSetOf = (component, spectrum) => {
        const componentBounds = getBounds(component);
        const spectrumBounds = getBounds(spectrum);
        const componentMinEdge = getBoundsProperty(componentBounds, top);
        const componentMaxEdge = getBoundsProperty(componentBounds, bottom);
        const spectrumMinEdge = getBoundsProperty(spectrumBounds, top);
        return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);
    };

    // fire slider change event with x value
    const fireSliderChange$2 = (spectrum, value) => {
        emitWith(spectrum, sliderChangeEvent(), { value });
    };
    // find the value of the x offset of where the mouse was clicked from the model.
    const findValueOfOffset$1 = (spectrum, detail, left) => {
        const args = {
            min: minX(detail),
            max: maxX(detail),
            range: xRange(detail),
            value: left,
            step: step(detail),
            snap: snap(detail),
            snapStart: snapStart(detail),
            rounded: rounded(detail),
            hasMinEdge: hasLEdge(detail),
            hasMaxEdge: hasREdge(detail),
            minBound: getMinXBounds(spectrum),
            maxBound: getMaxXBounds(spectrum),
            screenRange: getXScreenRange(spectrum)
        };
        return findValueOf(args);
    };
    // find the value and fire a slider change event, returning the value
    const setValueFrom$2 = (spectrum, detail, value) => {
        const xValue = findValueOfOffset$1(spectrum, detail, value);
        const sliderVal = xValue;
        fireSliderChange$2(spectrum, sliderVal);
        return xValue;
    };
    // fire a slider change event with the minimum value
    const setToMin$2 = (spectrum, detail) => {
        const min = minX(detail);
        fireSliderChange$2(spectrum, min);
    };
    // fire a slider change event with the maximum value
    const setToMax$2 = (spectrum, detail) => {
        const max = maxX(detail);
        fireSliderChange$2(spectrum, max);
    };
    // move in a direction by step size. Fire change at the end
    const moveBy$2 = (direction, spectrum, detail, useMultiplier) => {
        const f = (direction > 0) ? increaseBy : reduceBy;
        const xValue = f(currentValue(detail), minX(detail), maxX(detail), step(detail, useMultiplier));
        fireSliderChange$2(spectrum, xValue);
        return Optional.some(xValue);
    };
    const handleMovement$2 = (direction) => (spectrum, detail, useMultiplier) => moveBy$2(direction, spectrum, detail, useMultiplier).map(always);
    // get x offset from event
    const getValueFromEvent$2 = (simulatedEvent) => {
        const pos = getEventSource(simulatedEvent);
        return pos.map((p) => p.left);
    };
    // find the x offset of a given value from the model
    const findOffsetOfValue$1 = (spectrum, detail, value, minEdge, maxEdge) => {
        const minOffset = 0;
        const maxOffset = getXScreenRange(spectrum);
        const centerMinEdge = minEdge.bind((edge) => Optional.some(getXCenterOffSetOf(edge, spectrum))).getOr(minOffset);
        const centerMaxEdge = maxEdge.bind((edge) => Optional.some(getXCenterOffSetOf(edge, spectrum))).getOr(maxOffset);
        const args = {
            min: minX(detail),
            max: maxX(detail),
            range: xRange(detail),
            value,
            hasMinEdge: hasLEdge(detail),
            hasMaxEdge: hasREdge(detail),
            minBound: getMinXBounds(spectrum),
            minOffset,
            maxBound: getMaxXBounds(spectrum),
            maxOffset,
            centerMinEdge,
            centerMaxEdge
        };
        return findOffsetOfValue$2(args);
    };
    // find left offset for absolute positioning from a given value
    const findPositionOfValue$1 = (slider, spectrum, value, minEdge, maxEdge, detail) => {
        const offset = findOffsetOfValue$1(spectrum, detail, value, minEdge, maxEdge);
        return (getMinXBounds(spectrum) - getMinXBounds(slider)) + offset;
    };
    // update the position of the thumb from the slider's current value
    const setPositionFromValue$2 = (slider, thumb, detail, edges) => {
        const value = currentValue(detail);
        const pos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
        const thumbRadius = get$c(thumb.element) / 2;
        set$7(thumb.element, 'left', (pos - thumbRadius) + 'px');
    };
    // Key Events
    const onLeft$2 = handleMovement$2(-1);
    const onRight$2 = handleMovement$2(1);
    const onUp$2 = Optional.none;
    const onDown$2 = Optional.none;
    // Edge Click Actions
    const edgeActions$2 = {
        'top-left': Optional.none(),
        'top': Optional.none(),
        'top-right': Optional.none(),
        'right': Optional.some(setToREdge),
        'bottom-right': Optional.none(),
        'bottom': Optional.none(),
        'bottom-left': Optional.none(),
        'left': Optional.some(setToLEdge)
    };

    var HorizontalModel = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom$2,
        setToMin: setToMin$2,
        setToMax: setToMax$2,
        findValueOfOffset: findValueOfOffset$1,
        getValueFromEvent: getValueFromEvent$2,
        findPositionOfValue: findPositionOfValue$1,
        setPositionFromValue: setPositionFromValue$2,
        onLeft: onLeft$2,
        onRight: onRight$2,
        onUp: onUp$2,
        onDown: onDown$2,
        edgeActions: edgeActions$2
    });

    // fire slider change event with y value
    const fireSliderChange$1 = (spectrum, value) => {
        emitWith(spectrum, sliderChangeEvent(), { value });
    };
    // find the value of the y offset of where the mouse was clicked from the model.
    const findValueOfOffset = (spectrum, detail, top) => {
        const args = {
            min: minY(detail),
            max: maxY(detail),
            range: yRange(detail),
            value: top,
            step: step(detail),
            snap: snap(detail),
            snapStart: snapStart(detail),
            rounded: rounded(detail),
            hasMinEdge: hasTEdge(detail),
            hasMaxEdge: hasBEdge(detail),
            minBound: getMinYBounds(spectrum),
            maxBound: getMaxYBounds(spectrum),
            screenRange: getYScreenRange(spectrum)
        };
        return findValueOf(args);
    };
    // find the value and fire a slider change event, returning the value
    const setValueFrom$1 = (spectrum, detail, value) => {
        const yValue = findValueOfOffset(spectrum, detail, value);
        const sliderVal = yValue;
        fireSliderChange$1(spectrum, sliderVal);
        return yValue;
    };
    // fire a slider change event with the minimum value
    const setToMin$1 = (spectrum, detail) => {
        const min = minY(detail);
        fireSliderChange$1(spectrum, min);
    };
    // fire a slider change event with the maximum value
    const setToMax$1 = (spectrum, detail) => {
        const max = maxY(detail);
        fireSliderChange$1(spectrum, max);
    };
    // move in a direction by step size. Fire change at the end
    const moveBy$1 = (direction, spectrum, detail, useMultiplier) => {
        const f = (direction > 0) ? increaseBy : reduceBy;
        const yValue = f(currentValue(detail), minY(detail), maxY(detail), step(detail, useMultiplier));
        fireSliderChange$1(spectrum, yValue);
        return Optional.some(yValue);
    };
    const handleMovement$1 = (direction) => (spectrum, detail, useMultiplier) => moveBy$1(direction, spectrum, detail, useMultiplier).map(always);
    // get y offset from event
    const getValueFromEvent$1 = (simulatedEvent) => {
        const pos = getEventSource(simulatedEvent);
        return pos.map((p) => {
            return p.top;
        });
    };
    // find the y offset of a given value from the model
    const findOffsetOfValue = (spectrum, detail, value, minEdge, maxEdge) => {
        const minOffset = 0;
        const maxOffset = getYScreenRange(spectrum);
        const centerMinEdge = minEdge.bind((edge) => Optional.some(getYCenterOffSetOf(edge, spectrum))).getOr(minOffset);
        const centerMaxEdge = maxEdge.bind((edge) => Optional.some(getYCenterOffSetOf(edge, spectrum))).getOr(maxOffset);
        const args = {
            min: minY(detail),
            max: maxY(detail),
            range: yRange(detail),
            value,
            hasMinEdge: hasTEdge(detail),
            hasMaxEdge: hasBEdge(detail),
            minBound: getMinYBounds(spectrum),
            minOffset,
            maxBound: getMaxYBounds(spectrum),
            maxOffset,
            centerMinEdge,
            centerMaxEdge
        };
        return findOffsetOfValue$2(args);
    };
    // find left offset for absolute positioning from a given value
    const findPositionOfValue = (slider, spectrum, value, minEdge, maxEdge, detail) => {
        const offset = findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge);
        return (getMinYBounds(spectrum) - getMinYBounds(slider)) + offset;
    };
    // update the position of the thumb from the slider's current value
    const setPositionFromValue$1 = (slider, thumb, detail, edges) => {
        const value = currentValue(detail);
        const pos = findPositionOfValue(slider, edges.getSpectrum(slider), value, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
        const thumbRadius = get$d(thumb.element) / 2;
        set$7(thumb.element, 'top', (pos - thumbRadius) + 'px');
    };
    // Key Events
    const onLeft$1 = Optional.none;
    const onRight$1 = Optional.none;
    const onUp$1 = handleMovement$1(-1);
    const onDown$1 = handleMovement$1(1);
    // Edge Click Actions
    const edgeActions$1 = {
        'top-left': Optional.none(),
        'top': Optional.some(setToTEdge),
        'top-right': Optional.none(),
        'right': Optional.none(),
        'bottom-right': Optional.none(),
        'bottom': Optional.some(setToBEdge),
        'bottom-left': Optional.none(),
        'left': Optional.none()
    };

    var VerticalModel = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom$1,
        setToMin: setToMin$1,
        setToMax: setToMax$1,
        findValueOfOffset: findValueOfOffset,
        getValueFromEvent: getValueFromEvent$1,
        findPositionOfValue: findPositionOfValue,
        setPositionFromValue: setPositionFromValue$1,
        onLeft: onLeft$1,
        onRight: onRight$1,
        onUp: onUp$1,
        onDown: onDown$1,
        edgeActions: edgeActions$1
    });

    // fire slider change event with xy value
    const fireSliderChange = (spectrum, value) => {
        emitWith(spectrum, sliderChangeEvent(), { value });
    };
    const sliderValue = (x, y) => ({
        x,
        y
    });
    // find both values of x and y offsets of where the mouse was clicked from the model.
    // then fire a slider change event with those values, returning the values
    const setValueFrom = (spectrum, detail, value) => {
        const xValue = findValueOfOffset$1(spectrum, detail, value.left);
        const yValue = findValueOfOffset(spectrum, detail, value.top);
        const val = sliderValue(xValue, yValue);
        fireSliderChange(spectrum, val);
        return val;
    };
    // move in a direction by step size. Fire change at the end
    const moveBy = (direction, isVerticalMovement, spectrum, detail, useMultiplier) => {
        const f = (direction > 0) ? increaseBy : reduceBy;
        const xValue = isVerticalMovement ? currentValue(detail).x :
            f(currentValue(detail).x, minX(detail), maxX(detail), step(detail, useMultiplier));
        const yValue = !isVerticalMovement ? currentValue(detail).y :
            f(currentValue(detail).y, minY(detail), maxY(detail), step(detail, useMultiplier));
        fireSliderChange(spectrum, sliderValue(xValue, yValue));
        return Optional.some(xValue);
    };
    const handleMovement = (direction, isVerticalMovement) => (spectrum, detail, useMultiplier) => moveBy(direction, isVerticalMovement, spectrum, detail, useMultiplier).map(always);
    // fire a slider change event with the minimum value
    const setToMin = (spectrum, detail) => {
        const mX = minX(detail);
        const mY = minY(detail);
        fireSliderChange(spectrum, sliderValue(mX, mY));
    };
    // fire a slider change event with the maximum value
    const setToMax = (spectrum, detail) => {
        const mX = maxX(detail);
        const mY = maxY(detail);
        fireSliderChange(spectrum, sliderValue(mX, mY));
    };
    // get event data as a SugarPosition
    const getValueFromEvent = (simulatedEvent) => getEventSource(simulatedEvent);
    // update the position of the thumb from the slider's current value
    const setPositionFromValue = (slider, thumb, detail, edges) => {
        const value = currentValue(detail);
        const xPos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value.x, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
        const yPos = findPositionOfValue(slider, edges.getSpectrum(slider), value.y, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
        const thumbXRadius = get$c(thumb.element) / 2;
        const thumbYRadius = get$d(thumb.element) / 2;
        set$7(thumb.element, 'left', (xPos - thumbXRadius) + 'px');
        set$7(thumb.element, 'top', (yPos - thumbYRadius) + 'px');
    };
    // Key Events
    const onLeft = handleMovement(-1, false);
    const onRight = handleMovement(1, false);
    const onUp = handleMovement(-1, true);
    const onDown = handleMovement(1, true);
    // Edge Click Actions
    const edgeActions = {
        'top-left': Optional.some(setToTLEdgeXY),
        'top': Optional.some(setToTEdgeXY),
        'top-right': Optional.some(setToTREdgeXY),
        'right': Optional.some(setToREdgeXY),
        'bottom-right': Optional.some(setToBREdgeXY),
        'bottom': Optional.some(setToBEdgeXY),
        'bottom-left': Optional.some(setToBLEdgeXY),
        'left': Optional.some(setToLEdgeXY)
    };

    var TwoDModel = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom,
        setToMin: setToMin,
        setToMax: setToMax,
        getValueFromEvent: getValueFromEvent,
        setPositionFromValue: setPositionFromValue,
        onLeft: onLeft,
        onRight: onRight,
        onUp: onUp,
        onDown: onDown,
        edgeActions: edgeActions
    });

    const SliderSchema = [
        defaulted('stepSize', 1),
        defaulted('speedMultiplier', 10),
        defaulted('onChange', noop),
        defaulted('onChoose', noop),
        defaulted('onInit', noop),
        defaulted('onDragStart', noop),
        defaulted('onDragEnd', noop),
        defaulted('snapToGrid', false),
        defaulted('rounded', true),
        option$3('snapStart'),
        requiredOf('model', choose$1('mode', {
            x: [
                defaulted('minX', 0),
                defaulted('maxX', 100),
                customField('value', (spec) => Cell(spec.mode.minX)),
                required$1('getInitialValue'),
                output$1('manager', HorizontalModel)
            ],
            y: [
                defaulted('minY', 0),
                defaulted('maxY', 100),
                customField('value', (spec) => Cell(spec.mode.minY)),
                required$1('getInitialValue'),
                output$1('manager', VerticalModel)
            ],
            xy: [
                defaulted('minX', 0),
                defaulted('maxX', 100),
                defaulted('minY', 0),
                defaulted('maxY', 100),
                customField('value', (spec) => Cell({
                    x: spec.mode.minX,
                    y: spec.mode.minY
                })),
                required$1('getInitialValue'),
                output$1('manager', TwoDModel)
            ]
        })),
        field('sliderBehaviours', [Keying, Representing]),
        customField('mouseIsDown', () => Cell(false))
    ];

    const sketch$1 = (detail, components, _spec, _externals) => {
        const getThumb = (component) => getPartOrDie(component, detail, 'thumb');
        const getSpectrum = (component) => getPartOrDie(component, detail, 'spectrum');
        const getLeftEdge = (component) => getPart(component, detail, 'left-edge');
        const getRightEdge = (component) => getPart(component, detail, 'right-edge');
        const getTopEdge = (component) => getPart(component, detail, 'top-edge');
        const getBottomEdge = (component) => getPart(component, detail, 'bottom-edge');
        const modelDetail = detail.model;
        const model = modelDetail.manager;
        const refresh = (slider, thumb) => {
            model.setPositionFromValue(slider, thumb, detail, {
                getLeftEdge,
                getRightEdge,
                getTopEdge,
                getBottomEdge,
                getSpectrum
            });
        };
        const setValue = (slider, newValue) => {
            modelDetail.value.set(newValue);
            const thumb = getThumb(slider);
            refresh(slider, thumb);
        };
        const changeValue = (slider, newValue) => {
            setValue(slider, newValue);
            const thumb = getThumb(slider);
            detail.onChange(slider, thumb, newValue);
            return Optional.some(true);
        };
        const resetToMin = (slider) => {
            model.setToMin(slider, detail);
        };
        const resetToMax = (slider) => {
            model.setToMax(slider, detail);
        };
        const choose = (slider) => {
            const fireOnChoose = () => {
                getPart(slider, detail, 'thumb').each((thumb) => {
                    const value = modelDetail.value.get();
                    detail.onChoose(slider, thumb, value);
                });
            };
            const wasDown = detail.mouseIsDown.get();
            detail.mouseIsDown.set(false);
            // We don't want this to fire if the mouse wasn't pressed down over anything other than the slider.
            if (wasDown) {
                fireOnChoose();
            }
        };
        const onDragStart = (slider, simulatedEvent) => {
            simulatedEvent.stop();
            detail.mouseIsDown.set(true);
            detail.onDragStart(slider, getThumb(slider));
        };
        const onDragEnd = (slider, simulatedEvent) => {
            simulatedEvent.stop();
            detail.onDragEnd(slider, getThumb(slider));
            choose(slider);
        };
        const focusWidget = (component) => {
            getPart(component, detail, 'spectrum').map(Keying.focusIn);
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.sliderBehaviours, [
                Keying.config({
                    mode: 'special',
                    focusIn: focusWidget
                }),
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue: (_) => {
                            return modelDetail.value.get();
                        },
                        setValue
                    }
                }),
                Receiving.config({
                    channels: {
                        [mouseReleased()]: {
                            onReceive: choose
                        }
                    }
                })
            ]),
            events: derive$2([
                run$1(sliderChangeEvent(), (slider, simulatedEvent) => {
                    changeValue(slider, simulatedEvent.event.value);
                }),
                runOnAttached((slider, _simulatedEvent) => {
                    // Set the initial value
                    const getInitial = modelDetail.getInitialValue();
                    modelDetail.value.set(getInitial);
                    const thumb = getThumb(slider);
                    refresh(slider, thumb);
                    const spectrum = getSpectrum(slider);
                    // Call onInit instead of onChange for the first value.
                    detail.onInit(slider, thumb, spectrum, modelDetail.value.get());
                }),
                run$1(touchstart(), onDragStart),
                run$1(touchend(), onDragEnd),
                run$1(mousedown(), (component, event) => {
                    focusWidget(component);
                    onDragStart(component, event);
                }),
                run$1(mouseup(), onDragEnd),
            ]),
            apis: {
                resetToMin,
                resetToMax,
                setValue,
                refresh
            },
            domModification: {
                styles: {
                    position: 'relative'
                }
            }
        };
    };

    const Slider = composite({
        name: 'Slider',
        configFields: SliderSchema,
        partFields: SliderParts,
        factory: sketch$1,
        apis: {
            setValue: (apis, slider, value) => {
                apis.setValue(slider, value);
            },
            resetToMin: (apis, slider) => {
                apis.resetToMin(slider);
            },
            resetToMax: (apis, slider) => {
                apis.resetToMax(slider);
            },
            refresh: (apis, slider) => {
                apis.refresh(slider);
            }
        }
    });

    const owner = 'container';
    const schema$7 = [
        field('slotBehaviours', [])
    ];
    const getPartName = (name) => '<alloy.field.' + name + '>';
    const sketch = (sSpec) => {
        // As parts.slot is called, record all of the parts that are registered
        // as part of this SlotContainer.
        const parts = (() => {
            const record = [];
            const slot = (name, config) => {
                record.push(name);
                return generateOne$1(owner, getPartName(name), config);
            };
            return {
                slot,
                record: constant$1(record)
            };
        })();
        const spec = sSpec(parts);
        const partNames = parts.record();
        // Like a Form, a SlotContainer does not know its parts in advance. So the
        // record lists the names of the parts to put in the schema.
        // TODO: Find a nice way to remove dupe with Form
        const fieldParts = map$2(partNames, (n) => required({ name: n, pname: getPartName(n) }));
        return composite$1(owner, schema$7, fieldParts, make$3, spec);
    };
    const make$3 = (detail, components) => {
        const getSlotNames = (_) => getAllPartNames(detail);
        const getSlot = (container, key) => getPart(container, detail, key);
        const onSlot = (f, def) => (container, key) => getPart(container, detail, key).map((slot) => f(slot, key)).getOr(def);
        const onSlots = (f) => (container, keys) => {
            each$1(keys, (key) => f(container, key));
        };
        const doShowing = (comp, _key) => get$g(comp.element, 'aria-hidden') !== 'true';
        const doShow = (comp, key) => {
            // NOTE: May need to restore old values.
            if (!doShowing(comp)) {
                const element = comp.element;
                remove$6(element, 'display');
                remove$8(element, 'aria-hidden');
                emitWith(comp, slotVisibility(), { name: key, visible: true });
            }
        };
        const doHide = (comp, key) => {
            // NOTE: May need to save old values.
            if (doShowing(comp)) {
                const element = comp.element;
                set$7(element, 'display', 'none');
                set$9(element, 'aria-hidden', 'true');
                emitWith(comp, slotVisibility(), { name: key, visible: false });
            }
        };
        const isShowing = onSlot(doShowing, false);
        const hideSlot = onSlot(doHide);
        const hideSlots = onSlots(hideSlot);
        const hideAllSlots = (container) => hideSlots(container, getSlotNames());
        const showSlot = onSlot(doShow);
        const apis = {
            getSlotNames,
            getSlot,
            isShowing,
            hideSlot,
            hideAllSlots,
            showSlot
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: get$2(detail.slotBehaviours),
            apis
        };
    };
    // No type safety doing it this way. But removes dupe.
    // We could probably use spread operator to help here.
    const slotApis = map$1({
        getSlotNames: (apis, c) => apis.getSlotNames(c),
        getSlot: (apis, c, key) => apis.getSlot(c, key),
        isShowing: (apis, c, key) => apis.isShowing(c, key),
        hideSlot: (apis, c, key) => apis.hideSlot(c, key),
        hideAllSlots: (apis, c) => apis.hideAllSlots(c),
        showSlot: (apis, c, key) => apis.showSlot(c, key)
    }, (value) => makeApi(value));
    const SlotContainer = {
        ...slotApis,
        ...{ sketch }
    };

    const generate$1 = (xs, f) => {
        const init = {
            len: 0,
            list: []
        };
        const r = foldl(xs, (b, a) => {
            const value = f(a, b.len);
            return value.fold(constant$1(b), (v) => ({
                len: v.finish,
                list: b.list.concat([v])
            }));
        }, init);
        return r.list;
    };

    const output = (within, extra, withinWidth) => ({
        within,
        extra,
        withinWidth
    });
    const apportion = (units, total, len) => {
        const parray = generate$1(units, (unit, current) => {
            const width = len(unit);
            return Optional.some({
                element: unit,
                start: current,
                finish: current + width,
                width
            });
        });
        const within = filter$2(parray, (unit) => unit.finish <= total);
        const withinWidth = foldr(within, (acc, el) => acc + el.width, 0);
        const extra = parray.slice(within.length);
        return {
            within,
            extra,
            withinWidth
        };
    };
    const toUnit = (parray) => map$2(parray, (unit) => unit.element);
    const fitLast = (within, extra, withinWidth) => {
        const fits = toUnit(within.concat(extra));
        return output(fits, [], withinWidth);
    };
    const overflow = (within, extra, overflower, withinWidth) => {
        const fits = toUnit(within).concat([overflower]);
        return output(fits, toUnit(extra), withinWidth);
    };
    const fitAll = (within, extra, withinWidth) => output(toUnit(within), [], withinWidth);
    const tryFit = (total, units, len) => {
        const divide = apportion(units, total, len);
        return divide.extra.length === 0 ? Optional.some(divide) : Optional.none();
    };
    const partition = (total, units, len, overflower) => {
        // Firstly, we try without the overflower.
        const divide = tryFit(total, units, len).getOrThunk(() => 
        // If that doesn't work, overflow
        apportion(units, total - len(overflower), len));
        const within = divide.within;
        const extra = divide.extra;
        const withinWidth = divide.withinWidth;
        if (extra.length === 1 && extra[0].width <= len(overflower)) {
            return fitLast(within, extra, withinWidth);
        }
        else if (extra.length >= 1) {
            return overflow(within, extra, overflower, withinWidth);
        }
        else {
            return fitAll(within, extra, withinWidth);
        }
    };

    const setGroups = (toolbar, storedGroups) => {
        const bGroups = map$2(storedGroups, (g) => premade(g));
        Toolbar.setGroups(toolbar, bGroups);
    };
    const findFocusedComp = (comps) => findMap(comps, (comp) => search(comp.element).bind((focusedElm) => comp.getSystem().getByDom(focusedElm).toOptional()));
    const refresh$2 = (toolbar, detail, setOverflow) => {
        // Ensure we have toolbar groups to render
        const builtGroups = detail.builtGroups.get();
        if (builtGroups.length === 0) {
            return;
        }
        const primary = getPartOrDie(toolbar, detail, 'primary');
        const overflowGroup = Coupling.getCoupled(toolbar, 'overflowGroup');
        // Set the primary toolbar to have visibility hidden;
        set$7(primary.element, 'visibility', 'hidden');
        const groups = builtGroups.concat([overflowGroup]);
        // Store the current focus state
        const focusedComp = findFocusedComp(groups);
        // Clear the overflow toolbar
        setOverflow([]);
        // Put all the groups inside the primary toolbar
        setGroups(primary, groups);
        const availableWidth = get$c(primary.element);
        const overflows = partition(availableWidth, detail.builtGroups.get(), (comp) => Math.ceil(comp.element.dom.getBoundingClientRect().width), overflowGroup);
        if (overflows.extra.length === 0) {
            // Not ideal. Breaking abstraction somewhat, though remove is better than insert
            // Can just reset the toolbar groups also ... but may be a bit slower.
            Replacing.remove(primary, overflowGroup);
            setOverflow([]);
        }
        else {
            setGroups(primary, overflows.within);
            setOverflow(overflows.extra);
        }
        remove$6(primary.element, 'visibility');
        reflow(primary.element);
        // Restore the focus
        focusedComp.each(Focusing.focus);
    };

    const schema$6 = constant$1([
        field('splitToolbarBehaviours', [Coupling]),
        customField('builtGroups', () => Cell([]))
    ]);

    const schema$5 = constant$1([
        markers$1(['overflowToggledClass']),
        optionFunction('getOverflowBounds'),
        required$1('lazySink'),
        customField('overflowGroups', () => Cell([])),
        onHandler('onOpened'),
        onHandler('onClosed')
    ].concat(schema$6()));
    const parts$5 = constant$1([
        required({
            factory: Toolbar,
            schema: schema$d(),
            name: 'primary'
        }),
        external$1({
            schema: schema$d(),
            name: 'overflow'
        }),
        external$1({
            name: 'overflow-button'
        }),
        external$1({
            name: 'overflow-group'
        })
    ]);

    const schema$4 = constant$1([
        required$1('items'),
        markers$1(['itemSelector']),
        field('tgroupBehaviours', [Keying])
    ]);
    const parts$4 = constant$1([
        group({
            name: 'items',
            unit: 'item'
        })
    ]);

    const factory$b = (detail, components, _spec, _externals) => ({
        uid: detail.uid,
        dom: detail.dom,
        components,
        behaviours: augment(detail.tgroupBehaviours, [
            Keying.config({
                mode: 'flow',
                selector: detail.markers.itemSelector
            })
        ]),
        domModification: {
            attributes: {
                role: 'toolbar'
            }
        }
    });
    const ToolbarGroup = composite({
        name: 'ToolbarGroup',
        configFields: schema$4(),
        partFields: parts$4(),
        factory: factory$b
    });

    const buildGroups = (comps) => map$2(comps, (g) => premade(g));
    const refresh$1 = (toolbar, memFloatingToolbarButton, detail) => {
        refresh$2(toolbar, detail, (overflowGroups) => {
            detail.overflowGroups.set(overflowGroups);
            memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton) => {
                FloatingToolbarButton.setGroups(floatingToolbarButton, buildGroups(overflowGroups));
            });
        });
    };
    const factory$a = (detail, components, spec, externals) => {
        const memFloatingToolbarButton = record(FloatingToolbarButton.sketch({
            fetch: () => Future.nu((resolve) => {
                resolve(buildGroups(detail.overflowGroups.get()));
            }),
            layouts: {
                onLtr: () => [southwest$2, southeast$2],
                onRtl: () => [southeast$2, southwest$2],
                onBottomLtr: () => [northwest$2, northeast$2],
                onBottomRtl: () => [northeast$2, northwest$2]
            },
            getBounds: spec.getOverflowBounds,
            lazySink: detail.lazySink,
            fireDismissalEventInstead: {},
            markers: {
                toggledClass: detail.markers.overflowToggledClass
            },
            parts: {
                button: externals['overflow-button'](),
                toolbar: externals.overflow()
            },
            onToggled: (comp, state) => detail[state ? 'onOpened' : 'onClosed'](comp)
        }));
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.splitToolbarBehaviours, [
                Coupling.config({
                    others: {
                        overflowGroup: () => {
                            return ToolbarGroup.sketch({
                                ...externals['overflow-group'](),
                                items: [
                                    memFloatingToolbarButton.asSpec()
                                ]
                            });
                        }
                    }
                })
            ]),
            apis: {
                setGroups: (toolbar, groups) => {
                    detail.builtGroups.set(map$2(groups, toolbar.getSystem().build));
                    refresh$1(toolbar, memFloatingToolbarButton, detail);
                },
                refresh: (toolbar) => refresh$1(toolbar, memFloatingToolbarButton, detail),
                toggle: (toolbar) => {
                    memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton) => {
                        FloatingToolbarButton.toggle(floatingToolbarButton);
                    });
                },
                toggleWithoutFocusing: (toolbar) => {
                    memFloatingToolbarButton.getOpt(toolbar).each(FloatingToolbarButton.toggleWithoutFocusing);
                },
                isOpen: (toolbar) => memFloatingToolbarButton.getOpt(toolbar).map(FloatingToolbarButton.isOpen).getOr(false),
                reposition: (toolbar) => {
                    memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton) => {
                        FloatingToolbarButton.reposition(floatingToolbarButton);
                    });
                },
                getOverflow: (toolbar) => memFloatingToolbarButton.getOpt(toolbar).bind(FloatingToolbarButton.getToolbar)
            },
            domModification: {
                attributes: { role: 'group' }
            }
        };
    };
    const SplitFloatingToolbar = composite({
        name: 'SplitFloatingToolbar',
        configFields: schema$5(),
        partFields: parts$5(),
        factory: factory$a,
        apis: {
            setGroups: (apis, toolbar, groups) => {
                apis.setGroups(toolbar, groups);
            },
            refresh: (apis, toolbar) => {
                apis.refresh(toolbar);
            },
            reposition: (apis, toolbar) => {
                apis.reposition(toolbar);
            },
            toggle: (apis, toolbar) => {
                apis.toggle(toolbar);
            },
            toggleWithoutFocusing: (apis, toolbar) => {
                apis.toggle(toolbar);
            },
            isOpen: (apis, toolbar) => apis.isOpen(toolbar),
            getOverflow: (apis, toolbar) => apis.getOverflow(toolbar)
        }
    });

    const schema$3 = constant$1([
        markers$1(['closedClass', 'openClass', 'shrinkingClass', 'growingClass', 'overflowToggledClass']),
        onHandler('onOpened'),
        onHandler('onClosed')
    ].concat(schema$6()));
    const parts$3 = constant$1([
        required({
            factory: Toolbar,
            schema: schema$d(),
            name: 'primary'
        }),
        required({
            factory: Toolbar,
            schema: schema$d(),
            name: 'overflow',
            overrides: (detail) => {
                return {
                    toolbarBehaviours: derive$1([
                        Sliding.config({
                            dimension: {
                                property: 'height'
                            },
                            closedClass: detail.markers.closedClass,
                            openClass: detail.markers.openClass,
                            shrinkingClass: detail.markers.shrinkingClass,
                            growingClass: detail.markers.growingClass,
                            onShrunk: (comp) => {
                                getPart(comp, detail, 'overflow-button').each((button) => {
                                    Toggling.off(button);
                                });
                                detail.onClosed(comp);
                            },
                            onGrown: (comp) => {
                                detail.onOpened(comp);
                            },
                            onStartGrow: (comp) => {
                                getPart(comp, detail, 'overflow-button').each(Toggling.on);
                            }
                        }),
                        Keying.config({
                            mode: 'acyclic',
                            onEscape: (comp) => {
                                getPart(comp, detail, 'overflow-button').each(Focusing.focus);
                                return Optional.some(true);
                            }
                        })
                    ])
                };
            }
        }),
        external$1({
            name: 'overflow-button',
            overrides: (detail) => ({
                buttonBehaviours: derive$1([
                    Toggling.config({
                        toggleClass: detail.markers.overflowToggledClass,
                        aria: {
                            mode: 'expanded'
                        },
                        toggleOnExecute: false
                    })
                ])
            })
        }),
        external$1({
            name: 'overflow-group'
        })
    ]);

    const isOpen = (toolbar, detail) => getPart(toolbar, detail, 'overflow').map(Sliding.hasGrown).getOr(false);
    const toggleToolbar = (toolbar, detail, skipFocus) => {
        // Make sure that the toolbar needs to toggled by checking for overflow button presence
        getPart(toolbar, detail, 'overflow-button')
            .each((oveflowButton) => {
            getPart(toolbar, detail, 'overflow').each((overf) => {
                refresh(toolbar, detail);
                if (Sliding.hasShrunk(overf)) {
                    const fn = detail.onOpened;
                    detail.onOpened = (comp) => {
                        if (!skipFocus) {
                            Keying.focusIn(overf);
                        }
                        fn(comp);
                        detail.onOpened = fn;
                    };
                }
                else {
                    const fn = detail.onClosed;
                    detail.onClosed = (comp) => {
                        if (!skipFocus) {
                            Focusing.focus(oveflowButton);
                        }
                        fn(comp);
                        detail.onClosed = fn;
                    };
                }
                Sliding.toggleGrow(overf);
            });
        });
    };
    const refresh = (toolbar, detail) => {
        getPart(toolbar, detail, 'overflow').each((overflow) => {
            refresh$2(toolbar, detail, (groups) => {
                const builtGroups = map$2(groups, (g) => premade(g));
                Toolbar.setGroups(overflow, builtGroups);
            });
            getPart(toolbar, detail, 'overflow-button').each((button) => {
                if (Sliding.hasGrown(overflow)) {
                    Toggling.on(button);
                }
            });
            Sliding.refresh(overflow);
        });
    };
    const factory$9 = (detail, components, spec, externals) => {
        const toolbarToggleEvent = 'alloy.toolbar.toggle';
        const doSetGroups = (toolbar, groups) => {
            const built = map$2(groups, toolbar.getSystem().build);
            detail.builtGroups.set(built);
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.splitToolbarBehaviours, [
                Coupling.config({
                    others: {
                        overflowGroup: (toolbar) => {
                            return ToolbarGroup.sketch({
                                ...externals['overflow-group'](),
                                items: [
                                    Button.sketch({
                                        ...externals['overflow-button'](),
                                        action: (_button) => {
                                            emit(toolbar, toolbarToggleEvent);
                                        }
                                    })
                                ]
                            });
                        }
                    }
                }),
                config('toolbar-toggle-events', [
                    run$1(toolbarToggleEvent, (toolbar) => {
                        toggleToolbar(toolbar, detail, false);
                    })
                ])
            ]),
            apis: {
                setGroups: (toolbar, groups) => {
                    doSetGroups(toolbar, groups);
                    refresh(toolbar, detail);
                },
                refresh: (toolbar) => refresh(toolbar, detail),
                toggle: (toolbar) => {
                    toggleToolbar(toolbar, detail, false);
                },
                toggleWithoutFocusing: (toolbar) => {
                    toggleToolbar(toolbar, detail, true);
                },
                isOpen: (toolbar) => isOpen(toolbar, detail)
            },
            domModification: {
                attributes: { role: 'group' }
            }
        };
    };
    const SplitSlidingToolbar = composite({
        name: 'SplitSlidingToolbar',
        configFields: schema$3(),
        partFields: parts$3(),
        factory: factory$9,
        apis: {
            setGroups: (apis, toolbar, groups) => {
                apis.setGroups(toolbar, groups);
            },
            refresh: (apis, toolbar) => {
                apis.refresh(toolbar);
            },
            toggle: (apis, toolbar) => {
                apis.toggle(toolbar);
            },
            isOpen: (apis, toolbar) => apis.isOpen(toolbar)
        }
    });

    const factory$8 = (detail, _spec) => ({
        uid: detail.uid,
        dom: detail.dom,
        components: detail.components,
        events: events(detail.action),
        behaviours: augment(detail.tabButtonBehaviours, [
            Focusing.config({}),
            Keying.config({
                mode: 'execution',
                useSpace: true,
                useEnter: true
            }),
            Representing.config({
                store: {
                    mode: 'memory',
                    initialValue: detail.value
                }
            })
        ]),
        domModification: detail.domModification
    });
    const TabButton = single({
        name: 'TabButton',
        configFields: [
            defaulted('uid', undefined),
            required$1('value'),
            field$1('dom', 'dom', mergeWithThunk(() => ({
                attributes: {
                    'role': 'tab',
                    // NOTE: This is used in TabSection to connect "labelledby"
                    'id': generate$6('aria'),
                    'aria-selected': 'false'
                }
            })), anyValue()),
            option$3('action'),
            defaulted('domModification', {}),
            field('tabButtonBehaviours', [Focusing, Keying, Representing]),
            required$1('view')
        ],
        factory: factory$8
    });

    const schema$2 = constant$1([
        required$1('tabs'),
        required$1('dom'),
        defaulted('clickToDismiss', false),
        field('tabbarBehaviours', [Highlighting, Keying]),
        markers$1(['tabClass', 'selectedClass'])
    ]);
    const tabsPart = group({
        factory: TabButton,
        name: 'tabs',
        unit: 'tab',
        overrides: (barDetail) => {
            const dismissTab$1 = (tabbar, button) => {
                Highlighting.dehighlight(tabbar, button);
                emitWith(tabbar, dismissTab(), {
                    tabbar,
                    button
                });
            };
            const changeTab$1 = (tabbar, button) => {
                Highlighting.highlight(tabbar, button);
                emitWith(tabbar, changeTab(), {
                    tabbar,
                    button
                });
            };
            return {
                action: (button) => {
                    const tabbar = button.getSystem().getByUid(barDetail.uid).getOrDie();
                    const activeButton = Highlighting.isHighlighted(tabbar, button);
                    const response = (() => {
                        if (activeButton && barDetail.clickToDismiss) {
                            return dismissTab$1;
                        }
                        else if (!activeButton) {
                            return changeTab$1;
                        }
                        else {
                            return noop;
                        }
                    })();
                    response(tabbar, button);
                },
                domModification: {
                    classes: [barDetail.markers.tabClass]
                }
            };
        }
    });
    const parts$2 = constant$1([
        tabsPart
    ]);

    const factory$7 = (detail, components, _spec, _externals) => ({
        'uid': detail.uid,
        'dom': detail.dom,
        components,
        'debug.sketcher': 'Tabbar',
        'domModification': {
            attributes: {
                role: 'tablist'
            }
        },
        'behaviours': augment(detail.tabbarBehaviours, [
            Highlighting.config({
                highlightClass: detail.markers.selectedClass,
                itemClass: detail.markers.tabClass,
                // https://www.w3.org/TR/2010/WD-wai-aria-practices-20100916/#tabpanel
                // Consider a more seam-less way of combining highlighting and toggling
                onHighlight: (tabbar, tab) => {
                    // TODO: Integrate highlighting and toggling in a nice way
                    set$9(tab.element, 'aria-selected', 'true');
                },
                onDehighlight: (tabbar, tab) => {
                    set$9(tab.element, 'aria-selected', 'false');
                }
            }),
            Keying.config({
                mode: 'flow',
                getInitial: (tabbar) => {
                    // Restore focus to the previously highlighted tab.
                    return Highlighting.getHighlighted(tabbar).map((tab) => tab.element);
                },
                selector: '.' + detail.markers.tabClass,
                executeOnMove: true
            })
        ])
    });
    const Tabbar = composite({
        name: 'Tabbar',
        configFields: schema$2(),
        partFields: parts$2(),
        factory: factory$7
    });

    const factory$6 = (detail, _spec) => ({
        uid: detail.uid,
        dom: detail.dom,
        behaviours: augment(detail.tabviewBehaviours, [
            Replacing.config({})
        ]),
        domModification: {
            attributes: { role: 'tabpanel' }
        }
    });
    const Tabview = single({
        name: 'Tabview',
        configFields: [
            field('tabviewBehaviours', [Replacing])
        ],
        factory: factory$6
    });

    const schema$1 = constant$1([
        defaulted('selectFirst', true),
        onHandler('onChangeTab'),
        onHandler('onDismissTab'),
        defaulted('tabs', []),
        field('tabSectionBehaviours', [])
    ]);
    const barPart = required({
        factory: Tabbar,
        schema: [
            required$1('dom'),
            requiredObjOf('markers', [
                required$1('tabClass'),
                required$1('selectedClass')
            ])
        ],
        name: 'tabbar',
        defaults: (detail) => {
            return {
                tabs: detail.tabs
            };
        }
    });
    const viewPart = required({
        factory: Tabview,
        name: 'tabview'
    });
    const parts$1 = constant$1([
        barPart,
        viewPart
    ]);

    const factory$5 = (detail, components, _spec, _externals) => {
        const changeTab$1 = (button) => {
            const tabValue = Representing.getValue(button);
            getPart(button, detail, 'tabview').each((tabview) => {
                const tabWithValue = find$5(detail.tabs, (t) => t.value === tabValue);
                tabWithValue.each((tabData) => {
                    const panel = tabData.view();
                    // Update the tabview to refer to the current tab.
                    getOpt(button.element, 'id').each((id) => {
                        set$9(tabview.element, 'aria-labelledby', id);
                    });
                    Replacing.set(tabview, panel);
                    detail.onChangeTab(tabview, button, panel);
                });
            });
        };
        const changeTabBy = (section, byPred) => {
            getPart(section, detail, 'tabbar').each((tabbar) => {
                byPred(tabbar).each(emitExecute);
            });
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: get$2(detail.tabSectionBehaviours),
            events: derive$2(flatten([
                detail.selectFirst ? [
                    runOnAttached((section, _simulatedEvent) => {
                        changeTabBy(section, Highlighting.getFirst);
                    })
                ] : [],
                [
                    run$1(changeTab(), (section, simulatedEvent) => {
                        const button = simulatedEvent.event.button;
                        changeTab$1(button);
                    }),
                    run$1(dismissTab(), (section, simulatedEvent) => {
                        const button = simulatedEvent.event.button;
                        detail.onDismissTab(section, button);
                    })
                ]
            ])),
            apis: {
                getViewItems: (section) => {
                    return getPart(section, detail, 'tabview').map((tabview) => Replacing.contents(tabview)).getOr([]);
                },
                // How should "clickToDismiss" interact with this? At the moment, it will never dismiss
                showTab: (section, tabKey) => {
                    // We only change the tab if it isn't currently active because that takes
                    // the whole "dismiss" issue out of the equation.
                    const getTabIfNotActive = (tabbar) => {
                        const candidates = Highlighting.getCandidates(tabbar);
                        const optTab = find$5(candidates, (c) => Representing.getValue(c) === tabKey);
                        return optTab.filter((tab) => !Highlighting.isHighlighted(tabbar, tab));
                    };
                    changeTabBy(section, getTabIfNotActive);
                }
            }
        };
    };
    const TabSection = composite({
        name: 'TabSection',
        configFields: schema$1(),
        partFields: parts$1(),
        factory: factory$5,
        apis: {
            getViewItems: (apis, component) => apis.getViewItems(component),
            showTab: (apis, component, tabKey) => {
                apis.showTab(component, tabKey);
            }
        }
    });

    // When showing a value in an input field, which part of the item do we use?
    const setValueFromItem = (model, input, item) => {
        const itemData = Representing.getValue(item);
        Representing.setValue(input, itemData);
        setCursorAtEnd(input);
    };
    const setSelectionOn = (input, f) => {
        const el = input.element;
        const value = get$5(el);
        const node = el.dom;
        // Only do for valid input types.
        if (get$g(el, 'type') !== 'number') {
            f(node, value);
        }
    };
    const setCursorAtEnd = (input) => {
        setSelectionOn(input, (node, value) => node.setSelectionRange(value.length, value.length));
    };
    const setSelectionToEnd = (input, startOffset) => {
        setSelectionOn(input, (node, value) => node.setSelectionRange(startOffset, value.length));
    };
    const attemptSelectOver = (model, input, item) => {
        if (!model.selectsOver) {
            return Optional.none();
        }
        else {
            const currentValue = Representing.getValue(input);
            const inputDisplay = model.getDisplayText(currentValue);
            const itemValue = Representing.getValue(item);
            const itemDisplay = model.getDisplayText(itemValue);
            return itemDisplay.indexOf(inputDisplay) === 0 ?
                Optional.some(() => {
                    setValueFromItem(model, input, item);
                    setSelectionToEnd(input, inputDisplay.length);
                })
                : Optional.none();
        }
    };

    const itemExecute = constant$1('alloy.typeahead.itemexecute');

    // TODO: Fix this.
    const make$2 = (detail, components, spec, externals) => {
        const navigateList = (comp, simulatedEvent, highlighter) => {
            /*
             * If we have an open Sandbox with an active menu,
             * but no highlighted item, then highlight the menu
             *
             * If we have an open Sandbox with an active menu,
             * and there is a highlighted item, simulated a keydown
             * on the menu
             *
             * If we have a closed sandbox, open the sandbox
             *
             * Regardless, this is a user initiated action. End previewing.
             */
            detail.previewing.set(false);
            const sandbox = Coupling.getCoupled(comp, 'sandbox');
            if (Sandboxing.isOpen(sandbox)) {
                Composing.getCurrent(sandbox).each((menu) => {
                    Highlighting.getHighlighted(menu).fold(() => {
                        highlighter(menu);
                    }, () => {
                        dispatchEvent(sandbox, menu.element, 'keydown', simulatedEvent);
                    });
                });
            }
            else {
                const onOpenSync = (sandbox) => {
                    Composing.getCurrent(sandbox).each(highlighter);
                };
                open(detail, mapFetch(comp), comp, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);
            }
        };
        // Due to the fact that typeahead probably need to separate value from text, they can't reuse
        // (easily) the same representing logic as input fields.
        const focusBehaviours$1 = focusBehaviours(detail);
        const mapFetch = (comp) => (tdata) => tdata.map((data) => {
            const menus = values(data.menus);
            const items = bind$3(menus, (menu) => filter$2(menu.items, (item) => item.type === 'item'));
            const repState = Representing.getState(comp);
            repState.update(map$2(items, (item) => item.data));
            return data;
        });
        // This function (getActiveMenu) is intended to make it easier to read what is happening
        // without having to decipher the Highlighting and Composing calls.
        const getActiveMenu = (sandboxComp) => Composing.getCurrent(sandboxComp);
        const typeaheadCustomEvents = 'typeaheadevents';
        const behaviours = [
            Focusing.config({}),
            Representing.config({
                onSetValue: detail.onSetValue,
                store: {
                    mode: 'dataset',
                    getDataKey: (comp) => get$5(comp.element),
                    // This really needs to be configurable
                    getFallbackEntry: (itemString) => ({
                        value: itemString,
                        meta: {}
                    }),
                    setValue: (comp, data) => {
                        set$4(comp.element, detail.model.getDisplayText(data));
                    },
                    ...detail.initialData.map((d) => wrap('initialValue', d)).getOr({})
                }
            }),
            Streaming.config({
                stream: {
                    mode: 'throttle',
                    delay: detail.responseTime,
                    stopEvent: false
                },
                onStream: (component, _simulatedEvent) => {
                    const sandbox = Coupling.getCoupled(component, 'sandbox');
                    const focusInInput = Focusing.isFocused(component);
                    // You don't want it to change when something else has triggered the change.
                    if (focusInInput) {
                        if (get$5(component.element).length >= detail.minChars) {
                            // Get the value of the previously active (selected/highlighted) item. We
                            // are going to try to preserve this.
                            const previousValue = getActiveMenu(sandbox).bind((activeMenu) => Highlighting.getHighlighted(activeMenu).map(Representing.getValue));
                            // Turning previewing ON here every keystroke is unnecessary, but relies
                            // on the fact that it will be turned off if required by highlighting events.
                            // So even if previewing was supposed to be off, turning it on here is
                            // just temporary, because the onOpenSync below will trigger a highlight
                            // if there was meant to be one, which will turn it off if required.
                            detail.previewing.set(true);
                            const onOpenSync = (_sandbox) => {
                                // This getActiveMenu relies on a menu being highlighted / active
                                getActiveMenu(sandbox).each((activeMenu) => {
                                    // The folds can make this hard to follow, but the basic gist of it is
                                    // that we want to see if we need to highlight one of the items in the
                                    // menu that we just opened. If we do highlight an item, then that
                                    // highlighting action will clear previewing (handled by the TieredMenu
                                    // part configuration for onHighlight). Note: that onOpenSync runs
                                    // *after* the highlightOnOpen setting.
                                    //
                                    // 1. If in "selectsOver" mode and we don't have a previous item,
                                    // then highlight the first one. This one will be used as the basis
                                    // for the "selectsOver" text selection. The act of highlighting the
                                    // first item will take us out of previewing mode. If the "selectsOver"
                                    // operation fails, it should clear the highlight, and restore previewing
                                    // 2. If not in "selectsOver" mode, and we don't have a previous item,
                                    // then we don't highlight anything. This will keep us in previewing
                                    // mode until the menu is interacted with (hover, navigation etc.)
                                    // 3. If we have a previous item, then try and rehighlight it. But if
                                    // we can't, the just highlight the first. Either action will take us
                                    // out of previewing mode.
                                    previousValue.fold(() => {
                                        // We are using "selectOver", so we need *something* to highlight
                                        if (detail.model.selectsOver) {
                                            Highlighting.highlightFirst(activeMenu);
                                        }
                                        // We aren't using "selectOver", so don't highlight anything
                                        // to preserve our "previewing" mode.
                                    }, (pv) => {
                                        // We have a previous item, so if we can't rehighlight it, then
                                        // we'll change to the first item. We want to keep some selection.
                                        Highlighting.highlightBy(activeMenu, (item) => {
                                            const itemData = Representing.getValue(item);
                                            return itemData.value === pv.value;
                                        });
                                        // Highlight first if could not find it?
                                        Highlighting.getHighlighted(activeMenu).orThunk(() => {
                                            Highlighting.highlightFirst(activeMenu);
                                            return Optional.none();
                                        });
                                    });
                                });
                            };
                            open(detail, mapFetch(component), component, sandbox, externals, onOpenSync, 
                            // The onOpenSync takes care of what should be given the highlights, but
                            // we want to highlight just the menu so that the onOpenSync can find the
                            // activeMenu.
                            HighlightOnOpen.HighlightJustMenu).get(noop);
                        }
                    }
                },
                cancelEvent: typeaheadCancel()
            }),
            Keying.config({
                mode: 'special',
                onDown: (comp, simulatedEvent) => {
                    // The navigation here will stop the "previewing" mode, because
                    // now the menu will get focus (fake focus, but focus nevertheless)
                    navigateList(comp, simulatedEvent, Highlighting.highlightFirst);
                    return Optional.some(true);
                },
                onEscape: (comp) => {
                    // Escape only has handling if the sandbox is visible. It has no meaning
                    // to the input itself.
                    const sandbox = Coupling.getCoupled(comp, 'sandbox');
                    if (Sandboxing.isOpen(sandbox)) {
                        Sandboxing.close(sandbox);
                        return Optional.some(true);
                    }
                    return Optional.none();
                },
                onUp: (comp, simulatedEvent) => {
                    // The navigation here will stop the "previewing" mode, because
                    // now the menu will get focus (fake focus, but focus nevertheless)
                    navigateList(comp, simulatedEvent, Highlighting.highlightLast);
                    return Optional.some(true);
                },
                onEnter: (comp) => {
                    const sandbox = Coupling.getCoupled(comp, 'sandbox');
                    const sandboxIsOpen = Sandboxing.isOpen(sandbox);
                    // 'Previewing' means that items are shown but none has been actively selected by the user.
                    // When previewing, all keyboard input should still be processed by the
                    // input itself, not the menu. The menu is not considered to have focus.
                    // 'Previewing' is turned on by (streaming) keystrokes, and turned off by
                    // successful interaction with the menu (navigation, highlighting, hovering).
                    // So if we aren't previewing, and the dropdown sandbox is open, then
                    // we process <enter> keys on the items in the menu. All this will do
                    // is trigger an itemExecute event. The typeahead events (in the spec below)
                    // are responsible for doing something with that event.
                    if (sandboxIsOpen && !detail.previewing.get()) {
                        return getActiveMenu(sandbox).bind((activeMenu) => Highlighting.getHighlighted(activeMenu)).map((item) => {
                            // And item was selected, so trigger execute and consider the
                            // <enter> key 'handled'
                            emitWith(comp, itemExecute(), { item });
                            return true;
                        });
                    }
                    else {
                        // We are either previewing, or the sandbox isn't open, so we should
                        // process the <enter> key inside the input itself. This should cancel
                        // any attempt to fetch data (the typeaheadCancel), and trigger the execute.
                        // We also close the sandbox if it's open.
                        const currentValue = Representing.getValue(comp);
                        emit(comp, typeaheadCancel());
                        detail.onExecute(sandbox, comp, currentValue);
                        // If we're open and previewing, close the sandbox after firing execute.
                        if (sandboxIsOpen) {
                            Sandboxing.close(sandbox);
                        }
                        return Optional.some(true);
                    }
                }
            }),
            Toggling.config({
                toggleClass: detail.markers.openClass,
                aria: {
                    mode: 'expanded'
                }
            }),
            Coupling.config({
                others: {
                    sandbox: (hotspot) => {
                        return makeSandbox$1(detail, hotspot, {
                            onOpen: () => Toggling.on(hotspot),
                            onClose: () => {
                                // TINY-9280: Remove aria-activedescendant that is set when menu item is highlighted
                                detail.lazyTypeaheadComp.get().each((input) => remove$8(input.element, 'aria-activedescendant'));
                                Toggling.off(hotspot);
                            }
                        });
                    }
                }
            }),
            config(typeaheadCustomEvents, [
                runOnAttached((typeaheadComp) => {
                    // Set up the reference to the typeahead, so that it can retrieved from
                    // the tiered menu part, even if the tieredmenu is in a different
                    // system / alloy root / mothership.
                    detail.lazyTypeaheadComp.set(Optional.some(typeaheadComp));
                }),
                runOnDetached((_typeaheadComp) => {
                    detail.lazyTypeaheadComp.set(Optional.none());
                }),
                runOnExecute$1((comp) => {
                    const onOpenSync = noop;
                    togglePopup(detail, mapFetch(comp), comp, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);
                }),
                run$1(itemExecute(), (comp, se) => {
                    const sandbox = Coupling.getCoupled(comp, 'sandbox');
                    // Copy the value from the executed item into the input, because it was "chosen"
                    setValueFromItem(detail.model, comp, se.event.item);
                    emit(comp, typeaheadCancel());
                    detail.onItemExecute(comp, sandbox, se.event.item, Representing.getValue(comp));
                    Sandboxing.close(sandbox);
                    setCursorAtEnd(comp);
                })
            ].concat(detail.dismissOnBlur ? [
                run$1(postBlur(), (typeahead) => {
                    const sandbox = Coupling.getCoupled(typeahead, 'sandbox');
                    // Only close the sandbox if the focus isn't inside it!
                    if (search(sandbox.element).isNone()) {
                        Sandboxing.close(sandbox);
                    }
                })
            ] : []))
        ];
        // The order specified here isn't important. Alloy just requires a
        // deterministic order for the configured behaviours.
        const eventOrder = {
            [detachedFromDom()]: [
                Representing.name(),
                Streaming.name(),
                typeaheadCustomEvents
            ],
            ...detail.eventOrder,
        };
        return {
            uid: detail.uid,
            dom: dom$1(deepMerge(detail, {
                // TODO: Add aria-activedescendant attribute
                inputAttributes: {
                    'role': 'combobox',
                    'aria-autocomplete': 'list',
                    'aria-haspopup': 'true'
                }
            })),
            behaviours: {
                ...focusBehaviours$1,
                ...augment(detail.typeaheadBehaviours, behaviours)
            },
            eventOrder
        };
    };

    const schema = constant$1([
        option$3('lazySink'),
        required$1('fetch'),
        defaulted('minChars', 5),
        defaulted('responseTime', 1000),
        onHandler('onOpen'),
        // TODO: Remove dupe with Dropdown
        defaulted('getHotspot', Optional.some),
        defaulted('getAnchorOverrides', constant$1({})),
        defaulted('layouts', Optional.none()),
        defaulted('eventOrder', {}),
        // Information about what these model settings do can be found in TypeaheadTypes
        defaultedObjOf('model', {}, [
            defaulted('getDisplayText', (itemData) => itemData.meta !== undefined && itemData.meta.text !== undefined ? itemData.meta.text : itemData.value),
            defaulted('selectsOver', true),
            defaulted('populateFromBrowse', true)
        ]),
        onHandler('onSetValue'),
        onKeyboardHandler('onExecute'),
        onHandler('onItemExecute'),
        defaulted('inputClasses', []),
        defaulted('inputAttributes', {}),
        defaulted('inputStyles', {}),
        defaulted('matchWidth', true),
        defaulted('useMinWidth', false),
        defaulted('dismissOnBlur', true),
        markers$1(['openClass']),
        option$3('initialData'),
        option$3('listRole'),
        field('typeaheadBehaviours', [
            Focusing, Representing, Streaming, Keying, Toggling, Coupling
        ]),
        customField('lazyTypeaheadComp', () => Cell(Optional.none)),
        customField('previewing', () => Cell(true))
    ].concat(schema$9()).concat(sandboxFields()));
    const parts = constant$1([
        external$1({
            schema: [
                tieredMenuMarkers()
            ],
            name: 'menu',
            overrides: (detail) => {
                return {
                    fakeFocus: true,
                    onHighlightItem: (_tmenu, menu, item) => {
                        if (!detail.previewing.get()) {
                            // We need to use this type of reference, rather than just looking
                            // it up from the system by uid, because the input and the tieredmenu
                            // might be in different systems.
                            detail.lazyTypeaheadComp.get().each((input) => {
                                if (detail.model.populateFromBrowse) {
                                    setValueFromItem(detail.model, input, item);
                                }
                                // The focus is retained on the input element when the menu is shown, unlike the combobox, in which the focus is passed to the menu.
                                // This results in screen readers not being able to announce the menu or highlighted item.
                                // The solution is to tell screen readers which menu item is highlighted using the `aria-activedescendant` attribute.
                                // TINY-9280: The aria attribute is removed when the menu is closed.
                                // Since `onDehighlight` is called only when highlighting a new menu item, this will be handled in
                                // https://github.com/tinymce/tinymce/blob/2d8c1c034e8aa484b868a0c44605489ee0ca9cd4/modules/alloy/src/main/ts/ephox/alloy/ui/composite/TypeaheadSpec.ts#L282
                                getOpt(item.element, 'id').each((id) => set$9(input.element, 'aria-activedescendant', id));
                            });
                        }
                        else {
                            // ASSUMPTION: Currently, any interaction with the menu via the keyboard or the mouse
                            // will firstly clear previewing mode before triggering any highlights
                            // so if we are still in previewing mode by the time we get to the highlight call,
                            // that means that the highlight was triggered NOT by the user interacting
                            // with the menu, but instead by the Highlighting API call that happens automatically
                            // when a streamed keyboard input event is updating its results. That call will
                            // try to keep any active highlight if there already was one (defaulting to first
                            // if it can't find the original), but if there wasn't an active highlight, but
                            // it is using "selectsOver", it will just highlight the first item. In this
                            // latter case, it is only doing that so that selectsOver has something to copy.
                            // So all of the complex code below is trying to handle whether we should stay
                            // in previewing mode after this highlight, and the ONLY case where we should stay
                            // in previewing mode is that we were in previewing mode, we are using selectsOver,
                            // and the selectsOver failed to succeed. In that case, to stay in previewing mode,
                            // we want to cancel the highlight that we just made via the highlighting API
                            // and reset previewing to true. Otherwise, all codepaths should set previewing
                            // to false, because now we have a valid highlight.
                            //
                            // As of 2022-08-18, the selectsOver model is not in use by TinyMCE, so
                            // this subtle interaction is unfortunately largely untested. Also, if we can't
                            // get a reference to the typeahead input by lazyTypeaheadComp, then we don't
                            // change previewing, either. Note also, that it is likely that if we checked
                            // if selectsOver would succeed before setting the highlight in the streaming
                            // response, this could might be a lot easier to follow.
                            detail.lazyTypeaheadComp.get().each((input) => {
                                attemptSelectOver(detail.model, input, item).fold(
                                // If we are in "previewing" mode and we can't select over the
                                // thing that is first, then clear the highlight.
                                // Hopefully, this doesn't cause a flicker. Find a better
                                // way to do this.
                                () => {
                                    // If using "selectOver", we essentially want to cancel the highlight
                                    // that was only invoked just so that we'd have something to selectOver,
                                    // so we dehighlight, and then, importantly, *DON'T* clear previewing.
                                    // We'll set it to be true to be explicit, although it should
                                    // always be true if it reached here (unless an above function changed
                                    // it)
                                    if (detail.model.selectsOver) {
                                        Highlighting.dehighlight(menu, item);
                                        detail.previewing.set(true);
                                    }
                                    else {
                                        // Because we aren't using selectsOver mode, we now want to keep
                                        // whatever highlight we just made, and because we have a highlighted
                                        // item in the menu, we are no longer previewing.
                                        detail.previewing.set(false);
                                    }
                                }, ((selectOverTextInInput) => {
                                    // We have made a selection in the menu, and have selected over text
                                    // in the input, so clear previewing.
                                    selectOverTextInInput();
                                    detail.previewing.set(false);
                                }));
                            });
                        }
                    },
                    // Because the focus stays inside the input, this onExecute is fired when the
                    // user "clicks" on an item. The focusing behaviour should be configured
                    // so that items don't get focus, but they prevent a mousedown event from
                    // firing so that the typeahead doesn't lose focus. This is the handler
                    // for clicking on an item. We need to close the sandbox, update the typeahead
                    // to show the item clicked on, and fire an execute.
                    onExecute: (_menu, item) => {
                        // Note: This will only work when the typeahead and menu are in the same system.
                        return detail.lazyTypeaheadComp.get().map((typeahead) => {
                            emitWith(typeahead, itemExecute(), { item });
                            return true;
                        });
                    },
                    onHover: (menu, item) => {
                        // Hovering is also a user-initiated action, so previewing mode is over.
                        // TODO: Have a better API for managing state in between parts.
                        detail.previewing.set(false);
                        detail.lazyTypeaheadComp.get().each((input) => {
                            if (detail.model.populateFromBrowse) {
                                setValueFromItem(detail.model, input, item);
                            }
                        });
                    }
                };
            }
        })
    ]);

    const Typeahead = composite({
        name: 'Typeahead',
        configFields: schema(),
        partFields: parts(),
        factory: make$2
    });

    var global$b = tinymce.util.Tools.resolve('tinymce.ThemeManager');

    var global$a = tinymce.util.Tools.resolve('tinymce.util.Delay');

    var global$9 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');

    var global$8 = tinymce.util.Tools.resolve('tinymce.EditorManager');

    var global$7 = tinymce.util.Tools.resolve('tinymce.Env');

    var ToolbarMode$1;
    (function (ToolbarMode) {
        ToolbarMode["default"] = "wrap";
        ToolbarMode["floating"] = "floating";
        ToolbarMode["sliding"] = "sliding";
        ToolbarMode["scrolling"] = "scrolling";
    })(ToolbarMode$1 || (ToolbarMode$1 = {}));
    var ToolbarLocation$1;
    (function (ToolbarLocation) {
        ToolbarLocation["auto"] = "auto";
        ToolbarLocation["top"] = "top";
        ToolbarLocation["bottom"] = "bottom";
    })(ToolbarLocation$1 || (ToolbarLocation$1 = {}));
    const option$2 = (name) => (editor) => editor.options.get(name);
    const wrapOptional = (fn) => (editor) => Optional.from(fn(editor));
    const register$f = (editor) => {
        const isPhone = global$7.deviceType.isPhone();
        const isMobile = global$7.deviceType.isTablet() || isPhone;
        const registerOption = editor.options.register;
        const stringOrFalseProcessor = (value) => isString(value) || value === false;
        const stringOrNumberProcessor = (value) => isString(value) || isNumber(value);
        registerOption('skin', {
            processor: (value) => isString(value) || value === false,
            default: 'oxide'
        });
        registerOption('skin_url', {
            processor: 'string'
        });
        registerOption('height', {
            processor: stringOrNumberProcessor,
            default: Math.max(editor.getElement().offsetHeight, 400)
        });
        registerOption('width', {
            processor: stringOrNumberProcessor,
            default: global$9.DOM.getStyle(editor.getElement(), 'width')
        });
        registerOption('min_height', {
            processor: 'number',
            default: 100
        });
        registerOption('min_width', {
            processor: 'number'
        });
        registerOption('max_height', {
            processor: 'number'
        });
        registerOption('max_width', {
            processor: 'number'
        });
        registerOption('style_formats', {
            processor: 'object[]'
        });
        registerOption('style_formats_merge', {
            processor: 'boolean',
            default: false
        });
        registerOption('style_formats_autohide', {
            processor: 'boolean',
            default: false
        });
        registerOption('line_height_formats', {
            processor: 'string',
            default: '1 1.1 1.2 1.3 1.4 1.5 2'
        });
        registerOption('font_family_formats', {
            processor: 'string',
            default: 'Andale Mono=andale mono,monospace;' +
                'Arial=arial,helvetica,sans-serif;' +
                'Arial Black=arial black,sans-serif;' +
                'Book Antiqua=book antiqua,palatino,serif;' +
                'Comic Sans MS=comic sans ms,sans-serif;' +
                'Courier New=courier new,courier,monospace;' +
                'Georgia=georgia,palatino,serif;' +
                'Helvetica=helvetica,arial,sans-serif;' +
                'Impact=impact,sans-serif;' +
                'Symbol=symbol;' +
                'Tahoma=tahoma,arial,helvetica,sans-serif;' +
                'Terminal=terminal,monaco,monospace;' +
                'Times New Roman=times new roman,times,serif;' +
                'Trebuchet MS=trebuchet ms,geneva,sans-serif;' +
                'Verdana=verdana,geneva,sans-serif;' +
                'Webdings=webdings;' +
                'Wingdings=wingdings,zapf dingbats'
        });
        registerOption('font_size_formats', {
            processor: 'string',
            default: '8pt 10pt 12pt 14pt 18pt 24pt 36pt'
        });
        registerOption('font_size_input_default_unit', {
            processor: 'string',
            default: 'pt'
        });
        registerOption('block_formats', {
            processor: 'string',
            default: 'Paragraph=p;' +
                'Heading 1=h1;' +
                'Heading 2=h2;' +
                'Heading 3=h3;' +
                'Heading 4=h4;' +
                'Heading 5=h5;' +
                'Heading 6=h6;' +
                'Preformatted=pre'
        });
        registerOption('content_langs', {
            processor: 'object[]'
        });
        registerOption('removed_menuitems', {
            processor: 'string',
            default: ''
        });
        registerOption('menubar', {
            processor: (value) => isString(value) || isBoolean(value),
            // Phones don't have a lot of screen space so disable the menubar
            default: !isPhone
        });
        registerOption('menu', {
            processor: 'object',
            default: {}
        });
        registerOption('toolbar', {
            processor: (value) => {
                if (isBoolean(value) || isString(value) || isArray(value)) {
                    return { value, valid: true };
                }
                else {
                    return { valid: false, message: 'Must be a boolean, string or array.' };
                }
            },
            default: true
        });
        // Register the toolbarN variations: toolbar1 -> toolbar9
        range$2(9, (num) => {
            registerOption('toolbar' + (num + 1), {
                processor: 'string'
            });
        });
        registerOption('toolbar_mode', {
            processor: 'string',
            // Use the default side-scrolling toolbar for tablets/phones
            default: isMobile ? 'scrolling' : 'floating'
        });
        registerOption('toolbar_groups', {
            processor: 'object',
            default: {}
        });
        registerOption('toolbar_location', {
            processor: 'string',
            default: ToolbarLocation$1.auto
        });
        registerOption('toolbar_persist', {
            processor: 'boolean',
            default: false
        });
        registerOption('toolbar_sticky', {
            processor: 'boolean',
            default: editor.inline
        });
        registerOption('toolbar_sticky_offset', {
            processor: 'number',
            default: 0
        });
        registerOption('fixed_toolbar_container', {
            processor: 'string',
            default: ''
        });
        registerOption('fixed_toolbar_container_target', {
            processor: 'object'
        });
        registerOption('ui_mode', {
            processor: 'string',
            default: 'combined'
        });
        registerOption('file_picker_callback', {
            processor: 'function'
        });
        registerOption('file_picker_validator_handler', {
            processor: 'function'
        });
        registerOption('file_picker_types', {
            processor: 'string'
        });
        registerOption('typeahead_urls', {
            processor: 'boolean',
            default: true
        });
        registerOption('anchor_top', {
            processor: stringOrFalseProcessor,
            default: '#top'
        });
        registerOption('anchor_bottom', {
            processor: stringOrFalseProcessor,
            default: '#bottom'
        });
        registerOption('draggable_modal', {
            processor: 'boolean',
            default: false
        });
        registerOption('statusbar', {
            processor: 'boolean',
            default: true
        });
        registerOption('elementpath', {
            processor: 'boolean',
            default: true
        });
        registerOption('branding', {
            processor: 'boolean',
            default: true
        });
        registerOption('promotion', {
            processor: 'boolean',
            default: true
        });
        registerOption('resize', {
            processor: (value) => value === 'both' || isBoolean(value),
            // Editor resize doesn't work on touch devices at this stage
            default: !global$7.deviceType.isTouch()
        });
        registerOption('sidebar_show', {
            processor: 'string'
        });
        // This option is being registered in the theme instead of the help plugin as it cannot be accessed from the theme when registered there
        registerOption('help_accessibility', {
            processor: 'boolean',
            default: editor.hasPlugin('help')
        });
        registerOption('default_font_stack', {
            processor: 'string[]',
            default: []
        });
    };
    const isReadOnly = option$2('readonly');
    const isDisabled = option$2('disabled');
    const getHeightOption = option$2('height');
    const getWidthOption = option$2('width');
    const getMinWidthOption = wrapOptional(option$2('min_width'));
    const getMinHeightOption = wrapOptional(option$2('min_height'));
    const getMaxWidthOption = wrapOptional(option$2('max_width'));
    const getMaxHeightOption = wrapOptional(option$2('max_height'));
    const getUserStyleFormats = wrapOptional(option$2('style_formats'));
    const shouldMergeStyleFormats = option$2('style_formats_merge');
    const shouldAutoHideStyleFormats = option$2('style_formats_autohide');
    const getContentLanguages = option$2('content_langs');
    const getRemovedMenuItems = option$2('removed_menuitems');
    const getToolbarMode = option$2('toolbar_mode');
    const getToolbarGroups = option$2('toolbar_groups');
    const getToolbarLocation = option$2('toolbar_location');
    const fixedContainerSelector = option$2('fixed_toolbar_container');
    const fixedToolbarContainerTarget = option$2('fixed_toolbar_container_target');
    const isToolbarPersist = option$2('toolbar_persist');
    const getStickyToolbarOffset = option$2('toolbar_sticky_offset');
    const getMenubar = option$2('menubar');
    const getToolbar = option$2('toolbar');
    const getFilePickerCallback = option$2('file_picker_callback');
    const getFilePickerValidatorHandler = option$2('file_picker_validator_handler');
    const getFontSizeInputDefaultUnit = option$2('font_size_input_default_unit');
    const getFilePickerTypes = option$2('file_picker_types');
    const useTypeaheadUrls = option$2('typeahead_urls');
    const getAnchorTop = option$2('anchor_top');
    const getAnchorBottom = option$2('anchor_bottom');
    const isDraggableModal$1 = option$2('draggable_modal');
    const useStatusBar = option$2('statusbar');
    const useElementPath = option$2('elementpath');
    const useBranding = option$2('branding');
    const getResize = option$2('resize');
    const getPasteAsText = option$2('paste_as_text');
    const getSidebarShow = option$2('sidebar_show');
    const promotionEnabled = option$2('promotion');
    const useHelpAccessibility = option$2('help_accessibility');
    const getDefaultFontStack = option$2('default_font_stack');
    const getSkin = option$2('skin');
    const isSkinDisabled = (editor) => editor.options.get('skin') === false;
    const isMenubarEnabled = (editor) => editor.options.get('menubar') !== false;
    const getSkinUrl = (editor) => {
        const skinUrl = editor.options.get('skin_url');
        if (isSkinDisabled(editor)) {
            return skinUrl;
        }
        else {
            if (skinUrl) {
                return editor.documentBaseURI.toAbsolute(skinUrl);
            }
            else {
                const skin = editor.options.get('skin');
                return global$8.baseURL + '/skins/ui/' + skin;
            }
        }
    };
    const getSkinUrlOption = (editor) => Optional.from(editor.options.get('skin_url'));
    const getLineHeightFormats = (editor) => editor.options.get('line_height_formats').split(' ');
    const isToolbarEnabled = (editor) => {
        const toolbar = getToolbar(editor);
        const isToolbarString = isString(toolbar);
        const isToolbarObjectArray = isArray(toolbar) && toolbar.length > 0;
        // Toolbar is enabled if its value is true, a string or non-empty object array, but not string array
        return !isMultipleToolbars(editor) && (isToolbarObjectArray || isToolbarString || toolbar === true);
    };
    // Convert toolbar<n> into toolbars array
    const getMultipleToolbarsOption = (editor) => {
        const toolbars = range$2(9, (num) => editor.options.get('toolbar' + (num + 1)));
        const toolbarArray = filter$2(toolbars, isString);
        return someIf(toolbarArray.length > 0, toolbarArray);
    };
    // Check if multiple toolbars is enabled
    // Multiple toolbars is enabled if toolbar value is a string array or if toolbar<n> is present
    const isMultipleToolbars = (editor) => getMultipleToolbarsOption(editor).fold(() => {
        const toolbar = getToolbar(editor);
        return isArrayOf(toolbar, isString) && toolbar.length > 0;
    }, always);
    const isToolbarLocationBottom = (editor) => getToolbarLocation(editor) === ToolbarLocation$1.bottom;
    const fixedContainerTarget = (editor) => {
        var _a;
        if (!editor.inline) {
            // fixed_toolbar_container(_target) is only available in inline mode
            return Optional.none();
        }
        const selector = (_a = fixedContainerSelector(editor)) !== null && _a !== void 0 ? _a : '';
        if (selector.length > 0) {
            // If we have a valid selector
            return descendant(body(), selector);
        }
        const element = fixedToolbarContainerTarget(editor);
        if (isNonNullable(element)) {
            // If we have a valid target
            return Optional.some(SugarElement.fromDom(element));
        }
        return Optional.none();
    };
    const useFixedContainer = (editor) => editor.inline && fixedContainerTarget(editor).isSome();
    const getUiContainer = (editor) => {
        const fixedContainer = fixedContainerTarget(editor);
        return fixedContainer.getOrThunk(() => getContentContainer(getRootNode(SugarElement.fromDom(editor.getElement()))));
    };
    const isDistractionFree = (editor) => editor.inline && !isMenubarEnabled(editor) && !isToolbarEnabled(editor) && !isMultipleToolbars(editor);
    const isStickyToolbar = (editor) => {
        const isStickyToolbar = editor.options.get('toolbar_sticky');
        return (isStickyToolbar || editor.inline) && !useFixedContainer(editor) && !isDistractionFree(editor);
    };
    const isSplitUiMode = (editor) => !useFixedContainer(editor) && editor.options.get('ui_mode') === 'split';
    const getMenus = (editor) => {
        const menu = editor.options.get('menu');
        return map$1(menu, (menu) => ({ ...menu, items: menu.items }));
    };

    var Options = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get ToolbarMode () { return ToolbarMode$1; },
        get ToolbarLocation () { return ToolbarLocation$1; },
        register: register$f,
        getSkinUrl: getSkinUrl,
        getSkinUrlOption: getSkinUrlOption,
        isReadOnly: isReadOnly,
        isDisabled: isDisabled,
        getSkin: getSkin,
        isSkinDisabled: isSkinDisabled,
        getHeightOption: getHeightOption,
        getWidthOption: getWidthOption,
        getMinWidthOption: getMinWidthOption,
        getMinHeightOption: getMinHeightOption,
        getMaxWidthOption: getMaxWidthOption,
        getMaxHeightOption: getMaxHeightOption,
        getUserStyleFormats: getUserStyleFormats,
        shouldMergeStyleFormats: shouldMergeStyleFormats,
        shouldAutoHideStyleFormats: shouldAutoHideStyleFormats,
        getLineHeightFormats: getLineHeightFormats,
        getContentLanguages: getContentLanguages,
        getRemovedMenuItems: getRemovedMenuItems,
        isMenubarEnabled: isMenubarEnabled,
        isMultipleToolbars: isMultipleToolbars,
        isToolbarEnabled: isToolbarEnabled,
        isToolbarPersist: isToolbarPersist,
        getMultipleToolbarsOption: getMultipleToolbarsOption,
        getUiContainer: getUiContainer,
        useFixedContainer: useFixedContainer,
        isSplitUiMode: isSplitUiMode,
        getToolbarMode: getToolbarMode,
        isDraggableModal: isDraggableModal$1,
        isDistractionFree: isDistractionFree,
        isStickyToolbar: isStickyToolbar,
        getStickyToolbarOffset: getStickyToolbarOffset,
        getToolbarLocation: getToolbarLocation,
        isToolbarLocationBottom: isToolbarLocationBottom,
        getToolbarGroups: getToolbarGroups,
        getMenus: getMenus,
        getMenubar: getMenubar,
        getToolbar: getToolbar,
        getFilePickerCallback: getFilePickerCallback,
        getFilePickerTypes: getFilePickerTypes,
        useTypeaheadUrls: useTypeaheadUrls,
        getAnchorTop: getAnchorTop,
        getAnchorBottom: getAnchorBottom,
        getFilePickerValidatorHandler: getFilePickerValidatorHandler,
        getFontSizeInputDefaultUnit: getFontSizeInputDefaultUnit,
        useStatusBar: useStatusBar,
        useElementPath: useElementPath,
        promotionEnabled: promotionEnabled,
        useBranding: useBranding,
        getResize: getResize,
        getPasteAsText: getPasteAsText,
        getSidebarShow: getSidebarShow,
        useHelpAccessibility: useHelpAccessibility,
        getDefaultFontStack: getDefaultFontStack
    });

    // See https://developer.mozilla.org/en-US/docs/Glossary/Scroll_container for what makes an element scrollable
    const nonScrollingOverflows = ['visible', 'hidden', 'clip'];
    const isScrollingOverflowValue = (value) => trim$1(value).length > 0 && !contains$2(nonScrollingOverflows, value);
    const isScroller = (elem) => {
        if (isHTMLElement(elem)) {
            const overflowX = get$e(elem, 'overflow-x');
            const overflowY = get$e(elem, 'overflow-y');
            return isScrollingOverflowValue(overflowX) || isScrollingOverflowValue(overflowY);
        }
        else {
            return false;
        }
    };
    const isFullscreen = (editor) => editor.plugins.fullscreen && editor.plugins.fullscreen.isFullscreen();
    // NOTE: Calculating the list of scrolling ancestors each time this function is called might
    // be unnecessary. It will depend on its usage.
    const detect = (editor, popupSinkElem) => {
        const ancestorsScrollers = ancestors(popupSinkElem, isScroller);
        // If there is no scrollable container, we try to see if it's in a shadow root, and try to traverse beyond the host of shadow root to retrieve the scrollable container
        // If it is not within a ShadowRoot, since if there's a scrollable container as the ancestors, then it would not execute the code below, or return an empty array if it's not in a ShadowRoot
        const scrollers = ancestorsScrollers.length === 0
            ? getShadowRoot(popupSinkElem).map(getShadowHost).map((x) => ancestors(x, isScroller)).getOr([])
            : ancestorsScrollers;
        return head(scrollers)
            .map((element) => ({
            element,
            // A list of all scrolling elements above the nearest scroller,
            // ordered from closest to popup -> closest to top of document
            others: scrollers.slice(1),
            isFullscreen: () => isFullscreen(editor)
        }));
    };
    const detectWhenSplitUiMode = (editor, popupSinkElem) => isSplitUiMode(editor) ? detect(editor, popupSinkElem) : Optional.none();
    // Using all the scrolling viewports in the ancestry, limit the absolute
    // coordinates of window so that the bounds are limited by all the scrolling
    // viewports.
    const getBoundsFrom = (sc) => {
        const scrollableBoxes = [
            // sc.element is the main scroller, others are *additional* scrollers above that
            // we need to combine all of them to constrain the bounds
            ...map$2(sc.others, box$1),
            win()
        ];
        return sc.isFullscreen() ? win() : constrainByMany(box$1(sc.element), scrollableBoxes);
    };

    /*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */

    const {
      entries,
      setPrototypeOf,
      isFrozen,
      getPrototypeOf,
      getOwnPropertyDescriptor
    } = Object;
    let {
      freeze,
      seal,
      create: create$1
    } = Object; // eslint-disable-line import/no-mutable-exports
    let {
      apply,
      construct
    } = typeof Reflect !== 'undefined' && Reflect;
    if (!freeze) {
      freeze = function freeze(x) {
        return x;
      };
    }
    if (!seal) {
      seal = function seal(x) {
        return x;
      };
    }
    if (!apply) {
      apply = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    if (!construct) {
      construct = function construct(Func, args) {
        return new Func(...args);
      };
    }
    const arrayForEach = unapply(Array.prototype.forEach);
    const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
    const arrayPop = unapply(Array.prototype.pop);
    const arrayPush = unapply(Array.prototype.push);
    const arraySplice = unapply(Array.prototype.splice);
    const stringToLowerCase = unapply(String.prototype.toLowerCase);
    const stringToString = unapply(String.prototype.toString);
    const stringMatch = unapply(String.prototype.match);
    const stringReplace = unapply(String.prototype.replace);
    const stringIndexOf = unapply(String.prototype.indexOf);
    const stringTrim = unapply(String.prototype.trim);
    const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
    const regExpTest = unapply(RegExp.prototype.test);
    const typeErrorCreate = unconstruct(TypeError);
    /**
     * Creates a new function that calls the given function with a specified thisArg and arguments.
     *
     * @param func - The function to be wrapped and called.
     * @returns A new function that calls the given function with a specified thisArg and arguments.
     */
    function unapply(func) {
      return function (thisArg) {
        if (thisArg instanceof RegExp) {
          thisArg.lastIndex = 0;
        }
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return apply(func, thisArg, args);
      };
    }
    /**
     * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
     *
     * @param func - The constructor function to be wrapped and called.
     * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
     */
    function unconstruct(func) {
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return construct(func, args);
      };
    }
    /**
     * Add properties to a lookup table
     *
     * @param set - The set to which elements will be added.
     * @param array - The array containing elements to be added to the set.
     * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
     * @returns The modified set with added elements.
     */
    function addToSet(set, array) {
      let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
      if (setPrototypeOf) {
        // Make 'in' and truthy checks like Boolean(set.constructor)
        // independent of any properties defined on Object.prototype.
        // Prevent prototype setters from intercepting set as a this value.
        setPrototypeOf(set, null);
      }
      let l = array.length;
      while (l--) {
        let element = array[l];
        if (typeof element === 'string') {
          const lcElement = transformCaseFunc(element);
          if (lcElement !== element) {
            // Config presets (e.g. tags.js, attrs.js) are immutable.
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }
            element = lcElement;
          }
        }
        set[element] = true;
      }
      return set;
    }
    /**
     * Clean up an array to harden against CSPP
     *
     * @param array - The array to be cleaned.
     * @returns The cleaned version of the array
     */
    function cleanArray(array) {
      for (let index = 0; index < array.length; index++) {
        const isPropertyExist = objectHasOwnProperty(array, index);
        if (!isPropertyExist) {
          array[index] = null;
        }
      }
      return array;
    }
    /**
     * Shallow clone an object
     *
     * @param object - The object to be cloned.
     * @returns A new object that copies the original.
     */
    function clone(object) {
      const newObject = create$1(null);
      for (const [property, value] of entries(object)) {
        const isPropertyExist = objectHasOwnProperty(object, property);
        if (isPropertyExist) {
          if (Array.isArray(value)) {
            newObject[property] = cleanArray(value);
          } else if (value && typeof value === 'object' && value.constructor === Object) {
            newObject[property] = clone(value);
          } else {
            newObject[property] = value;
          }
        }
      }
      return newObject;
    }
    /**
     * This method automatically checks if the prop is function or getter and behaves accordingly.
     *
     * @param object - The object to look up the getter function in its prototype chain.
     * @param prop - The property name for which to find the getter function.
     * @returns The getter function found in the prototype chain or a fallback function.
     */
    function lookupGetter(object, prop) {
      while (object !== null) {
        const desc = getOwnPropertyDescriptor(object, prop);
        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }
          if (typeof desc.value === 'function') {
            return unapply(desc.value);
          }
        }
        object = getPrototypeOf(object);
      }
      function fallbackValue() {
        return null;
      }
      return fallbackValue;
    }

    const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
    const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
    const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
    // List of SVG elements that are disallowed by default.
    // We still need to know them so that we can do namespace
    // checks properly in case one wants to add them to
    // allow-list.
    const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
    const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
    // Similarly to SVG, we want to know all MathML elements,
    // even those that we disallow by default.
    const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
    const text$1 = freeze(['#text']);

    const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
    const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
    const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
    const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

    // eslint-disable-next-line unicorn/better-regex
    const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
    const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
    const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
    const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
    );
    const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
    );
    const DOCTYPE_NAME = seal(/^html$/i);
    const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

    var EXPRESSIONS = /*#__PURE__*/Object.freeze({
      __proto__: null,
      ARIA_ATTR: ARIA_ATTR,
      ATTR_WHITESPACE: ATTR_WHITESPACE,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT,
      DATA_ATTR: DATA_ATTR,
      DOCTYPE_NAME: DOCTYPE_NAME,
      ERB_EXPR: ERB_EXPR,
      IS_ALLOWED_URI: IS_ALLOWED_URI,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
      MUSTACHE_EXPR: MUSTACHE_EXPR,
      TMPLIT_EXPR: TMPLIT_EXPR
    });

    /* eslint-disable @typescript-eslint/indent */
    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
    const NODE_TYPE = {
      element: 1,
      attribute: 2,
      text: 3,
      cdataSection: 4,
      entityReference: 5,
      // Deprecated
      entityNode: 6,
      // Deprecated
      progressingInstruction: 7,
      comment: 8,
      document: 9,
      documentType: 10,
      documentFragment: 11,
      notation: 12 // Deprecated
    };
    const getGlobal = function getGlobal() {
      return typeof window === 'undefined' ? null : window;
    };
    /**
     * Creates a no-op policy for internal use only.
     * Don't export this function outside this module!
     * @param trustedTypes The policy factory.
     * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
     * @return The policy created (or null, if Trusted Types
     * are not supported or creating the policy failed).
     */
    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
        return null;
      }
      // Allow the callers to control the unique policy name
      // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
      // Policy creation with duplicate names throws in Trusted Types.
      let suffix = null;
      const ATTR_NAME = 'data-tt-policy-suffix';
      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
        suffix = purifyHostElement.getAttribute(ATTR_NAME);
      }
      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML(html) {
            return html;
          },
          createScriptURL(scriptUrl) {
            return scriptUrl;
          }
        });
      } catch (_) {
        // Policy creation failed (most likely another DOMPurify script has
        // already run). Skip creating the policy, as this will only cause errors
        // if TT are enforced.
        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
        return null;
      }
    };
    const _createHooksMap = function _createHooksMap() {
      return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
      };
    };
    function createDOMPurify() {
      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
      const DOMPurify = root => createDOMPurify(root);
      DOMPurify.version = '3.2.6';
      DOMPurify.removed = [];
      if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {
        // Not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
      }
      let {
        document
      } = window;
      const originalDocument = document;
      const currentScript = originalDocument.currentScript;
      const {
        DocumentFragment,
        HTMLTemplateElement,
        Node,
        Element,
        NodeFilter,
        NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
        HTMLFormElement,
        DOMParser,
        trustedTypes
      } = window;
      const ElementPrototype = Element.prototype;
      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
      const remove = lookupGetter(ElementPrototype, 'remove');
      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
      // As per issue #47, the web-components registry is inherited by a
      // new document created via createHTMLDocument. As per the spec
      // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
      // a new empty registry is used when creating a template contents owner
      // document, so we use that as our parent document to ensure nothing
      // is inherited.
      if (typeof HTMLTemplateElement === 'function') {
        const template = document.createElement('template');
        if (template.content && template.content.ownerDocument) {
          document = template.content.ownerDocument;
        }
      }
      let trustedTypesPolicy;
      let emptyHTML = '';
      const {
        implementation,
        createNodeIterator,
        createDocumentFragment,
        getElementsByTagName
      } = document;
      const {
        importNode
      } = originalDocument;
      let hooks = _createHooksMap();
      /**
       * Expose whether this browser supports running the full DOMPurify.
       */
      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
      const {
        MUSTACHE_EXPR,
        ERB_EXPR,
        TMPLIT_EXPR,
        DATA_ATTR,
        ARIA_ATTR,
        IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE,
        CUSTOM_ELEMENT
      } = EXPRESSIONS;
      let {
        IS_ALLOWED_URI: IS_ALLOWED_URI$1
      } = EXPRESSIONS;
      /**
       * We consider the elements and attributes below to be safe. Ideally
       * don't add any new ones but feel free to remove unwanted ones.
       */
      /* allowed element names */
      let ALLOWED_TAGS = null;
      const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text$1]);
      /* Allowed attribute names */
      let ALLOWED_ATTR = null;
      const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
      /*
       * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
       * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
       * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
       * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
       */
      let CUSTOM_ELEMENT_HANDLING = Object.seal(create$1(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false
        }
      }));
      /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
      let FORBID_TAGS = null;
      /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
      let FORBID_ATTR = null;
      /* Decide if ARIA attributes are okay */
      let ALLOW_ARIA_ATTR = true;
      /* Decide if custom data attributes are okay */
      let ALLOW_DATA_ATTR = true;
      /* Decide if unknown protocols are okay */
      let ALLOW_UNKNOWN_PROTOCOLS = false;
      /* Decide if self-closing tags in attributes are allowed.
       * Usually removed due to a mXSS issue in jQuery 3.0 */
      let ALLOW_SELF_CLOSE_IN_ATTR = true;
      /* Output should be safe for common template engines.
       * This means, DOMPurify removes data attributes, mustaches and ERB
       */
      let SAFE_FOR_TEMPLATES = false;
      /* Output should be safe even for XML used within HTML and alike.
       * This means, DOMPurify removes comments when containing risky content.
       */
      let SAFE_FOR_XML = true;
      /* Decide if document with <html>... should be returned */
      let WHOLE_DOCUMENT = false;
      /* Track whether config is already set on this instance of DOMPurify. */
      let SET_CONFIG = false;
      /* Decide if all elements (e.g. style, script) must be children of
       * document.body. By default, browsers might move them to document.head */
      let FORCE_BODY = false;
      /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
       * string (or a TrustedHTML object if Trusted Types are supported).
       * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
       */
      let RETURN_DOM = false;
      /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
       * string  (or a TrustedHTML object if Trusted Types are supported) */
      let RETURN_DOM_FRAGMENT = false;
      /* Try to return a Trusted Type object instead of a string, return a string in
       * case Trusted Types are not supported  */
      let RETURN_TRUSTED_TYPE = false;
      /* Output should be free from DOM clobbering attacks?
       * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
       */
      let SANITIZE_DOM = true;
      /* Achieve full DOM Clobbering protection by isolating the namespace of named
       * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
       *
       * HTML/DOM spec rules that enable DOM Clobbering:
       *   - Named Access on Window (7.3.3)
       *   - DOM Tree Accessors (3.1.5)
       *   - Form Element Parent-Child Relations (4.10.3)
       *   - Iframe srcdoc / Nested WindowProxies (4.8.5)
       *   - HTMLCollection (4.2.10.2)
       *
       * Namespace isolation is implemented by prefixing `id` and `name` attributes
       * with a constant string, i.e., `user-content-`
       */
      let SANITIZE_NAMED_PROPS = false;
      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
      /* Keep element content when removing element? */
      let KEEP_CONTENT = true;
      /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
       * of importing it into a new Document and returning a sanitized copy */
      let IN_PLACE = false;
      /* Allow usage of profiles like html, svg and mathMl */
      let USE_PROFILES = {};
      /* Tags to ignore content of when KEEP_CONTENT is true */
      let FORBID_CONTENTS = null;
      const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
      /* Tags that are safe for data: URIs */
      let DATA_URI_TAGS = null;
      const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
      /* Attributes safe for values like "javascript:" */
      let URI_SAFE_ATTRIBUTES = null;
      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
      /* Document namespace */
      let NAMESPACE = HTML_NAMESPACE;
      let IS_EMPTY_INPUT = false;
      /* Allowed XHTML+XML namespaces */
      let ALLOWED_NAMESPACES = null;
      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
      let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
      let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
      // Certain elements are allowed in both SVG and HTML
      // namespace. We need to specify them explicitly
      // so that they don't get erroneously deleted from
      // HTML namespace.
      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
      /* Parsing of strict XHTML documents */
      let PARSER_MEDIA_TYPE = null;
      const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
      let transformCaseFunc = null;
      /* Keep a reference to config to pass to hooks */
      let CONFIG = null;
      /* Ideally, do not touch anything below this line */
      /* ______________________________________________ */
      const formElement = document.createElement('form');
      const isRegexOrFunction = function isRegexOrFunction(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
      };
      /**
       * _parseConfig
       *
       * @param cfg optional config literal
       */
      // eslint-disable-next-line complexity
      const _parseConfig = function _parseConfig() {
        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        /* Shield configuration object from tampering */
        if (!cfg || typeof cfg !== 'object') {
          cfg = {};
        }
        /* Shield configuration object from prototype pollution */
        cfg = clone(cfg);
        PARSER_MEDIA_TYPE =
        // eslint-disable-next-line unicorn/prefer-includes
        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
        /* Set configuration parameters */
        ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
        FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
        USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
        RETURN_DOM = cfg.RETURN_DOM || false; // Default false
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
        FORCE_BODY = cfg.FORCE_BODY || false; // Default false
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
        IN_PLACE = cfg.IN_PLACE || false; // Default false
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        /* Parse profile info */
        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, text$1);
          ALLOWED_ATTR = [];
          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html$1);
            addToSet(ALLOWED_ATTR, html);
          }
          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg$1);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl$1);
            addToSet(ALLOWED_ATTR, mathMl);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        /* Merge configuration parameters */
        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
        }
        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
        }
        if (cfg.FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
        }
        /* Add #text in case KEEP_CONTENT is set to true */
        if (KEEP_CONTENT) {
          ALLOWED_TAGS['#text'] = true;
        }
        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
        }
        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ['tbody']);
          delete FORBID_TAGS.tbody;
        }
        if (cfg.TRUSTED_TYPES_POLICY) {
          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          }
          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          }
          // Overwrite existing TrustedTypes policy.
          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
          // Sign local variables required by `sanitize`.
          emptyHTML = trustedTypesPolicy.createHTML('');
        } else {
          // Uninitialized policy, attempt to initialize the internal dompurify policy.
          if (trustedTypesPolicy === undefined) {
            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
          }
          // If creating the internal policy succeeded sign internal variables.
          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
            emptyHTML = trustedTypesPolicy.createHTML('');
          }
        }
        // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.
        if (freeze) {
          freeze(cfg);
        }
        CONFIG = cfg;
      };
      /* Keep track of all possible SVG and MathML tags
       * so that we can perform the namespace checks
       * correctly. */
      const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
      const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
      /**
       * @param element a DOM element whose namespace is being checked
       * @returns Return false if the element has a
       *  namespace that a spec-compliant parser would never
       *  return. Return true otherwise.
       */
      const _checkValidNamespace = function _checkValidNamespace(element) {
        let parent = getParentNode(element);
        // In JSDOM, if we're inside shadow DOM, then parentNode
        // can be null. We just simulate parent in this case.
        if (!parent || !parent.tagName) {
          parent = {
            namespaceURI: NAMESPACE,
            tagName: 'template'
          };
        }
        const tagName = stringToLowerCase(element.tagName);
        const parentTagName = stringToLowerCase(parent.tagName);
        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
          return false;
        }
        if (element.namespaceURI === SVG_NAMESPACE) {
          // The only way to switch from HTML namespace to SVG
          // is via <svg>. If it happens via any other tag, then
          // it should be killed.
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'svg';
          }
          // The only way to switch from MathML to SVG is via`
          // svg if parent is either <annotation-xml> or MathML
          // text integration points.
          if (parent.namespaceURI === MATHML_NAMESPACE) {
            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          }
          // We only allow elements that are defined in SVG
          // spec. All others are disallowed in SVG namespace.
          return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
          // The only way to switch from HTML namespace to MathML
          // is via <math>. If it happens via any other tag, then
          // it should be killed.
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'math';
          }
          // The only way to switch from SVG to MathML is via
          // <math> and HTML integration points
          if (parent.namespaceURI === SVG_NAMESPACE) {
            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
          }
          // We only allow elements that are defined in MathML
          // spec. All others are disallowed in MathML namespace.
          return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
          // The only way to switch from SVG to HTML is via
          // HTML integration points, and from MathML to HTML
          // is via MathML text integration points
          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          // We disallow tags that are specific for MathML
          // or SVG and should never appear in HTML namespace
          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        // For XHTML and XML documents that support custom namespaces
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
          return true;
        }
        // The code should never reach this place (this means
        // that the element somehow got namespace that is not
        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
        // Return false just in case.
        return false;
      };
      /**
       * _forceRemove
       *
       * @param node a DOM node
       */
      const _forceRemove = function _forceRemove(node) {
        arrayPush(DOMPurify.removed, {
          element: node
        });
        try {
          // eslint-disable-next-line unicorn/prefer-dom-node-remove
          getParentNode(node).removeChild(node);
        } catch (_) {
          remove(node);
        }
      };
      /**
       * _removeAttribute
       *
       * @param name an Attribute name
       * @param element a DOM node
       */
      const _removeAttribute = function _removeAttribute(name, element) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: element.getAttributeNode(name),
            from: element
          });
        } catch (_) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: element
          });
        }
        element.removeAttribute(name);
        // We void attribute values for unremovable "is" attributes
        if (name === 'is') {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(element);
            } catch (_) {}
          } else {
            try {
              element.setAttribute(name, '');
            } catch (_) {}
          }
        }
      };
      /**
       * _initDocument
       *
       * @param dirty - a string of dirty markup
       * @return a DOM, filled with the dirty markup
       */
      const _initDocument = function _initDocument(dirty) {
        /* Create a HTML document */
        let doc = null;
        let leadingWhitespace = null;
        if (FORCE_BODY) {
          dirty = '<remove></remove>' + dirty;
        } else {
          /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
          const matches = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches && matches[0];
        }
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
          // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
        }
        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        /*
         * Use the DOMParser API by default, fallback later if needs be
         * DOMParser not work for svg when has multiple root element.
         */
        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
          } catch (_) {}
        }
        /* Use createHTMLDocument in case DOMParser is not available */
        if (!doc || !doc.documentElement) {
          doc = implementation.createDocument(NAMESPACE, 'template', null);
          try {
            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
          } catch (_) {
            // Syntax error if dirtyPayload is invalid xml
          }
        }
        const body = doc.body || doc.documentElement;
        if (dirty && leadingWhitespace) {
          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        /* Work on whole document or just its body */
        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
        }
        return WHOLE_DOCUMENT ? doc.documentElement : body;
      };
      /**
       * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
       *
       * @param root The root element or node to start traversing on.
       * @return The created NodeIterator
       */
      const _createNodeIterator = function _createNodeIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
      };
      /**
       * _isClobbered
       *
       * @param element element to check for clobbering attacks
       * @return true if clobbered, false if safe
       */
      const _isClobbered = function _isClobbered(element) {
        return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
      };
      /**
       * Checks whether the given object is a DOM node.
       *
       * @param value object to check whether it's a DOM node
       * @return true is object is a DOM node
       */
      const _isNode = function _isNode(value) {
        return typeof Node === 'function' && value instanceof Node;
      };
      function _executeHooks(hooks, currentNode, data) {
        arrayForEach(hooks, hook => {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      }
      /**
       * _sanitizeElements
       *
       * @protect nodeName
       * @protect textContent
       * @protect removeChild
       * @param currentNode to check for permission to exist
       * @return true if node was killed, false if left alive
       */
      const _sanitizeElements = function _sanitizeElements(currentNode) {
        let content = null;
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
        /* Check if element is clobbered or can clobber */
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Now let's check the element's type and name */
        const tagName = transformCaseFunc(currentNode.nodeName);
        /* Execute a hook if present */
        _executeHooks(hooks.uponSanitizeElement, currentNode, {
          tagName,
          allowedTags: ALLOWED_TAGS
        });
        /* Detect mXSS attempts abusing namespace confusion */
        if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove any occurrence of processing instructions */
        if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove any kind of possibly harmful comments */
        if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove element if anything forbids its presence */
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          /* Check if we have a custom element to handle */
          if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
              return false;
            }
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
              return false;
            }
          }
          /* Keep content except for bad-listed elements */
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            const parentNode = getParentNode(currentNode) || currentNode.parentNode;
            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
            if (childNodes && parentNode) {
              const childCount = childNodes.length;
              for (let i = childCount - 1; i >= 0; --i) {
                const childClone = cloneNode(childNodes[i], true);
                childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                parentNode.insertBefore(childClone, getNextSibling(currentNode));
              }
            }
          }
          _forceRemove(currentNode);
          return true;
        }
        /* Check whether element has a valid namespace */
        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Make sure that older browsers don't get fallback-tag mXSS */
        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Sanitize element content to be template-safe */
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
          /* Get the element's text content */
          content = currentNode.textContent;
          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
            content = stringReplace(content, expr, ' ');
          });
          if (currentNode.textContent !== content) {
            arrayPush(DOMPurify.removed, {
              element: currentNode.cloneNode()
            });
            currentNode.textContent = content;
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeElements, currentNode, null);
        return false;
      };
      /**
       * _isValidAttribute
       *
       * @param lcTag Lowercase tag name of containing element.
       * @param lcName Lowercase attribute name.
       * @param value Attribute value.
       * @return Returns true if `value` is valid, otherwise false.
       */
      // eslint-disable-next-line complexity
      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        /* Make sure attribute cannot clobber */
        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
          return false;
        }
        /* Allow valid data-* attributes: At least one character after "-"
            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
            We don't need to check the value; it's always URI safe. */
        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
          // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
            return false;
          }
          /* Check value is safe. First, is attr inert? If so, is safe */
        } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
          return false;
        } else ;
        return true;
      };
      /**
       * _isBasicCustomElement
       * checks if at least one dash is included in tagName, and it's not the first char
       * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
       *
       * @param tagName name of the tag of the node to sanitize
       * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
       */
      const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
        return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
      };
      /**
       * _sanitizeAttributes
       *
       * @protect attributes
       * @protect nodeName
       * @protect removeAttribute
       * @protect setAttribute
       *
       * @param currentNode to sanitize
       */
      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
        const {
          attributes
        } = currentNode;
        /* Check if we have attributes; if not we might have a text node */
        if (!attributes || _isClobbered(currentNode)) {
          return;
        }
        const hookEvent = {
          attrName: '',
          attrValue: '',
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR,
          forceKeepAttr: undefined
        };
        let l = attributes.length;
        /* Go backwards over all attributes; safely remove bad ones */
        while (l--) {
          const attr = attributes[l];
          const {
            name,
            namespaceURI,
            value: attrValue
          } = attr;
          const lcName = transformCaseFunc(name);
          const initValue = attrValue;
          let value = name === 'value' ? initValue : stringTrim(initValue);
          /* Execute a hook if present */
          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
          _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
          value = hookEvent.attrValue;
          /* Full DOM Clobbering protection via namespace isolation,
           * Prefix id and name attributes with `user-content-`
           */
          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
            // Remove the attribute with this value
            _removeAttribute(name, currentNode);
            // Prefix the value and later re-create the attribute with the sanitized value
            value = SANITIZE_NAMED_PROPS_PREFIX + value;
          }
          /* Work around a security issue with comments inside attributes */
          if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Did the hooks approve of the attribute? */
          if (hookEvent.forceKeepAttr) {
            continue;
          }
          /* Did the hooks approve of the attribute? */
          if (!hookEvent.keepAttr) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Work around a security issue in jQuery 3.0 */
          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Sanitize attribute content to be template-safe */
          if (SAFE_FOR_TEMPLATES) {
            arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
              value = stringReplace(value, expr, ' ');
            });
          }
          /* Is `value` valid for this attribute? */
          const lcTag = transformCaseFunc(currentNode.nodeName);
          if (!_isValidAttribute(lcTag, lcName, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Handle attributes that require Trusted Types */
          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
            if (namespaceURI) ; else {
              switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                case 'TrustedHTML':
                  {
                    value = trustedTypesPolicy.createHTML(value);
                    break;
                  }
                case 'TrustedScriptURL':
                  {
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                  }
              }
            }
          }
          /* Handle invalid data-* attribute set by try-catching it */
          if (value !== initValue) {
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
                currentNode.setAttribute(name, value);
              }
              if (_isClobbered(currentNode)) {
                _forceRemove(currentNode);
              } else {
                arrayPop(DOMPurify.removed);
              }
            } catch (_) {
              _removeAttribute(name, currentNode);
            }
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
      };
      /**
       * _sanitizeShadowDOM
       *
       * @param fragment to iterate over recursively
       */
      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        let shadowNode = null;
        const shadowIterator = _createNodeIterator(fragment);
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
        while (shadowNode = shadowIterator.nextNode()) {
          /* Execute a hook if present */
          _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
          /* Sanitize tags and elements */
          _sanitizeElements(shadowNode);
          /* Check attributes next */
          _sanitizeAttributes(shadowNode);
          /* Deep shadow DOM detected */
          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(shadowNode.content);
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
      };
      // eslint-disable-next-line complexity
      DOMPurify.sanitize = function (dirty) {
        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let body = null;
        let importedNode = null;
        let currentNode = null;
        let returnNode = null;
        /* Make sure we have a string to sanitize.
          DO NOT return early, as this will return the wrong type if
          the user has requested a DOM object rather than a string */
        IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
          dirty = '<!-->';
        }
        /* Stringify, in case dirty is an object */
        if (typeof dirty !== 'string' && !_isNode(dirty)) {
          if (typeof dirty.toString === 'function') {
            dirty = dirty.toString();
            if (typeof dirty !== 'string') {
              throw typeErrorCreate('dirty is not a string, aborting');
            }
          } else {
            throw typeErrorCreate('toString is not a function');
          }
        }
        /* Return dirty HTML if DOMPurify cannot run */
        if (!DOMPurify.isSupported) {
          return dirty;
        }
        /* Assign config vars */
        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        /* Clean up removed elements */
        DOMPurify.removed = [];
        /* Check if dirty is correctly typed for IN_PLACE */
        if (typeof dirty === 'string') {
          IN_PLACE = false;
        }
        if (IN_PLACE) {
          /* Do some early pre-sanitization to avoid unsafe root nodes */
          if (dirty.nodeName) {
            const tagName = transformCaseFunc(dirty.nodeName);
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
            }
          }
        } else if (dirty instanceof Node) {
          /* If dirty is a DOM element, append to an empty document to avoid
             elements being stripped by the parser */
          body = _initDocument('<!---->');
          importedNode = body.ownerDocument.importNode(dirty, true);
          if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
            /* Node is already a body, use as is */
            body = importedNode;
          } else if (importedNode.nodeName === 'HTML') {
            body = importedNode;
          } else {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            body.appendChild(importedNode);
          }
        } else {
          /* Exit directly if we have nothing to do */
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
          // eslint-disable-next-line unicorn/prefer-includes
          dirty.indexOf('<') === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          /* Initialize the document to work on */
          body = _initDocument(dirty);
          /* Check we have a DOM node from the data */
          if (!body) {
            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
          }
        }
        /* Remove first element node (ours) if FORCE_BODY is set */
        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        /* Get node iterator */
        const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
        /* Now start iterating over the created document */
        while (currentNode = nodeIterator.nextNode()) {
          /* Sanitize tags and elements */
          _sanitizeElements(currentNode);
          /* Check attributes next */
          _sanitizeAttributes(currentNode);
          /* Shadow DOM detected, sanitize it */
          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
        }
        /* If we sanitized `dirty` in-place, return it. */
        if (IN_PLACE) {
          return dirty;
        }
        /* Return sanitized string or DOM */
        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);
            while (body.firstChild) {
              // eslint-disable-next-line unicorn/prefer-dom-node-append
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }
          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
            /*
              AdoptNode() is not used because internal state is not reset
              (e.g. the past names map of a HTMLFormElement), this is safe
              in theory but we would rather not risk another attack vector.
              The state that is cloned by importNode() is explicitly defined
              by the specs.
            */
            returnNode = importNode.call(originalDocument, returnNode, true);
          }
          return returnNode;
        }
        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        /* Serialize doctype if allowed */
        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
        }
        /* Sanitize final string template-safe */
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
            serializedHTML = stringReplace(serializedHTML, expr, ' ');
          });
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      DOMPurify.setConfig = function () {
        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _parseConfig(cfg);
        SET_CONFIG = true;
      };
      DOMPurify.clearConfig = function () {
        CONFIG = null;
        SET_CONFIG = false;
      };
      DOMPurify.isValidAttribute = function (tag, attr, value) {
        /* Initialize shared config vars if necessary. */
        if (!CONFIG) {
          _parseConfig({});
        }
        const lcTag = transformCaseFunc(tag);
        const lcName = transformCaseFunc(attr);
        return _isValidAttribute(lcTag, lcName, value);
      };
      DOMPurify.addHook = function (entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') {
          return;
        }
        arrayPush(hooks[entryPoint], hookFunction);
      };
      DOMPurify.removeHook = function (entryPoint, hookFunction) {
        if (hookFunction !== undefined) {
          const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
          return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];
        }
        return arrayPop(hooks[entryPoint]);
      };
      DOMPurify.removeHooks = function (entryPoint) {
        hooks[entryPoint] = [];
      };
      DOMPurify.removeAllHooks = function () {
        hooks = _createHooksMap();
      };
      return DOMPurify;
    }
    var purify = createDOMPurify();

    const sanitizeHtmlString = (html) => purify().sanitize(html);

    var global$6 = tinymce.util.Tools.resolve('tinymce.util.I18n');

    // Icons that need to be transformed in RTL
    const rtlTransform = {
        'indent': true,
        'outdent': true,
        'table-insert-column-after': true,
        'table-insert-column-before': true,
        'paste-column-after': true,
        'paste-column-before': true,
        'unordered-list': true,
        'list-bull-circle': true,
        'list-bull-disc': true,
        'list-bull-default': true,
        'list-bull-square': true
    };
    const defaultIconName = 'temporary-placeholder';
    const defaultIcon = (icons) => () => get$h(icons, defaultIconName).getOr('!not found!');
    const getIconName = (name, icons) => {
        const lcName = name.toLowerCase();
        // If in rtl mode then try to see if we have a rtl icon to use instead
        if (global$6.isRtl()) {
            const rtlName = ensureTrailing(lcName, '-rtl');
            return has$2(icons, rtlName) ? rtlName : lcName;
        }
        else {
            return lcName;
        }
    };
    const lookupIcon = (name, icons) => get$h(icons, getIconName(name, icons));
    const get = (name, iconProvider) => {
        const icons = iconProvider();
        return lookupIcon(name, icons).getOrThunk(defaultIcon(icons));
    };
    const getOr = (name, iconProvider, fallbackIcon) => {
        const icons = iconProvider();
        return lookupIcon(name, icons).or(fallbackIcon).getOrThunk(defaultIcon(icons));
    };
    const needsRtlTransform = (iconName) => global$6.isRtl() ? has$2(rtlTransform, iconName) : false;
    const addFocusableBehaviour = () => config('add-focusable', [
        runOnAttached((comp) => {
            // set focusable=false on SVGs to prevent focusing the toolbar when tabbing into the editor
            child(comp.element, 'svg').each((svg) => set$9(svg, 'focusable', 'false'));
        })
    ]);
    const renderIcon$3 = (spec, iconName, icons, fallbackIcon) => {
        var _a, _b, _c;
        // If RTL, add the flip icon class if the icon doesn't have a `-rtl` icon available.
        const rtlIconClasses = needsRtlTransform(iconName) ? ['tox-icon--flip'] : [];
        const iconHtml = get$h(icons, getIconName(iconName, icons)).or(fallbackIcon).getOrThunk(defaultIcon(icons));
        return {
            dom: {
                tag: spec.tag,
                attributes: (_a = spec.attributes) !== null && _a !== void 0 ? _a : {},
                classes: spec.classes.concat(rtlIconClasses),
                innerHtml: iconHtml
            },
            behaviours: derive$1([
                ...(_b = spec.behaviours) !== null && _b !== void 0 ? _b : [],
                addFocusableBehaviour()
            ]),
            eventOrder: (_c = spec.eventOrder) !== null && _c !== void 0 ? _c : {}
        };
    };
    const render$4 = (iconName, spec, iconProvider, fallbackIcon = Optional.none()) => renderIcon$3(spec, iconName, iconProvider(), fallbackIcon);
    const renderFirst = (iconNames, spec, iconProvider) => {
        const icons = iconProvider();
        const iconName = find$5(iconNames, (name) => has$2(icons, getIconName(name, icons)));
        return renderIcon$3(spec, iconName.getOr(defaultIconName), icons, Optional.none());
    };

    const notificationIconMap = {
        success: 'checkmark',
        error: 'warning',
        err: 'error',
        warning: 'warning',
        warn: 'warning',
        info: 'info'
    };
    const factory$4 = (detail) => {
        // For using the alert banner as a standalone banner
        const notificationTextId = generate$6('notification-text');
        const memBannerText = record({
            dom: fromHtml(`<p id=${notificationTextId}>${sanitizeHtmlString(detail.backstageProvider.translate(detail.text))}</p>`),
            behaviours: derive$1([
                Replacing.config({})
            ])
        });
        const renderPercentBar = (percent) => ({
            dom: {
                tag: 'div',
                classes: ['tox-bar'],
                styles: {
                    width: `${percent}%`
                }
            }
        });
        const renderPercentText = (percent) => ({
            dom: {
                tag: 'div',
                classes: ['tox-text'],
                innerHtml: `${percent}%`
            }
        });
        const memBannerProgress = record({
            dom: {
                tag: 'div',
                classes: detail.progress ? ['tox-progress-bar', 'tox-progress-indicator'] : ['tox-progress-bar']
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-bar-container']
                    },
                    components: [
                        renderPercentBar(0)
                    ]
                },
                renderPercentText(0)
            ],
            behaviours: derive$1([
                Replacing.config({})
            ])
        });
        const updateProgress = (comp, percent) => {
            if (comp.getSystem().isConnected()) {
                memBannerProgress.getOpt(comp).each((progress) => {
                    Replacing.set(progress, [
                        {
                            dom: {
                                tag: 'div',
                                classes: ['tox-bar-container']
                            },
                            components: [
                                renderPercentBar(percent)
                            ]
                        },
                        renderPercentText(percent)
                    ]);
                });
            }
        };
        const updateText = (comp, text) => {
            if (comp.getSystem().isConnected()) {
                const banner = memBannerText.get(comp);
                Replacing.set(banner, [
                    text$2(text)
                ]);
            }
        };
        const apis = {
            updateProgress,
            updateText
        };
        const iconChoices = flatten([
            detail.icon.toArray(),
            [detail.level],
            Optional.from(notificationIconMap[detail.level]).toArray()
        ]);
        const memButton = record(Button.sketch({
            dom: {
                tag: 'button',
                classes: ['tox-notification__dismiss', 'tox-button', 'tox-button--naked', 'tox-button--icon'],
                attributes: {
                    'aria-label': detail.backstageProvider.translate('Close')
                }
            },
            components: [
                render$4('close', {
                    tag: 'span',
                    classes: ['tox-icon'],
                }, detail.iconProvider)
            ],
            buttonBehaviours: derive$1([
                Tabstopping.config({}),
                Tooltipping.config({
                    ...detail.backstageProvider.tooltips.getConfig({
                        tooltipText: detail.backstageProvider.translate('Close')
                    })
                })
            ]),
            action: (comp) => {
                detail.onAction(comp);
            }
        }));
        const notificationIconSpec = renderFirst(iconChoices, { tag: 'div', classes: ['tox-notification__icon'] }, detail.iconProvider);
        const notificationBodySpec = {
            dom: {
                tag: 'div',
                classes: ['tox-notification__body']
            },
            components: [
                memBannerText.asSpec()
            ],
            behaviours: derive$1([
                Replacing.config({})
            ])
        };
        const components = [notificationIconSpec, notificationBodySpec];
        return {
            uid: detail.uid,
            dom: {
                tag: 'div',
                attributes: {
                    'role': 'alert',
                    'aria-labelledby': notificationTextId
                },
                classes: ['tox-notification', 'tox-notification--in', `tox-notification--${detail.level}`],
            },
            behaviours: derive$1([
                Tabstopping.config({}),
                Focusing.config({}),
                Keying.config({
                    mode: 'special',
                    onEscape: (comp) => {
                        detail.onAction(comp);
                        return Optional.some(true);
                    }
                })
            ]),
            components: components
                .concat(detail.progress ? [memBannerProgress.asSpec()] : [])
                .concat([memButton.asSpec()]),
            apis
        };
    };
    const Notification = single({
        name: 'Notification',
        factory: factory$4,
        configFields: [
            defaultedStringEnum('level', 'info', ['success', 'error', 'warning', 'warn', 'info']),
            required$1('progress'),
            option$3('icon'),
            required$1('onAction'),
            required$1('text'),
            required$1('iconProvider'),
            required$1('backstageProvider'),
        ],
        apis: {
            updateProgress: (apis, comp, percent) => {
                apis.updateProgress(comp, percent);
            },
            updateText: (apis, comp, text) => {
                apis.updateText(comp, text);
            }
        }
    });

    var NotificationManagerImpl = (editor, extras, uiMothership, notificationRegion) => {
        const sharedBackstage = extras.backstage.shared;
        const getBoundsContainer = () => SugarElement.fromDom(editor.queryCommandValue('ToggleView') === '' ? editor.getContentAreaContainer() : editor.getContainer());
        const getBounds = () => {
            const contentArea = box$1(getBoundsContainer());
            return Optional.some(contentArea);
        };
        const clampComponentsToBounds = (components) => {
            getBounds().each((bounds) => {
                each$1(components, (comp) => {
                    remove$6(comp.element, 'width');
                    if (get$c(comp.element) > bounds.width) {
                        set$7(comp.element, 'width', bounds.width + 'px');
                    }
                });
            });
        };
        const open = (settings, closeCallback, isEditorOrUIFocused) => {
            const close = () => {
                const removeNotificationAndReposition = (region) => {
                    Replacing.remove(region, notification);
                    reposition();
                };
                const manageRegionVisibility = (region, editorOrUiFocused) => {
                    if (children(region.element).length === 0) {
                        handleEmptyRegion(region, editorOrUiFocused);
                    }
                    else {
                        handleRegionWithChildren(region, editorOrUiFocused);
                    }
                };
                const handleEmptyRegion = (region, editorOrUIFocused) => {
                    InlineView.hide(region);
                    notificationRegion.clear();
                    if (editorOrUIFocused) {
                        editor.focus();
                    }
                };
                const handleRegionWithChildren = (region, editorOrUIFocused) => {
                    if (editorOrUIFocused) {
                        Keying.focusIn(region);
                    }
                };
                notificationRegion.on((region) => {
                    closeCallback();
                    const editorOrUIFocused = isEditorOrUIFocused();
                    removeNotificationAndReposition(region);
                    manageRegionVisibility(region, editorOrUIFocused);
                });
            };
            const shouldApplyDocking = () => !isStickyToolbar(editor) || !sharedBackstage.header.isPositionedAtTop();
            const notification = build$1(Notification.sketch({
                text: settings.text,
                level: contains$2(['success', 'error', 'warning', 'warn', 'info'], settings.type) ? settings.type : undefined,
                progress: settings.progressBar === true,
                icon: settings.icon,
                onAction: close,
                iconProvider: sharedBackstage.providers.icons,
                backstageProvider: sharedBackstage.providers,
            }));
            if (!notificationRegion.isSet()) {
                const notificationWrapper = build$1(InlineView.sketch({
                    dom: {
                        tag: 'div',
                        classes: ['tox-notifications-container'],
                        attributes: {
                            'aria-label': 'Notifications',
                            'role': 'region'
                        }
                    },
                    lazySink: sharedBackstage.getSink,
                    fireDismissalEventInstead: {},
                    ...sharedBackstage.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} },
                    inlineBehaviours: derive$1([
                        Keying.config({
                            mode: 'cyclic',
                            selector: '.tox-notification, .tox-notification a, .tox-notification button',
                        }),
                        Replacing.config({}),
                        ...(shouldApplyDocking()
                            ? [
                                Docking.config({
                                    contextual: {
                                        lazyContext: () => Optional.some(box$1(getBoundsContainer())),
                                        fadeInClass: 'tox-notification-container-dock-fadein',
                                        fadeOutClass: 'tox-notification-container-dock-fadeout',
                                        transitionClass: 'tox-notification-container-dock-transition'
                                    },
                                    modes: ['top'],
                                    lazyViewport: (comp) => {
                                        const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);
                                        return optScrollingContext
                                            .map((sc) => {
                                            const combinedBounds = getBoundsFrom(sc);
                                            return {
                                                bounds: combinedBounds,
                                                optScrollEnv: Optional.some({
                                                    currentScrollTop: sc.element.dom.scrollTop,
                                                    scrollElmTop: absolute$3(sc.element).top
                                                })
                                            };
                                        }).getOrThunk(() => ({
                                            bounds: win(),
                                            optScrollEnv: Optional.none()
                                        }));
                                    }
                                })
                            ] : [])
                    ])
                }));
                const notificationSpec = premade(notification);
                const anchorOverrides = {
                    maxHeightFunction: expandable$1()
                };
                const anchor = {
                    ...sharedBackstage.anchors.banner(),
                    overrides: anchorOverrides
                };
                notificationRegion.set(notificationWrapper);
                uiMothership.add(notificationWrapper);
                InlineView.showWithinBounds(notificationWrapper, notificationSpec, { anchor }, getBounds);
            }
            else {
                const notificationSpec = premade(notification);
                notificationRegion.on((notificationWrapper) => {
                    Replacing.append(notificationWrapper, notificationSpec);
                    InlineView.reposition(notificationWrapper);
                    if (notification.hasConfigured(Docking)) {
                        Docking.refresh(notificationWrapper);
                    }
                    clampComponentsToBounds(notificationWrapper.components());
                });
            }
            if (isNumber(settings.timeout) && settings.timeout > 0) {
                global$a.setEditorTimeout(editor, () => {
                    close();
                }, settings.timeout);
            }
            const reposition = () => {
                notificationRegion.on((region) => {
                    InlineView.reposition(region);
                    if (region.hasConfigured(Docking)) {
                        Docking.refresh(region);
                    }
                    clampComponentsToBounds(region.components());
                });
            };
            const thisNotification = {
                close,
                reposition,
                text: (nuText) => {
                    // check if component is still mounted
                    Notification.updateText(notification, nuText);
                },
                settings,
                getEl: () => notification.element.dom,
                progressBar: {
                    value: (percent) => {
                        Notification.updateProgress(notification, percent);
                    }
                }
            };
            return thisNotification;
        };
        const close = (notification) => {
            notification.close();
        };
        const getArgs = (notification) => {
            return notification.settings;
        };
        return {
            open,
            close,
            getArgs
        };
    };

    const setup$c = (api, editor) => {
        const redirectKeyToItem = (item, e) => {
            emitWith(item, keydown(), { raw: e });
        };
        const getItem = () => api.getMenu().bind(Highlighting.getHighlighted);
        editor.on('keydown', (e) => {
            const keyCode = e.which;
            // If the autocompleter isn't activated then do nothing
            if (!api.isActive()) {
                return;
            }
            if (api.isMenuOpen()) {
                // Pressing <enter> executes any item currently selected, or does nothing
                if (keyCode === 13) {
                    getItem().each(emitExecute);
                    e.preventDefault();
                    // Pressing <down> either highlights the first option, or moves down the menu
                }
                else if (keyCode === 40) {
                    getItem().fold(
                    // No current item, so highlight the first one
                    () => {
                        api.getMenu().each(Highlighting.highlightFirst);
                    }, 
                    // There is a current item, so move down in the menu
                    (item) => {
                        redirectKeyToItem(item, e);
                    });
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    // Pressing <up>, <left>, <right> gets redirected to the selected item
                }
                else if (keyCode === 37 || keyCode === 38 || keyCode === 39) {
                    getItem().each((item) => {
                        redirectKeyToItem(item, e);
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    });
                }
            }
            else {
                // Pressing <enter>, <down> or <up> closes the autocompleter when it's active but the menu isn't open
                if (keyCode === 13 || keyCode === 38 || keyCode === 40) {
                    api.cancelIfNecessary();
                }
            }
        });
        editor.on('NodeChange', () => {
            // Close if active, not in the middle of an onAction callback and we're no longer inside the autocompleter span
            if (api.isActive() && !api.isProcessingAction() && !editor.queryCommandState('mceAutoCompleterInRange')) {
                api.cancelIfNecessary();
            }
        });
    };
    const AutocompleterEditorEvents = {
        setup: setup$c
    };

    var ItemResponse;
    (function (ItemResponse) {
        ItemResponse[ItemResponse["CLOSE_ON_EXECUTE"] = 0] = "CLOSE_ON_EXECUTE";
        ItemResponse[ItemResponse["BUBBLE_TO_SANDBOX"] = 1] = "BUBBLE_TO_SANDBOX";
    })(ItemResponse || (ItemResponse = {}));
    var ItemResponse$1 = ItemResponse;

    const navClass = 'tox-menu-nav__js';
    const selectableClass = 'tox-collection__item';
    const colorClass = 'tox-swatch';
    const presetClasses = {
        normal: navClass,
        color: colorClass
    };
    const tickedClass = 'tox-collection__item--enabled';
    const groupHeadingClass = 'tox-collection__group-heading';
    const iconClass = 'tox-collection__item-icon';
    const imageClass = 'tox-collection__item-image';
    const imageSelectorClasll = 'tox-collection__item-image-selector';
    const textClass = 'tox-collection__item-label';
    const accessoryClass = 'tox-collection__item-accessory';
    const caretClass = 'tox-collection__item-caret';
    const checkmarkClass = 'tox-collection__item-checkmark';
    const activeClass = 'tox-collection__item--active';
    const containerClass = 'tox-collection__item-container';
    const containerColumnClass = 'tox-collection__item-container--column';
    const containerRowClass = 'tox-collection__item-container--row';
    const containerAlignRightClass = 'tox-collection__item-container--align-right';
    const containerAlignLeftClass = 'tox-collection__item-container--align-left';
    const containerValignTopClass = 'tox-collection__item-container--valign-top';
    const containerValignMiddleClass = 'tox-collection__item-container--valign-middle';
    const containerValignBottomClass = 'tox-collection__item-container--valign-bottom';
    const classForPreset = (presets) => get$h(presetClasses, presets).getOr(navClass);

    const forMenu = (presets) => {
        if (presets === 'color') {
            return 'tox-swatches';
        }
        else {
            return 'tox-menu';
        }
    };
    const classes = (presets) => ({
        backgroundMenu: 'tox-background-menu',
        selectedMenu: 'tox-selected-menu',
        selectedItem: 'tox-collection__item--active',
        hasIcons: 'tox-menu--has-icons',
        menu: forMenu(presets),
        tieredMenu: 'tox-tiered-menu'
    });

    const markers = (presets) => {
        const menuClasses = classes(presets);
        return {
            backgroundMenu: menuClasses.backgroundMenu,
            selectedMenu: menuClasses.selectedMenu,
            menu: menuClasses.menu,
            selectedItem: menuClasses.selectedItem,
            item: classForPreset(presets)
        };
    };
    const dom = (hasIcons, columns, presets) => {
        const menuClasses = classes(presets);
        return {
            tag: 'div',
            classes: flatten([
                [menuClasses.menu, `tox-menu-${columns}-column`],
                hasIcons ? [menuClasses.hasIcons] : []
            ])
        };
    };
    const components = [
        Menu.parts.items({})
    ];
    // NOTE: Up to here.
    const part = (hasIcons, columns, presets) => {
        const menuClasses = classes(presets);
        const d = {
            tag: 'div',
            classes: flatten([
                [menuClasses.tieredMenu]
            ])
        };
        return {
            dom: d,
            markers: markers(presets)
        };
    };

    // This event is triggered by a menu item from a dropdown when it wants the
    // dropdown to refetch its contents based on a search string.
    const refetchTriggerEvent = generate$6('refetch-trigger-event');
    // This event is triggerd by a menu item from a dropdown, when it wants to
    // redispatch that event to the currently active item of that dropdown menu. It will
    // be used in situations where the event should be firing on the item with fake focus,
    // but instead it is firing on the item with real focus (e.g of real focus:
    // menu search field)
    const redirectMenuItemInteractionEvent = generate$6('redirect-menu-item-interaction');

    // This is not stored in ItemClasses, because the searcher is not actually
    // contained within items. It isn't part of their navigation, and it
    // isn't maintained by menus. It is just part of the first menu, but
    // not its items.
    const menuSearcherClass = 'tox-menu__searcher';
    // Ideally, we'd be using mementos to find it again, but we'd need to pass
    // that memento onto the dropdown, which isn't going to have it. Especially,
    // because the dropdown isn't responsible for putting this searcher component
    // into the menu, NestedMenus is.
    const findWithinSandbox = (sandboxComp) => {
        return descendant(sandboxComp.element, `.${menuSearcherClass}`).bind((inputElem) => sandboxComp.getSystem().getByDom(inputElem).toOptional());
    };
    // There is nothing sandbox-specific about this code. It just needs to be
    // a container that wraps the search field.
    const findWithinMenu = findWithinSandbox;
    const restoreState = (inputComp, searcherState) => {
        Representing.setValue(inputComp, searcherState.fetchPattern);
        inputComp.element.dom.selectionStart = searcherState.selectionStart;
        inputComp.element.dom.selectionEnd = searcherState.selectionEnd;
    };
    const saveState = (inputComp) => {
        const fetchPattern = Representing.getValue(inputComp);
        const selectionStart = inputComp.element.dom.selectionStart;
        const selectionEnd = inputComp.element.dom.selectionEnd;
        return {
            fetchPattern,
            selectionStart,
            selectionEnd
        };
    };
    // Make sure there is ARIA communicating the currently active item in the results.
    const setActiveDescendant = (inputComp, active) => {
        getOpt(active.element, 'id')
            .each((id) => set$9(inputComp.element, 'aria-activedescendant', id));
    };
    const renderMenuSearcher = (spec) => {
        const handleByBrowser = (comp, se) => {
            // We "cut" this event, so that the browser still handles it, but it is not processed
            // by any of the above alloy components. We could also do this by stopping propagation,
            // but not preventing default, but it's probably good to allow some overarching thing
            // in the DOM (outside of alloy) to stop it if they want to.
            se.cut();
            // Returning a Some here (regardless of boolean value) is going to call `stop` on the
            // simulated event, which is going to call: preventDefault and stopPropagation. We want
            // neither of these things to happen, so we return None here to say that it hasn't been
            // handled. But because we've cut it, it will not propagate to any other alloy components
            return Optional.none();
        };
        const handleByHighlightedItem = (comp, se) => {
            // Because we need to redispatch based on highlighted items that we don't know about here,
            // we are going to emit an event, that the sandbox listens to, and the sandbox will
            // redispatch the event.
            const eventData = {
                interactionEvent: se.event,
                eventType: se.event.raw.type
            };
            emitWith(comp, redirectMenuItemInteractionEvent, eventData);
            return Optional.some(true);
        };
        const customSearcherEventsName = 'searcher-events';
        return {
            dom: {
                tag: 'div',
                // NOTE: This is very intentionally NOT the navigation class, because
                // we don't want the searcher to be part of the navigation. This class
                // is just for styling consistency. Perhaps it should be its own class.
                classes: [selectableClass]
            },
            components: [
                Input.sketch({
                    inputClasses: [menuSearcherClass, 'tox-textfield'],
                    inputAttributes: {
                        ...(spec.placeholder.map((placeholder) => ({ placeholder: spec.i18n(placeholder) })).getOr({})),
                        // This ARIA is based on the algolia example documented in TINY-8952
                        'type': 'search',
                        'aria-autocomplete': 'list'
                    },
                    inputBehaviours: derive$1([
                        config(customSearcherEventsName, [
                            // When the user types into the search field, we want to retrigger
                            // a fetch on the dropdown. This will be fired from within the
                            // dropdown's sandbox, so the dropdown is going to have to listen
                            // for it there. See CommonDropdown.ts.
                            run$1(
                            // Use "input" to handle keydown, paste etc.
                            input(), (inputComp) => {
                                emit(inputComp, refetchTriggerEvent);
                            }),
                            run$1(keydown(), (inputComp, se) => {
                                // The Special Keying config type since TINY-7005 processes the Escape
                                // key on keyup, not keydown. We need to stop the keydown event for this
                                // input, because some browsers (e.g. Chrome) will process a keydown
                                // for Escape inside an input[type=search] by clearing the input value,
                                // and then triggering an "input" event. This "input" event will trigger
                                // a refetch, which if it completes before the keyup is fired for Escape,
                                // will go back to only showing one level of menu. Then, when the escape
                                // keyup is processed by Keying, it will close the single remaining menu.
                                // This has the effect of closing *all* menus that are open when Escape is
                                // pressed instead of the last one. So, instead, we are going to kill the
                                // keydown event, so that it doesn't have the default browser behaviour, and
                                // won't trigger an input (and then Refetch). Then the keyup will still fire
                                // so just one level of the menu will close. This is all based on the underlying
                                // assumption that preventDefault and/or stop on a keydown does not suppress
                                // the related keyup. All of the documentation found so far, suggests it should
                                // only suppress the keypress, not the keyup, but that might not be across all
                                // browsers, or implemented consistently.
                                if (se.event.raw.key === 'Escape') {
                                    se.stop();
                                }
                            })
                        ]),
                        // In addition to input handling, we want special handling for
                        // Up/Down/Left/Right/Enter/Escape/Space. We can divide these into two categories
                        //  - events that we don't want to allow the overall menu system to process (left and right and space)
                        //  - events that we want to redispatch on the "highlighted item" based on the
                        // current fake focus.
                        Keying.config({
                            mode: 'special',
                            onLeft: handleByBrowser,
                            onRight: handleByBrowser,
                            onSpace: handleByBrowser,
                            onEnter: handleByHighlightedItem,
                            onEscape: handleByHighlightedItem,
                            onUp: handleByHighlightedItem,
                            onDown: handleByHighlightedItem
                        })
                    ]),
                    // Because we have customised handling for keydown, and we are configuring
                    // Keying, we need to specify which "behaviour" (custom events or keying) gets to
                    // process the keydown event first. In this situation, we want to stop escape before
                    // anything happens (although it really isn't necessary)
                    eventOrder: {
                        keydown: [customSearcherEventsName, Keying.name()]
                    }
                })
            ]
        };
    };

    const searchResultsClass = 'tox-collection--results__js';
    // NOTE: this is operating on the the final AlloySpec
    const augmentWithAria = (item) => {
        var _a;
        if (item.dom) {
            return {
                ...item,
                dom: {
                    ...item.dom,
                    attributes: {
                        ...(_a = item.dom.attributes) !== null && _a !== void 0 ? _a : {},
                        'id': generate$6('aria-item-search-result-id'),
                        'aria-selected': 'false'
                    }
                }
            };
        }
        else {
            return item;
        }
    };

    const widgetAriaLabel = 'Use arrow keys to navigate.';
    const chunk = (rowDom, numColumns) => (items) => {
        const chunks = chunk$1(items, numColumns);
        return map$2(chunks, (c) => ({
            dom: rowDom,
            components: c
        }));
    };
    const forSwatch = (columns) => ({
        dom: {
            tag: 'div',
            classes: ['tox-menu', 'tox-swatches-menu'],
            attributes: {
                'aria-label': global$6.translate(widgetAriaLabel)
            }
        },
        components: [
            {
                dom: {
                    tag: 'div',
                    classes: ['tox-swatches']
                },
                components: [
                    Menu.parts.items({
                        preprocess: columns !== 'auto' ? chunk({
                            tag: 'div',
                            classes: ['tox-swatches__row']
                        }, columns) : identity
                    })
                ]
            }
        ]
    });
    const forImageSelector = (columns) => ({
        dom: {
            tag: 'div',
            classes: ['tox-menu', 'tox-image-selector-menu']
        },
        components: [
            {
                dom: {
                    tag: 'div',
                    classes: ['tox-image-selector']
                },
                components: [
                    Menu.parts.items({
                        preprocess: columns !== 'auto' ? chunk({
                            tag: 'div',
                            classes: ['tox-image-selector__row']
                        }, columns) : identity
                    })
                ]
            }
        ]
    });
    const forToolbar = (columns) => ({
        dom: {
            tag: 'div',
            // TODO: Configurable lg setting?
            classes: ['tox-menu', 'tox-collection', 'tox-collection--toolbar', 'tox-collection--toolbar-lg']
        },
        components: [
            Menu.parts.items({
                preprocess: chunk({
                    tag: 'div',
                    classes: ['tox-collection__group']
                }, columns)
            })
        ]
    });
    // NOTE: That type signature isn't quite true.
    const preprocessCollection = (items, isSeparator) => {
        const allSplits = [];
        let currentSplit = [];
        each$1(items, (item, i) => {
            if (isSeparator(item, i)) {
                if (currentSplit.length > 0) {
                    allSplits.push(currentSplit);
                }
                currentSplit = [];
                if (has$2(item.dom, 'innerHtml') || item.components && item.components.length > 0) {
                    currentSplit.push(item);
                }
            }
            else {
                currentSplit.push(item);
            }
        });
        if (currentSplit.length > 0) {
            allSplits.push(currentSplit);
        }
        return map$2(allSplits, (s) => ({
            dom: {
                tag: 'div',
                classes: ['tox-collection__group']
            },
            components: s
        }));
    };
    const insertItemsPlaceholder = (columns, initItems, onItem) => {
        return Menu.parts.items({
            preprocess: (rawItems) => {
                // Add any information to the items that is required. For example
                // when the items are results in a searchable menu, we need them to have
                // an ID that can be referenced by aria-activedescendant
                const enrichedItems = map$2(rawItems, onItem);
                if (columns !== 'auto' && columns > 1) {
                    return chunk({
                        tag: 'div',
                        classes: ['tox-collection__group']
                    }, columns)(enrichedItems);
                }
                else {
                    return preprocessCollection(enrichedItems, (_item, i) => initItems[i].type === 'separator');
                }
            }
        });
    };
    const hasWidget = (items) => exists(items, (item) => item.type === 'widget');
    const forCollection = (columns, initItems, _hasIcons = true) => ({
        dom: {
            tag: 'div',
            classes: ['tox-menu', 'tox-collection'].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid']),
            attributes: {
                // widget item can be inserttable, colorswatch or imageselect - all of them are navigated with arrow keys
                ...hasWidget(initItems) ? { 'aria-label': global$6.translate(widgetAriaLabel) } : {}
            },
        },
        components: [
            // We don't need to add IDs for each item because there are no
            // aria relationships we need to maintain
            insertItemsPlaceholder(columns, initItems, identity)
        ]
    });
    const forCollectionWithSearchResults = (columns, initItems, _hasIcons = true) => {
        // A collection with results is exactly like a collection, except it also has
        // an ID and class on its outer div to allow for aria-controls relationships, and ids
        // on its items.
        // This connects the search bar with the list box.
        const ariaControlsSearchResults = generate$6('aria-controls-search-results');
        return {
            dom: {
                tag: 'div',
                classes: ['tox-menu', 'tox-collection', searchResultsClass].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid']),
                attributes: {
                    id: ariaControlsSearchResults
                }
            },
            components: [
                // For each item, it needs to have an ID, so that we can refer to it
                // by the aria-activedescendant attribute
                insertItemsPlaceholder(columns, initItems, augmentWithAria)
            ]
        };
    };
    // Does a searchable menu *really* support columns !== 1 ?
    const forCollectionWithSearchField = (columns, initItems, searchField) => {
        // This connects the search bar with the list box.
        const ariaControlsSearchResults = generate$6('aria-controls-search-results');
        return {
            dom: {
                tag: 'div',
                classes: ['tox-menu', 'tox-collection'].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid'])
            },
            components: [
                // Importantly, the search bar is not in the "items" part, which means that it is
                // not given any of the item decorations by default. In order to ensure that is
                // not part of the navigation, however, we need to prevent it from getting the nav
                // class. For general collection menu items, it is navClass, which is:
                // tox-menu-nav__js. So simply, do not add this class when creating
                // the search, so that it isn't in the navigation. Ideally, it would only ever look
                // inside its items section, but the items aren't guaranteed to have a separate
                // container, and navigation candidates are found anywhere inside the menu
                // container. We could add configuration to alloy's Menu movement, where there was
                // a 'navigation container' that all items would be in. That could be another
                // way to solve the problem. For now, we'll just manually avoid adding the navClass
                renderMenuSearcher({
                    i18n: global$6.translate,
                    placeholder: searchField.placeholder
                }),
                {
                    // We need a separate container for the items, because this is the container
                    // that multiple tox-collection__groups might go into, and will be the container
                    // that the search bar controls.
                    dom: {
                        tag: 'div',
                        classes: [
                            ...(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid']),
                            searchResultsClass
                        ],
                        attributes: {
                            id: ariaControlsSearchResults
                        }
                    },
                    components: [
                        // For each item, it needs to have an ID, so that we can refer to it
                        // by the aria-activedescendant attribute
                        insertItemsPlaceholder(columns, initItems, augmentWithAria)
                    ]
                }
            ]
        };
    };
    const forHorizontalCollection = (initItems, _hasIcons = true) => ({
        dom: {
            tag: 'div',
            classes: ['tox-collection', 'tox-collection--horizontal']
        },
        components: [
            Menu.parts.items({
                preprocess: (items) => preprocessCollection(items, (_item, i) => initItems[i].type === 'separator')
            })
        ]
    });

    const menuHasIcons = (xs) => exists(xs, (item) => 'icon' in item && item.icon !== undefined);
    const handleError = (error) => {
        // eslint-disable-next-line no-console
        console.error(formatError(error));
        // eslint-disable-next-line no-console
        console.log(error);
        return Optional.none();
    };
    const createHorizontalPartialMenuWithAlloyItems = (value, _hasIcons, items, _columns, _menuLayout) => {
        // Horizontal collections do not support different menu layout structures currently.
        const structure = forHorizontalCollection(items);
        return {
            value,
            dom: structure.dom,
            components: structure.components,
            items
        };
    };
    const createPartialMenuWithAlloyItems = (value, hasIcons, items, columns, menuLayout) => {
        const getNormalStructure = () => {
            if (menuLayout.menuType !== 'searchable') {
                return forCollection(columns, items);
            }
            else {
                return menuLayout.searchMode.searchMode === 'search-with-field'
                    ? forCollectionWithSearchField(columns, items, menuLayout.searchMode)
                    : forCollectionWithSearchResults(columns, items);
            }
        };
        if (menuLayout.menuType === 'color') {
            const structure = forSwatch(columns);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items
            };
        }
        else if (menuLayout.menuType === 'imageselector' && columns !== 'auto') {
            const structure = forImageSelector(columns);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items
            };
        }
        else if (menuLayout.menuType === 'normal' && columns === 'auto') {
            const structure = forCollection(columns, items);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items
            };
        }
        else if (menuLayout.menuType === 'normal' || menuLayout.menuType === 'searchable') {
            const structure = getNormalStructure();
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items
            };
        }
        else if (menuLayout.menuType === 'listpreview' && columns !== 'auto') {
            const structure = forToolbar(columns);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items
            };
        }
        else {
            return {
                value,
                dom: dom(hasIcons, columns, menuLayout.menuType),
                components: components,
                items
            };
        }
    };

    const type = requiredString('type');
    const name = requiredString('name');
    const label = requiredString('label');
    const text = requiredString('text');
    const title = requiredString('title');
    const icon = requiredString('icon');
    const url = requiredString('url');
    const value = requiredString('value');
    const fetch = requiredFunction('fetch');
    const getSubmenuItems = requiredFunction('getSubmenuItems');
    const onAction = requiredFunction('onAction');
    const onItemAction = requiredFunction('onItemAction');
    const onSetup = defaultedFunction('onSetup', () => noop);
    const optionalName = optionString('name');
    const optionalText = optionString('text');
    const optionalRole = optionString('role');
    const optionalIcon = optionString('icon');
    const optionalTooltip = optionString('tooltip');
    const optionalChevronTooltip = optionString('chevronTooltip');
    const optionalLabel = optionString('label');
    const optionalShortcut = optionString('shortcut');
    const optionalSelect = optionFunction('select');
    const active = defaultedBoolean('active', false);
    const borderless = defaultedBoolean('borderless', false);
    const enabled = defaultedBoolean('enabled', true);
    const primary = defaultedBoolean('primary', false);
    const defaultedColumns = (num) => defaulted('columns', num);
    const defaultedMeta = defaulted('meta', {});
    const defaultedOnAction = defaultedFunction('onAction', noop);
    const defaultedType = (type) => defaultedString('type', type);
    const generatedName = (namePrefix) => field$1('name', 'name', defaultedThunk(() => generate$6(`${namePrefix}-name`)), string);
    const generatedValue = (valuePrefix) => field$1('value', 'value', defaultedThunk(() => generate$6(`${valuePrefix}-value`)), anyValue());

    const alertBannerFields = [
        type,
        text,
        requiredStringEnum('level', ['info', 'warn', 'error', 'success']),
        icon,
        defaulted('url', '')
    ];
    const alertBannerSchema = objOf(alertBannerFields);

    const createBarFields = (itemsField) => [
        type,
        itemsField
    ];

    const buttonFields = [
        type,
        text,
        enabled,
        generatedName('button'),
        optionalIcon,
        borderless,
        // this should be defaulted to `secondary` but the implementation needs to manage the deprecation
        optionStringEnum('buttonType', ['primary', 'secondary', 'toolbar']),
        // this should be removed, but must live here because FieldSchema doesn't have a way to manage deprecated fields
        primary,
        defaultedString('context', 'mode:design')
    ];
    const buttonSchema = objOf(buttonFields);

    const formComponentFields = [
        type,
        name
    ];
    const formComponentWithLabelFields = formComponentFields.concat([
        optionalLabel
    ]);

    const checkboxFields = formComponentFields.concat([
        label,
        enabled,
        defaultedString('context', 'mode:design')
    ]);
    const checkboxSchema = objOf(checkboxFields);
    const checkboxDataProcessor = boolean;

    const collectionFields = formComponentWithLabelFields.concat([
        defaultedColumns('auto'),
        defaultedString('context', 'mode:design')
    ]);
    const collectionSchema = objOf(collectionFields);
    // TODO: Make type for CollectionItem
    const collectionDataProcessor = arrOfObj([
        value,
        text,
        icon
    ]);

    const colorInputFields = formComponentWithLabelFields.concat([
        defaultedString('storageKey', 'default'),
        defaultedString('context', 'mode:design'),
    ]);
    const colorInputSchema = objOf(colorInputFields);
    const colorInputDataProcessor = string;

    const colorPickerFields = formComponentWithLabelFields;
    const colorPickerSchema = objOf(colorPickerFields);
    const colorPickerDataProcessor = string;

    const customEditorFields = formComponentFields.concat([
        defaultedString('tag', 'textarea'),
        requiredString('scriptId'),
        requiredString('scriptUrl'),
        optionFunction('onFocus'),
        defaultedPostMsg('settings', undefined)
    ]);
    const customEditorFieldsOld = formComponentFields.concat([
        defaultedString('tag', 'textarea'),
        requiredFunction('init')
    ]);
    const customEditorSchema = valueOf((v) => asRaw('customeditor.old', objOfOnly(customEditorFieldsOld), v).orThunk(() => asRaw('customeditor.new', objOfOnly(customEditorFields), v)));
    const customEditorDataProcessor = string;

    const commonMenuItemFields = [
        enabled,
        optionalText,
        optionalRole,
        optionalShortcut,
        generatedValue('menuitem'),
        defaultedMeta,
        defaultedString('context', 'mode:design')
    ];

    const dialogToggleMenuItemSchema = objOf([
        type,
        name
    ].concat(commonMenuItemFields));
    const dialogToggleMenuItemDataProcessor = boolean;

    const baseFooterButtonFields = [
        generatedName('button'),
        optionalIcon,
        defaultedStringEnum('align', 'end', ['start', 'end']),
        // this should be removed, but must live here because FieldSchema doesn't have a way to manage deprecated fields
        primary,
        enabled,
        // this should be defaulted to `secondary` but the implementation needs to manage the deprecation
        optionStringEnum('buttonType', ['primary', 'secondary']),
        defaultedString('context', 'mode:design')
    ];
    const dialogFooterButtonFields = [
        ...baseFooterButtonFields,
        text
    ];
    const normalFooterButtonFields = [
        requiredStringEnum('type', ['submit', 'cancel', 'custom']),
        ...dialogFooterButtonFields
    ];
    const menuFooterButtonFields = [
        requiredStringEnum('type', ['menu']),
        optionalText,
        optionalTooltip,
        optionalIcon,
        requiredArrayOf('items', dialogToggleMenuItemSchema),
        ...baseFooterButtonFields
    ];
    const toggleButtonSpecFields = [
        ...baseFooterButtonFields,
        requiredStringEnum('type', ['togglebutton']),
        optionalTooltip,
        optionalIcon,
        optionalText,
        defaultedBoolean('active', false)
    ];
    const dialogFooterButtonSchema = choose$1('type', {
        submit: normalFooterButtonFields,
        cancel: normalFooterButtonFields,
        custom: normalFooterButtonFields,
        menu: menuFooterButtonFields,
        togglebutton: toggleButtonSpecFields
    });

    const dropZoneFields = formComponentWithLabelFields.concat([
        defaultedString('context', 'mode:design'),
    ]);
    const dropZoneSchema = objOf(dropZoneFields);
    const dropZoneDataProcessor = arrOfVal();

    const createGridFields = (itemsField) => [
        type,
        requiredNumber('columns'),
        itemsField
    ];

    const htmlPanelFields = [
        type,
        requiredString('html'),
        defaultedStringEnum('presets', 'presentation', ['presentation', 'document']),
        defaultedFunction('onInit', noop),
        defaultedBoolean('stretched', false),
    ];
    const htmlPanelSchema = objOf(htmlPanelFields);

    const iframeFields = formComponentWithLabelFields.concat([
        defaultedBoolean('border', false),
        defaultedBoolean('sandboxed', true),
        defaultedBoolean('streamContent', false),
        defaultedBoolean('transparent', true)
    ]);
    const iframeSchema = objOf(iframeFields);
    const iframeDataProcessor = string;

    const imagePreviewSchema = objOf(formComponentFields.concat([
        optionString('height'),
    ]));
    const imagePreviewDataProcessor = objOf([
        requiredString('url'),
        optionNumber('zoom'),
        optionNumber('cachedWidth'),
        optionNumber('cachedHeight'),
    ]);

    const inputFields = formComponentWithLabelFields.concat([
        optionString('inputMode'),
        optionString('placeholder'),
        defaultedBoolean('maximized', false),
        enabled,
        defaultedString('context', 'mode:design'),
    ]);
    const inputSchema = objOf(inputFields);
    const inputDataProcessor = string;

    const createLabelFields = (itemsField) => [
        type,
        label,
        itemsField,
        defaultedStringEnum('align', 'start', ['start', 'center', 'end']),
        optionString('for')
    ];

    const listBoxSingleItemFields = [
        text,
        value
    ];
    const listBoxNestedItemFields = [
        text,
        requiredArrayOf('items', thunkOf('items', () => listBoxItemSchema))
    ];
    const listBoxItemSchema = oneOf([
        objOf(listBoxSingleItemFields),
        objOf(listBoxNestedItemFields)
    ]);
    const listBoxFields = formComponentWithLabelFields.concat([
        requiredArrayOf('items', listBoxItemSchema),
        enabled,
        defaultedString('context', 'mode:design')
    ]);
    const listBoxSchema = objOf(listBoxFields);
    const listBoxDataProcessor = string;

    const selectBoxFields = formComponentWithLabelFields.concat([
        requiredArrayOfObj('items', [
            text,
            value
        ]),
        defaultedNumber('size', 1),
        enabled,
        defaultedString('context', 'mode:design')
    ]);
    const selectBoxSchema = objOf(selectBoxFields);
    const selectBoxDataProcessor = string;

    const sizeInputFields = formComponentWithLabelFields.concat([
        defaultedBoolean('constrain', true),
        enabled,
        defaultedString('context', 'mode:design')
    ]);
    const sizeInputSchema = objOf(sizeInputFields);
    const sizeInputDataProcessor = objOf([
        requiredString('width'),
        requiredString('height')
    ]);

    const sliderFields = formComponentFields.concat([
        label,
        defaultedNumber('min', 0),
        defaultedNumber('max', 0),
    ]);
    const sliderSchema = objOf(sliderFields);
    const sliderInputDataProcessor = number;

    const tableFields = [
        type,
        requiredArrayOf('header', string),
        requiredArrayOf('cells', arrOf(string))
    ];
    const tableSchema = objOf(tableFields);

    const textAreaFields = formComponentWithLabelFields.concat([
        optionString('placeholder'),
        defaultedBoolean('maximized', false),
        enabled,
        defaultedString('context', 'mode:design'),
        optionBoolean('spellcheck'),
    ]);
    const textAreaSchema = objOf(textAreaFields);
    const textAreaDataProcessor = string;

    const baseMenuButtonFields = [
        defaultedString('buttonType', 'default'),
        optionString('text'),
        optionString('tooltip'),
        optionString('icon'),
        defaultedOf('search', false, 
        // So our boulder validation are:
        // a) boolean -> we need to map it into an Option
        // b) object -> we need to map it into a Some
        oneOf([
            // Unfortunately, due to objOf not checking to see that the
            // input is an object, the boolean check MUST be first
            boolean,
            objOf([
                optionString('placeholder')
            ])
        ], 
        // This function allows you to standardise the output.
        (x) => {
            if (isBoolean(x)) {
                return x ? Optional.some({ placeholder: Optional.none() }) : Optional.none();
            }
            else {
                return Optional.some(x);
            }
        })),
        requiredFunction('fetch'),
        defaultedFunction('onSetup', () => noop),
        defaultedString('context', 'mode:design')
    ];

    const MenuButtonSchema = objOf([
        type,
        ...baseMenuButtonFields
    ]);
    const createMenuButton = (spec) => asRaw('menubutton', MenuButtonSchema, spec);

    const baseTreeItemFields = [
        requiredStringEnum('type', ['directory', 'leaf']),
        title,
        requiredString('id'),
        optionOf('menu', MenuButtonSchema),
        optionString('customStateIcon'),
        optionString('customStateIconTooltip'),
    ];
    const treeItemLeafFields = baseTreeItemFields;
    const treeItemLeafSchema = objOf(treeItemLeafFields);
    const treeItemDirectoryFields = baseTreeItemFields.concat([
        requiredArrayOf('children', thunkOf('children', () => {
            return choose$2('type', {
                directory: treeItemDirectorySchema,
                leaf: treeItemLeafSchema,
            });
        })),
    ]);
    const treeItemDirectorySchema = objOf(treeItemDirectoryFields);
    const treeItemSchema = choose$2('type', {
        directory: treeItemDirectorySchema,
        leaf: treeItemLeafSchema,
    });
    const treeFields = [
        type,
        requiredArrayOf('items', treeItemSchema),
        optionFunction('onLeafAction'),
        optionFunction('onToggleExpand'),
        defaultedArrayOf('defaultExpandedIds', [], string),
        optionString('defaultSelectedId'),
    ];
    const treeSchema = objOf(treeFields);

    const urlInputFields = formComponentWithLabelFields.concat([
        defaultedStringEnum('filetype', 'file', ['image', 'media', 'file']),
        enabled,
        optionString('picker_text'),
        defaultedString('context', 'mode:design')
    ]);
    const urlInputSchema = objOf(urlInputFields);
    const urlInputDataProcessor = objOf([
        value,
        defaultedMeta
    ]);

    const createItemsField = (name) => field$1('items', 'items', required$2(), arrOf(valueOf((v) => asRaw(`Checking item of ${name}`, itemSchema$1, v).fold((sErr) => Result.error(formatError(sErr)), (passValue) => Result.value(passValue)))));
    // We're using a thunk here so we can refer to panel fields
    const itemSchema$1 = valueThunk(() => choose$2('type', {
        alertbanner: alertBannerSchema,
        bar: objOf(createBarFields(createItemsField('bar'))),
        button: buttonSchema,
        checkbox: checkboxSchema,
        colorinput: colorInputSchema,
        colorpicker: colorPickerSchema,
        dropzone: dropZoneSchema,
        grid: objOf(createGridFields(createItemsField('grid'))),
        iframe: iframeSchema,
        input: inputSchema,
        listbox: listBoxSchema,
        selectbox: selectBoxSchema,
        sizeinput: sizeInputSchema,
        slider: sliderSchema,
        textarea: textAreaSchema,
        urlinput: urlInputSchema,
        customeditor: customEditorSchema,
        htmlpanel: htmlPanelSchema,
        imagepreview: imagePreviewSchema,
        collection: collectionSchema,
        label: objOf(createLabelFields(createItemsField('label'))),
        table: tableSchema,
        tree: treeSchema,
        panel: panelSchema
    }));
    const panelFields = [
        type,
        defaulted('classes', []),
        requiredArrayOf('items', itemSchema$1)
    ];
    const panelSchema = objOf(panelFields);

    const tabFields = [
        generatedName('tab'),
        title,
        requiredArrayOf('items', itemSchema$1)
    ];
    const tabPanelFields = [
        type,
        requiredArrayOfObj('tabs', tabFields)
    ];
    const tabPanelSchema = objOf(tabPanelFields);

    const dialogButtonFields = dialogFooterButtonFields;
    const dialogButtonSchema = dialogFooterButtonSchema;
    const dialogSchema = objOf([
        requiredString('title'),
        requiredOf('body', choose$2('type', {
            panel: panelSchema,
            tabpanel: tabPanelSchema
        })),
        defaultedString('size', 'normal'),
        defaultedArrayOf('buttons', [], dialogButtonSchema),
        defaulted('initialData', {}),
        defaultedFunction('onAction', noop),
        defaultedFunction('onChange', noop),
        defaultedFunction('onSubmit', noop),
        defaultedFunction('onClose', noop),
        defaultedFunction('onCancel', noop),
        defaultedFunction('onTabChange', noop)
    ]);
    const createDialog = (spec) => asRaw('dialog', dialogSchema, spec);

    const urlDialogButtonSchema = objOf([
        requiredStringEnum('type', ['cancel', 'custom']),
        ...dialogButtonFields
    ]);
    const urlDialogSchema = objOf([
        requiredString('title'),
        requiredString('url'),
        optionNumber('height'),
        optionNumber('width'),
        optionArrayOf('buttons', urlDialogButtonSchema),
        defaultedFunction('onAction', noop),
        defaultedFunction('onCancel', noop),
        defaultedFunction('onClose', noop),
        defaultedFunction('onMessage', noop)
    ]);
    const createUrlDialog = (spec) => asRaw('dialog', urlDialogSchema, spec);

    // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    const getAllObjects = (obj) => {
        if (isObject(obj)) {
            return [obj].concat(bind$3(values(obj), getAllObjects));
        }
        else if (isArray(obj)) {
            return bind$3(obj, getAllObjects);
        }
        else {
            return [];
        }
    };

    const isNamedItem = (obj) => isString(obj.type) && isString(obj.name);
    const dataProcessors = {
        checkbox: checkboxDataProcessor,
        colorinput: colorInputDataProcessor,
        colorpicker: colorPickerDataProcessor,
        dropzone: dropZoneDataProcessor,
        input: inputDataProcessor,
        iframe: iframeDataProcessor,
        imagepreview: imagePreviewDataProcessor,
        selectbox: selectBoxDataProcessor,
        sizeinput: sizeInputDataProcessor,
        slider: sliderInputDataProcessor,
        listbox: listBoxDataProcessor,
        size: sizeInputDataProcessor,
        textarea: textAreaDataProcessor,
        urlinput: urlInputDataProcessor,
        customeditor: customEditorDataProcessor,
        collection: collectionDataProcessor,
        togglemenuitem: dialogToggleMenuItemDataProcessor
    };
    const getDataProcessor = (item) => Optional.from(dataProcessors[item.type]);
    const getNamedItems = (structure) => filter$2(getAllObjects(structure), isNamedItem);

    const createDataValidator = (structure) => {
        const namedItems = getNamedItems(structure);
        const fields = bind$3(namedItems, (item) => getDataProcessor(item).fold(() => [], (schema) => [requiredOf(item.name, schema)]));
        return objOf(fields);
    };

    const extract = (structure) => {
        var _a;
        const internalDialog = getOrDie(createDialog(structure));
        const dataValidator = createDataValidator(structure);
        // We used to validate data here, but it's done when loading the dialog in tinymce
        const initialData = (_a = structure.initialData) !== null && _a !== void 0 ? _a : {};
        return {
            internalDialog,
            dataValidator,
            initialData
        };
    };
    const DialogManager = {
        open: (factory, structure) => {
            const extraction = extract(structure);
            return factory(extraction.internalDialog, extraction.initialData, extraction.dataValidator);
        },
        openUrl: (factory, structure) => {
            const internalDialog = getOrDie(createUrlDialog(structure));
            return factory(internalDialog);
        },
        redial: (structure) => extract(structure)
    };

    const separatorMenuItemSchema = objOf([
        type,
        optionalText
    ]);
    const createSeparatorMenuItem = (spec) => asRaw('separatormenuitem', separatorMenuItemSchema, spec);

    const autocompleterItemSchema = objOf([
        // Currently, autocomplete items don't support configuring type, active, disabled, meta
        defaultedType('autocompleteitem'),
        active,
        enabled,
        defaultedMeta,
        value,
        optionalText,
        optionalIcon
    ]);
    objOf([
        type,
        requiredString('trigger'),
        defaultedNumber('minChars', 1),
        defaultedColumns(1),
        defaultedNumber('maxResults', 10),
        optionFunction('matches'),
        fetch,
        onAction,
        defaultedArrayOf('highlightOn', [], string)
    ]);
    const createSeparatorItem = (spec) => asRaw('Autocompleter.Separator', separatorMenuItemSchema, spec);
    const createAutocompleterItem = (spec) => asRaw('Autocompleter.Item', autocompleterItemSchema, spec);

    const baseToolbarButtonFields = [
        enabled,
        optionalTooltip,
        optionalIcon,
        optionalText,
        onSetup,
        defaultedString('context', 'mode:design')
    ];
    const toolbarButtonSchema = objOf([
        type,
        onAction,
        optionalShortcut
    ].concat(baseToolbarButtonFields));
    const createToolbarButton = (spec) => asRaw('toolbarbutton', toolbarButtonSchema, spec);

    const baseToolbarToggleButtonFields = [
        active
    ].concat(baseToolbarButtonFields);
    const toggleButtonSchema = objOf(baseToolbarToggleButtonFields.concat([
        type,
        onAction,
        optionalShortcut
    ]));
    const createToggleButton = (spec) => asRaw('ToggleButton', toggleButtonSchema, spec);

    const contextBarFields = [
        defaultedFunction('predicate', never),
        defaultedStringEnum('scope', 'node', ['node', 'editor']),
        defaultedStringEnum('position', 'selection', ['node', 'selection', 'line'])
    ];

    const contextButtonFields = baseToolbarButtonFields.concat([
        defaultedType('contextformbutton'),
        defaultedString('align', 'end'),
        primary,
        onAction,
        customField('original', identity)
    ]);
    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
        defaultedType('contextformbutton'),
        defaultedString('align', 'end'),
        primary,
        onAction,
        customField('original', identity)
    ]);
    const launchButtonFields$1 = baseToolbarButtonFields.concat([
        defaultedType('contextformbutton')
    ]);
    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([
        defaultedType('contextformtogglebutton')
    ]);
    const toggleOrNormal = choose$1('type', {
        contextformbutton: contextButtonFields,
        contextformtogglebutton: contextToggleButtonFields
    });
    const baseContextFormFields = [
        optionalLabel,
        requiredArrayOf('commands', toggleOrNormal),
        optionOf('launch', choose$1('type', {
            contextformbutton: launchButtonFields$1,
            contextformtogglebutton: launchToggleButtonFields
        })),
        defaultedFunction('onInput', noop),
        defaultedFunction('onSetup', noop)
    ];
    const contextFormFields = [
        ...contextBarFields,
        ...baseContextFormFields,
        requiredStringEnum('type', ['contextform']),
        defaultedFunction('initValue', constant$1('')),
        optionString('placeholder'),
    ];
    const contextSliderFormFields = [
        ...contextBarFields,
        ...baseContextFormFields,
        requiredStringEnum('type', ['contextsliderform']),
        defaultedFunction('initValue', constant$1(0)),
        defaultedFunction('min', constant$1(0)),
        defaultedFunction('max', constant$1(100))
    ];
    const contextSizeInputFormFields = [
        ...contextBarFields,
        ...baseContextFormFields,
        requiredStringEnum('type', ['contextsizeinputform']),
        defaultedFunction('initValue', constant$1({ width: '', height: '' }))
    ];
    const contextFormSchema = choose$1('type', {
        contextform: contextFormFields,
        contextsliderform: contextSliderFormFields,
        contextsizeinputform: contextSizeInputFormFields
    });
    const createContextForm = (spec) => asRaw('ContextForm', contextFormSchema, spec);

    const launchButtonFields = baseToolbarButtonFields.concat([
        defaultedType('contexttoolbarbutton')
    ]);
    const contextToolbarSchema = objOf([
        defaultedType('contexttoolbar'),
        optionObjOf('launch', launchButtonFields),
        requiredOf('items', oneOf([
            string,
            arrOfObj([
                optionString('name'),
                optionString('label'),
                requiredArrayOf('items', string)
            ])
        ])),
    ].concat(contextBarFields));
    const toolbarGroupBackToSpec = (toolbarGroup) => ({
        name: toolbarGroup.name.getOrUndefined(),
        label: toolbarGroup.label.getOrUndefined(),
        items: toolbarGroup.items
    });
    const contextToolbarToSpec = (contextToolbar) => ({
        ...contextToolbar,
        launch: contextToolbar.launch.getOrUndefined(),
        items: isString(contextToolbar.items) ? contextToolbar.items : map$2(contextToolbar.items, toolbarGroupBackToSpec)
    });
    const createContextToolbar = (spec) => asRaw('ContextToolbar', contextToolbarSchema, spec);

    const cardImageFields = [
        type,
        requiredString('src'),
        optionString('alt'),
        defaultedArrayOf('classes', [], string)
    ];
    const cardImageSchema = objOf(cardImageFields);

    const cardTextFields = [
        type,
        text,
        optionalName,
        defaultedArrayOf('classes', ['tox-collection__item-label'], string)
    ];
    const cardTextSchema = objOf(cardTextFields);

    const itemSchema = valueThunk(() => choose$2('type', {
        cardimage: cardImageSchema,
        cardtext: cardTextSchema,
        cardcontainer: cardContainerSchema
    }));
    const cardContainerSchema = objOf([
        type,
        defaultedString('direction', 'horizontal'),
        defaultedString('align', 'left'),
        defaultedString('valign', 'middle'),
        requiredArrayOf('items', itemSchema)
    ]);

    const cardMenuItemSchema = objOf([
        type,
        optionalLabel,
        requiredArrayOf('items', itemSchema),
        onSetup,
        defaultedOnAction
    ].concat(commonMenuItemFields));
    const createCardMenuItem = (spec) => asRaw('cardmenuitem', cardMenuItemSchema, spec);

    const choiceMenuItemSchema = objOf([
        type,
        active,
        optionalIcon,
        optionalLabel
    ].concat(commonMenuItemFields));
    const createChoiceMenuItem = (spec) => asRaw('choicemenuitem', choiceMenuItemSchema, spec);

    const baseFields = [
        type,
        requiredString('fancytype'),
        defaultedOnAction
    ];
    const insertTableFields = [
        defaulted('initData', {})
    ].concat(baseFields);
    const colorSwatchFields = [
        optionFunction('select'),
        defaultedObjOf('initData', {}, [
            defaultedBoolean('allowCustomColors', true),
            defaultedString('storageKey', 'default'),
            // Note: We don't validate the colors as they are instead validated by choiceschema when rendering
            optionArrayOf('colors', anyValue())
        ])
    ].concat(baseFields);
    const imageSelectFields = [
        optionFunction('select'),
        requiredObjOf('initData', [
            requiredNumber('columns'),
            // Note: We don't validate the items as they are instead validated by imageMenuItemSchema when rendering
            defaultedArrayOf('items', [], anyValue())
        ])
    ].concat(baseFields);
    const fancyMenuItemSchema = choose$1('fancytype', {
        inserttable: insertTableFields,
        colorswatch: colorSwatchFields,
        imageselect: imageSelectFields
    });
    const createFancyMenuItem = (spec) => asRaw('fancymenuitem', fancyMenuItemSchema, spec);

    const imageMenuItemSchema = objOf([
        type,
        active,
        url,
        optionalLabel,
        optionalTooltip
    ].concat(commonMenuItemFields));
    const resetImageItemSchema = objOf([
        type,
        active,
        icon,
        label,
        optionalTooltip,
        value
    ].concat(commonMenuItemFields));
    const createImageMenuItem = (spec) => asRaw('imagemenuitem', imageMenuItemSchema, spec);
    const createResetImageItem = (spec) => asRaw('resetimageitem', resetImageItemSchema, spec);

    const menuItemSchema = objOf([
        type,
        onSetup,
        defaultedOnAction,
        optionalIcon
    ].concat(commonMenuItemFields));
    const createMenuItem = (spec) => asRaw('menuitem', menuItemSchema, spec);

    const nestedMenuItemSchema = objOf([
        type,
        getSubmenuItems,
        onSetup,
        optionalIcon
    ].concat(commonMenuItemFields));
    const createNestedMenuItem = (spec) => asRaw('nestedmenuitem', nestedMenuItemSchema, spec);

    const toggleMenuItemSchema = objOf([
        type,
        optionalIcon,
        active,
        onSetup,
        onAction
    ].concat(commonMenuItemFields));
    const createToggleMenuItem = (spec) => asRaw('togglemenuitem', toggleMenuItemSchema, spec);

    const sidebarSchema = objOf([
        optionalIcon,
        optionalTooltip,
        defaultedFunction('onShow', noop),
        defaultedFunction('onHide', noop),
        onSetup
    ]);
    const createSidebar = (spec) => asRaw('sidebar', sidebarSchema, spec);

    const groupToolbarButtonSchema = objOf([
        type,
        requiredOf('items', oneOf([
            arrOfObj([
                name,
                requiredArrayOf('items', string)
            ]),
            string
        ]))
    ].concat(baseToolbarButtonFields));
    const createGroupToolbarButton = (spec) => asRaw('GroupToolbarButton', groupToolbarButtonSchema, spec);

    const splitButtonSchema = objOf([
        type,
        optionalTooltip,
        optionalChevronTooltip,
        optionalIcon,
        optionalText,
        optionalSelect,
        fetch,
        onSetup,
        // TODO: Validate the allowed presets
        defaultedStringEnum('presets', 'normal', ['normal', 'color', 'listpreview']),
        defaultedColumns(1),
        onAction,
        onItemAction,
        defaultedString('context', 'mode:design')
    ]);
    const createSplitButton = (spec) => asRaw('SplitButton', splitButtonSchema, spec);

    const baseButtonFields = [
        optionalText,
        optionalIcon,
        optionString('tooltip'),
        defaultedStringEnum('buttonType', 'secondary', ['primary', 'secondary']),
        defaultedBoolean('borderless', false),
        requiredFunction('onAction'),
        defaultedString('context', 'mode:design')
    ];
    const normalButtonFields = [
        ...baseButtonFields,
        text,
        requiredStringEnum('type', ['button']),
    ];
    const toggleButtonFields = [
        ...baseButtonFields,
        defaultedBoolean('active', false),
        requiredStringEnum('type', ['togglebutton'])
    ];
    const schemaWithoutGroupButton = {
        button: normalButtonFields,
        togglebutton: toggleButtonFields,
    };
    const groupFields = [
        requiredStringEnum('type', ['group']),
        defaultedArrayOf('buttons', [], choose$1('type', schemaWithoutGroupButton))
    ];
    const viewButtonSchema = choose$1('type', {
        ...schemaWithoutGroupButton,
        group: groupFields
    });

    const viewSchema = objOf([
        defaultedArrayOf('buttons', [], viewButtonSchema),
        requiredFunction('onShow'),
        requiredFunction('onHide')
    ]);
    const createView = (spec) => asRaw('view', viewSchema, spec);

    const detectSize = (comp, margin, selectorClass) => {
        const descendants$1 = descendants(comp.element, '.' + selectorClass);
        // TODO: This seems to cause performance issues in the emoji dialog
        if (descendants$1.length > 0) {
            const columnLength = findIndex$1(descendants$1, (c) => {
                const thisTop = c.dom.getBoundingClientRect().top;
                const cTop = descendants$1[0].dom.getBoundingClientRect().top;
                return Math.abs(thisTop - cTop) > margin;
            }).getOr(descendants$1.length);
            return Optional.some({
                numColumns: columnLength,
                numRows: Math.ceil(descendants$1.length / columnLength)
            });
        }
        else {
            return Optional.none();
        }
    };

    // Consider moving to alloy once it takes shape.
    const namedEvents = (name, handlers) => derive$1([
        config(name, handlers)
    ]);
    const unnamedEvents = (handlers) => namedEvents(generate$6('unnamed-events'), handlers);
    const SimpleBehaviours = {
        namedEvents,
        unnamedEvents
    };

    const item = (disabled) => Disabling.config({
        disabled,
        disableClass: 'tox-collection__item--state-disabled'
    });
    const button = (disabled) => Disabling.config({
        disabled
    });
    const splitButton = (disabled) => Disabling.config({
        disabled,
        disableClass: 'tox-tbtn--disabled'
    });
    const toolbarButton = (disabled) => Disabling.config({
        disabled,
        disableClass: 'tox-tbtn--disabled',
        useNative: false
    });
    const DisablingConfigs = {
        item,
        button,
        splitButton,
        toolbarButton
    };

    const runWithApi = (info, comp) => {
        const api = info.getApi(comp);
        return (f) => {
            f(api);
        };
    };
    // These handlers are used for providing common onAttached and onDetached handlers.
    // Essentially, the `editorOffCell` is used store the onDestroy function returned
    // by onSetup. The reason onControlAttached doesn't create the cell itself, is because
    // it also has to be passed into onControlDetached. We could make this function return
    // the cell and the onAttachedHandler, but that would provide too much complexity.
    const onControlAttached = (info, editorOffCell) => runOnAttached((comp) => {
        if (isFunction(info.onBeforeSetup)) {
            info.onBeforeSetup(comp);
        }
        const run = runWithApi(info, comp);
        run((api) => {
            const onDestroy = info.onSetup(api);
            if (isFunction(onDestroy)) {
                editorOffCell.set(onDestroy);
            }
        });
    });
    const onControlDetached = (getApi, editorOffCell) => runOnDetached((comp) => runWithApi(getApi, comp)(editorOffCell.get()));
    const onContextFormControlDetached = (getApi, editorOffCell, valueState) => runOnDetached((comp) => {
        valueState.set(Representing.getValue(comp));
        return runWithApi(getApi, comp)(editorOffCell.get());
    });

    const UiStateChannel = 'silver.uistate';
    const messageSetDisabled = 'setDisabled';
    const messageSetEnabled = 'setEnabled';
    const messageInit = 'init';
    const messageSwitchMode = 'switchmode';
    const modeContextMessages = [messageSwitchMode, messageInit];
    const broadcastEvents = (uiRefs, messageType) => {
        const outerContainer = uiRefs.mainUi.outerContainer;
        const motherships = [uiRefs.mainUi.mothership, ...uiRefs.uiMotherships];
        if (messageType === messageSetDisabled) {
            each$1(motherships, (m) => {
                m.broadcastOn([dismissPopups()], { target: outerContainer.element });
            });
        }
        each$1(motherships, (m) => {
            m.broadcastOn([UiStateChannel], messageType);
        });
    };
    const setupEventsForUi = (editor, uiRefs) => {
        editor.on('init SwitchMode', (event) => {
            broadcastEvents(uiRefs, event.type);
        });
        editor.on('DisabledStateChange', (event) => {
            if (!event.isDefaultPrevented()) {
                // When the event state indicates the editor is **enabled** (`event.state` is false),
                // we send an 'init' message instead of 'setEnabled' because the editor might be in read-only mode.
                // Sending 'setEnabled' would enable all the toolbar buttons, which is undesirable if the editor is read-only.
                const messageType = event.state ? messageSetDisabled : messageInit;
                broadcastEvents(uiRefs, messageType);
                // After refreshing the state of the buttons, trigger a NodeChange event.
                if (!event.state) {
                    editor.nodeChanged();
                }
            }
        });
        editor.on('NodeChange', (e) => {
            const messageType = editor.ui.isEnabled() ? e.type : messageSetDisabled;
            broadcastEvents(uiRefs, messageType);
        });
        if (isReadOnly(editor)) {
            editor.mode.set('readonly');
        }
    };
    const toggleOnReceive = (getContext) => Receiving.config({
        channels: {
            [UiStateChannel]: {
                onReceive: (comp, messageType) => {
                    if (messageType === messageSetDisabled || messageType === messageSetEnabled) {
                        Disabling.set(comp, messageType === messageSetDisabled);
                        return;
                    }
                    const { contextType, shouldDisable } = getContext();
                    if (contextType === 'mode' && !contains$2(modeContextMessages, messageType)) {
                        return;
                    }
                    Disabling.set(comp, shouldDisable);
                }
            }
        }
    });

    // Perform `action` when an item is clicked on, close menus, and stop event
    const onMenuItemExecute = (info, itemResponse) => runOnExecute$1((comp, simulatedEvent) => {
        // If there is an action, run the action
        runWithApi(info, comp)(info.onAction);
        if (!info.triggersSubmenu && itemResponse === ItemResponse$1.CLOSE_ON_EXECUTE) {
            if (comp.getSystem().isConnected()) {
                emit(comp, sandboxClose());
            }
            simulatedEvent.stop();
        }
    });
    const menuItemEventOrder = {
        // TODO: use the constants provided by behaviours.
        [execute$5()]: ['disabling', 'alloy.base.behaviour', 'toggling', 'item-events']
    };

    const componentRenderPipeline = cat;
    const renderCommonItem = (spec, structure, itemResponse, providersBackstage) => {
        const editorOffCell = Cell(noop);
        return {
            type: 'item',
            dom: structure.dom,
            components: componentRenderPipeline(structure.optComponents),
            data: spec.data,
            eventOrder: menuItemEventOrder,
            hasSubmenu: spec.triggersSubmenu,
            itemBehaviours: derive$1([
                config('item-events', [
                    onMenuItemExecute(spec, itemResponse),
                    onControlAttached(spec, editorOffCell),
                    onControlDetached(spec, editorOffCell)
                ]),
                DisablingConfigs.item(() => !spec.enabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context)),
                Replacing.config({})
            ].concat(spec.itemBehaviours))
        };
    };
    const buildData = (source) => ({
        value: source.value,
        meta: {
            text: source.text.getOr(''),
            ...source.meta
        }
    });

    const renderImage$1 = (spec, imageUrl) => {
        var _a, _b;
        const spinnerElement = SugarElement.fromTag('div');
        add$2(spinnerElement, 'tox-image-selector-loading-spinner');
        const addSpinnerElement = (loadingElement) => {
            add$2(loadingElement, 'tox-image-selector-loading-spinner-wrapper');
            append$2(loadingElement, spinnerElement);
        };
        const removeSpinnerElement = (loadingElement) => {
            remove$3(loadingElement, 'tox-image-selector-loading-spinner-wrapper');
            remove$7(spinnerElement);
        };
        return {
            dom: {
                tag: spec.tag,
                attributes: (_a = spec.attributes) !== null && _a !== void 0 ? _a : {},
                classes: spec.classes,
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-image-selector-image-wrapper']
                    },
                    components: [
                        {
                            dom: {
                                tag: 'img',
                                attributes: { src: imageUrl },
                                classes: ['tox-image-selector-image-img']
                            }
                        },
                    ]
                },
                ...spec.checkMark.toArray()
            ],
            behaviours: derive$1([
                ...(_b = spec.behaviours) !== null && _b !== void 0 ? _b : [],
                config('render-image-events', [
                    runOnAttached((component) => {
                        addSpinnerElement(component.element);
                        descendant(component.element, 'img').each((image$1) => {
                            image(image$1).catch((e) => {
                                // eslint-disable-next-line no-console
                                console.error(e);
                            }).finally(() => {
                                removeSpinnerElement(component.element);
                            });
                        });
                    })
                ]),
            ])
        };
    };
    const render$3 = (imageUrl, spec) => renderImage$1(spec, imageUrl);

    // Converts shortcut format to Mac/PC variants
    // Note: This is different to the help shortcut converter, as it doesn't padd the + symbol with spaces
    //       so as to not take up large amounts of space in the menus
    const convertText = (source) => {
        const isMac = global$7.os.isMacOS() || global$7.os.isiOS();
        const mac = {
            alt: '\u2325',
            ctrl: '\u2303',
            shift: '\u21E7',
            meta: '\u2318',
            access: '\u2303\u2325'
        };
        const other = {
            meta: 'Ctrl',
            access: 'Shift+Alt'
        };
        const replace = isMac ? mac : other;
        const shortcut = source.split('+');
        const updated = map$2(shortcut, (segment) => {
            // search lowercase, but if not found use the original
            const search = segment.toLowerCase().trim();
            return has$2(replace, search) ? replace[search] : segment;
        });
        return isMac ? updated.join('') : updated.join('+');
    };

    const renderIcon$2 = (name, icons, classes = [iconClass]) => render$4(name, { tag: 'div', classes }, icons);
    const renderText = (text) => ({
        dom: {
            tag: 'div',
            classes: [textClass]
        },
        components: [text$2(global$6.translate(text))]
    });
    const renderHtml = (html, classes) => ({
        dom: {
            tag: 'div',
            classes,
            innerHtml: html
        }
    });
    const renderStyledText = (style, text) => ({
        dom: {
            tag: 'div',
            classes: [textClass]
        },
        components: [
            {
                dom: {
                    tag: style.tag,
                    styles: style.styles
                },
                components: [text$2(global$6.translate(text))]
            }
        ]
    });
    const renderShortcut = (shortcut) => ({
        dom: {
            tag: 'div',
            classes: [accessoryClass]
        },
        components: [
            text$2(convertText(shortcut))
        ]
    });
    const renderCheckmark = (icons) => renderIcon$2('checkmark', icons, [checkmarkClass]);
    const renderSubmenuCaret = (icons) => renderIcon$2('chevron-right', icons, [caretClass]);
    const renderDownwardsCaret = (icons) => renderIcon$2('chevron-down', icons, [caretClass]);
    const renderContainer = (container, components) => {
        const directionClass = container.direction === 'vertical' ? containerColumnClass : containerRowClass;
        const alignClass = container.align === 'left' ? containerAlignLeftClass : containerAlignRightClass;
        const getValignClass = () => {
            switch (container.valign) {
                case 'top':
                    return containerValignTopClass;
                case 'middle':
                    return containerValignMiddleClass;
                case 'bottom':
                    return containerValignBottomClass;
            }
        };
        return {
            dom: {
                tag: 'div',
                classes: [
                    containerClass,
                    directionClass,
                    alignClass,
                    getValignClass()
                ]
            },
            components
        };
    };
    const renderImage = (src, classes, alt) => ({
        dom: {
            tag: 'img',
            classes,
            attributes: {
                src,
                alt: alt.getOr('')
            }
        }
    });

    const renderColorStructure = (item, providerBackstage, fallbackIcon) => {
        const colorPickerCommand = 'custom';
        const removeColorCommand = 'remove';
        const itemValue = item.value;
        const iconSvg = item.iconContent.map((name) => getOr(name, providerBackstage.icons, fallbackIcon));
        const attributes = item.ariaLabel.map((al) => ({
            'aria-label': providerBackstage.translate(al),
            'data-mce-name': al
        })).getOr({});
        const getDom = () => {
            const common = colorClass;
            const icon = iconSvg.getOr('');
            const baseDom = {
                tag: 'div',
                attributes,
                classes: [common]
            };
            if (itemValue === colorPickerCommand) {
                return {
                    ...baseDom,
                    tag: 'button',
                    classes: [...baseDom.classes, 'tox-swatches__picker-btn'],
                    innerHtml: icon
                };
            }
            else if (itemValue === removeColorCommand) {
                return {
                    ...baseDom,
                    classes: [...baseDom.classes, 'tox-swatch--remove'],
                    innerHtml: icon
                };
            }
            else if (isNonNullable(itemValue)) {
                return {
                    ...baseDom,
                    attributes: {
                        ...baseDom.attributes,
                        'data-mce-color': itemValue
                    },
                    styles: {
                        'background-color': itemValue
                    },
                    innerHtml: icon
                };
            }
            else {
                return baseDom;
            }
        };
        return {
            dom: getDom(),
            optComponents: []
        };
    };
    const renderItemDomStructure = (ariaLabel, classes) => {
        const domTitle = ariaLabel.map((label) => ({
            attributes: {
                'id': generate$6('menu-item'),
                'aria-label': global$6.translate(label)
            }
        })).getOr({});
        return {
            tag: 'div',
            classes: [navClass, selectableClass].concat(classes),
            ...domTitle
        };
    };
    const createLabel = (label) => {
        return {
            dom: {
                tag: 'label'
            },
            components: [
                text$2(label)
            ]
        };
    };
    const renderNormalItemStructure = (info, providersBackstage, renderIcons, fallbackIcon) => {
        // TODO: TINY-3036 Work out a better way of dealing with custom icons
        const iconSpec = { tag: 'div', classes: [iconClass] };
        const renderIcon = (iconName) => render$4(iconName, iconSpec, providersBackstage.icons, fallbackIcon);
        const renderEmptyIcon = () => Optional.some({ dom: iconSpec });
        // Note: renderIcons indicates if any icons are present in the menu - if false then the icon column will not be present for the whole menu
        const leftIcon = renderIcons ? info.iconContent.map(renderIcon).orThunk(renderEmptyIcon) : Optional.none();
        // TINY-3345: Dedicated columns for icon and checkmark if applicable
        const checkmark = info.checkMark;
        // Style items and autocompleter both have meta. Need to branch on style
        // This could probably be more stable...
        const textRender = Optional.from(info.meta).fold(() => renderText, (meta) => has$2(meta, 'style') ? curry(renderStyledText, meta.style) : renderText);
        const content = info.htmlContent.fold(() => info.textContent.map(textRender), (html) => Optional.some(renderHtml(html, [textClass])));
        const menuItem = {
            dom: renderItemDomStructure(info.ariaLabel, []),
            optComponents: [
                leftIcon,
                content,
                info.shortcutContent.map(renderShortcut),
                checkmark,
                info.caret,
                info.labelContent.map(createLabel)
            ]
        };
        return menuItem;
    };
    const renderImgItemStructure = (info) => {
        const menuItem = {
            dom: renderItemDomStructure(info.ariaLabel, [imageSelectorClasll]),
            optComponents: [
                Optional.some(render$3(info.iconContent.getOrDie(), { tag: 'div', classes: [imageClass], checkMark: info.checkMark })),
                info.labelContent.map(createLabel)
            ]
        };
        return menuItem;
    };
    // TODO: Maybe need aria-label
    const renderItemStructure = (info, providersBackstage, renderIcons, fallbackIcon = Optional.none()) => {
        if (info.presets === 'color') {
            return renderColorStructure(info, providersBackstage, fallbackIcon);
        }
        else if (info.presets === 'img') {
            return renderImgItemStructure(info);
        }
        else {
            return renderNormalItemStructure(info, providersBackstage, renderIcons, fallbackIcon);
        }
    };

    // Use meta to pass through special information about the tooltip
    // (yes this is horrible but it is not yet public API)
    const tooltipBehaviour = (meta, sharedBackstage, tooltipText) => get$h(meta, 'tooltipWorker')
        .map((tooltipWorker) => [
        Tooltipping.config({
            lazySink: sharedBackstage.getSink,
            tooltipDom: {
                tag: 'div',
                classes: ['tox-tooltip-worker-container']
            },
            tooltipComponents: [],
            anchor: (comp) => ({
                type: 'submenu',
                item: comp,
                overrides: {
                    // NOTE: this avoids it setting overflow and max-height.
                    maxHeightFunction: expandable$1
                }
            }),
            mode: 'follow-highlight',
            onShow: (component, _tooltip) => {
                tooltipWorker((elm) => {
                    Tooltipping.setComponents(component, [
                        external({ element: SugarElement.fromDom(elm) })
                    ]);
                });
            }
        })
    ])
        .getOrThunk(() => {
        return tooltipText.map((text) => [
            Tooltipping.config({
                ...sharedBackstage.providers.tooltips.getConfig({
                    tooltipText: text
                }),
                mode: 'follow-highlight'
            })
        ]).getOr([]);
    });
    const encodeText = (text) => global$9.DOM.encode(text);
    const replaceText = (text, matchText) => {
        const translated = global$6.translate(text);
        const encoded = encodeText(translated);
        if (matchText.length > 0) {
            const escapedMatchRegex = new RegExp(escape(matchText), 'gi');
            return encoded.replace(escapedMatchRegex, (match) => `<span class="tox-autocompleter-highlight">${match}</span>`);
        }
        else {
            return encoded;
        }
    };
    const renderAutocompleteItem = (spec, matchText, useText, presets, onItemValueHandler, itemResponse, sharedBackstage, renderIcons = true) => {
        const structure = renderItemStructure({
            presets,
            textContent: Optional.none(),
            htmlContent: useText ? spec.text.map((text) => replaceText(text, matchText)) : Optional.none(),
            ariaLabel: spec.text,
            labelContent: Optional.none(),
            iconContent: spec.icon,
            shortcutContent: Optional.none(),
            checkMark: Optional.none(),
            caret: Optional.none(),
            value: spec.value
        }, sharedBackstage.providers, renderIcons, spec.icon);
        const tooltipString = spec.text.filter((text) => !useText && text !== '');
        return renderCommonItem({
            context: 'mode:design',
            data: buildData(spec),
            enabled: spec.enabled,
            getApi: constant$1({}),
            onAction: (_api) => onItemValueHandler(spec.value, spec.meta),
            onSetup: constant$1(noop),
            triggersSubmenu: false,
            itemBehaviours: tooltipBehaviour(spec, sharedBackstage, tooltipString)
        }, structure, itemResponse, sharedBackstage.providers);
    };

    const render$2 = (items, extras) => map$2(items, (item) => {
        switch (item.type) {
            case 'cardcontainer':
                return renderContainer(item, render$2(item.items, extras));
            case 'cardimage':
                return renderImage(item.src, item.classes, item.alt);
            case 'cardtext':
                // Only highlight targeted text components
                const shouldHighlight = item.name.exists((name) => contains$2(extras.cardText.highlightOn, name));
                const matchText = shouldHighlight ? Optional.from(extras.cardText.matchText).getOr('') : '';
                return renderHtml(replaceText(item.text, matchText), item.classes);
        }
    });
    const renderCardMenuItem = (spec, itemResponse, sharedBackstage, extras) => {
        const getApi = (component) => ({
            isEnabled: () => !Disabling.isDisabled(component),
            setEnabled: (state) => {
                Disabling.set(component, !state);
                // Disable sub components
                each$1(descendants(component.element, '*'), (elm) => {
                    component.getSystem().getByDom(elm).each((comp) => {
                        if (comp.hasConfigured(Disabling)) {
                            Disabling.set(comp, !state);
                        }
                    });
                });
            }
        });
        const structure = {
            dom: renderItemDomStructure(spec.label, []),
            optComponents: [
                Optional.some({
                    dom: {
                        tag: 'div',
                        classes: [containerClass, containerRowClass]
                    },
                    components: render$2(spec.items, extras)
                })
            ]
        };
        return renderCommonItem({
            context: 'mode:design',
            data: buildData({ text: Optional.none(), ...spec }),
            enabled: spec.enabled,
            getApi,
            onAction: spec.onAction,
            onSetup: spec.onSetup,
            triggersSubmenu: false,
            itemBehaviours: Optional.from(extras.itemBehaviours).getOr([])
        }, structure, itemResponse, sharedBackstage.providers);
    };

    const renderChoiceItem = (spec, useText, presets, onItemValueHandler, isSelected, itemResponse, providersBackstage, renderIcons = true) => {
        const getApi = (component) => ({
            setActive: (state) => {
                Toggling.set(component, state);
            },
            isActive: () => Toggling.isOn(component),
            isEnabled: () => !Disabling.isDisabled(component),
            setEnabled: (state) => Disabling.set(component, !state)
        });
        const structure = renderItemStructure({
            presets,
            textContent: useText ? spec.text : Optional.none(),
            htmlContent: Optional.none(),
            labelContent: spec.label,
            ariaLabel: spec.text,
            iconContent: spec.icon,
            shortcutContent: useText ? spec.shortcut : Optional.none(),
            // useText essentially says that we have one column. In one column lists, we should show a tick
            // The tick is controlled by the tickedClass (via css). It is always present
            // but is hidden unless the tickedClass is present.
            checkMark: useText ? Optional.some(renderCheckmark(providersBackstage.icons)) : Optional.none(),
            caret: Optional.none(),
            value: spec.value
        }, providersBackstage, renderIcons);
        const optTooltipping = spec.text
            .filter(constant$1(!useText))
            .map((t) => Tooltipping.config(providersBackstage.tooltips.getConfig({
            tooltipText: providersBackstage.translate(t)
        })));
        return deepMerge(renderCommonItem({
            context: spec.context,
            data: buildData(spec),
            enabled: spec.enabled,
            getApi,
            onAction: (_api) => onItemValueHandler(spec.value),
            onSetup: (api) => {
                api.setActive(isSelected);
                return noop;
            },
            triggersSubmenu: false,
            itemBehaviours: [
                ...optTooltipping.toArray()
            ]
        }, structure, itemResponse, providersBackstage), {
            toggling: {
                toggleClass: tickedClass,
                toggleOnExecute: false,
                selected: spec.active,
                exclusive: true
            }
        });
    };

    const hexColour = (value) => ({
        value: normalizeHex(value)
    });
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    const longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    const isHexString = (hex) => shorthandRegex.test(hex) || longformRegex.test(hex);
    const normalizeHex = (hex) => removeLeading(hex, '#').toUpperCase();
    const fromString$1 = (hex) => isHexString(hex) ? Optional.some({ value: normalizeHex(hex) }) : Optional.none();
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    const getLongForm = (hex) => {
        const hexString = hex.value.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
        return { value: hexString };
    };
    const extractValues = (hex) => {
        const longForm = getLongForm(hex);
        const splitForm = longformRegex.exec(longForm.value);
        return splitForm === null ? ['FFFFFF', 'FF', 'FF', 'FF'] : splitForm;
    };
    const toHex = (component) => {
        const hex = component.toString(16);
        return (hex.length === 1 ? '0' + hex : hex).toUpperCase();
    };
    const fromRgba = (rgbaColour) => {
        const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);
        return hexColour(value);
    };

    const hsvColour = (hue, saturation, value) => ({
        hue,
        saturation,
        value
    });
    const fromRgb = (rgbaColour) => {
        let h = 0;
        let s = 0;
        let v = 0;
        const r = rgbaColour.red / 255;
        const g = rgbaColour.green / 255;
        const b = rgbaColour.blue / 255;
        const minRGB = Math.min(r, Math.min(g, b));
        const maxRGB = Math.max(r, Math.max(g, b));
        if (minRGB === maxRGB) {
            v = minRGB;
            return hsvColour(0, 0, v * 100);
        }
        /* eslint no-nested-ternary:0 */
        const d = (r === minRGB) ? g - b : ((b === minRGB) ? r - g : b - r);
        h = (r === minRGB) ? 3 : ((b === minRGB) ? 1 : 5);
        h = 60 * (h - d / (maxRGB - minRGB));
        s = (maxRGB - minRGB) / maxRGB;
        v = maxRGB;
        return hsvColour(Math.round(h), Math.round(s * 100), Math.round(v * 100));
    };

    const min = Math.min;
    const max = Math.max;
    const round$1 = Math.round;
    const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i;
    // This regex will match rgba(0, 0, 0, 0.5) or rgba(0, 0, 0, 50%) , or without commas
    const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i;
    const rgbaColour = (red, green, blue, alpha) => ({
        red,
        green,
        blue,
        alpha
    });
    const isRgbaComponent = (value) => {
        const num = parseInt(value, 10);
        return num.toString() === value && num >= 0 && num <= 255;
    };
    const fromHsv = (hsv) => {
        let r;
        let g;
        let b;
        const hue = (hsv.hue || 0) % 360;
        let saturation = hsv.saturation / 100;
        let brightness = hsv.value / 100;
        saturation = max(0, min(saturation, 1));
        brightness = max(0, min(brightness, 1));
        if (saturation === 0) {
            r = g = b = round$1(255 * brightness);
            return rgbaColour(r, g, b, 1);
        }
        const side = hue / 60;
        const chroma = brightness * saturation;
        const x = chroma * (1 - Math.abs(side % 2 - 1));
        const match = brightness - chroma;
        switch (Math.floor(side)) {
            case 0:
                r = chroma;
                g = x;
                b = 0;
                break;
            case 1:
                r = x;
                g = chroma;
                b = 0;
                break;
            case 2:
                r = 0;
                g = chroma;
                b = x;
                break;
            case 3:
                r = 0;
                g = x;
                b = chroma;
                break;
            case 4:
                r = x;
                g = 0;
                b = chroma;
                break;
            case 5:
                r = chroma;
                g = 0;
                b = x;
                break;
            default:
                r = g = b = 0;
        }
        r = round$1(255 * (r + match));
        g = round$1(255 * (g + match));
        b = round$1(255 * (b + match));
        return rgbaColour(r, g, b, 1);
    };
    // Temporarily using: https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
    const fromHex = (hexColour) => {
        const result = extractValues(hexColour);
        const red = parseInt(result[1], 16);
        const green = parseInt(result[2], 16);
        const blue = parseInt(result[3], 16);
        return rgbaColour(red, green, blue, 1);
    };
    const fromStringValues = (red, green, blue, alpha) => {
        const r = parseInt(red, 10);
        const g = parseInt(green, 10);
        const b = parseInt(blue, 10);
        const a = parseFloat(alpha);
        return rgbaColour(r, g, b, a);
    };
    const fromString = (rgbaString) => {
        const rgbMatch = rgbRegex.exec(rgbaString);
        if (rgbMatch !== null) {
            return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));
        }
        const rgbaMatch = rgbaRegex.exec(rgbaString);
        if (rgbaMatch !== null) {
            return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
        }
        return Optional.none();
    };
    const toString = (rgba) => `rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`;
    const red = rgbaColour(255, 0, 0, 1);

    const hexToHsv = (hex) => fromRgb(fromHex(hex));
    const hsvToHex = (hsv) => fromRgba(fromHsv(hsv));
    const anyToHex = (color) => fromString$1(color)
        .orThunk(() => fromString(color).map(fromRgba))
        .getOrThunk(() => {
        // Not dealing with Hex or RGBA so use a canvas to parse the color
        const canvas = document.createElement('canvas');
        canvas.height = 1;
        canvas.width = 1;
        const canvasContext = canvas.getContext('2d');
        // all valid colors after this point
        canvasContext.clearRect(0, 0, canvas.width, canvas.height);
        // invalid colors will be shown as white - the first assignment will pass and the second may be ignored
        canvasContext.fillStyle = '#FFFFFF';
        canvasContext.fillStyle = color;
        canvasContext.fillRect(0, 0, 1, 1);
        const rgba = canvasContext.getImageData(0, 0, 1, 1).data;
        const r = rgba[0];
        const g = rgba[1];
        const b = rgba[2];
        const a = rgba[3];
        return fromRgba(rgbaColour(r, g, b, a));
    });

    const fireSkinLoaded$1 = (editor) => {
        editor.dispatch('SkinLoaded');
    };
    const fireSkinLoadError$1 = (editor, error) => {
        editor.dispatch('SkinLoadError', error);
    };
    const fireResizeEditor = (editor) => {
        editor.dispatch('ResizeEditor');
    };
    const fireResizeContent = (editor, e) => {
        editor.dispatch('ResizeContent', e);
    };
    const fireScrollContent = (editor, e) => {
        editor.dispatch('ScrollContent', e);
    };
    const fireTextColorChange = (editor, data) => {
        editor.dispatch('TextColorChange', data);
    };
    const fireAfterProgressState = (editor, state) => {
        editor.dispatch('AfterProgressState', { state });
    };
    const fireResolveName = (editor, node) => editor.dispatch('ResolveName', {
        name: node.nodeName.toLowerCase(),
        target: node
    });
    const fireToggleToolbarDrawer = (editor, state) => {
        editor.dispatch('ToggleToolbarDrawer', { state });
    };
    const fireStylesTextUpdate = (editor, data) => {
        editor.dispatch('StylesTextUpdate', data);
    };
    const fireAlignTextUpdate = (editor, data) => {
        editor.dispatch('AlignTextUpdate', data);
    };
    const fireFontSizeTextUpdate = (editor, data) => {
        editor.dispatch('FontSizeTextUpdate', data);
    };
    const fireFontSizeInputTextUpdate = (editor, data) => {
        editor.dispatch('FontSizeInputTextUpdate', data);
    };
    const fireBlocksTextUpdate = (editor, data) => {
        editor.dispatch('BlocksTextUpdate', data);
    };
    const fireFontFamilyTextUpdate = (editor, data) => {
        editor.dispatch('FontFamilyTextUpdate', data);
    };
    const fireToggleSidebar = (editor) => {
        editor.dispatch('ToggleSidebar');
    };
    const fireToggleView = (editor) => {
        editor.dispatch('ToggleView');
    };
    const fireContextToolbarClose = (editor) => {
        editor.dispatch('ContextToolbarClose');
    };
    const fireContextFormSlideBack = (editor) => {
        editor.dispatch('ContextFormSlideBack');
    };

    const composeUnbinders = (f, g) => () => {
        f();
        g();
    };
    const onSetupEditableToggle = (editor, enabledPredicate = always) => onSetupEvent(editor, 'NodeChange', (api) => {
        api.setEnabled(editor.selection.isEditable() && enabledPredicate());
    });
    const onSetupFormatToggle = (editor, name) => (api) => {
        const boundFormatChangeCallback = unbindable();
        const init = () => {
            api.setActive(editor.formatter.match(name));
            const binding = editor.formatter.formatChanged(name, api.setActive);
            boundFormatChangeCallback.set(binding);
        };
        // The editor may or may not have been setup yet, so check for that
        editor.initialized ? init() : editor.once('init', init);
        return () => {
            editor.off('init', init);
            boundFormatChangeCallback.clear();
        };
    };
    const onSetupStateToggle = (editor, name) => (api) => {
        const unbindEditableToogle = onSetupEditableToggle(editor)(api);
        const unbindFormatToggle = onSetupFormatToggle(editor, name)(api);
        return () => {
            unbindEditableToogle();
            unbindFormatToggle();
        };
    };
    const onSetupEvent = (editor, event, f) => (api) => {
        const handleEvent = () => f(api);
        const init = () => {
            f(api);
            editor.on(event, handleEvent);
        };
        // The editor may or may not have been setup yet, so check for that
        editor.initialized ? init() : editor.once('init', init);
        return () => {
            editor.off('init', init);
            editor.off(event, handleEvent);
        };
    };
    const onActionToggleFormat$1 = (editor) => (rawItem) => () => {
        editor.undoManager.transact(() => {
            editor.focus();
            editor.execCommand('mceToggleFormat', false, rawItem.format);
        });
    };
    const onActionExecCommand = (editor, command) => () => editor.execCommand(command);

    var global$5 = tinymce.util.Tools.resolve('tinymce.util.LocalStorage');

    const cacheStorage = {};
    const ColorCache = (storageId, max = 10) => {
        const storageString = global$5.getItem(storageId);
        const localstorage = isString(storageString) ? JSON.parse(storageString) : [];
        const prune = (list) => {
            // When the localStorage cache is too big,
            // remove the difference from the tail (head is fresh, tail is stale!)
            const diff = max - list.length;
            return (diff < 0) ? list.slice(0, max) : list;
        };
        const cache = prune(localstorage);
        const add = (key) => {
            // Remove duplicates first.
            indexOf(cache, key).each(remove);
            cache.unshift(key);
            // When max size is exceeded, the oldest colors will be removed
            if (cache.length > max) {
                cache.pop();
            }
            global$5.setItem(storageId, JSON.stringify(cache));
        };
        const remove = (idx) => {
            cache.splice(idx, 1);
        };
        const state = () => cache.slice(0);
        return {
            add,
            state
        };
    };
    const getCacheForId = (id) => get$h(cacheStorage, id).getOrThunk(() => {
        const storageId = `tinymce-custom-colors-${id}`;
        const currentData = global$5.getItem(storageId);
        if (isNullable(currentData)) {
            const legacyDefault = global$5.getItem('tinymce-custom-colors');
            global$5.setItem(storageId, isNonNullable(legacyDefault) ? legacyDefault : '[]');
        }
        const storage = ColorCache(storageId, 10);
        cacheStorage[id] = storage;
        return storage;
    });
    const getCurrentColors = (id) => map$2(getCacheForId(id).state(), (color) => ({
        type: 'choiceitem',
        text: color,
        icon: 'checkmark',
        value: color
    }));
    const addColor = (id, color) => {
        getCacheForId(id).add(color);
    };

    const foregroundId = 'forecolor';
    const backgroundId = 'hilitecolor';
    const fallbackCols = 5;
    const mapColors = (colorMap) => mapColorsRaw(colorMap.map((color, index) => {
        if (index % 2 === 0) {
            return '#' + anyToHex(color).value;
        }
        return color;
    }));
    const mapColorsRaw = (colorMap) => {
        const colors = [];
        for (let i = 0; i < colorMap.length; i += 2) {
            colors.push({
                text: colorMap[i + 1],
                value: colorMap[i],
                icon: 'checkmark',
                type: 'choiceitem'
            });
        }
        return colors;
    };
    const option$1 = (name) => (editor) => editor.options.get(name);
    const fallbackColor = '#000000';
    const register$e = (editor) => {
        const registerOption = editor.options.register;
        const colorProcessor = (value) => {
            if (isArrayOf(value, isString)) {
                return { value: mapColors(value), valid: true };
            }
            else {
                return { valid: false, message: 'Must be an array of strings.' };
            }
        };
        const colorProcessorRaw = (value) => {
            if (isArrayOf(value, isString)) {
                return { value: mapColorsRaw(value), valid: true };
            }
            else {
                return { valid: false, message: 'Must be an array of strings.' };
            }
        };
        const colorColsProcessor = (value) => {
            if (isNumber(value) && value > 0) {
                return { value, valid: true };
            }
            else {
                return { valid: false, message: 'Must be a positive number.' };
            }
        };
        registerOption('color_map', {
            processor: colorProcessor,
            default: [
                '#BFEDD2', 'Light Green',
                '#FBEEB8', 'Light Yellow',
                '#F8CAC6', 'Light Red',
                '#ECCAFA', 'Light Purple',
                '#C2E0F4', 'Light Blue',
                '#2DC26B', 'Green',
                '#F1C40F', 'Yellow',
                '#E03E2D', 'Red',
                '#B96AD9', 'Purple',
                '#3598DB', 'Blue',
                '#169179', 'Dark Turquoise',
                '#E67E23', 'Orange',
                '#BA372A', 'Dark Red',
                '#843FA1', 'Dark Purple',
                '#236FA1', 'Dark Blue',
                '#ECF0F1', 'Light Gray',
                '#CED4D9', 'Medium Gray',
                '#95A5A6', 'Gray',
                '#7E8C8D', 'Dark Gray',
                '#34495E', 'Navy Blue',
                '#000000', 'Black',
                '#ffffff', 'White'
            ]
        });
        registerOption('color_map_raw', {
            processor: colorProcessorRaw,
        });
        registerOption('color_map_background', {
            processor: colorProcessor
        });
        registerOption('color_map_foreground', {
            processor: colorProcessor
        });
        registerOption('color_cols', {
            processor: colorColsProcessor,
            default: calcCols(editor)
        });
        registerOption('color_cols_foreground', {
            processor: colorColsProcessor,
            default: defaultCols(editor, foregroundId)
        });
        registerOption('color_cols_background', {
            processor: colorColsProcessor,
            default: defaultCols(editor, backgroundId)
        });
        registerOption('custom_colors', {
            processor: 'boolean',
            default: true
        });
        registerOption('color_default_foreground', {
            processor: 'string',
            default: fallbackColor
        });
        registerOption('color_default_background', {
            processor: 'string',
            default: fallbackColor
        });
    };
    const getColors$2 = (editor, id) => {
        if (id === foregroundId && editor.options.isSet('color_map_foreground')) {
            return option$1('color_map_foreground')(editor);
        }
        else if (id === backgroundId && editor.options.isSet('color_map_background')) {
            return option$1('color_map_background')(editor);
        }
        else if (editor.options.isSet('color_map_raw')) {
            return option$1('color_map_raw')(editor);
        }
        else {
            return option$1('color_map')(editor);
        }
    };
    const calcCols = (editor, id = 'default') => Math.max(fallbackCols, Math.ceil(Math.sqrt(getColors$2(editor, id).length)));
    const defaultCols = (editor, id) => {
        const defaultCols = option$1('color_cols')(editor);
        const calculatedCols = calcCols(editor, id);
        if (defaultCols === calcCols(editor)) {
            return calculatedCols;
        }
        else {
            return defaultCols;
        }
    };
    const getColorCols$1 = (editor, id = 'default') => {
        const getCols = () => {
            if (id === foregroundId) {
                return option$1('color_cols_foreground')(editor);
            }
            else if (id === backgroundId) {
                return option$1('color_cols_background')(editor);
            }
            else {
                return option$1('color_cols')(editor);
            }
        };
        return Math.round(getCols());
    };
    const hasCustomColors$1 = option$1('custom_colors');
    const getDefaultForegroundColor = option$1('color_default_foreground');
    const getDefaultBackgroundColor = option$1('color_default_background');

    const defaultBackgroundColor = 'rgba(0, 0, 0, 0)';
    const isValidBackgroundColor = (value) => fromString(value).exists((c) => c.alpha !== 0);
    // Climb up the tree to find the value of the background until finding a non-transparent value or defaulting.
    const getClosestCssBackgroundColorValue = (scope) => {
        return closest(scope, (node) => {
            if (isElement$1(node)) {
                const color = get$e(node, 'background-color');
                return someIf(isValidBackgroundColor(color), color);
            }
            else {
                return Optional.none();
            }
        }).getOr(defaultBackgroundColor);
    };
    const getCurrentColor = (editor, format) => {
        const node = SugarElement.fromDom(editor.selection.getStart());
        const cssRgbValue = format === 'hilitecolor'
            ? getClosestCssBackgroundColorValue(node)
            : get$e(node, 'color');
        return fromString(cssRgbValue).map((rgba) => '#' + fromRgba(rgba).value);
    };
    const applyFormat = (editor, format, value) => {
        editor.undoManager.transact(() => {
            editor.focus();
            editor.formatter.apply(format, { value });
            editor.nodeChanged();
        });
    };
    const removeFormat = (editor, format) => {
        editor.undoManager.transact(() => {
            editor.focus();
            editor.formatter.remove(format, { value: null }, undefined, true);
            editor.nodeChanged();
        });
    };
    const registerCommands = (editor) => {
        editor.addCommand('mceApplyTextcolor', (format, value) => {
            applyFormat(editor, format, value);
        });
        editor.addCommand('mceRemoveTextcolor', (format) => {
            removeFormat(editor, format);
        });
    };
    const getAdditionalColors = (hasCustom) => {
        const type = 'choiceitem';
        const remove = {
            type,
            text: 'Remove color',
            icon: 'color-swatch-remove-color',
            value: 'remove'
        };
        const custom = {
            type,
            text: 'Custom color',
            icon: 'color-picker',
            value: 'custom'
        };
        return hasCustom ? [
            remove,
            custom
        ] : [remove];
    };
    const applyColor = (editor, format, value, onChoice) => {
        if (value === 'custom') {
            const dialog = colorPickerDialog(editor);
            dialog((colorOpt) => {
                colorOpt.each((color) => {
                    addColor(format, color);
                    editor.execCommand('mceApplyTextcolor', format, color);
                    onChoice(color);
                });
            }, getCurrentColor(editor, format).getOr(fallbackColor));
        }
        else if (value === 'remove') {
            onChoice('');
            editor.execCommand('mceRemoveTextcolor', format);
        }
        else {
            onChoice(value);
            editor.execCommand('mceApplyTextcolor', format, value);
        }
    };
    const getColors$1 = (colors, id, hasCustom) => colors.concat(getCurrentColors(id).concat(getAdditionalColors(hasCustom)));
    const getFetch$1 = (colors, id, hasCustom) => (callback) => {
        callback(getColors$1(colors, id, hasCustom));
    };
    const setIconColor = (splitButtonApi, name, newColor) => {
        const id = name === 'forecolor' ? 'tox-icon-text-color__color' : 'tox-icon-highlight-bg-color__color';
        splitButtonApi.setIconFill(id, newColor);
    };
    const setTooltip = (buttonApi, tooltip) => {
        buttonApi.setTooltip(tooltip);
    };
    const select$1 = (editor, format) => (value) => {
        const optCurrentHex = getCurrentColor(editor, format);
        return is$1(optCurrentHex, value.toUpperCase());
    };
    // Selecting `Remove Color` would set the lastColor to ''
    const getToolTipText = (editor, format, lastColor) => {
        if (isEmpty(lastColor)) {
            return format === 'forecolor' ? 'Text color' : 'Background color';
        }
        const tooltipPrefix = format === 'forecolor' ? 'Text color {0}' : 'Background color {0}';
        const colors = getColors$1(getColors$2(editor, format), format, false);
        const colorText = find$5(colors, (c) => c.value === lastColor).getOr({ text: '' }).text;
        return editor.translate([tooltipPrefix, editor.translate(colorText)]);
    };
    const registerTextColorButton = (editor, name, format, lastColor) => {
        editor.ui.registry.addSplitButton(name, {
            tooltip: getToolTipText(editor, format, lastColor.get()),
            chevronTooltip: name === 'forecolor' ? 'Text color menu' : 'Background color menu',
            presets: 'color',
            icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',
            select: select$1(editor, format),
            columns: getColorCols$1(editor, format),
            fetch: getFetch$1(getColors$2(editor, format), format, hasCustomColors$1(editor)),
            onAction: (_splitButtonApi) => {
                applyColor(editor, format, lastColor.get(), noop);
            },
            onItemAction: (_splitButtonApi, value) => {
                applyColor(editor, format, value, (newColor) => {
                    lastColor.set(newColor);
                    fireTextColorChange(editor, {
                        name,
                        color: newColor
                    });
                });
            },
            onSetup: (splitButtonApi) => {
                setIconColor(splitButtonApi, name, lastColor.get());
                const handler = (e) => {
                    if (e.name === name) {
                        setIconColor(splitButtonApi, e.name, e.color);
                        setTooltip(splitButtonApi, getToolTipText(editor, format, e.color));
                    }
                };
                editor.on('TextColorChange', handler);
                return composeUnbinders(onSetupEditableToggle(editor)(splitButtonApi), () => {
                    editor.off('TextColorChange', handler);
                });
            }
        });
    };
    const registerTextColorMenuItem = (editor, name, format, text, lastColor) => {
        editor.ui.registry.addNestedMenuItem(name, {
            text,
            icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',
            onSetup: (api) => {
                setTooltip(api, getToolTipText(editor, format, lastColor.get()));
                setIconColor(api, name, lastColor.get());
                return onSetupEditableToggle(editor)(api);
            },
            getSubmenuItems: () => [
                {
                    type: 'fancymenuitem',
                    fancytype: 'colorswatch',
                    select: select$1(editor, format),
                    initData: {
                        storageKey: format,
                    },
                    onAction: (data) => {
                        applyColor(editor, format, data.value, (newColor) => {
                            lastColor.set(newColor);
                            fireTextColorChange(editor, {
                                name,
                                color: newColor
                            });
                        });
                    },
                }
            ]
        });
    };
    const colorPickerDialog = (editor) => (callback, value) => {
        let isValid = false;
        const onSubmit = (api) => {
            const data = api.getData();
            const hex = data.colorpicker;
            if (isValid) {
                callback(Optional.from(hex));
                api.close();
            }
            else {
                editor.windowManager.alert(editor.translate(['Invalid hex color code: {0}', hex]));
            }
        };
        const onAction = (_api, details) => {
            if (details.name === 'hex-valid') {
                isValid = details.value;
            }
        };
        const initialData = {
            colorpicker: value
        };
        editor.windowManager.open({
            title: 'Color Picker',
            size: 'normal',
            body: {
                type: 'panel',
                items: [
                    {
                        type: 'colorpicker',
                        name: 'colorpicker',
                        label: 'Color'
                    }
                ]
            },
            buttons: [
                {
                    type: 'cancel',
                    name: 'cancel',
                    text: 'Cancel'
                },
                {
                    type: 'submit',
                    name: 'save',
                    text: 'Save',
                    primary: true
                }
            ],
            initialData,
            onAction,
            onSubmit,
            onClose: noop,
            onCancel: () => {
                callback(Optional.none());
            }
        });
    };
    const register$d = (editor) => {
        registerCommands(editor);
        const fallbackColorForeground = getDefaultForegroundColor(editor);
        const fallbackColorBackground = getDefaultBackgroundColor(editor);
        const lastForeColor = Cell(fallbackColorForeground);
        const lastBackColor = Cell(fallbackColorBackground);
        registerTextColorButton(editor, 'forecolor', 'forecolor', lastForeColor);
        registerTextColorButton(editor, 'backcolor', 'hilitecolor', lastBackColor);
        registerTextColorMenuItem(editor, 'forecolor', 'forecolor', 'Text color', lastForeColor);
        registerTextColorMenuItem(editor, 'backcolor', 'hilitecolor', 'Background color', lastBackColor);
    };

    const renderImgItem = (spec, onItemValueHandler, isSelected, itemResponse, providersBackstage) => {
        const getApi = (component) => ({
            setActive: (state) => {
                Toggling.set(component, state);
            },
            isActive: () => Toggling.isOn(component),
            isEnabled: () => !Disabling.isDisabled(component),
            setEnabled: (state) => Disabling.set(component, !state)
        });
        const structure = renderItemStructure({
            presets: 'img',
            textContent: Optional.none(),
            htmlContent: Optional.none(),
            ariaLabel: spec.tooltip,
            iconContent: Optional.some(spec.url),
            labelContent: spec.label,
            shortcutContent: Optional.none(),
            checkMark: Optional.some(renderCheckmark(providersBackstage.icons)),
            caret: Optional.none(),
            value: spec.value
        }, providersBackstage, true);
        const optTooltipping = spec.tooltip
            .map((t) => Tooltipping.config(providersBackstage.tooltips.getConfig({
            tooltipText: providersBackstage.translate(t)
        })));
        return deepMerge(renderCommonItem({
            context: spec.context,
            data: buildData(spec),
            enabled: spec.enabled,
            getApi,
            onAction: (api) => {
                onItemValueHandler(spec.value);
                api.setActive(true);
            },
            onSetup: (api) => {
                api.setActive(isSelected);
                return noop;
            },
            triggersSubmenu: false,
            itemBehaviours: [
                ...optTooltipping.toArray()
            ]
        }, structure, itemResponse, providersBackstage), {
            toggling: {
                toggleClass: tickedClass,
                toggleOnExecute: false,
                selected: spec.active,
                exclusive: true
            }
        });
    };

    const createPartialChoiceMenu = (value, items, onItemValueHandler, columns, presets, itemResponse, select, providersBackstage) => {
        const hasIcons = menuHasIcons(items);
        const presetItemTypes = presets !== 'color' ? 'normal' : 'color';
        const alloyItems = createChoiceItems(items, onItemValueHandler, columns, presetItemTypes, itemResponse, select, providersBackstage);
        const menuLayout = {
            menuType: presets
        };
        return createPartialMenuWithAlloyItems(value, hasIcons, alloyItems, columns, menuLayout);
    };
    const createChoiceItems = (items, onItemValueHandler, columns, itemPresets, itemResponse, select, providersBackstage) => cat(map$2(items, (item) => {
        if (item.type === 'choiceitem') {
            return createChoiceMenuItem(item).fold(handleError, (d) => Optional.some(renderChoiceItem(d, columns === 1, itemPresets, onItemValueHandler, select(d.value), itemResponse, providersBackstage, menuHasIcons(items))));
        }
        else if (item.type === 'imageitem') {
            return createImageMenuItem(item).fold(handleError, (d) => Optional.some(renderImgItem(d, onItemValueHandler, select(d.value), itemResponse, providersBackstage)));
        }
        else if (item.type === 'resetimage') {
            return createResetImageItem(item).fold(handleError, (d) => Optional.some(renderChoiceItem(({
                ...d,
                type: 'choiceitem',
                text: d.tooltip,
                icon: Optional.some(d.icon),
                label: Optional.some(d.label),
            }), columns === 1, itemPresets, onItemValueHandler, select(d.value), itemResponse, providersBackstage, menuHasIcons(items))));
        }
        else {
            return Optional.none();
        }
    }));

    const deriveMenuMovement = (columns, presets) => {
        const menuMarkers = markers(presets);
        if (columns === 1) {
            return { mode: 'menu', moveOnTab: true };
        }
        else if (columns === 'auto') {
            return {
                mode: 'grid',
                selector: '.' + menuMarkers.item,
                initSize: {
                    numColumns: 1,
                    numRows: 1
                }
            };
        }
        else {
            const rowClass = {
                color: 'tox-swatches__row',
                imageselector: 'tox-image-selector__row',
                listpreview: 'tox-collection__group',
                normal: 'tox-collection__group'
            }[presets];
            return {
                mode: 'matrix',
                rowSelector: '.' + rowClass,
                previousSelector: (menu) => {
                    // We only want the navigation to start on the selected item if we are in color-mode (The colorswatch)
                    return presets === 'color'
                        ? descendant(menu.element, '[aria-checked=true]')
                        : Optional.none();
                }
            };
        }
    };
    const deriveCollectionMovement = (columns, presets) => {
        if (columns === 1) {
            return {
                mode: 'menu',
                moveOnTab: false,
                selector: '.tox-collection__item'
            };
        }
        else if (columns === 'auto') {
            return {
                mode: 'flatgrid',
                selector: '.' + 'tox-collection__item',
                initSize: {
                    numColumns: 1,
                    numRows: 1
                }
            };
        }
        else {
            return {
                mode: 'matrix',
                selectors: {
                    row: presets === 'color' ? '.tox-swatches__row' : '.tox-collection__group',
                    cell: presets === 'color' ? `.${colorClass}` : `.${selectableClass}`
                }
            };
        }
    };

    const renderColorSwatchItem = (spec, backstage) => {
        const items = getColorItems(spec, backstage);
        const columns = backstage.colorinput.getColorCols(spec.initData.storageKey);
        const presets = 'color';
        const menuSpec = createPartialChoiceMenu(generate$6('menu-value'), items, (value) => {
            spec.onAction({ value });
        }, columns, presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), backstage.shared.providers);
        const widgetSpec = {
            ...menuSpec,
            markers: markers(presets),
            movement: deriveMenuMovement(columns, presets),
            // TINY-10806: Avoid duplication of ARIA role="menu" in the accessibility tree for Color Swatch menu item.
            showMenuRole: false
        };
        return {
            type: 'widget',
            data: { value: generate$6('widget-id') },
            dom: {
                tag: 'div',
                classes: ['tox-fancymenuitem']
            },
            autofocus: true,
            components: [
                parts$7.widget(Menu.sketch(widgetSpec))
            ]
        };
    };
    const getColorItems = (spec, backstage) => {
        const useCustomColors = spec.initData.allowCustomColors && backstage.colorinput.hasCustomColors();
        return spec.initData.colors.fold(() => getColors$1(backstage.colorinput.getColors(spec.initData.storageKey), spec.initData.storageKey, useCustomColors), (colors) => colors.concat(getAdditionalColors(useCustomColors)));
    };

    const renderImageSelector = (spec, backstage) => {
        const presets = 'imageselector';
        const columns = spec.initData.columns;
        const menuSpec = createPartialChoiceMenu(generate$6('menu-value'), spec.initData.items, (value) => {
            spec.onAction({ value });
        }, columns, presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), backstage.shared.providers);
        const widgetSpec = {
            ...menuSpec,
            markers: markers(presets),
            movement: deriveMenuMovement(columns, presets),
            // TINY-10806: Avoid duplication of ARIA role="menu" in the accessibility tree for Image Selector menu item.
            showMenuRole: false
        };
        return {
            type: 'widget',
            data: { value: generate$6('widget-id') },
            dom: {
                tag: 'div',
                classes: ['tox-fancymenuitem', 'tox-collection--toolbar']
            },
            autofocus: true,
            components: [
                parts$7.widget(Menu.sketch(widgetSpec))
            ]
        };
    };

    const cellOverEvent = generate$6('cell-over');
    const cellExecuteEvent = generate$6('cell-execute');
    const makeAnnouncementText = (backstage) => (row, col) => backstage.shared.providers.translate(['{0} columns, {1} rows', col, row]);
    const makeCell = (row, col, label) => {
        const emitCellOver = (c) => emitWith(c, cellOverEvent, { row, col });
        const emitExecute = (c) => emitWith(c, cellExecuteEvent, { row, col });
        const onClick = (c, se) => {
            se.stop();
            emitExecute(c);
        };
        return build$1({
            dom: {
                tag: 'div',
                attributes: {
                    role: 'button',
                    ['aria-label']: label
                }
            },
            behaviours: derive$1([
                config('insert-table-picker-cell', [
                    run$1(mouseover(), Focusing.focus),
                    run$1(execute$5(), emitExecute),
                    run$1(click(), onClick),
                    run$1(tap(), onClick)
                ]),
                Toggling.config({
                    toggleClass: 'tox-insert-table-picker__selected',
                    toggleOnExecute: false
                }),
                Focusing.config({ onFocus: emitCellOver })
            ])
        });
    };
    const makeCells = (getCellLabel, numRows, numCols) => {
        const cells = [];
        for (let i = 0; i < numRows; i++) {
            const row = [];
            for (let j = 0; j < numCols; j++) {
                const label = getCellLabel(i + 1, j + 1);
                row.push(makeCell(i, j, label));
            }
            cells.push(row);
        }
        return cells;
    };
    const selectCells = (cells, selectedRow, selectedColumn, numRows, numColumns) => {
        for (let i = 0; i < numRows; i++) {
            for (let j = 0; j < numColumns; j++) {
                Toggling.set(cells[i][j], i <= selectedRow && j <= selectedColumn);
            }
        }
    };
    const makeComponents = (cells) => bind$3(cells, (cellRow) => map$2(cellRow, premade));
    const makeLabelText = (row, col) => text$2(`${col}x${row}`);
    const renderInsertTableMenuItem = (spec, backstage) => {
        const numRows = 10;
        const numColumns = 10;
        const getCellLabel = makeAnnouncementText(backstage);
        const cells = makeCells(getCellLabel, numRows, numColumns);
        const emptyLabelText = makeLabelText(0, 0);
        const memLabel = record({
            dom: {
                tag: 'span',
                classes: ['tox-insert-table-picker__label'],
            },
            components: [emptyLabelText],
            behaviours: derive$1([
                Replacing.config({})
            ])
        });
        return {
            type: 'widget',
            data: { value: generate$6('widget-id') },
            dom: {
                tag: 'div',
                classes: ['tox-fancymenuitem']
            },
            autofocus: true,
            components: [parts$7.widget({
                    dom: {
                        tag: 'div',
                        classes: ['tox-insert-table-picker']
                    },
                    components: makeComponents(cells).concat(memLabel.asSpec()),
                    behaviours: derive$1([
                        config('insert-table-picker', [
                            runOnAttached((c) => {
                                // Restore the empty label when opened, otherwise it may still be using an old label from last time it was opened
                                Replacing.set(memLabel.get(c), [emptyLabelText]);
                            }),
                            runWithTarget(cellOverEvent, (c, t, e) => {
                                const { row, col } = e.event;
                                selectCells(cells, row, col, numRows, numColumns);
                                Replacing.set(memLabel.get(c), [makeLabelText(row + 1, col + 1)]);
                            }),
                            runWithTarget(cellExecuteEvent, (c, _, e) => {
                                const { row, col } = e.event;
                                // Close the sandbox before triggering the action
                                emit(c, sandboxClose());
                                spec.onAction({ numRows: row + 1, numColumns: col + 1 });
                            })
                        ]),
                        Keying.config({
                            initSize: {
                                numRows,
                                numColumns
                            },
                            mode: 'flatgrid',
                            selector: '[role="button"]'
                        })
                    ])
                })]
        };
    };

    const fancyMenuItems = {
        inserttable: renderInsertTableMenuItem,
        colorswatch: renderColorSwatchItem,
        imageselect: renderImageSelector
    };
    const renderFancyMenuItem = (spec, backstage) => get$h(fancyMenuItems, spec.fancytype).map((render) => render(spec, backstage));

    // Note, this does not create a valid SketchSpec.
    const renderNestedItem = (spec, itemResponse, providersBackstage, renderIcons = true, downwardsCaret = false) => {
        const caret = downwardsCaret ? renderDownwardsCaret(providersBackstage.icons) : renderSubmenuCaret(providersBackstage.icons);
        const getApi = (component) => ({
            isEnabled: () => !Disabling.isDisabled(component),
            setEnabled: (state) => Disabling.set(component, !state),
            setIconFill: (id, value) => {
                descendant(component.element, `svg path[class="${id}"], rect[class="${id}"]`).each((underlinePath) => {
                    set$9(underlinePath, 'fill', value);
                });
            },
            setTooltip: (tooltip) => {
                const translatedTooltip = providersBackstage.translate(tooltip);
                set$9(component.element, 'aria-label', translatedTooltip);
            }
        });
        const structure = renderItemStructure({
            presets: 'normal',
            iconContent: spec.icon,
            textContent: spec.text,
            htmlContent: Optional.none(),
            ariaLabel: spec.text,
            labelContent: Optional.none(),
            caret: Optional.some(caret),
            checkMark: Optional.none(),
            shortcutContent: spec.shortcut
        }, providersBackstage, renderIcons);
        return renderCommonItem({
            context: spec.context,
            data: buildData(spec),
            getApi,
            enabled: spec.enabled,
            onAction: noop,
            onSetup: spec.onSetup,
            triggersSubmenu: true,
            itemBehaviours: []
        }, structure, itemResponse, providersBackstage);
    };

    // Note, this does not create a valid SketchSpec.
    const renderNormalItem = (spec, itemResponse, providersBackstage, renderIcons = true) => {
        const getApi = (component) => ({
            isEnabled: () => !Disabling.isDisabled(component),
            setEnabled: (state) => Disabling.set(component, !state)
        });
        const structure = renderItemStructure({
            presets: 'normal',
            iconContent: spec.icon,
            textContent: spec.text,
            htmlContent: Optional.none(),
            labelContent: Optional.none(),
            ariaLabel: spec.text,
            caret: Optional.none(),
            checkMark: Optional.none(),
            shortcutContent: spec.shortcut
        }, providersBackstage, renderIcons);
        return renderCommonItem({
            context: spec.context,
            data: buildData(spec),
            getApi,
            enabled: spec.enabled,
            onAction: spec.onAction,
            onSetup: spec.onSetup,
            triggersSubmenu: false,
            itemBehaviours: []
        }, structure, itemResponse, providersBackstage);
    };

    const renderSeparatorItem = (spec) => ({
        type: 'separator',
        dom: {
            tag: 'div',
            classes: [selectableClass, groupHeadingClass]
        },
        components: spec.text.map(text$2).toArray()
    });

    const renderToggleMenuItem = (spec, itemResponse, providersBackstage, renderIcons = true) => {
        const getApi = (component) => ({
            setActive: (state) => {
                Toggling.set(component, state);
            },
            isActive: () => Toggling.isOn(component),
            isEnabled: () => !Disabling.isDisabled(component),
            setEnabled: (state) => Disabling.set(component, !state)
        });
        // BespokeSelects use meta to pass through styling information. Bespokes should only
        // be togglemenuitems hence meta is only passed through in this MenuItem.
        const structure = renderItemStructure({
            iconContent: spec.icon,
            textContent: spec.text,
            htmlContent: Optional.none(),
            labelContent: Optional.none(),
            ariaLabel: spec.text,
            checkMark: Optional.some(renderCheckmark(providersBackstage.icons)),
            caret: Optional.none(),
            shortcutContent: spec.shortcut,
            presets: 'normal',
            meta: spec.meta
        }, providersBackstage, renderIcons);
        return deepMerge(renderCommonItem({
            context: spec.context,
            data: buildData(spec),
            enabled: spec.enabled,
            getApi,
            onAction: spec.onAction,
            onSetup: spec.onSetup,
            triggersSubmenu: false,
            itemBehaviours: []
        }, structure, itemResponse, providersBackstage), {
            toggling: {
                toggleClass: tickedClass,
                toggleOnExecute: false,
                selected: spec.active
            },
            role: spec.role.getOrUndefined()
        });
    };

    const autocomplete = renderAutocompleteItem;
    const separator$3 = renderSeparatorItem;
    const normal = renderNormalItem;
    const nested = renderNestedItem;
    const toggle = renderToggleMenuItem;
    const fancy = renderFancyMenuItem;
    const card = renderCardMenuItem;

    const identifyMenuLayout = (searchMode) => {
        switch (searchMode.searchMode) {
            case 'no-search': {
                return {
                    menuType: 'normal'
                };
            }
            default: {
                return {
                    menuType: 'searchable',
                    searchMode
                };
            }
        }
    };
    const handleRefetchTrigger = (originalSandboxComp) => {
        // At the moment, a Sandbox is "Represented" by its triggering Dropdown.
        // We'll want to make this an official API, in case we change it later.
        const dropdown = Representing.getValue(originalSandboxComp);
        // Because refetch will replace the entire menu, we need to store the
        // original version of the searcher state, so that we can reinstate it
        // after the fetch completes (which is async)
        const optSearcherState = findWithinSandbox(originalSandboxComp).map(saveState);
        Dropdown.refetch(dropdown).get(() => {
            // It has completed, so now find the searcher and set its value
            // again. We can't just use the originalSandbox, because that will
            // have been thrown away and recreated by now.
            const newSandboxComp = Coupling.getCoupled(dropdown, 'sandbox');
            optSearcherState.each((searcherState) => findWithinSandbox(newSandboxComp).each((inputComp) => restoreState(inputComp, searcherState)));
        });
    };
    // This event is triggered by the searcher for key events
    // that should be handled by the currently selected item
    // (that is, the one with *fake* focus, not real focus). So we
    // need to redispatch them to the selected item in the sandbox.
    const handleRedirectToMenuItem = (sandboxComp, se) => {
        getActiveMenuItemFrom(sandboxComp).each((activeItem) => {
            retargetAndDispatchWith(sandboxComp, activeItem.element, se.event.eventType, se.event.interactionEvent);
        });
    };
    // This function is useful when you have fakeFocus, so you can't just find the
    // currently focused item (or the item that triggered a key event). It relies on
    // the following relationships between components
    // The Sandbox creates a tieredmenu, so Sandboxing.getState returns the TieredMenu
    // The TieredMenu uses Highlighting for managing which menus are active, so
    // Highlighting.getHighlighted(tmenu) is the current active menu
    // The Menu uses highlighting to manage the active item, so use
    // Highlighting.getHighlighted(menu) to get the current item.
    const getActiveMenuItemFrom = (sandboxComp) => {
        // Consider moving some of these things into shared APIs. For example, make an extra API
        // for TieredMenu to get the highlighted item.
        return Sandboxing.getState(sandboxComp)
            .bind(Highlighting.getHighlighted)
            .bind(Highlighting.getHighlighted);
    };
    const getSearchResults = (activeMenuComp) => {
        // Depending on the menu layout, the search results will either be the entire
        // menu, or something within the menu.
        return has(activeMenuComp.element, searchResultsClass)
            ? Optional.some(activeMenuComp.element)
            : descendant(activeMenuComp.element, '.' + searchResultsClass);
    };
    // Model the interaction with ARIA
    const updateAriaOnHighlight = (tmenuComp, menuComp, itemComp) => {
        // This ARIA behaviour is based on the algolia example documented in TINY-8952
        findWithinMenu(tmenuComp).each((inputComp) => {
            setActiveDescendant(inputComp, itemComp);
            const optActiveResults = getSearchResults(menuComp);
            optActiveResults.each((resultsElem) => {
                // Link aria-controls of the input to the id of the results container.
                getOpt(resultsElem, 'id')
                    .each((controlledId) => set$9(inputComp.element, 'aria-controls', controlledId));
            });
        });
        // Update the aria-selected on the item. The removal is handled by onDehighlight
        set$9(itemComp.element, 'aria-selected', 'true');
    };
    const updateAriaOnDehighlight = (tmenuComp, menuComp, itemComp) => {
        // This ARIA behaviour is based on the algolia example documented in TINY-8952
        set$9(itemComp.element, 'aria-selected', 'false');
    };
    const focusSearchField = (tmenuComp) => {
        findWithinMenu(tmenuComp).each((searcherComp) => Focusing.focus(searcherComp));
    };
    const getSearchPattern = (dropdownComp) => {
        // Dropdowns are "coupled" with their sandbox and generally, create them on demand.
        // When using "getExistingCoupled" of Coupling, it only returns the coupled
        // component (here: the sandbox) if it already exists ... it won't do any creation.
        // So here, we are trying to get possible fetchContext information for our fetch
        // callback. If there is no sandbox, then there is no open menu, and we
        // don't have any search context, so use an empty string. Otherwise, dive into
        // the sandbox, and find the search field's current pattern.
        const optSandboxComp = Coupling.getExistingCoupled(dropdownComp, 'sandbox');
        return optSandboxComp
            .bind(findWithinSandbox)
            .map(saveState)
            .map((state) => state.fetchPattern)
            .getOr('');
    };

    var FocusMode;
    (function (FocusMode) {
        FocusMode[FocusMode["ContentFocus"] = 0] = "ContentFocus";
        FocusMode[FocusMode["UiFocus"] = 1] = "UiFocus";
    })(FocusMode || (FocusMode = {}));
    const createMenuItemFromBridge = (item, itemResponse, backstage, menuHasIcons, isHorizontalMenu) => {
        const providersBackstage = backstage.shared.providers;
        // If we're making a horizontal menu (mobile context menu) we want text OR icons
        // to simplify the UI. We also don't want shortcut text.
        const parseForHorizontalMenu = (menuitem) => !isHorizontalMenu ? menuitem : ({
            ...menuitem,
            shortcut: Optional.none(),
            icon: menuitem.text.isSome() ? Optional.none() : menuitem.icon
        });
        switch (item.type) {
            case 'menuitem':
                return createMenuItem(item).fold(handleError, (d) => Optional.some(normal(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons)));
            case 'nestedmenuitem':
                return createNestedMenuItem(item).fold(handleError, (d) => Optional.some(nested(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons, isHorizontalMenu)));
            case 'togglemenuitem':
                return createToggleMenuItem(item).fold(handleError, (d) => Optional.some(toggle(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons)));
            case 'separator':
                return createSeparatorMenuItem(item).fold(handleError, (d) => Optional.some(separator$3(d)));
            case 'fancymenuitem':
                return createFancyMenuItem(item).fold(handleError, 
                // Fancy menu items don't have shortcuts or icons
                (d) => fancy(d, backstage));
            default: {
                // eslint-disable-next-line no-console
                console.error('Unknown item in general menu', item);
                return Optional.none();
            }
        }
    };
    const createAutocompleteItems = (items, matchText, onItemValueHandler, columns, itemResponse, sharedBackstage, highlightOn) => {
        // Render text and icons if we're using a single column, otherwise only render icons
        const renderText = columns === 1;
        const renderIcons = !renderText || menuHasIcons(items);
        return cat(map$2(items, (item) => {
            switch (item.type) {
                case 'separator':
                    return createSeparatorItem(item).fold(handleError, (d) => Optional.some(separator$3(d)));
                case 'cardmenuitem':
                    return createCardMenuItem(item).fold(handleError, (d) => Optional.some(card({
                        ...d,
                        // Intercept action
                        onAction: (api) => {
                            d.onAction(api);
                            onItemValueHandler(d.value, d.meta);
                        }
                    }, itemResponse, sharedBackstage, {
                        itemBehaviours: tooltipBehaviour(d.meta, sharedBackstage, Optional.none()),
                        cardText: {
                            matchText,
                            highlightOn
                        }
                    })));
                case 'autocompleteitem':
                default:
                    return createAutocompleterItem(item).fold(handleError, (d) => Optional.some(autocomplete(d, matchText, renderText, 'normal', onItemValueHandler, itemResponse, sharedBackstage, renderIcons)));
            }
        }));
    };
    const createPartialMenu = (value, items, itemResponse, backstage, isHorizontalMenu, searchMode) => {
        const hasIcons = menuHasIcons(items);
        const alloyItems = cat(map$2(items, (item) => {
            // Have to check each item for an icon, instead of as part of hasIcons above,
            // else in horizontal menus, items with an icon but without text will display
            // with neither
            const itemHasIcon = (i) => isHorizontalMenu ? !has$2(i, 'text') : hasIcons;
            const createItem = (i) => createMenuItemFromBridge(i, itemResponse, backstage, itemHasIcon(i), isHorizontalMenu);
            if (item.type === 'nestedmenuitem' && item.getSubmenuItems().length <= 0) {
                return createItem({ ...item, enabled: false });
            }
            else {
                return createItem(item);
            }
        }));
        // The menu layout is dependent upon our search mode.
        const menuLayout = identifyMenuLayout(searchMode);
        const createPartial = isHorizontalMenu ?
            createHorizontalPartialMenuWithAlloyItems :
            createPartialMenuWithAlloyItems;
        return createPartial(value, hasIcons, alloyItems, 1, menuLayout);
    };
    const createTieredDataFrom = (partialMenu) => tieredMenu.singleData(partialMenu.value, partialMenu);
    const createInlineMenuFrom = (partialMenu, columns, focusMode, presets) => {
        const movement = deriveMenuMovement(columns, presets);
        const menuMarkers = markers(presets);
        return {
            data: createTieredDataFrom({
                ...partialMenu,
                movement,
                menuBehaviours: SimpleBehaviours.unnamedEvents(columns !== 'auto' ? [] : [
                    runOnAttached((comp, _se) => {
                        detectSize(comp, 4, menuMarkers.item).each(({ numColumns, numRows }) => {
                            Keying.setGridSize(comp, numRows, numColumns);
                        });
                    })
                ])
            }),
            menu: {
                markers: markers(presets),
                fakeFocus: focusMode === FocusMode.ContentFocus
            }
        };
    };

    const rangeToSimRange = (r) => SimRange.create(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);
    const register$c = (editor, sharedBackstage) => {
        const autocompleterId = generate$6('autocompleter');
        const processingAction = Cell(false);
        const activeState = Cell(false);
        const activeRange = value$2();
        const autocompleter = build$1(InlineView.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-autocompleter'],
                attributes: {
                    id: autocompleterId
                }
            },
            components: [],
            fireDismissalEventInstead: {},
            inlineBehaviours: derive$1([
                config('dismissAutocompleter', [
                    run$1(dismissRequested(), () => cancelIfNecessary()),
                    run$1(highlight$1(), (_, se) => {
                        getOpt(se.event.target, 'id').each((id) => set$9(SugarElement.fromDom(editor.getBody()), 'aria-activedescendant', id));
                    }),
                ])
            ]),
            lazySink: sharedBackstage.getSink
        }));
        const isMenuOpen = () => InlineView.isOpen(autocompleter);
        const isActive = activeState.get;
        const hideIfNecessary = () => {
            if (isMenuOpen()) {
                InlineView.hide(autocompleter);
                editor.dom.remove(autocompleterId, false);
                const editorBody = SugarElement.fromDom(editor.getBody());
                getOpt(editorBody, 'aria-owns')
                    .filter((ariaOwnsAttr) => ariaOwnsAttr === autocompleterId)
                    .each(() => {
                    remove$8(editorBody, 'aria-owns');
                    remove$8(editorBody, 'aria-activedescendant');
                });
            }
        };
        const getMenu = () => InlineView.getContent(autocompleter).bind((tmenu) => {
            // The autocompleter menu will be the first child component of the tiered menu.
            // Unfortunately a memento can't be used to do this lookup because the component
            // id is changed while generating the tiered menu.
            return get$i(tmenu.components(), 0);
        });
        const cancelIfNecessary = () => editor.execCommand('mceAutocompleterClose');
        const getCombinedItems = (matches) => {
            const columns = findMap(matches, (m) => Optional.from(m.columns)).getOr(1);
            return bind$3(matches, (match) => {
                const choices = match.items;
                return createAutocompleteItems(choices, match.matchText, (itemValue, itemMeta) => {
                    const autocompleterApi = {
                        hide: () => cancelIfNecessary(),
                        reload: (fetchOptions) => {
                            hideIfNecessary();
                            editor.execCommand('mceAutocompleterReload', false, { fetchOptions });
                        }
                    };
                    // Asks the editor for a new active range that emits an event that updates
                    // the activeRange state not ideal but trying to avoid direct method calls to the core.
                    // We need to get a fresh range since when you hit enter the IME commits and the updates the DOM so we then need to rescan.
                    editor.execCommand('mceAutocompleterRefreshActiveRange');
                    activeRange.get().each((range) => {
                        processingAction.set(true);
                        match.onAction(autocompleterApi, range, itemValue, itemMeta);
                        processingAction.set(false);
                    });
                }, columns, ItemResponse$1.BUBBLE_TO_SANDBOX, sharedBackstage, match.highlightOn);
            });
        };
        const display = (lookupData, items) => {
            // Display the autocompleter menu
            const columns = findMap(lookupData, (ld) => Optional.from(ld.columns)).getOr(1);
            InlineView.showMenuAt(autocompleter, {
                anchor: {
                    type: 'selection',
                    getSelection: () => activeRange.get().map(rangeToSimRange),
                    root: SugarElement.fromDom(editor.getBody()),
                }
            }, createInlineMenuFrom(createPartialMenuWithAlloyItems('autocompleter-value', true, items, columns, { menuType: 'normal' }), columns, FocusMode.ContentFocus, 
            // Use the constant.
            'normal'));
            getMenu().each(Highlighting.highlightFirst);
        };
        const updateDisplay = (lookupData) => {
            const combinedItems = getCombinedItems(lookupData);
            // Open the autocompleter if there are items to show
            if (combinedItems.length > 0) {
                display(lookupData, combinedItems);
                set$9(SugarElement.fromDom(editor.getBody()), 'aria-owns', autocompleterId);
                if (!editor.inline) {
                    cloneAutocompleterToEditorDoc();
                }
            }
            else {
                hideIfNecessary();
            }
        };
        const cloneAutocompleterToEditorDoc = () => {
            if (editor.dom.get(autocompleterId)) {
                editor.dom.remove(autocompleterId, false);
            }
            const docElm = editor.getDoc().documentElement;
            const selection = editor.selection.getNode();
            const newElm = deep(autocompleter.element);
            setAll(newElm, {
                border: '0',
                clip: 'rect(0 0 0 0)',
                height: '1px',
                margin: '-1px',
                overflow: 'hidden',
                padding: '0',
                position: 'absolute',
                width: '1px',
                top: `${selection.offsetTop}px`,
                left: `${selection.offsetLeft}px`,
            });
            editor.dom.add(docElm, newElm.dom);
            // Clean up positioning styles so that the "hidden" autocompleter is around the selection
            descendant(newElm, '[role="menu"]').each((child) => {
                remove$6(child, 'position');
                remove$6(child, 'max-height');
            });
        };
        editor.on('AutocompleterStart', ({ lookupData }) => {
            activeState.set(true);
            processingAction.set(false);
            updateDisplay(lookupData);
        });
        editor.on('AutocompleterUpdate', ({ lookupData }) => updateDisplay(lookupData));
        editor.on('AutocompleterUpdateActiveRange', ({ range }) => activeRange.set(range));
        editor.on('AutocompleterEnd', () => {
            // Hide the menu and reset
            hideIfNecessary();
            activeState.set(false);
            processingAction.set(false);
            activeRange.clear();
        });
        const autocompleterUiApi = {
            cancelIfNecessary,
            isMenuOpen,
            isActive,
            isProcessingAction: processingAction.get,
            getMenu
        };
        AutocompleterEditorEvents.setup(autocompleterUiApi, editor);
    };
    const Autocompleter = {
        register: register$c
    };

    const renderBar = (spec, backstage) => ({
        dom: {
            tag: 'div',
            classes: ['tox-bar', 'tox-form__controls-h-stack']
        },
        components: map$2(spec.items, backstage.interpreter)
    });

    var global$4 = tinymce.util.Tools.resolve('tinymce.html.Entities');

    const renderFormFieldWith = (pLabel, pField, extraClasses, extraBehaviours) => {
        const spec = renderFormFieldSpecWith(pLabel, pField, extraClasses, extraBehaviours);
        return FormField.sketch(spec);
    };
    const renderFormField = (pLabel, pField) => renderFormFieldWith(pLabel, pField, [], []);
    const renderFormFieldSpecWith = (pLabel, pField, extraClasses, extraBehaviours) => ({
        dom: renderFormFieldDomWith(extraClasses),
        components: pLabel.toArray().concat([pField]),
        fieldBehaviours: derive$1(extraBehaviours)
    });
    const renderFormFieldDom = () => renderFormFieldDomWith([]);
    const renderFormFieldDomWith = (extraClasses) => ({
        tag: 'div',
        classes: ['tox-form__group'].concat(extraClasses)
    });
    const renderLabel$3 = (label, providersBackstage) => FormField.parts.label({
        dom: {
            tag: 'label',
            classes: ['tox-label']
        },
        components: [
            text$2(providersBackstage.translate(label))
        ]
    });

    const formChangeEvent = generate$6('form-component-change');
    const formInputEvent = generate$6('form-component-input');
    const formCloseEvent = generate$6('form-close');
    const formCancelEvent = generate$6('form-cancel');
    const formActionEvent = generate$6('form-action');
    const formSubmitEvent = generate$6('form-submit');
    const formBlockEvent = generate$6('form-block');
    const formUnblockEvent = generate$6('form-unblock');
    const formTabChangeEvent = generate$6('form-tabchange');
    const formResizeEvent = generate$6('form-resize');

    const renderCollection = (spec, providersBackstage, initialData) => {
        // DUPE with TextField.
        const pLabel = spec.label.map((label) => renderLabel$3(label, providersBackstage));
        const icons = providersBackstage.icons();
        // TINY-10174: Icon string is either in icon pack or displayed directly
        const getIcon = (icon) => { var _a; return (_a = icons[icon]) !== null && _a !== void 0 ? _a : icon; };
        const runOnItem = (f) => (comp, se) => {
            closest$3(se.event.target, '[data-collection-item-value]').each((target) => {
                f(comp, se, target, get$g(target, 'data-collection-item-value'));
            });
        };
        const setContents = (comp, items) => {
            // Giving it a default `mode:design` context, these shouldn't run at all in mode:readonly
            const disabled = providersBackstage.checkUiComponentContext('mode:design').shouldDisable || providersBackstage.isDisabled();
            const disabledClass = disabled ? ' tox-collection__item--state-disabled' : '';
            const htmlLines = map$2(items, (item) => {
                const itemText = global$6.translate(item.text);
                const textContent = spec.columns === 1 ? `<div class="tox-collection__item-label">${itemText}</div>` : '';
                const iconContent = `<div class="tox-collection__item-icon">${getIcon(item.icon)}</div>`;
                // Replacing the hyphens and underscores in collection items with spaces
                // to ensure the screen readers pronounce the words correctly.
                // This is only for aria purposes. Emoticon and Special Character names will still use _ and - for autocompletion.
                const mapItemName = {
                    '_': ' ',
                    ' - ': ' ',
                    '-': ' '
                };
                // Using aria-label here overrides the Apple description of emojis and special characters in Mac/ MS description in Windows.
                // But if only the title attribute is used instead, the names are read out twice. i.e., the description followed by the item.text.
                const ariaLabel = itemText.replace(/\_| \- |\-/g, (match) => mapItemName[match]);
                return `<div data-mce-tooltip="${ariaLabel}" class="tox-collection__item${disabledClass}" tabindex="-1" data-collection-item-value="${global$4.encodeAllRaw(item.value)}" aria-label="${ariaLabel}">${iconContent}${textContent}</div>`;
            });
            const chunks = spec.columns !== 'auto' && spec.columns > 1 ? chunk$1(htmlLines, spec.columns) : [htmlLines];
            const html = map$2(chunks, (ch) => `<div class="tox-collection__group">${ch.join('')}</div>`);
            set$8(comp.element, html.join(''));
        };
        const onClick = runOnItem((comp, se, tgt, itemValue) => {
            se.stop();
            if (!(providersBackstage.checkUiComponentContext('mode:design').shouldDisable || providersBackstage.isDisabled())) {
                emitWith(comp, formActionEvent, {
                    name: spec.name,
                    value: itemValue
                });
            }
        });
        const collectionEvents = [
            run$1(mouseover(), runOnItem((comp, se, tgt) => {
                focus$4(tgt, true);
            })),
            run$1(click(), onClick),
            run$1(tap(), onClick),
            run$1(focusin(), runOnItem((comp, se, tgt) => {
                descendant(comp.element, '.' + activeClass).each((currentActive) => {
                    remove$3(currentActive, activeClass);
                });
                add$2(tgt, activeClass);
            })),
            run$1(focusout(), runOnItem((comp) => {
                descendant(comp.element, '.' + activeClass).each((currentActive) => {
                    remove$3(currentActive, activeClass);
                    blur$1(currentActive);
                });
            })),
            runOnExecute$1(runOnItem((comp, se, tgt, itemValue) => {
                emitWith(comp, formActionEvent, {
                    name: spec.name,
                    value: itemValue
                });
            })),
        ];
        const iterCollectionItems = (comp, applyAttributes) => map$2(descendants(comp.element, '.tox-collection__item'), applyAttributes);
        const pField = FormField.parts.field({
            dom: {
                tag: 'div',
                // FIX: Read from columns
                classes: ['tox-collection'].concat(spec.columns !== 1 ? ['tox-collection--grid'] : ['tox-collection--list'])
            },
            components: [],
            factory: { sketch: identity },
            behaviours: derive$1([
                Disabling.config({
                    disabled: () => providersBackstage.checkUiComponentContext(spec.context).shouldDisable,
                    onDisabled: (comp) => {
                        iterCollectionItems(comp, (childElm) => {
                            add$2(childElm, 'tox-collection__item--state-disabled');
                            set$9(childElm, 'aria-disabled', true);
                        });
                    },
                    onEnabled: (comp) => {
                        iterCollectionItems(comp, (childElm) => {
                            remove$3(childElm, 'tox-collection__item--state-disabled');
                            remove$8(childElm, 'aria-disabled');
                        });
                    }
                }),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context)),
                Replacing.config({}),
                Tooltipping.config({
                    ...providersBackstage.tooltips.getConfig({
                        tooltipText: '',
                        onShow: (comp) => {
                            descendant(comp.element, '.' + activeClass + '[data-mce-tooltip]').each((current) => {
                                getOpt(current, 'data-mce-tooltip').each((text) => {
                                    Tooltipping.setComponents(comp, providersBackstage.tooltips.getComponents({ tooltipText: text }));
                                });
                            });
                        }
                    }),
                    mode: 'children-keyboard-focus',
                    anchor: (comp) => ({
                        type: 'node',
                        node: descendant(comp.element, '.' + activeClass).orThunk(() => first('.tox-collection__item')),
                        root: comp.element,
                        layouts: {
                            onLtr: constant$1([south$2, north$2, southeast$2, northeast$2, southwest$2, northwest$2]),
                            onRtl: constant$1([south$2, north$2, southeast$2, northeast$2, southwest$2, northwest$2])
                        },
                        bubble: nu$6(0, -2, {}),
                    })
                }),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: initialData.getOr([])
                    },
                    onSetValue: (comp, items) => {
                        setContents(comp, items);
                        if (spec.columns === 'auto') {
                            detectSize(comp, 5, 'tox-collection__item').each(({ numRows, numColumns }) => {
                                Keying.setGridSize(comp, numRows, numColumns);
                            });
                        }
                        emit(comp, formResizeEvent);
                    }
                }),
                Tabstopping.config({}),
                Keying.config(deriveCollectionMovement(spec.columns, 'normal')),
                config('collection-events', collectionEvents)
            ]),
            eventOrder: {
                [execute$5()]: ['disabling', 'alloy.base.behaviour', 'collection-events'],
                [focusin()]: ['collection-events', 'tooltipping'],
            }
        });
        const extraClasses = ['tox-form__group--collection'];
        return renderFormFieldWith(pLabel, pField, extraClasses, []);
    };

    const renderPanelButton = (spec, sharedBackstage) => Dropdown.sketch({
        dom: spec.dom,
        components: spec.components,
        toggleClass: 'mce-active',
        dropdownBehaviours: derive$1([
            DisablingConfigs.button(() => sharedBackstage.providers.isDisabled() || sharedBackstage.providers.checkUiComponentContext(spec.context).shouldDisable),
            toggleOnReceive(() => sharedBackstage.providers.checkUiComponentContext(spec.context)),
            Unselecting.config({}),
            Tabstopping.config({})
        ]),
        layouts: spec.layouts,
        sandboxClasses: ['tox-dialog__popups'],
        lazySink: sharedBackstage.getSink,
        fetch: (comp) => Future.nu((callback) => spec.fetch(callback)).map((items) => Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, (value) => {
            spec.onItemAction(comp, value);
        }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, 
        // No colour is ever selected on opening
        never, sharedBackstage.providers), {
            movement: deriveMenuMovement(spec.columns, spec.presets)
        })))),
        parts: {
            menu: part(false, 1, spec.presets)
        }
    });

    const colorInputChangeEvent = generate$6('color-input-change');
    const colorSwatchChangeEvent = generate$6('color-swatch-change');
    const colorPickerCancelEvent = generate$6('color-picker-cancel');
    const renderColorInput = (spec, sharedBackstage, colorInputBackstage, initialData) => {
        const pField = FormField.parts.field({
            factory: Input,
            inputClasses: ['tox-textfield'],
            data: initialData,
            onSetValue: (c) => Invalidating.run(c).get(noop),
            inputBehaviours: derive$1([
                Disabling.config({
                    disabled: () => sharedBackstage.providers.isDisabled() || sharedBackstage.providers.checkUiComponentContext(spec.context).shouldDisable
                }),
                toggleOnReceive(() => sharedBackstage.providers.checkUiComponentContext(spec.context)),
                Tabstopping.config({}),
                Invalidating.config({
                    invalidClass: 'tox-textbox-field-invalid',
                    getRoot: (comp) => parentElement(comp.element),
                    notify: {
                        onValid: (comp) => {
                            // onValid should pass through the value here
                            // We need a snapshot of the value validated.
                            const val = Representing.getValue(comp);
                            emitWith(comp, colorInputChangeEvent, {
                                color: val
                            });
                        }
                    },
                    validator: {
                        validateOnLoad: false,
                        validate: (input) => {
                            const inputValue = Representing.getValue(input);
                            // Consider empty strings valid colours
                            if (inputValue.length === 0) {
                                return Future.pure(Result.value(true));
                            }
                            else {
                                const span = SugarElement.fromTag('span');
                                set$7(span, 'background-color', inputValue);
                                const res = getRaw(span, 'background-color').fold(
                                // TODO: Work out what we want to do here.
                                () => Result.error('blah'), (_) => Result.value(inputValue));
                                return Future.pure(res);
                            }
                        }
                    }
                })
            ]),
            selectOnFocus: false
        });
        const pLabel = spec.label.map((label) => renderLabel$3(label, sharedBackstage.providers));
        const emitSwatchChange = (colorBit, value) => {
            emitWith(colorBit, colorSwatchChangeEvent, {
                value
            });
        };
        const onItemAction = (comp, value) => {
            memColorButton.getOpt(comp).each((colorBit) => {
                if (value === 'custom') {
                    colorInputBackstage.colorPicker((valueOpt) => {
                        valueOpt.fold(() => emit(colorBit, colorPickerCancelEvent), (value) => {
                            emitSwatchChange(colorBit, value);
                            addColor(spec.storageKey, value);
                        });
                    }, '#ffffff');
                }
                else if (value === 'remove') {
                    emitSwatchChange(colorBit, '');
                }
                else {
                    emitSwatchChange(colorBit, value);
                }
            });
        };
        const memColorButton = record(renderPanelButton({
            dom: {
                tag: 'span',
                attributes: {
                    'aria-label': sharedBackstage.providers.translate('Color swatch')
                }
            },
            layouts: {
                onRtl: () => [southwest$2, southeast$2, south$2],
                onLtr: () => [southeast$2, southwest$2, south$2]
            },
            components: [],
            fetch: getFetch$1(colorInputBackstage.getColors(spec.storageKey), spec.storageKey, colorInputBackstage.hasCustomColors()),
            columns: colorInputBackstage.getColorCols(spec.storageKey),
            presets: 'color',
            onItemAction,
            context: spec.context
        }, sharedBackstage));
        return FormField.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-form__group']
            },
            components: pLabel.toArray().concat([
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-color-input']
                    },
                    components: [
                        pField,
                        memColorButton.asSpec()
                    ]
                }
            ]),
            fieldBehaviours: derive$1([
                config('form-field-events', [
                    run$1(colorInputChangeEvent, (comp, se) => {
                        memColorButton.getOpt(comp).each((colorButton) => {
                            set$7(colorButton.element, 'background-color', se.event.color);
                        });
                        emitWith(comp, formChangeEvent, { name: spec.name });
                    }),
                    run$1(colorSwatchChangeEvent, (comp, se) => {
                        FormField.getField(comp).each((field) => {
                            Representing.setValue(field, se.event.value);
                            // Focus the field now that we've set its value
                            Composing.getCurrent(comp).each(Focusing.focus);
                        });
                    }),
                    run$1(colorPickerCancelEvent, (comp, _se) => {
                        FormField.getField(comp).each((_field) => {
                            Composing.getCurrent(comp).each(Focusing.focus);
                        });
                    })
                ])
            ])
        });
    };

    // TODO: Move this to alloy if the concept works out
    // eslint-disable-next-line consistent-this
    const self = () => Composing.config({
        find: Optional.some
    });
    const memento$1 = (mem) => Composing.config({
        find: mem.getOpt
    });
    const childAt = (index) => Composing.config({
        find: (comp) => child$2(comp.element, index)
            .bind((element) => comp.getSystem().getByDom(element).toOptional())
    });
    const ComposingConfigs = {
        self,
        memento: memento$1,
        childAt
    };

    const processors = objOf([
        defaulted('preprocess', identity),
        defaulted('postprocess', identity)
    ]);
    const memento = (mem, rawProcessors) => {
        const ps = asRawOrDie$1('RepresentingConfigs.memento processors', processors, rawProcessors);
        return Representing.config({
            store: {
                mode: 'manual',
                getValue: (comp) => {
                    const other = mem.get(comp);
                    const rawValue = Representing.getValue(other);
                    return ps.postprocess(rawValue);
                },
                setValue: (comp, rawValue) => {
                    const newValue = ps.preprocess(rawValue);
                    const other = mem.get(comp);
                    Representing.setValue(other, newValue);
                }
            }
        });
    };
    const withComp = (optInitialValue, getter, setter) => Representing.config({
        store: {
            mode: 'manual',
            ...optInitialValue.map((initialValue) => ({ initialValue })).getOr({}),
            getValue: getter,
            setValue: setter
        }
    });
    const withElement = (initialValue, getter, setter) => withComp(initialValue, (c) => getter(c.element), (c, v) => setter(c.element, v));
    const domHtml = (optInitialValue) => withElement(optInitialValue, get$f, set$8);
    const memory = (initialValue) => Representing.config({
        store: {
            mode: 'memory',
            initialValue
        }
    });

    const fieldsUpdate = generate$6('rgb-hex-update');
    const sliderUpdate = generate$6('slider-update');
    const paletteUpdate = generate$6('palette-update');

    const sliderFactory = (translate, getClass) => {
        const spectrum = Slider.parts.spectrum({
            dom: {
                tag: 'div',
                classes: [getClass('hue-slider-spectrum')],
                attributes: {
                    role: 'presentation'
                }
            }
        });
        const thumb = Slider.parts.thumb({
            dom: {
                tag: 'div',
                classes: [getClass('hue-slider-thumb')],
                attributes: {
                    role: 'presentation'
                }
            }
        });
        return Slider.sketch({
            dom: {
                tag: 'div',
                classes: [getClass('hue-slider')],
                attributes: {
                    'role': 'slider',
                    'aria-valuemin': 0,
                    'aria-valuemax': 360,
                    'aria-valuenow': 120,
                }
            },
            rounded: false,
            model: {
                mode: 'y',
                getInitialValue: constant$1(0)
            },
            components: [
                spectrum,
                thumb
            ],
            sliderBehaviours: derive$1([
                Focusing.config({})
            ]),
            onChange: (slider, _thumb, value) => {
                set$9(slider.element, 'aria-valuenow', Math.floor(360 - (value * 3.6)));
                emitWith(slider, sliderUpdate, {
                    value
                });
            }
        });
    };

    const validInput = generate$6('valid-input');
    const invalidInput = generate$6('invalid-input');
    const validatingInput = generate$6('validating-input');
    const translatePrefix = 'colorcustom.rgb.';
    const uninitiatedTooltipApi = {
        isEnabled: always,
        setEnabled: noop,
        immediatelyShow: noop,
        immediatelyHide: noop,
    };
    const rgbFormFactory = (translate, getClass, onValidHexx, onInvalidHexx, tooltipGetConfig, makeIcon) => {
        const setTooltipEnabled = (enabled, tooltipApi) => {
            const api = tooltipApi.get();
            if (enabled === api.isEnabled()) {
                return;
            }
            api.setEnabled(enabled);
            if (enabled) {
                api.immediatelyShow();
            }
            else {
                api.immediatelyHide();
            }
        };
        const invalidation = (label, isValid, tooltipApi) => Invalidating.config({
            invalidClass: getClass('invalid'),
            notify: {
                onValidate: (comp) => {
                    emitWith(comp, validatingInput, {
                        type: label
                    });
                },
                onValid: (comp) => {
                    setTooltipEnabled(false, tooltipApi);
                    emitWith(comp, validInput, {
                        type: label,
                        value: Representing.getValue(comp)
                    });
                },
                onInvalid: (comp) => {
                    setTooltipEnabled(true, tooltipApi);
                    emitWith(comp, invalidInput, {
                        type: label,
                        value: Representing.getValue(comp)
                    });
                }
            },
            validator: {
                validate: (comp) => {
                    const value = Representing.getValue(comp);
                    const res = isValid(value) ? Result.value(true) : Result.error(translate('aria.input.invalid'));
                    return Future.pure(res);
                },
                validateOnLoad: false
            }
        });
        const renderTextField = (isValid, name, label, description, data) => {
            const tooltipApi = Cell(uninitiatedTooltipApi);
            const helptext = translate(translatePrefix + 'range');
            const pLabel = FormField.parts.label({
                dom: { tag: 'label' },
                components: [text$2(label)]
            });
            const pField = FormField.parts.field({
                data,
                factory: Input,
                inputAttributes: {
                    'type': 'text',
                    'aria-label': description,
                    ...name === 'hex' ? { 'aria-live': 'polite' } : {}
                },
                inputClasses: [getClass('textfield')],
                // Have basic invalidating and tabstopping behaviour.
                inputBehaviours: derive$1([
                    invalidation(name, isValid, tooltipApi),
                    Tabstopping.config({}),
                    Tooltipping.config({
                        ...tooltipGetConfig({
                            tooltipText: '',
                            onSetup: (comp) => {
                                tooltipApi.set({
                                    isEnabled: () => {
                                        return Tooltipping.isEnabled(comp);
                                    },
                                    setEnabled: (enabled) => {
                                        return Tooltipping.setEnabled(comp, enabled);
                                    },
                                    immediatelyShow: () => {
                                        return Tooltipping.immediateOpenClose(comp, true);
                                    },
                                    immediatelyHide: () => {
                                        return Tooltipping.immediateOpenClose(comp, false);
                                    },
                                });
                                Tooltipping.setEnabled(comp, false);
                            },
                            onShow: (component, _tooltip) => {
                                Tooltipping.setComponents(component, [
                                    {
                                        dom: {
                                            tag: 'p',
                                            classes: [
                                                getClass('rgb-warning-note')
                                            ]
                                        },
                                        components: [text$2(translate(name === 'hex' ? 'colorcustom.rgb.invalidHex' : 'colorcustom.rgb.invalid'))]
                                    }
                                ]);
                            },
                        })
                    })
                ]),
                // If it was invalid, and the value was set, run validation against it.
                onSetValue: (input) => {
                    if (Invalidating.isInvalid(input)) {
                        const run = Invalidating.run(input);
                        run.get(noop);
                    }
                }
            });
            const errorId = generate$6('aria-invalid');
            const memInvalidIcon = record(makeIcon('invalid', Optional.some(errorId), 'warning'));
            const memStatus = record({
                dom: {
                    tag: 'div',
                    classes: [getClass('invalid-icon')]
                },
                components: [
                    memInvalidIcon.asSpec()
                ]
            });
            const comps = [pLabel, pField, memStatus.asSpec()];
            const concats = name !== 'hex' ? [FormField.parts['aria-descriptor']({
                    text: helptext
                })] : [];
            const components = comps.concat(concats);
            return {
                dom: {
                    tag: 'div',
                    attributes: {
                        role: 'presentation'
                    },
                    classes: [
                        getClass('rgb-container'),
                    ]
                },
                components
            };
        };
        const copyRgbToHex = (form, rgba) => {
            const hex = fromRgba(rgba);
            Form.getField(form, 'hex').each((hexField) => {
                // Not amazing, but it turns out that if we have an invalid RGB field, and no hex code
                // and then type in a valid three digit hex code, the RGB field will be overriden, then validate and then set
                // the hex field to be the six digit version of that same three digit hex code. This is incorrect.
                if (!Focusing.isFocused(hexField)) {
                    Representing.setValue(form, {
                        hex: hex.value
                    });
                }
            });
            return hex;
        };
        const copyRgbToForm = (form, rgb) => {
            const red = rgb.red;
            const green = rgb.green;
            const blue = rgb.blue;
            Representing.setValue(form, { red, green, blue });
        };
        const memPreview = record({
            dom: {
                tag: 'div',
                classes: [getClass('rgba-preview')],
                styles: {
                    'background-color': 'white'
                },
                attributes: {
                    role: 'presentation'
                }
            }
        });
        const updatePreview = (anyInSystem, hex) => {
            memPreview.getOpt(anyInSystem).each((preview) => {
                set$7(preview.element, 'background-color', '#' + hex.value);
            });
        };
        const factory = () => {
            const state = {
                red: Cell(Optional.some(255)),
                green: Cell(Optional.some(255)),
                blue: Cell(Optional.some(255)),
                hex: Cell(Optional.some('ffffff'))
            };
            const copyHexToRgb = (form, hex) => {
                const rgb = fromHex(hex);
                copyRgbToForm(form, rgb);
                setValueRgb(rgb);
            };
            const get = (prop) => state[prop].get();
            const set = (prop, value) => {
                state[prop].set(value);
            };
            const getValueRgb = () => get('red').bind((red) => get('green').bind((green) => get('blue').map((blue) => rgbaColour(red, green, blue, 1))));
            // TODO: Find way to use this for palette and slider updates
            const setValueRgb = (rgb) => {
                const red = rgb.red;
                const green = rgb.green;
                const blue = rgb.blue;
                set('red', Optional.some(red));
                set('green', Optional.some(green));
                set('blue', Optional.some(blue));
            };
            const onInvalidInput = (form, simulatedEvent) => {
                const data = simulatedEvent.event;
                if (data.type !== 'hex') {
                    set(data.type, Optional.none());
                }
                else {
                    onInvalidHexx(form);
                }
            };
            const onValidHex = (form, value) => {
                onValidHexx(form);
                const hex = hexColour(value);
                set('hex', Optional.some(hex.value));
                const rgb = fromHex(hex);
                copyRgbToForm(form, rgb);
                setValueRgb(rgb);
                emitWith(form, fieldsUpdate, {
                    hex
                });
                updatePreview(form, hex);
            };
            const onValidRgb = (form, prop, value) => {
                const val = parseInt(value, 10);
                set(prop, Optional.some(val));
                getValueRgb().each((rgb) => {
                    const hex = copyRgbToHex(form, rgb);
                    emitWith(form, fieldsUpdate, {
                        hex
                    });
                    updatePreview(form, hex);
                });
            };
            const isHexInputEvent = (data) => data.type === 'hex';
            const onValidInput = (form, simulatedEvent) => {
                const data = simulatedEvent.event;
                if (isHexInputEvent(data)) {
                    onValidHex(form, data.value);
                }
                else {
                    onValidRgb(form, data.type, data.value);
                }
            };
            const formPartStrings = (key) => ({
                label: translate(translatePrefix + key + '.label'),
                description: translate(translatePrefix + key + '.description')
            });
            const redStrings = formPartStrings('red');
            const greenStrings = formPartStrings('green');
            const blueStrings = formPartStrings('blue');
            const hexStrings = formPartStrings('hex');
            // TODO: Provide a nice way of adding APIs to existing sketchers
            return deepMerge(Form.sketch((parts) => ({
                dom: {
                    tag: 'form',
                    classes: [getClass('rgb-form')],
                    attributes: { 'aria-label': translate('aria.color.picker') }
                },
                components: [
                    parts.field('red', FormField.sketch(renderTextField(isRgbaComponent, 'red', redStrings.label, redStrings.description, 255))),
                    parts.field('green', FormField.sketch(renderTextField(isRgbaComponent, 'green', greenStrings.label, greenStrings.description, 255))),
                    parts.field('blue', FormField.sketch(renderTextField(isRgbaComponent, 'blue', blueStrings.label, blueStrings.description, 255))),
                    parts.field('hex', FormField.sketch(renderTextField(isHexString, 'hex', hexStrings.label, hexStrings.description, 'ffffff'))),
                    memPreview.asSpec()
                ],
                formBehaviours: derive$1([
                    Invalidating.config({
                        invalidClass: getClass('form-invalid')
                    }),
                    config('rgb-form-events', [
                        run$1(validInput, onValidInput),
                        run$1(invalidInput, onInvalidInput),
                        run$1(validatingInput, onInvalidInput)
                    ])
                ])
            })), {
                apis: {
                    updateHex: (form, hex) => {
                        Representing.setValue(form, {
                            hex: hex.value
                        });
                        copyHexToRgb(form, hex);
                        updatePreview(form, hex);
                    }
                }
            });
        };
        const rgbFormSketcher = single({
            factory,
            name: 'RgbForm',
            configFields: [],
            apis: {
                updateHex: (apis, form, hex) => {
                    apis.updateHex(form, hex);
                }
            },
            extraApis: {}
        });
        return rgbFormSketcher;
    };

    const paletteFactory = (translate, getClass) => {
        const spectrumPart = Slider.parts.spectrum({
            dom: {
                tag: 'canvas',
                attributes: {
                    role: 'presentation'
                },
                classes: [getClass('sv-palette-spectrum')]
            }
        });
        const thumbPart = Slider.parts.thumb({
            dom: {
                tag: 'div',
                attributes: {
                    role: 'presentation'
                },
                classes: [getClass('sv-palette-thumb')],
                innerHtml: `<div class=${getClass('sv-palette-inner-thumb')} role="presentation"></div>`
            }
        });
        const setColour = (canvas, rgba) => {
            const { width, height } = canvas;
            const ctx = canvas.getContext('2d');
            if (ctx === null) {
                return;
            }
            ctx.fillStyle = rgba;
            ctx.fillRect(0, 0, width, height);
            const grdWhite = ctx.createLinearGradient(0, 0, width, 0);
            grdWhite.addColorStop(0, 'rgba(255,255,255,1)');
            grdWhite.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grdWhite;
            ctx.fillRect(0, 0, width, height);
            const grdBlack = ctx.createLinearGradient(0, 0, 0, height);
            grdBlack.addColorStop(0, 'rgba(0,0,0,0)');
            grdBlack.addColorStop(1, 'rgba(0,0,0,1)');
            ctx.fillStyle = grdBlack;
            ctx.fillRect(0, 0, width, height);
        };
        const setPaletteHue = (slider, hue) => {
            const canvas = slider.components()[0].element.dom;
            const hsv = hsvColour(hue, 100, 100);
            const rgba = fromHsv(hsv);
            setColour(canvas, toString(rgba));
        };
        const setPaletteThumb = (slider, hex) => {
            const hsv = fromRgb(fromHex(hex));
            Slider.setValue(slider, { x: hsv.saturation, y: 100 - hsv.value });
            set$9(slider.element, 'aria-valuetext', translate(['Saturation {0}%, Brightness {1}%', hsv.saturation, hsv.value]));
        };
        const factory = (_detail) => {
            const getInitialValue = constant$1({
                x: 0,
                y: 0
            });
            const onChange = (slider, _thumb, value) => {
                if (!isNumber(value)) {
                    set$9(slider.element, 'aria-valuetext', translate(['Saturation {0}%, Brightness {1}%', Math.floor(value.x), Math.floor(100 - value.y)]));
                }
                emitWith(slider, paletteUpdate, {
                    value
                });
            };
            const onInit = (_slider, _thumb, spectrum, _value) => {
                // Maybe make this initial value configurable?
                setColour(spectrum.element.dom, toString(red));
            };
            const sliderBehaviours = derive$1([
                Composing.config({
                    find: Optional.some
                }),
                Focusing.config({})
            ]);
            return Slider.sketch({
                dom: {
                    tag: 'div',
                    attributes: {
                        'role': 'slider',
                        'aria-valuetext': translate(['Saturation {0}%, Brightness {1}%', 0, 0])
                    },
                    classes: [getClass('sv-palette')]
                },
                model: {
                    mode: 'xy',
                    getInitialValue,
                },
                rounded: false,
                components: [
                    spectrumPart,
                    thumbPart
                ],
                onChange,
                onInit,
                sliderBehaviours
            });
        };
        const saturationBrightnessPaletteSketcher = single({
            factory,
            name: 'SaturationBrightnessPalette',
            configFields: [],
            apis: {
                setHue: (_apis, slider, hue) => {
                    setPaletteHue(slider, hue);
                },
                setThumb: (_apis, slider, hex) => {
                    setPaletteThumb(slider, hex);
                }
            },
            extraApis: {}
        });
        return saturationBrightnessPaletteSketcher;
    };

    const makeFactory = (translate, getClass, tooltipConfig, makeIcon) => {
        const factory = (detail) => {
            const rgbForm = rgbFormFactory(translate, getClass, detail.onValidHex, detail.onInvalidHex, tooltipConfig, makeIcon);
            const sbPalette = paletteFactory(translate, getClass);
            const hueSliderToDegrees = (hue) => (100 - hue) / 100 * 360;
            const hueDegreesToSlider = (hue) => 100 - (hue / 360) * 100;
            const state = {
                paletteRgba: Cell(red),
                paletteHue: Cell(0)
            };
            const memSlider = record(sliderFactory(translate, getClass));
            const memPalette = record(sbPalette.sketch({}));
            const memRgb = record(rgbForm.sketch({}));
            const updatePalette = (anyInSystem, _hex, hue) => {
                memPalette.getOpt(anyInSystem).each((palette) => {
                    sbPalette.setHue(palette, hue);
                });
            };
            const updateFields = (anyInSystem, hex) => {
                memRgb.getOpt(anyInSystem).each((form) => {
                    rgbForm.updateHex(form, hex);
                });
            };
            const updateSlider = (anyInSystem, _hex, hue) => {
                memSlider.getOpt(anyInSystem).each((slider) => {
                    Slider.setValue(slider, hueDegreesToSlider(hue));
                });
            };
            const updatePaletteThumb = (anyInSystem, hex) => {
                memPalette.getOpt(anyInSystem).each((palette) => {
                    sbPalette.setThumb(palette, hex);
                });
            };
            const updateState = (hex, hue) => {
                const rgba = fromHex(hex);
                state.paletteRgba.set(rgba);
                state.paletteHue.set(hue);
            };
            const runUpdates = (anyInSystem, hex, hue, updates) => {
                updateState(hex, hue);
                each$1(updates, (update) => {
                    update(anyInSystem, hex, hue);
                });
            };
            const onPaletteUpdate = () => {
                const updates = [updateFields];
                return (form, simulatedEvent) => {
                    const value = simulatedEvent.event.value;
                    const oldHue = state.paletteHue.get();
                    const newHsv = hsvColour(oldHue, value.x, (100 - value.y));
                    const newHex = hsvToHex(newHsv);
                    runUpdates(form, newHex, oldHue, updates);
                };
            };
            const onSliderUpdate = () => {
                const updates = [updatePalette, updateFields];
                return (form, simulatedEvent) => {
                    const hue = hueSliderToDegrees(simulatedEvent.event.value);
                    const oldRgb = state.paletteRgba.get();
                    const oldHsv = fromRgb(oldRgb);
                    const newHsv = hsvColour(hue, oldHsv.saturation, oldHsv.value);
                    const newHex = hsvToHex(newHsv);
                    runUpdates(form, newHex, hue, updates);
                };
            };
            const onFieldsUpdate = () => {
                const updates = [updatePalette, updateSlider, updatePaletteThumb];
                return (form, simulatedEvent) => {
                    const hex = simulatedEvent.event.hex;
                    const hsv = hexToHsv(hex);
                    runUpdates(form, hex, hsv.hue, updates);
                };
            };
            return {
                uid: detail.uid,
                dom: detail.dom,
                components: [
                    memPalette.asSpec(),
                    memSlider.asSpec(),
                    memRgb.asSpec()
                ],
                behaviours: derive$1([
                    config('colour-picker-events', [
                        run$1(fieldsUpdate, onFieldsUpdate()),
                        run$1(paletteUpdate, onPaletteUpdate()),
                        run$1(sliderUpdate, onSliderUpdate())
                    ]),
                    Composing.config({
                        find: (comp) => memRgb.getOpt(comp)
                    }),
                    Keying.config({
                        mode: 'acyclic'
                    })
                ])
            };
        };
        const colourPickerSketcher = single({
            name: 'ColourPicker',
            configFields: [
                required$1('dom'),
                defaulted('onValidHex', noop),
                defaulted('onInvalidHex', noop)
            ],
            factory
        });
        return colourPickerSketcher;
    };

    const english = {
        'colorcustom.rgb.red.label': 'R',
        'colorcustom.rgb.red.description': 'Red channel',
        'colorcustom.rgb.green.label': 'G',
        'colorcustom.rgb.green.description': 'Green channel',
        'colorcustom.rgb.blue.label': 'B',
        'colorcustom.rgb.blue.description': 'Blue channel',
        'colorcustom.rgb.hex.label': '#',
        'colorcustom.rgb.hex.description': 'Hex color code',
        'colorcustom.rgb.range': 'Range 0 to 255',
        'colorcustom.rgb.invalid': 'Numbers only, 0 to 255',
        'colorcustom.rgb.invalidHex': 'Hexadecimal only, 000000 to FFFFFF',
        'aria.color.picker': 'Color Picker',
        'aria.input.invalid': 'Invalid input'
    };
    const translate = (providerBackstage) => (key) => {
        if (isString(key)) {
            return providerBackstage.translate(english[key]);
        }
        else {
            return providerBackstage.translate(key);
        }
    };
    const renderColorPicker = (_spec, providerBackstage, initialData) => {
        const getClass = (key) => 'tox-' + key;
        const renderIcon = (name, errId, icon = name, label = name) => render$4(icon, {
            tag: 'div',
            classes: ['tox-icon', 'tox-control-wrap__status-icon-' + name],
            attributes: {
                'title': providerBackstage.translate(label),
                'aria-live': 'polite',
                ...errId.fold(() => ({}), (id) => ({ id }))
            }
        }, providerBackstage.icons);
        const colourPickerFactory = makeFactory(translate(providerBackstage), getClass, providerBackstage.tooltips.getConfig, renderIcon);
        const onValidHex = (form) => {
            emitWith(form, formActionEvent, { name: 'hex-valid', value: true });
        };
        const onInvalidHex = (form) => {
            emitWith(form, formActionEvent, { name: 'hex-valid', value: false });
        };
        const memPicker = record(colourPickerFactory.sketch({
            dom: {
                tag: 'div',
                classes: [getClass('color-picker-container')],
                attributes: {
                    role: 'presentation'
                }
            },
            onValidHex,
            onInvalidHex
        }));
        return {
            dom: {
                tag: 'div'
            },
            components: [
                memPicker.asSpec()
            ],
            behaviours: derive$1([
                // We'll allow invalid values
                withComp(initialData, (comp) => {
                    const picker = memPicker.get(comp);
                    const optRgbForm = Composing.getCurrent(picker);
                    const optHex = optRgbForm.bind((rgbForm) => {
                        const formValues = Representing.getValue(rgbForm);
                        return formValues.hex;
                    });
                    return optHex.map((hex) => '#' + removeLeading(hex, '#')).getOr('');
                }, (comp, newValue) => {
                    const pattern = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/;
                    const valOpt = Optional.from(pattern.exec(newValue)).bind((matches) => get$i(matches, 1));
                    const picker = memPicker.get(comp);
                    const optRgbForm = Composing.getCurrent(picker);
                    optRgbForm.fold(() => {
                        // eslint-disable-next-line no-console
                        console.log('Can not find form');
                    }, (rgbForm) => {
                        Representing.setValue(rgbForm, {
                            hex: valOpt.getOr('')
                        });
                        // So not the way to do this.
                        Form.getField(rgbForm, 'hex').each((hexField) => {
                            emit(hexField, input());
                        });
                    });
                }),
                ComposingConfigs.self()
            ])
        };
    };

    var global$3 = tinymce.util.Tools.resolve('tinymce.Resource');

    const isOldCustomEditor = (spec) => has$2(spec, 'init');
    const renderCustomEditor = (spec) => {
        const editorApi = value$2();
        const memReplaced = record({
            dom: {
                tag: spec.tag
            }
        });
        const initialValue = value$2();
        const focusBehaviour = !isOldCustomEditor(spec) && spec.onFocus.isSome() ? [
            Focusing.config({
                onFocus: (comp) => {
                    spec.onFocus.each((onFocusFn) => {
                        onFocusFn(comp.element.dom);
                    });
                }
            }),
            Tabstopping.config({})
        ] : [];
        return {
            dom: {
                tag: 'div',
                classes: ['tox-custom-editor']
            },
            behaviours: derive$1([
                config('custom-editor-events', [
                    runOnAttached((component) => {
                        memReplaced.getOpt(component).each((ta) => {
                            // eslint-disable-next-line @typescript-eslint/no-floating-promises
                            (isOldCustomEditor(spec)
                                ? spec.init(ta.element.dom)
                                : global$3.load(spec.scriptId, spec.scriptUrl).then((init) => init(ta.element.dom, spec.settings))).then((ea) => {
                                initialValue.on((cvalue) => {
                                    ea.setValue(cvalue);
                                });
                                initialValue.clear();
                                editorApi.set(ea);
                            });
                        });
                    })
                ]),
                withComp(Optional.none(), () => editorApi.get().fold(() => initialValue.get().getOr(''), (ed) => ed.getValue()), (_component, value) => {
                    editorApi.get().fold(() => initialValue.set(value), (ed) => ed.setValue(value));
                }),
                ComposingConfigs.self()
            ].concat(focusBehaviour)),
            components: [memReplaced.asSpec()]
        };
    };

    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    const browseFilesEvent = generate$6('browse.files.event');
    const filterByExtension = (files, providersBackstage) => {
        const allowedImageFileTypes = global$2.explode(providersBackstage.getOption('images_file_types'));
        const isFileInAllowedTypes = (file) => exists(allowedImageFileTypes, (type) => endsWith(file.name.toLowerCase(), `.${type.toLowerCase()}`));
        return filter$2(from(files), isFileInAllowedTypes);
    };
    const renderDropZone = (spec, providersBackstage, initialData) => {
        // TODO: Consider moving to alloy
        const stopper = (_, se) => {
            se.stop();
        };
        // TODO: Consider moving to alloy
        const sequence = (actions) => (comp, se) => {
            each$1(actions, (a) => {
                a(comp, se);
            });
        };
        const onDrop = (comp, se) => {
            var _a;
            if (!Disabling.isDisabled(comp)) {
                const transferEvent = se.event.raw;
                emitWith(comp, browseFilesEvent, { files: (_a = transferEvent.dataTransfer) === null || _a === void 0 ? void 0 : _a.files });
            }
        };
        const onSelect = (component, simulatedEvent) => {
            const input = simulatedEvent.event.raw.target;
            emitWith(component, browseFilesEvent, { files: input.files });
        };
        const handleFiles = (component, files) => {
            if (files) {
                Representing.setValue(component, filterByExtension(files, providersBackstage));
                emitWith(component, formChangeEvent, { name: spec.name });
            }
        };
        const memInput = record({
            dom: {
                tag: 'input',
                attributes: {
                    type: 'file',
                    accept: 'image/*'
                },
                styles: {
                    display: 'none'
                }
            },
            behaviours: derive$1([
                config('input-file-events', [
                    cutter(click()),
                    cutter(tap())
                ])
            ])
        });
        const pLabel = spec.label.map((label) => renderLabel$3(label, providersBackstage));
        const pField = FormField.parts.field({
            factory: Button,
            dom: {
                tag: 'button',
                styles: {
                    position: 'relative'
                },
                classes: ['tox-button', 'tox-button--secondary']
            },
            components: [
                text$2(providersBackstage.translate('Browse for an image')),
                memInput.asSpec()
            ],
            action: (comp) => {
                const inputComp = memInput.get(comp);
                inputComp.element.dom.click();
            },
            buttonBehaviours: derive$1([
                ComposingConfigs.self(),
                memory(initialData.getOr([])),
                Tabstopping.config({}),
                DisablingConfigs.button(() => providersBackstage.checkUiComponentContext(spec.context).shouldDisable),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context))
            ])
        });
        const wrapper = {
            dom: {
                tag: 'div',
                classes: ['tox-dropzone-container']
            },
            behaviours: derive$1([
                Disabling.config({
                    disabled: () => providersBackstage.checkUiComponentContext(spec.context).shouldDisable
                }),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context)),
                Toggling.config({
                    toggleClass: 'dragenter',
                    toggleOnExecute: false
                }),
                config('dropzone-events', [
                    run$1('dragenter', sequence([stopper, Toggling.toggle])),
                    run$1('dragleave', sequence([stopper, Toggling.toggle])),
                    run$1('dragover', stopper),
                    run$1('drop', sequence([stopper, onDrop])),
                    run$1(change(), onSelect)
                ])
            ]),
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-dropzone'],
                        styles: {}
                    },
                    components: [
                        {
                            dom: {
                                tag: 'p'
                            },
                            components: [
                                text$2(providersBackstage.translate('Drop an image here'))
                            ]
                        },
                        pField
                    ]
                }
            ]
        };
        return renderFormFieldWith(pLabel, wrapper, ['tox-form__group--stretched'], [config('handle-files', [
                run$1(browseFilesEvent, (comp, se) => {
                    FormField.getField(comp).each((field) => {
                        handleFiles(field, se.event.files);
                    });
                })
            ])]);
    };

    const renderGrid = (spec, backstage) => ({
        dom: {
            tag: 'div',
            classes: ['tox-form__grid', `tox-form__grid--${spec.columns}col`]
        },
        components: map$2(spec.items, backstage.interpreter)
    });

    const beforeObject = generate$6('alloy-fake-before-tabstop');
    const afterObject = generate$6('alloy-fake-after-tabstop');
    const craftWithClasses = (classes) => {
        return {
            dom: {
                tag: 'div',
                styles: {
                    width: '1px',
                    height: '1px',
                    outline: 'none'
                },
                attributes: {
                    tabindex: '0' // Capture native tabbing in the appropriate order
                },
                classes
            },
            behaviours: derive$1([
                Focusing.config({ ignore: true }),
                Tabstopping.config({})
            ])
        };
    };
    const craft = (containerClasses, spec) => {
        return {
            dom: {
                tag: 'div',
                classes: ['tox-navobj', ...containerClasses.getOr([])]
            },
            components: [
                craftWithClasses([beforeObject]),
                spec,
                craftWithClasses([afterObject])
            ],
            behaviours: derive$1([
                ComposingConfigs.childAt(1)
            ])
        };
    };
    // TODO: Create an API in alloy to do this.
    const triggerTab = (placeholder, shiftKey) => {
        emitWith(placeholder, keydown(), {
            raw: {
                which: 9,
                shiftKey
            }
        });
    };
    const onFocus = (container, targetComp) => {
        const target = targetComp.element;
        // If focus has shifted naturally to a before object, the tab direction is backwards.
        if (has(target, beforeObject)) {
            triggerTab(container, true);
        }
        else if (has(target, afterObject)) {
            triggerTab(container, false);
        }
    };
    const isPseudoStop = (element) => {
        return closest$1(element, ['.' + beforeObject, '.' + afterObject].join(','), never);
    };

    const dialogChannel = generate$6('update-dialog');
    const titleChannel = generate$6('update-title');
    const bodyChannel = generate$6('update-body');
    const footerChannel = generate$6('update-footer');
    const bodySendMessageChannel = generate$6('body-send-message');
    const dialogFocusShiftedChannel = generate$6('dialog-focus-shifted');

    const browser = detect$1().browser;
    const isSafari = browser.isSafari();
    const isFirefox = browser.isFirefox();
    const isSafariOrFirefox = isSafari || isFirefox;
    const isChromium = browser.isChromium();
    const isElementScrollAtBottom = ({ scrollTop, scrollHeight, clientHeight }) => Math.ceil(scrollTop) + clientHeight >= scrollHeight;
    const scrollToY = (win, y) => 
    // TINY-10128: The iframe body is occasionally null when we attempt to scroll, so instead of using body.scrollHeight, use a
    // fallback value of 99999999. To minimise the potential impact of future browser changes, this fallback is significantly smaller
    // than the minimum of the maximum value Window.scrollTo would take on supported browsers:
    // Chromium: > Number.MAX_SAFE_INTEGER
    // Safari: 2^31 - 1 = 2147483647
    // Firefox: 2147483583
    win.scrollTo(0, y === 'bottom' ? 99999999 : y);
    const getScrollingElement = (doc, html) => {
        // TINY-10110: The scrolling element can change between body and documentElement depending on whether there
        // is a doctype declaration. However, this behavior is inconsistent on Chrome and Safari so checking for
        // the scroll properties is the most reliable way to determine which element is the scrolling element, at
        // least for the purposes of determining whether scroll is at bottom.
        const body = doc.body;
        return Optional.from(!/^<!DOCTYPE (html|HTML)/.test(html) &&
            (!isChromium && !isSafari || isNonNullable(body) && (body.scrollTop !== 0 || Math.abs(body.scrollHeight - body.clientHeight) > 1))
            ? body : doc.documentElement);
    };
    const writeValue = (iframeElement, html, fallbackFn) => {
        const iframe = iframeElement.dom;
        Optional.from(iframe.contentDocument).fold(fallbackFn, (doc) => {
            let lastScrollTop = 0;
            // TINY-10032: If documentElement (or body) is nullable, we assume document is empty and so scroll is at bottom.
            const isScrollAtBottom = getScrollingElement(doc, html).map((el) => {
                lastScrollTop = el.scrollTop;
                return el;
            }).forall(isElementScrollAtBottom);
            const scrollAfterWrite = () => {
                const win = iframe.contentWindow;
                if (isNonNullable(win)) {
                    if (isScrollAtBottom) {
                        scrollToY(win, 'bottom');
                    }
                    else if (!isScrollAtBottom && isSafariOrFirefox && lastScrollTop !== 0) {
                        // TINY-10078: Safari and Firefox reset scroll to top on each document.write(), so we need to restore scroll manually
                        scrollToY(win, lastScrollTop);
                    }
                }
            };
            // TINY-10109: On Safari, attempting to scroll before the iframe has finished loading will cause scroll to reset to top upon load.
            // TINY-10128: We will not wait for the load event on Chrome and Firefox since doing so causes the scroll to jump around erratically,
            // especially on Firefox. However, not waiting for load has the trade-off of potentially losing bottom scroll when updating at a very
            // rapid rate, as attempting to scroll before the iframe body is loaded will not work.
            if (isSafari) {
                iframe.addEventListener('load', scrollAfterWrite, { once: true });
            }
            doc.open();
            doc.write(html);
            doc.close();
            if (!isSafari) {
                scrollAfterWrite();
            }
        });
    };
    // TINY-10078: On Firefox, throttle to 200ms to improve scrolling experience. Since we are manually maintaining previous scroll position
    // on each update, when updating rapidly without a throttle, attempting to scroll around the iframe can feel stuck.
    // TINY-10097: On Safari, throttle to 500ms to reduce flickering as the document.write() method still observes significant flickering.
    // Also improves scrolling, as scroll positions are maintained manually similar to Firefox.
    const throttleInterval = someIf(isSafariOrFirefox, isSafari ? 500 : 200);
    // TINY-10078: Use Throttler.adaptable to ensure that any content added during the waiting period is not lost.
    const writeValueThrottler = throttleInterval.map((interval) => adaptable(writeValue, interval));
    const getDynamicSource = (initialData, stream) => {
        const cachedValue = Cell(initialData.getOr(''));
        return {
            getValue: (_frameComponent) => 
            // Ideally we should fetch data from the iframe...innerHtml, this triggers Cors errors
            cachedValue.get(),
            setValue: (frameComponent, html) => {
                if (cachedValue.get() !== html) {
                    const iframeElement = frameComponent.element;
                    const setSrcdocValue = () => set$9(iframeElement, 'srcdoc', html);
                    if (stream) {
                        writeValueThrottler.fold(constant$1(writeValue), (throttler) => throttler.throttle)(iframeElement, html, setSrcdocValue);
                    }
                    else {
                        // TINY-3769: We need to use srcdoc here, instead of src with a data URI, otherwise browsers won't retain the Origin.
                        // See https://bugs.chromium.org/p/chromium/issues/detail?id=58999#c11
                        setSrcdocValue();
                    }
                }
                cachedValue.set(html);
            }
        };
    };
    const renderIFrame = (spec, providersBackstage, initialData) => {
        const baseClass = 'tox-dialog__iframe';
        const opaqueClass = spec.transparent ? [] : [`${baseClass}--opaque`];
        const containerBorderedClass = spec.border ? [`tox-navobj-bordered`] : [];
        const attributes = {
            ...spec.label.map((title) => ({ title })).getOr({}),
            ...initialData.map((html) => ({ srcdoc: html })).getOr({}),
            ...spec.sandboxed ? { sandbox: 'allow-scripts allow-same-origin' } : {}
        };
        const sourcing = getDynamicSource(initialData, spec.streamContent);
        const pLabel = spec.label.map((label) => renderLabel$3(label, providersBackstage));
        const factory = (newSpec) => craft(Optional.from(containerBorderedClass), {
            // We need to use the part uid or the label and field won't be linked with ARIA
            uid: newSpec.uid,
            dom: {
                tag: 'iframe',
                attributes,
                classes: [
                    baseClass,
                    ...opaqueClass
                ]
            },
            behaviours: derive$1([
                Tabstopping.config({}),
                Focusing.config({}),
                withComp(initialData, sourcing.getValue, sourcing.setValue),
                Receiving.config({
                    channels: {
                        [dialogFocusShiftedChannel]: {
                            onReceive: (comp, message) => {
                                message.newFocus.each((newFocus) => {
                                    parentElement(comp.element).each((parent) => {
                                        const f = eq(comp.element, newFocus) ? add$2 : remove$3;
                                        f(parent, 'tox-navobj-bordered-focus');
                                    });
                                });
                            }
                        }
                    }
                })
            ])
        });
        // Note, it's not going to handle escape at this point.
        const pField = FormField.parts.field({
            factory: { sketch: factory }
        });
        return renderFormFieldWith(pLabel, pField, ['tox-form__group--stretched'], []);
    };

    const calculateImagePosition = (panelWidth, panelHeight, imageWidth, imageHeight, zoom) => {
        const width = imageWidth * zoom;
        const height = imageHeight * zoom;
        const left = Math.max(0, panelWidth / 2 - width / 2);
        const top = Math.max(0, panelHeight / 2 - height / 2);
        return {
            left: left.toString() + 'px',
            top: top.toString() + 'px',
            width: width.toString() + 'px',
            height: height.toString() + 'px',
        };
    };
    const zoomToFit = (panel, width, height) => {
        const panelW = get$c(panel);
        const panelH = get$d(panel);
        return Math.min(panelW / width, panelH / height, 1);
    };
    const renderImagePreview = (spec, initialData) => {
        const cachedData = Cell(initialData.getOr({ url: '' }));
        const memImage = record({
            dom: {
                tag: 'img',
                classes: ['tox-imagepreview__image'],
                attributes: initialData.map((data) => ({ src: data.url })).getOr({})
            },
        });
        const memContainer = record({
            dom: {
                tag: 'div',
                classes: ['tox-imagepreview__container'],
                attributes: {
                    role: 'presentation'
                },
            },
            components: [
                memImage.asSpec()
            ]
        });
        const setValue = (frameComponent, data) => {
            const translatedData = {
                url: data.url
            };
            // update properties that are set by the data
            data.zoom.each((z) => translatedData.zoom = z);
            data.cachedWidth.each((z) => translatedData.cachedWidth = z);
            data.cachedHeight.each((z) => translatedData.cachedHeight = z);
            cachedData.set(translatedData);
            const applyFramePositioning = () => {
                const { cachedWidth, cachedHeight, zoom } = translatedData;
                if (!isUndefined(cachedWidth) && !isUndefined(cachedHeight)) {
                    if (isUndefined(zoom)) {
                        const z = zoomToFit(frameComponent.element, cachedWidth, cachedHeight);
                        // sneaky mutation since we own the object
                        translatedData.zoom = z;
                    }
                    const position = calculateImagePosition(get$c(frameComponent.element), get$d(frameComponent.element), cachedWidth, cachedHeight, translatedData.zoom);
                    memContainer.getOpt(frameComponent).each((container) => {
                        setAll(container.element, position);
                    });
                }
            };
            memImage.getOpt(frameComponent).each((imageComponent) => {
                const img = imageComponent.element;
                if (data.url !== get$g(img, 'src')) {
                    set$9(img, 'src', data.url);
                    remove$3(frameComponent.element, 'tox-imagepreview__loaded');
                }
                applyFramePositioning();
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                image(img).then((img) => {
                    // Ensure the component hasn't been removed while the image was loading
                    // if it is disconnected, just do nothing
                    if (frameComponent.getSystem().isConnected()) {
                        add$2(frameComponent.element, 'tox-imagepreview__loaded');
                        // sneaky mutation since we own the object
                        translatedData.cachedWidth = img.dom.naturalWidth;
                        translatedData.cachedHeight = img.dom.naturalHeight;
                        applyFramePositioning();
                    }
                });
            });
        };
        const styles = {};
        spec.height.each((h) => styles.height = h);
        // TODO: TINY-8393 Use the initial data properly once it's validated
        const fakeValidatedData = initialData.map((d) => ({
            url: d.url,
            zoom: Optional.from(d.zoom),
            cachedWidth: Optional.from(d.cachedWidth),
            cachedHeight: Optional.from(d.cachedHeight),
        }));
        return {
            dom: {
                tag: 'div',
                classes: ['tox-imagepreview'],
                styles,
                attributes: {
                    role: 'presentation'
                }
            },
            components: [
                memContainer.asSpec(),
            ],
            behaviours: derive$1([
                ComposingConfigs.self(),
                withComp(fakeValidatedData, () => 
                /*
                  NOTE: This is intentionally returning the cached image width and height.
      
                  Including those details in the dialog data helps when `setData` only changes the URL, as
                  the old image must continue to be displayed at the old size until the new image has loaded.
                */
                cachedData.get(), setValue),
            ])
        };
    };

    const renderLabel$2 = (spec, backstageShared, getCompByName) => {
        const baseClass = 'tox-label';
        const centerClass = spec.align === 'center' ? [`${baseClass}--center`] : [];
        const endClass = spec.align === 'end' ? [`${baseClass}--end`] : [];
        const label = record({
            dom: {
                tag: 'label',
                classes: [baseClass, ...centerClass, ...endClass]
            },
            components: [
                text$2(backstageShared.providers.translate(spec.label))
            ]
        });
        const comps = map$2(spec.items, backstageShared.interpreter);
        return {
            dom: {
                tag: 'div',
                classes: ['tox-form__group']
            },
            components: [
                label.asSpec(),
                ...comps
            ],
            behaviours: derive$1([
                ComposingConfigs.self(),
                Replacing.config({}),
                domHtml(Optional.none()),
                Keying.config({
                    mode: 'acyclic'
                }),
                config('label', [
                    runOnAttached((comp) => {
                        spec.for.each((name) => {
                            getCompByName(name).each((target) => {
                                label.getOpt(comp).each((labelComp) => {
                                    var _a;
                                    const id = (_a = get$g(target.element, 'id')) !== null && _a !== void 0 ? _a : generate$6('form-field');
                                    set$9(target.element, 'id', id);
                                    set$9(labelComp.element, 'for', id);
                                });
                            });
                        });
                    })
                ]),
            ])
        };
    };

    const internalToolbarButtonExecute = generate$6('toolbar.button.execute');
    // Perform `action` when an item is clicked on, close menus, and stop event
    const onToolbarButtonExecute = (info) => runOnExecute$1((comp, _simulatedEvent) => {
        // If there is an action, run the action
        runWithApi(info, comp)((itemApi) => {
            emitWith(comp, internalToolbarButtonExecute, {
                buttonApi: itemApi
            });
            info.onAction(itemApi);
        });
    });
    const commonButtonDisplayEvent = generate$6('common-button-display-events');
    const toolbarButtonEventOrder = {
        // TODO: use the constants provided by behaviours.
        [execute$5()]: ['disabling', 'alloy.base.behaviour', 'toggling', 'toolbar-button-events', 'tooltipping'],
        [attachedToDom()]: [
            'toolbar-button-events',
            commonButtonDisplayEvent
        ],
        [detachedFromDom()]: ['toolbar-button-events', 'dropdown-events', 'tooltipping'],
        [mousedown()]: [
            'focusing',
            'alloy.base.behaviour',
            commonButtonDisplayEvent
        ]
    };

    const forceInitialSize = (comp) => set$7(comp.element, 'width', get$e(comp.element, 'width'));

    const renderIcon$1 = (iconName, iconsProvider, behaviours) => render$4(iconName, {
        tag: 'span',
        classes: ["tox-icon" /* ToolbarButtonClasses.Icon */, "tox-tbtn__icon-wrap" /* ToolbarButtonClasses.IconWrap */],
        behaviours
    }, iconsProvider);
    const renderIconFromPack$1 = (iconName, iconsProvider) => renderIcon$1(iconName, iconsProvider, []);
    const renderReplaceableIconFromPack = (iconName, iconsProvider) => renderIcon$1(iconName, iconsProvider, [Replacing.config({})]);
    const renderLabel$1 = (text, prefix, providersBackstage) => ({
        dom: {
            tag: 'span',
            classes: [`${prefix}__select-label`]
        },
        components: [
            text$2(providersBackstage.translate(text))
        ],
        behaviours: derive$1([
            Replacing.config({})
        ])
    });

    const updateMenuText = generate$6('update-menu-text');
    const updateMenuIcon = generate$6('update-menu-icon');
    const updateTooltiptext = generate$6('update-tooltip-text');
    // TODO: Use renderCommonStructure here.
    const renderCommonDropdown = (spec, prefix, sharedBackstage, btnName) => {
        const editorOffCell = Cell(noop);
        const tooltip = Cell(spec.tooltip);
        // We need mementos for display text and display icon because on the events
        // updateMenuText and updateMenuIcon respectively, their contents are changed
        // via Replacing. These events are generally emitted by dropdowns that want the
        // main text and icon to match the current selection (e.g. bespokes like font family)
        const optMemDisplayText = spec.text.map((text) => record(renderLabel$1(text, prefix, sharedBackstage.providers)));
        const optMemDisplayIcon = spec.icon.map((iconName) => record(renderReplaceableIconFromPack(iconName, sharedBackstage.providers.icons)));
        /*
         * The desired behaviour here is:
         *
         *   when left or right is pressed, and it isn't associated with expanding or
         *   collapsing a submenu, then it should navigate to the next menu item, and
         *   expand it (without highlighting any items in the expanded menu).
         *   It also needs to close the previous menu
         */
        const onLeftOrRightInMenu = (comp, se) => {
            // The originating dropdown is stored on the sandbox itself. This is just an
            // implementation detail of alloy. We really need to make it a fully-fledged API.
            // TODO: TINY-9014 Make SandboxAPI have a function that just delegates to Representing
            const dropdown = Representing.getValue(comp);
            // Focus the dropdown. Current workaround required to make FlowLayout recognise the current focus.
            // The triggering keydown is going to try to move the focus left or
            // right of the current menu, so it needs to know what the current menu dropdown is. It
            // can't work it out by the current focus, because the current focus is *in* the menu, so
            // we help it by moving the focus to the button, so it can work out what the next menu to
            // the left or right is.
            Focusing.focus(dropdown);
            emitWith(dropdown, 'keydown', {
                raw: se.event.raw
            });
            // Because we have just navigated off this open menu, we want to close it.
            // INVESTIGATE: TINY-9014: Is this handling situations where there were no menus
            // to move to? Does it matter if we still close it when there are no other menus?
            Dropdown.close(dropdown);
            // The Optional.some(true) tells the keyboard handler that this event was handled,
            // which will do things like stopPropagation and preventDefault.
            return Optional.some(true);
        };
        const role = spec.role.fold(() => ({}), (role) => ({ role }));
        const listRole = Optional.from(spec.listRole).map((listRole) => ({ listRole })).getOr({});
        const ariaLabelAttribute = spec.ariaLabel.fold(() => ({}), (ariaLabel) => {
            const translatedAriaLabel = sharedBackstage.providers.translate(ariaLabel);
            return {
                'aria-label': translatedAriaLabel
            };
        });
        const iconSpec = render$4('chevron-down', {
            tag: 'div',
            classes: [`${prefix}__select-chevron`]
        }, sharedBackstage.providers.icons);
        const fixWidthBehaviourName = generate$6('common-button-display-events');
        // Should we use Id.generate here?
        const customEventsName = 'dropdown-events';
        const memDropdown = record(Dropdown.sketch({
            ...spec.uid ? { uid: spec.uid } : {},
            ...role,
            ...listRole,
            dom: {
                tag: 'button',
                classes: [prefix, `${prefix}--select`].concat(map$2(spec.classes, (c) => `${prefix}--${c}`)),
                attributes: {
                    ...ariaLabelAttribute,
                    ...(isNonNullable(btnName) ? { 'data-mce-name': btnName } : {})
                }
            },
            components: componentRenderPipeline([
                optMemDisplayIcon.map((mem) => mem.asSpec()),
                optMemDisplayText.map((mem) => mem.asSpec()),
                Optional.some(iconSpec)
            ]),
            matchWidth: true,
            useMinWidth: true,
            // When the dropdown opens, if we are in search mode, then we want to
            // focus our searcher.
            onOpen: (anchor, dropdownComp, tmenuComp) => {
                if (spec.searchable) {
                    focusSearchField(tmenuComp);
                }
            },
            dropdownBehaviours: derive$1([
                ...spec.dropdownBehaviours,
                DisablingConfigs.button(() => spec.disabled || sharedBackstage.providers.checkUiComponentContext(spec.context).shouldDisable),
                toggleOnReceive(() => sharedBackstage.providers.checkUiComponentContext(spec.context)),
                // INVESTIGATE (TINY-9012): There was a old comment here about something not quite working, and that
                // we can still get the button focused. It was probably related to Unselecting.
                Unselecting.config({}),
                Replacing.config({}),
                ...(spec.tooltip.map((t) => Tooltipping.config(sharedBackstage.providers.tooltips.getConfig({
                    tooltipText: sharedBackstage.providers.translate(t),
                    onShow: (comp) => {
                        if (lift2(tooltip.get(), spec.tooltip, (tooltipStr, tt) => tt !== tooltipStr).getOr(false)) {
                            const translatedTooltip = sharedBackstage.providers.translate(tooltip.get().getOr(''));
                            Tooltipping.setComponents(comp, sharedBackstage.providers.tooltips.getComponents({ tooltipText: translatedTooltip }));
                        }
                    }
                })))).toArray(),
                // This is the generic way to make onSetup and onDestroy call as the component is attached /
                // detached from the page/DOM.
                config(customEventsName, [
                    onControlAttached(spec, editorOffCell),
                    onControlDetached(spec, editorOffCell)
                ]),
                config(fixWidthBehaviourName, [
                    runOnAttached((comp, _se) => {
                        if (spec.listRole !== 'listbox') {
                            forceInitialSize(comp);
                        }
                    }),
                ]),
                config('update-dropdown-width-variable', [
                    run$1(windowResize(), (comp, _se) => Dropdown.close(comp)),
                ]),
                config('menubutton-update-display-text', [
                    // These handlers are just using Replacing to replace either the menu
                    // text or the icon.
                    run$1(updateMenuText, (comp, se) => {
                        optMemDisplayText.bind((mem) => mem.getOpt(comp)).each((displayText) => {
                            Replacing.set(displayText, [text$2(sharedBackstage.providers.translate(se.event.text))]);
                        });
                    }),
                    run$1(updateMenuIcon, (comp, se) => {
                        optMemDisplayIcon.bind((mem) => mem.getOpt(comp)).each((displayIcon) => {
                            Replacing.set(displayIcon, [
                                renderReplaceableIconFromPack(se.event.icon, sharedBackstage.providers.icons)
                            ]);
                        });
                    }),
                    run$1(updateTooltiptext, (comp, se) => {
                        const translatedTooltip = sharedBackstage.providers.translate(se.event.text);
                        set$9(comp.element, 'aria-label', translatedTooltip);
                        tooltip.set(Optional.some(se.event.text));
                    })
                ])
            ]),
            eventOrder: deepMerge(toolbarButtonEventOrder, {
                // INVESTIGATE (TINY-9014): Explain why we need the events in this order.
                // Ideally, have a test that fails when they are in a different order if order
                // is important
                [mousedown()]: ['focusing', 'alloy.base.behaviour', 'item-type-events', 'normal-dropdown-events'],
                [attachedToDom()]: [
                    'toolbar-button-events',
                    Tooltipping.name(),
                    customEventsName,
                    fixWidthBehaviourName,
                ]
            }),
            sandboxBehaviours: derive$1([
                Keying.config({
                    mode: 'special',
                    onLeft: onLeftOrRightInMenu,
                    onRight: onLeftOrRightInMenu
                }),
                config('dropdown-sandbox-events', [
                    run$1(refetchTriggerEvent, (originalSandboxComp, se) => {
                        handleRefetchTrigger(originalSandboxComp);
                        // It's a custom event that no-one else should be listening to, so stop it.
                        se.stop();
                    }),
                    run$1(redirectMenuItemInteractionEvent, (sandboxComp, se) => {
                        handleRedirectToMenuItem(sandboxComp, se);
                        // It's a custom event that no-one else should be listening to, so stop it.
                        se.stop();
                    })
                ])
            ]),
            lazySink: sharedBackstage.getSink,
            toggleClass: `${prefix}--active`,
            parts: {
                menu: {
                    ...part(false, spec.columns, spec.presets),
                    // When the menu is "searchable", use fakeFocus so that keyboard
                    // focus stays in the search field
                    fakeFocus: spec.searchable,
                    // We don't want to update the  `aria-selected` on highlight or dehighlight for the `listbox` role because that is used to indicate the selected item
                    ...(spec.listRole === 'listbox' ? {} : {
                        onHighlightItem: updateAriaOnHighlight,
                        onCollapseMenu: (tmenuComp, itemCompCausingCollapse, nowActiveMenuComp) => {
                            // We want to update ARIA on collapsing as well, because it isn't changing
                            // the highlights. So what we need to do is get the right parameters to
                            // pass to updateAriaOnHighlight
                            Highlighting.getHighlighted(nowActiveMenuComp).each((itemComp) => {
                                updateAriaOnHighlight(tmenuComp, nowActiveMenuComp, itemComp);
                            });
                        },
                        onDehighlightItem: updateAriaOnDehighlight
                    })
                }
            },
            getAnchorOverrides: () => {
                return {
                    maxHeightFunction: (element, available) => {
                        anchored()(element, available - 10);
                    },
                };
            },
            fetch: (comp) => Future.nu(curry(spec.fetch, comp))
        }));
        return memDropdown.asSpec();
    };

    const isMenuItemReference = (item) => isString(item);
    const isSeparator$2 = (item) => item.type === 'separator';
    const isExpandingMenuItem = (item) => has$2(item, 'getSubmenuItems');
    const separator$2 = {
        type: 'separator'
    };
    const unwrapReferences = (items, menuItems) => {
        // Unwrap any string based menu item references
        const realItems = foldl(items, (acc, item) => {
            if (isMenuItemReference(item)) {
                if (item === '') {
                    return acc;
                }
                else if (item === '|') {
                    // Ignore the separator if it's at the start or a duplicate
                    return acc.length > 0 && !isSeparator$2(acc[acc.length - 1]) ? acc.concat([separator$2]) : acc;
                }
                else if (has$2(menuItems, item.toLowerCase())) {
                    return acc.concat([menuItems[item.toLowerCase()]]);
                }
                else {
                    // TODO: Add back after TINY-3232 is implemented
                    // console.error('No representation for menuItem: ' + item);
                    return acc;
                }
            }
            else {
                return acc.concat([item]);
            }
        }, []);
        // Remove any trailing separators
        if (realItems.length > 0 && isSeparator$2(realItems[realItems.length - 1])) {
            realItems.pop();
        }
        return realItems;
    };
    const getFromExpandingItem = (item, menuItems) => {
        const submenuItems = item.getSubmenuItems();
        const rest = expand(submenuItems, menuItems);
        const newMenus = deepMerge(rest.menus, { [item.value]: rest.items });
        const newExpansions = deepMerge(rest.expansions, { [item.value]: item.value });
        return {
            item,
            menus: newMenus,
            expansions: newExpansions
        };
    };
    const generateValueIfRequired = (item) => {
        // Use the value already in item if it has one.
        const itemValue = get$h(item, 'value').getOrThunk(() => generate$6('generated-menu-item'));
        return deepMerge({ value: itemValue }, item);
    };
    // Takes items, and consolidates them into its return value
    const expand = (items, menuItems) => {
        // Fistly, we do all substitution using the registry for any items referenced by their
        // string key.
        const realItems = unwrapReferences(isString(items) ? items.split(' ') : items, menuItems);
        // Now that we have complete bridge Item specs for all items, we need to collect the
        // submenus, items in the primary menu, and triggering menu items all into one
        // giant object to from the building blocks on our TieredData
        return foldr(realItems, (acc, item) => {
            if (isExpandingMenuItem(item)) {
                // We generate a random value for item, but only if there isn't an existing value
                const itemWithValue = generateValueIfRequired(item);
                // The newData isn't quite in the format you might expect. The list of items
                // for an item with nested items is just the single parent item. All of the nested
                // items becomes part of '.menus'. Finally, the expansions is just a map from
                // the triggering item to the first submenu. Incidentally, they are given the same
                // value (triggering item and submenu), for convenience.
                const newData = getFromExpandingItem(itemWithValue, menuItems);
                return {
                    // Combine all of our current submenus and items with the new submenus created by
                    // this item with nested subitems
                    menus: deepMerge(acc.menus, newData.menus),
                    // Add our parent item into the list of items in the *current menu*.
                    items: [newData.item, ...acc.items],
                    // Merge together our "this item opens this submenu" objects
                    expansions: deepMerge(acc.expansions, newData.expansions)
                };
            }
            else {
                // If we aren't creating any submenus, then all we need to do is add this item
                // to the list of items in the current menu. So this is the same as an expanding
                // menu item, except it doesn't add to `menus` or `expansions`.
                return {
                    ...acc,
                    items: [item, ...acc.items]
                };
            }
        }, {
            menus: {},
            expansions: {},
            items: []
        });
    };

    const getSearchModeForField = (settings) => {
        return settings.search.fold(() => ({ searchMode: 'no-search' }), (searchSettings) => ({
            searchMode: 'search-with-field',
            placeholder: searchSettings.placeholder
        }));
    };
    const getSearchModeForResults = (settings) => {
        return settings.search.fold(() => ({ searchMode: 'no-search' }), (_) => ({ searchMode: 'search-with-results' }));
    };
    const build = (items, itemResponse, backstage, settings) => {
        const primary = generate$6('primary-menu');
        // The expand process identifies all the items, submenus, and triggering items
        // defined by the list of items. It substitutes the strings using the values registered
        // in the menuItem registry where necessary. It is the building blocks of TieredData,
        // but everything is still just in the bridge item format ... nothing has been turned
        // into AlloySpecs.
        const data = expand(items, backstage.shared.providers.menuItems());
        if (data.items.length === 0) {
            return Optional.none();
        }
        // Only the main menu has a searchable widget (if it is enabled)
        const mainMenuSearchMode = getSearchModeForField(settings);
        const mainMenu = createPartialMenu(primary, data.items, itemResponse, backstage, settings.isHorizontalMenu, mainMenuSearchMode);
        // The submenus do not have the search field, but will have search results for
        // connecting to the search field via aria-controls
        const submenuSearchMode = getSearchModeForResults(settings);
        const submenus = map$1(data.menus, (menuItems, menuName) => createPartialMenu(menuName, menuItems, itemResponse, backstage, 
        // Currently, submenus cannot be horizontal menus (so always false)
        false, submenuSearchMode));
        const menus = deepMerge(submenus, wrap(primary, mainMenu));
        return Optional.from(tieredMenu.tieredData(primary, menus, data.expansions));
    };

    const isSingleListItem = (item) => !has$2(item, 'items');
    const dataAttribute = 'data-value';
    const fetchItems = (dropdownComp, name, items, selectedValue, hasNestedItems) => map$2(items, (item) => {
        if (!isSingleListItem(item)) {
            return {
                type: 'nestedmenuitem',
                text: item.text,
                getSubmenuItems: () => fetchItems(dropdownComp, name, item.items, selectedValue, hasNestedItems)
            };
        }
        else {
            return {
                type: 'togglemenuitem',
                ...(hasNestedItems ? {} : { role: 'option' }),
                text: item.text,
                value: item.value,
                active: item.value === selectedValue,
                onAction: () => {
                    Representing.setValue(dropdownComp, item.value);
                    emitWith(dropdownComp, formChangeEvent, { name });
                    Focusing.focus(dropdownComp);
                }
            };
        }
    });
    const findItemByValue = (items, value) => findMap(items, (item) => {
        if (!isSingleListItem(item)) {
            return findItemByValue(item.items, value);
        }
        else {
            return someIf(item.value === value, item);
        }
    });
    const renderListBox = (spec, backstage, initialData) => {
        const hasNestedItems = exists(spec.items, (item) => !isSingleListItem(item));
        const providersBackstage = backstage.shared.providers;
        const initialItem = initialData
            .bind((value) => findItemByValue(spec.items, value))
            .orThunk(() => head(spec.items).filter(isSingleListItem));
        const pLabel = spec.label.map((label) => renderLabel$3(label, providersBackstage));
        const pField = FormField.parts.field({
            dom: {},
            factory: {
                sketch: (sketchSpec) => renderCommonDropdown({
                    context: spec.context,
                    uid: sketchSpec.uid,
                    text: initialItem.map((item) => item.text),
                    icon: Optional.none(),
                    tooltip: Optional.none(),
                    role: someIf(!hasNestedItems, 'combobox'),
                    ...(hasNestedItems ? {} : { listRole: 'listbox' }),
                    ariaLabel: spec.label,
                    fetch: (comp, callback) => {
                        const items = fetchItems(comp, spec.name, spec.items, Representing.getValue(comp), hasNestedItems);
                        callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
                            isHorizontalMenu: false,
                            search: Optional.none()
                        }));
                    },
                    onSetup: constant$1(noop),
                    getApi: constant$1({}),
                    columns: 1,
                    presets: 'normal',
                    classes: [],
                    dropdownBehaviours: [
                        Tabstopping.config({}),
                        withComp(initialItem.map((item) => item.value), (comp) => get$g(comp.element, dataAttribute), (comp, data) => {
                            // We only want to update the saved value if the value set is a valid property
                            findItemByValue(spec.items, data)
                                .each((item) => {
                                set$9(comp.element, dataAttribute, item.value);
                                emitWith(comp, updateMenuText, { text: item.text });
                            });
                        })
                    ]
                }, 'tox-listbox', backstage.shared)
            }
        });
        const listBoxWrap = {
            dom: {
                tag: 'div',
                classes: ['tox-listboxfield']
            },
            components: [pField]
        };
        return FormField.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-form__group']
            },
            components: flatten([pLabel.toArray(), [listBoxWrap]]),
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: () => !spec.enabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable,
                    onDisabled: (comp) => {
                        FormField.getField(comp).each(Disabling.disable);
                    },
                    onEnabled: (comp) => {
                        FormField.getField(comp).each(Disabling.enable);
                    }
                })
            ])
        });
    };

    const renderPanel = (spec, backstage) => ({
        dom: {
            tag: 'div',
            classes: spec.classes
        },
        // All of the items passed through the form need to be put through the interpreter
        // with their form part preserved.
        components: map$2(spec.items, backstage.shared.interpreter)
    });

    const renderSelectBox = (spec, providersBackstage, initialData) => {
        const translatedOptions = map$2(spec.items, (item) => ({
            text: providersBackstage.translate(item.text),
            value: item.value
        }));
        // DUPE with TextField.
        const pLabel = spec.label.map((label) => renderLabel$3(label, providersBackstage));
        const pField = FormField.parts.field({
            // TODO: Alloy should not allow dom changing of an HTML select!
            dom: {},
            ...initialData.map((data) => ({ data })).getOr({}),
            selectAttributes: {
                size: spec.size
            },
            options: translatedOptions,
            factory: HtmlSelect,
            selectBehaviours: derive$1([
                Disabling.config({
                    disabled: () => !spec.enabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable
                }),
                Tabstopping.config({}),
                config('selectbox-change', [
                    run$1(change(), (component, _) => {
                        emitWith(component, formChangeEvent, { name: spec.name });
                    })
                ])
            ])
        });
        const chevron = spec.size > 1 ? Optional.none() :
            Optional.some(render$4('chevron-down', { tag: 'div', classes: ['tox-selectfield__icon-js'] }, providersBackstage.icons));
        const selectWrap = {
            dom: {
                tag: 'div',
                classes: ['tox-selectfield']
            },
            components: flatten([[pField], chevron.toArray()])
        };
        return FormField.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-form__group']
            },
            components: flatten([pLabel.toArray(), [selectWrap]]),
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: () => !spec.enabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable,
                    onDisabled: (comp) => {
                        FormField.getField(comp).each(Disabling.disable);
                    },
                    onEnabled: (comp) => {
                        FormField.getField(comp).each(Disabling.enable);
                    }
                }),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context))
            ])
        });
    };

    const formatSize = (size) => {
        const unitDec = {
            '': 0,
            'px': 0,
            'pt': 1,
            'mm': 1,
            'pc': 2,
            'ex': 2,
            'em': 2,
            'ch': 2,
            'rem': 2,
            'cm': 3,
            'in': 4,
            '%': 4
        };
        const maxDecimal = (unit) => unit in unitDec ? unitDec[unit] : 1;
        let numText = size.value.toFixed(maxDecimal(size.unit));
        if (numText.indexOf('.') !== -1) {
            numText = numText.replace(/\.?0*$/, '');
        }
        return numText + size.unit;
    };
    const parseSize = (sizeText) => {
        const numPattern = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/;
        const match = numPattern.exec(sizeText);
        if (match !== null) {
            const value = parseFloat(match[1]);
            const unit = match[2];
            return Result.value({ value, unit });
        }
        else {
            return Result.error(sizeText);
        }
    };
    const convertUnit = (size, unit) => {
        const inInch = {
            '': 96,
            'px': 96,
            'pt': 72,
            'cm': 2.54,
            'pc': 12,
            'mm': 25.4,
            'in': 1
        };
        const supported = (u) => has$2(inInch, u);
        if (size.unit === unit) {
            return Optional.some(size.value);
        }
        else if (supported(size.unit) && supported(unit)) {
            if (inInch[size.unit] === inInch[unit]) {
                return Optional.some(size.value);
            }
            else {
                return Optional.some(size.value / inInch[size.unit] * inInch[unit]);
            }
        }
        else {
            return Optional.none();
        }
    };
    const noSizeConversion = (_input) => Optional.none();
    const ratioSizeConversion = (scale, unit) => (size) => convertUnit(size, unit).map((value) => ({ value: value * scale, unit }));
    const makeRatioConverter = (currentFieldText, otherFieldText) => {
        const cValue = parseSize(currentFieldText).toOptional();
        const oValue = parseSize(otherFieldText).toOptional();
        return lift2(cValue, oValue, (cSize, oSize) => convertUnit(cSize, oSize.unit).map((val) => oSize.value / val).map((r) => ratioSizeConversion(r, oSize.unit)).getOr(noSizeConversion)).getOr(noSizeConversion);
    };

    const renderSizeInput = (spec, providersBackstage) => {
        let converter = noSizeConversion;
        const ratioEvent = generate$6('ratio-event');
        const makeIcon = (iconName) => render$4(iconName, { tag: 'span', classes: ['tox-icon', 'tox-lock-icon__' + iconName] }, providersBackstage.icons);
        const disabled = () => !spec.enabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable;
        const toggleOnReceive$1 = toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context));
        const label = spec.label.getOr('Constrain proportions');
        const translatedLabel = providersBackstage.translate(label);
        const pLock = FormCoupledInputs.parts.lock({
            dom: {
                tag: 'button',
                classes: ['tox-lock', 'tox-button', 'tox-button--naked', 'tox-button--icon'],
                attributes: {
                    'aria-label': translatedLabel,
                    'data-mce-name': label
                }
            },
            components: [
                makeIcon('lock'),
                makeIcon('unlock')
            ],
            buttonBehaviours: derive$1([
                Disabling.config({ disabled }),
                toggleOnReceive$1,
                Tabstopping.config({}),
                Tooltipping.config(providersBackstage.tooltips.getConfig({
                    tooltipText: translatedLabel
                }))
            ])
        });
        const formGroup = (components) => ({
            dom: {
                tag: 'div',
                classes: ['tox-form__group']
            },
            components
        });
        const getFieldPart = (isField1) => FormField.parts.field({
            factory: Input,
            inputClasses: ['tox-textfield'],
            inputBehaviours: derive$1([
                Disabling.config({ disabled }),
                toggleOnReceive$1,
                Tabstopping.config({}),
                config('size-input-events', [
                    run$1(focusin(), (component, _simulatedEvent) => {
                        emitWith(component, ratioEvent, { isField1 });
                    }),
                    run$1(change(), (component, _simulatedEvent) => {
                        emitWith(component, formChangeEvent, { name: spec.name });
                    })
                ])
            ]),
            selectOnFocus: false
        });
        const getLabel = (label) => ({
            dom: {
                tag: 'label',
                classes: ['tox-label']
            },
            components: [
                text$2(providersBackstage.translate(label))
            ]
        });
        const widthField = FormCoupledInputs.parts.field1(formGroup([FormField.parts.label(getLabel('Width')), getFieldPart(true)]));
        const heightField = FormCoupledInputs.parts.field2(formGroup([FormField.parts.label(getLabel('Height')), getFieldPart(false)]));
        return FormCoupledInputs.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-form__group']
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-form__controls-h-stack']
                    },
                    components: [
                        // NOTE: Form coupled inputs to the FormField.sketch themselves.
                        widthField,
                        heightField,
                        formGroup([
                            getLabel(nbsp),
                            pLock
                        ])
                    ]
                }
            ],
            field1Name: 'width',
            field2Name: 'height',
            locked: true,
            markers: {
                lockClass: 'tox-locked'
            },
            onLockedChange: (current, other, _lock) => {
                parseSize(Representing.getValue(current)).each((size) => {
                    converter(size).each((newSize) => {
                        Representing.setValue(other, formatSize(newSize));
                    });
                });
            },
            coupledFieldBehaviours: derive$1([
                Disabling.config({
                    disabled,
                    onDisabled: (comp) => {
                        FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.disable);
                        FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.disable);
                        FormCoupledInputs.getLock(comp).each(Disabling.disable);
                    },
                    onEnabled: (comp) => {
                        FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.enable);
                        FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.enable);
                        FormCoupledInputs.getLock(comp).each(Disabling.enable);
                    }
                }),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext('mode:design')),
                config('size-input-events2', [
                    run$1(ratioEvent, (component, simulatedEvent) => {
                        const isField1 = simulatedEvent.event.isField1;
                        const optCurrent = isField1 ? FormCoupledInputs.getField1(component) : FormCoupledInputs.getField2(component);
                        const optOther = isField1 ? FormCoupledInputs.getField2(component) : FormCoupledInputs.getField1(component);
                        const value1 = optCurrent.map(Representing.getValue).getOr('');
                        const value2 = optOther.map(Representing.getValue).getOr('');
                        converter = makeRatioConverter(value1, value2);
                    })
                ])
            ])
        });
    };

    const renderSlider = (spec, providerBackstage, initialData) => {
        const labelPart = Slider.parts.label({
            dom: {
                tag: 'label',
                classes: ['tox-label']
            },
            components: [
                text$2(providerBackstage.translate(spec.label))
            ]
        });
        const spectrum = Slider.parts.spectrum({
            dom: {
                tag: 'div',
                classes: ['tox-slider__rail'],
                attributes: {
                    role: 'presentation'
                }
            }
        });
        const thumb = Slider.parts.thumb({
            dom: {
                tag: 'div',
                classes: ['tox-slider__handle'],
                attributes: {
                    role: 'presentation'
                }
            }
        });
        return Slider.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-slider'],
                attributes: {
                    role: 'presentation'
                }
            },
            model: {
                mode: 'x',
                minX: spec.min,
                maxX: spec.max,
                getInitialValue: constant$1(initialData.getOrThunk(() => (Math.abs(spec.max) - Math.abs(spec.min)) / 2))
            },
            components: [
                labelPart,
                spectrum,
                thumb
            ],
            sliderBehaviours: derive$1([
                ComposingConfigs.self(),
                Focusing.config({})
            ]),
            onChoose: (component, thumb, value) => {
                emitWith(component, formChangeEvent, { name: spec.name, value });
            },
            onChange: (component, thumb, value) => {
                emitWith(component, formChangeEvent, { name: spec.name, value });
            },
        });
    };

    const renderTable = (spec, providersBackstage) => {
        const renderTh = (text) => ({
            dom: {
                tag: 'th',
                innerHtml: providersBackstage.translate(text)
            }
        });
        const renderHeader = (header) => ({
            dom: {
                tag: 'thead'
            },
            components: [
                {
                    dom: {
                        tag: 'tr'
                    },
                    components: map$2(header, renderTh)
                }
            ]
        });
        const renderTd = (text) => ({ dom: { tag: 'td', innerHtml: providersBackstage.translate(text) } });
        const renderTr = (row) => ({ dom: { tag: 'tr' }, components: map$2(row, renderTd) });
        const renderRows = (rows) => ({ dom: { tag: 'tbody' }, components: map$2(rows, renderTr) });
        return {
            dom: {
                tag: 'table',
                classes: ['tox-dialog__table']
            },
            components: [
                renderHeader(spec.header),
                renderRows(spec.cells)
            ],
            behaviours: derive$1([
                Tabstopping.config({}),
                Focusing.config({})
            ])
        };
    };

    const renderTextField = (spec, providersBackstage) => {
        const pLabel = spec.label.map((label) => renderLabel$3(label, providersBackstage));
        const baseInputBehaviours = [
            Disabling.config({
                disabled: () => spec.disabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable
            }),
            toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context)),
            Keying.config({
                mode: 'execution',
                useEnter: spec.multiline !== true,
                useControlEnter: spec.multiline === true,
                execute: (comp) => {
                    emit(comp, formSubmitEvent);
                    return Optional.some(true);
                }
            }),
            config('textfield-change', [
                run$1(input(), (component, _) => {
                    emitWith(component, formChangeEvent, { name: spec.name });
                }),
                run$1(postPaste(), (component, _) => {
                    emitWith(component, formChangeEvent, { name: spec.name });
                })
            ]),
            Tabstopping.config({})
        ];
        const validatingBehaviours = spec.validation.map((vl) => Invalidating.config({
            getRoot: (input) => {
                return parentElement(input.element);
            },
            invalidClass: 'tox-invalid',
            validator: {
                validate: (input) => {
                    const v = Representing.getValue(input);
                    const result = vl.validator(v);
                    return Future.pure(result === true ? Result.value(v) : Result.error(result));
                },
                validateOnLoad: vl.validateOnLoad
            }
        })).toArray();
        const placeholder = spec.placeholder.fold(constant$1({}), (p) => ({ placeholder: providersBackstage.translate(p) }));
        const inputMode = spec.inputMode.fold(constant$1({}), (mode) => ({ inputmode: mode }));
        const spellcheck = spec.spellcheck.fold(constant$1({}), (spellchecker) => ({ spellcheck: spellchecker }));
        const inputAttributes = {
            ...spellcheck,
            ...placeholder,
            ...inputMode,
            'data-mce-name': spec.name
        };
        const pField = FormField.parts.field({
            tag: spec.multiline === true ? 'textarea' : 'input',
            ...spec.data.map((data) => ({ data })).getOr({}),
            inputAttributes,
            inputClasses: [spec.classname],
            inputBehaviours: derive$1(flatten([
                baseInputBehaviours,
                validatingBehaviours
            ])),
            selectOnFocus: false,
            factory: Input
        });
        // TINY-9331: This wrapper is needed to avoid border-radius rendering issues when the textarea has a scrollbar
        const pTextField = spec.multiline ? {
            dom: {
                tag: 'div',
                classes: ['tox-textarea-wrap']
            },
            components: [pField]
        } : pField;
        const extraClasses = spec.flex ? ['tox-form__group--stretched'] : [];
        const extraClasses2 = extraClasses.concat(spec.maximized ? ['tox-form-group--maximize'] : []);
        const extraBehaviours = [
            Disabling.config({
                disabled: () => spec.disabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable,
                onDisabled: (comp) => {
                    FormField.getField(comp).each(Disabling.disable);
                },
                onEnabled: (comp) => {
                    FormField.getField(comp).each(Disabling.enable);
                }
            }),
            toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context)),
        ];
        return renderFormFieldWith(pLabel, pTextField, extraClasses2, extraBehaviours);
    };
    const renderInput = (spec, providersBackstage, initialData) => renderTextField({
        name: spec.name,
        multiline: false,
        label: spec.label,
        inputMode: spec.inputMode,
        placeholder: spec.placeholder,
        flex: false,
        disabled: !spec.enabled,
        classname: 'tox-textfield',
        validation: Optional.none(),
        maximized: spec.maximized,
        data: initialData,
        context: spec.context,
        spellcheck: Optional.none(),
    }, providersBackstage);
    const renderTextarea = (spec, providersBackstage, initialData) => renderTextField({
        name: spec.name,
        multiline: true,
        label: spec.label,
        inputMode: Optional.none(), // type attribute is not valid for textareas
        placeholder: spec.placeholder,
        flex: true,
        disabled: !spec.enabled,
        classname: 'tox-textarea',
        validation: Optional.none(),
        maximized: spec.maximized,
        data: initialData,
        context: spec.context,
        spellcheck: spec.spellcheck,
    }, providersBackstage);

    const getMenuButtonApi = (component) => ({
        isEnabled: () => !Disabling.isDisabled(component),
        setEnabled: (state) => Disabling.set(component, !state),
        setActive: (state) => {
            // Note: We can't use the toggling behaviour here, as the dropdown for the menu also relies on it.
            // As such, we'll need to do this manually
            const elm = component.element;
            if (state) {
                add$2(elm, "tox-tbtn--enabled" /* ToolbarButtonClasses.Ticked */);
                set$9(elm, 'aria-pressed', true);
            }
            else {
                remove$3(elm, "tox-tbtn--enabled" /* ToolbarButtonClasses.Ticked */);
                remove$8(elm, 'aria-pressed');
            }
        },
        isActive: () => has(component.element, "tox-tbtn--enabled" /* ToolbarButtonClasses.Ticked */),
        setTooltip: (tooltip) => {
            emitWith(component, updateTooltiptext, {
                text: tooltip
            });
        },
        setText: (text) => {
            emitWith(component, updateMenuText, {
                text
            });
        },
        setIcon: (icon) => emitWith(component, updateMenuIcon, {
            icon
        })
    });
    const renderMenuButton = (spec, prefix, backstage, role, tabstopping = true, btnName) => {
        const classes = spec.buttonType === 'bordered' ? ['bordered'] : [];
        return renderCommonDropdown({
            text: spec.text,
            icon: spec.icon,
            tooltip: spec.tooltip,
            ariaLabel: spec.tooltip,
            searchable: spec.search.isSome(),
            // https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-2/menubar-2.html
            role,
            fetch: (dropdownComp, callback) => {
                const fetchContext = {
                    pattern: spec.search.isSome() ? getSearchPattern(dropdownComp) : ''
                };
                spec.fetch((items) => {
                    callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
                        isHorizontalMenu: false,
                        // MenuButtons are the only dropdowns that support searchable (2022-08-16)
                        search: spec.search
                    }));
                }, fetchContext, getMenuButtonApi(dropdownComp));
            },
            onSetup: spec.onSetup,
            getApi: (comp) => getMenuButtonApi(comp),
            columns: 1,
            presets: 'normal',
            classes,
            dropdownBehaviours: [
                ...(tabstopping ? [Tabstopping.config({})] : []),
            ],
            context: spec.context
        }, prefix, backstage.shared, btnName);
    };
    const getFetch = (items, getButton, backstage) => {
        const getMenuItemAction = (item) => (api) => {
            // Update the menu item state
            const newValue = !api.isActive();
            api.setActive(newValue);
            item.storage.set(newValue);
            // Fire the form action event
            backstage.shared.getSink().each((sink) => {
                getButton().getOpt(sink).each((orig) => {
                    focus$4(orig.element);
                    emitWith(orig, formActionEvent, {
                        name: item.name,
                        value: item.storage.get()
                    });
                });
            });
        };
        const getMenuItemSetup = (item) => (api) => {
            api.setActive(item.storage.get());
        };
        return (success) => {
            success(map$2(items, (item) => {
                const text = item.text.fold(() => ({}), (text) => ({
                    text
                }));
                return {
                    type: item.type,
                    active: false,
                    ...text,
                    context: item.context,
                    onAction: getMenuItemAction(item),
                    onSetup: getMenuItemSetup(item)
                };
            }));
        };
    };

    const renderLabel = (text) => ({
        dom: {
            tag: 'span',
            classes: ['tox-tree__label'],
            attributes: {
                'aria-label': text,
            }
        },
        components: [
            text$2(text)
        ],
    });
    const renderCustomStateIcon = (container, components, backstage) => {
        container.customStateIcon.each((icon) => components.push(renderIcon(icon, backstage.shared.providers.icons, container.customStateIconTooltip.fold(() => [], (tooltip) => [
            Tooltipping.config(backstage.shared.providers.tooltips.getConfig({
                tooltipText: tooltip
            }))
        ]), ['tox-icon-custom-state'])));
    };
    const leafLabelEventsId = generate$6('leaf-label-event-id');
    const renderLeafLabel = ({ leaf, onLeafAction, visible, treeId, selectedId, backstage }) => {
        const internalMenuButton = leaf.menu.map((btn) => renderMenuButton(btn, 'tox-mbtn', backstage, Optional.none(), visible));
        const components = [renderLabel(leaf.title)];
        renderCustomStateIcon(leaf, components, backstage);
        internalMenuButton.each((btn) => components.push(btn));
        return Button.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-tree--leaf__label', 'tox-trbtn']
                    .concat(visible ? ['tox-tree--leaf__label--visible'] : []),
            },
            components,
            role: 'treeitem',
            action: (button) => {
                onLeafAction(leaf.id);
                button.getSystem().broadcastOn([`update-active-item-${treeId}`], {
                    value: leaf.id
                });
            },
            eventOrder: {
                [keydown()]: [
                    leafLabelEventsId,
                    'keying',
                ]
            },
            buttonBehaviours: derive$1([
                ...(visible ? [Tabstopping.config({})] : []),
                Toggling.config({
                    toggleClass: 'tox-trbtn--enabled',
                    toggleOnExecute: false,
                    aria: {
                        mode: 'selected'
                    }
                }),
                Receiving.config({
                    channels: {
                        [`update-active-item-${treeId}`]: {
                            onReceive: (comp, message) => {
                                (message.value === leaf.id ? Toggling.on : Toggling.off)(comp);
                            }
                        }
                    }
                }),
                config(leafLabelEventsId, [
                    runOnAttached((comp, _se) => {
                        selectedId.each((id) => {
                            const toggle = id === leaf.id ? Toggling.on : Toggling.off;
                            toggle(comp);
                        });
                    }),
                    run$1(keydown(), (comp, se) => {
                        const isLeftArrowKey = se.event.raw.code === 'ArrowLeft';
                        const isRightArrowKey = se.event.raw.code === 'ArrowRight';
                        if (isLeftArrowKey) {
                            ancestor$1(comp.element, '.tox-tree--directory').each((dirElement) => {
                                comp.getSystem().getByDom(dirElement).each((dirComp) => {
                                    child(dirElement, '.tox-tree--directory__label').each((dirLabelElement) => {
                                        dirComp.getSystem().getByDom(dirLabelElement).each(Focusing.focus);
                                    });
                                });
                            });
                            se.stop();
                        }
                        else if (isRightArrowKey) {
                            se.stop();
                        }
                    })
                ])
            ]),
        });
    };
    const renderIcon = (iconName, iconsProvider, behaviours, extraClasses, extraAttributes) => render$4(iconName, {
        tag: 'span',
        classes: [
            'tox-tree__icon-wrap',
            'tox-icon',
        ].concat(extraClasses || []),
        behaviours,
        attributes: extraAttributes
    }, iconsProvider);
    const renderIconFromPack = (iconName, iconsProvider) => renderIcon(iconName, iconsProvider, []);
    const directoryLabelEventsId = generate$6('directory-label-event-id');
    const renderDirectoryLabel = ({ directory, visible, noChildren, backstage }) => {
        const internalMenuButton = directory.menu.map((btn) => renderMenuButton(btn, 'tox-mbtn', backstage, Optional.none()));
        const components = [
            {
                dom: {
                    tag: 'div',
                    classes: ['tox-chevron'],
                },
                components: [
                    renderIconFromPack('chevron-right', backstage.shared.providers.icons),
                ]
            },
            renderLabel(directory.title)
        ];
        renderCustomStateIcon(directory, components, backstage);
        internalMenuButton.each((btn) => {
            components.push(btn);
        });
        const toggleExpandChildren = (button) => {
            ancestor$1(button.element, '.tox-tree--directory').each((directoryEle) => {
                button.getSystem().getByDom(directoryEle).each((directoryComp) => {
                    const willExpand = !Toggling.isOn(directoryComp);
                    Toggling.toggle(directoryComp);
                    emitWith(button, 'expand-tree-node', { expanded: willExpand, node: directory.id });
                });
            });
        };
        return Button.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-tree--directory__label', 'tox-trbtn'].concat(visible ? ['tox-tree--directory__label--visible'] : []),
            },
            components,
            action: toggleExpandChildren,
            eventOrder: {
                [keydown()]: [
                    directoryLabelEventsId,
                    'keying',
                ]
            },
            buttonBehaviours: derive$1([
                ...(visible ? [Tabstopping.config({})] : []),
                config(directoryLabelEventsId, [
                    run$1(keydown(), (comp, se) => {
                        const isRightArrowKey = se.event.raw.code === 'ArrowRight';
                        const isLeftArrowKey = se.event.raw.code === 'ArrowLeft';
                        if (isRightArrowKey && noChildren) {
                            se.stop();
                        }
                        if (isRightArrowKey || isLeftArrowKey) {
                            ancestor$1(comp.element, '.tox-tree--directory').each((directoryEle) => {
                                comp.getSystem().getByDom(directoryEle).each((directoryComp) => {
                                    if (!Toggling.isOn(directoryComp) && isRightArrowKey || Toggling.isOn(directoryComp) && isLeftArrowKey) {
                                        toggleExpandChildren(comp);
                                        se.stop();
                                    }
                                    else if (isLeftArrowKey && !Toggling.isOn(directoryComp)) {
                                        ancestor$1(directoryComp.element, '.tox-tree--directory').each((parentDirElement) => {
                                            child(parentDirElement, '.tox-tree--directory__label').each((parentDirLabelElement) => {
                                                directoryComp.getSystem().getByDom(parentDirLabelElement).each(Focusing.focus);
                                            });
                                        });
                                        se.stop();
                                    }
                                });
                            });
                        }
                    })
                ])
            ])
        });
    };
    const renderDirectoryChildren = ({ children, onLeafAction, visible, treeId, expandedIds, selectedId, backstage }) => {
        return {
            dom: {
                tag: 'div',
                classes: ['tox-tree--directory__children'],
            },
            components: children.map((item) => {
                return item.type === 'leaf' ?
                    renderLeafLabel({ leaf: item, selectedId, onLeafAction, visible, treeId, backstage }) :
                    renderDirectory({ directory: item, expandedIds, selectedId, onLeafAction, labelTabstopping: visible, treeId, backstage });
            }),
            behaviours: derive$1([
                Sliding.config({
                    dimension: {
                        property: 'height'
                    },
                    closedClass: 'tox-tree--directory__children--closed',
                    openClass: 'tox-tree--directory__children--open',
                    growingClass: 'tox-tree--directory__children--growing',
                    shrinkingClass: 'tox-tree--directory__children--shrinking',
                    expanded: visible,
                }),
                Replacing.config({})
            ])
        };
    };
    const directoryEventsId = generate$6('directory-event-id');
    const renderDirectory = ({ directory, onLeafAction, labelTabstopping, treeId, backstage, expandedIds, selectedId }) => {
        const { children } = directory;
        const expandedIdsCell = Cell(expandedIds);
        const computedChildrenComponents = (visible) => children.map((item) => {
            return item.type === 'leaf' ?
                renderLeafLabel({ leaf: item, selectedId, onLeafAction, visible, treeId, backstage }) :
                renderDirectory({ directory: item, expandedIds: expandedIdsCell.get(), selectedId, onLeafAction, labelTabstopping: visible, treeId, backstage });
        });
        const childrenVisible = expandedIds.includes(directory.id);
        return ({
            dom: {
                tag: 'div',
                classes: ['tox-tree--directory'],
                attributes: {
                    role: 'treeitem'
                }
            },
            components: [
                renderDirectoryLabel({ directory, visible: labelTabstopping, noChildren: directory.children.length === 0, backstage }),
                renderDirectoryChildren({ children, expandedIds, selectedId, onLeafAction, visible: childrenVisible, treeId, backstage })
            ],
            behaviours: derive$1([
                config(directoryEventsId, [
                    runOnAttached((comp, _se) => {
                        Toggling.set(comp, childrenVisible);
                    }),
                    run$1('expand-tree-node', (_cmp, se) => {
                        const { expanded, node } = se.event;
                        expandedIdsCell.set(expanded ?
                            [...expandedIdsCell.get(), node] :
                            expandedIdsCell.get().filter((id) => id !== node));
                    }),
                ]),
                Toggling.config({
                    ...(directory.children.length > 0 ? {
                        aria: {
                            mode: 'expanded',
                        },
                    } : {}),
                    toggleClass: 'tox-tree--directory--expanded',
                    onToggled: (comp, childrenVisible) => {
                        const childrenComp = comp.components()[1];
                        const newChildren = computedChildrenComponents(childrenVisible);
                        if (childrenVisible) {
                            Sliding.grow(childrenComp);
                        }
                        else {
                            Sliding.shrink(childrenComp);
                        }
                        Replacing.set(childrenComp, newChildren);
                    },
                }),
            ])
        });
    };
    const treeEventsId = generate$6('tree-event-id');
    const renderTree = (spec, backstage) => {
        const onLeafAction = spec.onLeafAction.getOr(noop);
        const onToggleExpand = spec.onToggleExpand.getOr(noop);
        const defaultExpandedIds = spec.defaultExpandedIds;
        const expandedIds = Cell(defaultExpandedIds);
        const selectedIdCell = Cell(spec.defaultSelectedId);
        const treeId = generate$6('tree-id');
        const children = (selectedId, expandedIds) => spec.items.map((item) => {
            return item.type === 'leaf' ?
                renderLeafLabel({ leaf: item, selectedId, onLeafAction, visible: true, treeId, backstage }) :
                renderDirectory({ directory: item, selectedId, onLeafAction, expandedIds, labelTabstopping: true, treeId, backstage });
        });
        return {
            dom: {
                tag: 'div',
                classes: ['tox-tree'],
                attributes: {
                    role: 'tree'
                }
            },
            components: children(selectedIdCell.get(), expandedIds.get()),
            behaviours: derive$1([
                Keying.config({
                    mode: 'flow',
                    selector: '.tox-tree--leaf__label--visible, .tox-tree--directory__label--visible',
                    cycles: false,
                }),
                config(treeEventsId, [
                    run$1('expand-tree-node', (_cmp, se) => {
                        const { expanded, node } = se.event;
                        expandedIds.set(expanded ?
                            [...expandedIds.get(), node] :
                            expandedIds.get().filter((id) => id !== node));
                        onToggleExpand(expandedIds.get(), { expanded, node });
                    })
                ]),
                Receiving.config({
                    channels: {
                        [`update-active-item-${treeId}`]: {
                            onReceive: (comp, message) => {
                                selectedIdCell.set(Optional.some(message.value));
                                Replacing.set(comp, children(Optional.some(message.value), expandedIds.get()));
                            }
                        }
                    }
                }),
                Replacing.config({})
            ])
        };
    };

    const renderCommonSpec = (spec, actionOpt, extraBehaviours = [], dom, components, tooltip, providersBackstage) => {
        const action = actionOpt.fold(() => ({}), (action) => ({
            action
        }));
        const common = {
            buttonBehaviours: derive$1([
                DisablingConfigs.item(() => !spec.enabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context)),
                Tabstopping.config({}),
                ...tooltip.map((t) => Tooltipping.config(providersBackstage.tooltips.getConfig({
                    tooltipText: providersBackstage.translate(t)
                }))).toArray(),
                config('button press', [
                    preventDefault('click')
                ])
            ].concat(extraBehaviours)),
            eventOrder: {
                click: ['button press', 'alloy.base.behaviour'],
                mousedown: ['button press', 'alloy.base.behaviour']
            },
            ...action
        };
        const domFinal = deepMerge(common, { dom });
        return deepMerge(domFinal, { components });
    };
    // An IconButton just seems to be a button that *cannot* have text, but
    // can have a tooltip. It's only used for the More Drawer button at the moment.
    const renderIconButtonSpec = (spec, action, providersBackstage, extraBehaviours = [], btnName) => {
        const tooltipAttributes = spec.tooltip.map((tooltip) => ({
            'aria-label': providersBackstage.translate(tooltip),
        })).getOr({});
        const dom = {
            tag: 'button',
            classes: ["tox-tbtn" /* ToolbarButtonClasses.Button */],
            attributes: { ...tooltipAttributes, 'data-mce-name': btnName }
        };
        const icon = spec.icon.map((iconName) => renderIconFromPack$1(iconName, providersBackstage.icons));
        const components = componentRenderPipeline([
            icon
        ]);
        return renderCommonSpec(spec, action, extraBehaviours, dom, components, spec.tooltip, providersBackstage);
    };
    const calculateClassesFromButtonType = (buttonType) => {
        switch (buttonType) {
            case 'primary':
                return ['tox-button'];
            case 'toolbar':
                return ['tox-tbtn'];
            case 'secondary':
            default:
                return ['tox-button', 'tox-button--secondary'];
        }
    };
    // Maybe the list of extraBehaviours is better than doing a Merger.deepMerge that
    // we do elsewhere? Not sure.
    const renderButtonSpec = (spec, action, providersBackstage, extraBehaviours = [], extraClasses = []) => {
        // It's a bit confusing that this is called text. It seems to be a tooltip. Although I can see
        // that it's used if there is no icon
        const translatedText = providersBackstage.translate(spec.text);
        const icon = spec.icon.map((iconName) => renderIconFromPack$1(iconName, providersBackstage.icons));
        const components = [icon.getOrThunk(() => text$2(translatedText))];
        // The old default is based on the now-deprecated 'primary' property. `buttonType` takes precedence now.
        const buttonType = spec.buttonType.getOr(!spec.primary && !spec.borderless ? 'secondary' : 'primary');
        const baseClasses = calculateClassesFromButtonType(buttonType);
        const classes = [
            ...baseClasses,
            ...icon.isSome() ? ['tox-button--icon'] : [],
            ...spec.borderless ? ['tox-button--naked'] : [],
            ...extraClasses
        ];
        const dom = {
            tag: 'button',
            classes,
            attributes: {
                'aria-label': translatedText,
                'data-mce-name': spec.text
            }
        };
        // Only provide a tooltip if we are using an icon. This is because above, a button is only an icon
        // or text, and not both.
        const optTooltip = spec.icon.map(constant$1(translatedText));
        return renderCommonSpec(spec, action, extraBehaviours, dom, components, optTooltip, providersBackstage);
    };
    // This actually seems to be a button on the dialog for UrlInput only (browse). Interesting.
    const renderButton$1 = (spec, action, providersBackstage, extraBehaviours = [], extraClasses = []) => {
        const buttonSpec = renderButtonSpec(spec, Optional.some(action), providersBackstage, extraBehaviours, extraClasses);
        return Button.sketch(buttonSpec);
    };
    const getAction = (name, buttonType) => (comp) => {
        if (buttonType === 'custom') {
            emitWith(comp, formActionEvent, {
                name,
                value: {}
            });
        }
        else if (buttonType === 'submit') {
            emit(comp, formSubmitEvent);
        }
        else if (buttonType === 'cancel') {
            emit(comp, formCancelEvent);
        }
        else {
            // eslint-disable-next-line no-console
            console.error('Unknown button type: ', buttonType);
        }
    };
    const isMenuFooterButtonSpec = (spec, buttonType) => buttonType === 'menu';
    const isNormalFooterButtonSpec = (spec, buttonType) => buttonType === 'custom' || buttonType === 'cancel' || buttonType === 'submit';
    const isToggleButtonSpec = (spec, buttonType) => buttonType === 'togglebutton';
    const renderToggleButton = (spec, providers, btnName) => {
        var _a, _b;
        const optMemIcon = spec.icon
            .map((memIcon) => renderReplaceableIconFromPack(memIcon, providers.icons))
            .map(record);
        const action = (comp) => {
            emitWith(comp, formActionEvent, {
                name: spec.name,
                value: {
                    setIcon: (newIcon) => {
                        optMemIcon.map((memIcon) => memIcon.getOpt(comp).each((displayIcon) => {
                            Replacing.set(displayIcon, [
                                renderReplaceableIconFromPack(newIcon, providers.icons)
                            ]);
                        }));
                    }
                }
            });
        };
        // The old default is based on the now-deprecated 'primary' property. `buttonType` takes precedence now.
        const buttonType = spec.buttonType.getOr(!spec.primary ? 'secondary' : 'primary');
        const buttonSpec = {
            ...spec,
            name: (_a = spec.name) !== null && _a !== void 0 ? _a : '',
            primary: buttonType === 'primary',
            tooltip: spec.tooltip,
            enabled: (_b = spec.enabled) !== null && _b !== void 0 ? _b : false,
            borderless: false
        };
        const tooltipAttributes = buttonSpec.tooltip.or(spec.text).map((tooltip) => ({
            'aria-label': providers.translate(tooltip),
        })).getOr({});
        const buttonTypeClasses = calculateClassesFromButtonType(buttonType !== null && buttonType !== void 0 ? buttonType : 'secondary');
        const showIconAndText = spec.icon.isSome() && spec.text.isSome();
        const dom = {
            tag: 'button',
            classes: [
                ...buttonTypeClasses.concat(spec.icon.isSome() ? ['tox-button--icon'] : []),
                ...(spec.active ? ["tox-button--enabled" /* ViewButtonClasses.Ticked */] : []),
                ...(showIconAndText ? ['tox-button--icon-and-text'] : [])
            ],
            attributes: {
                ...tooltipAttributes,
                ...(isNonNullable(btnName) ? { 'data-mce-name': btnName } : {})
            }
        };
        const extraBehaviours = [];
        const translatedText = providers.translate(spec.text.getOr(''));
        const translatedTextComponed = text$2(translatedText);
        const iconComp = componentRenderPipeline([optMemIcon.map((memIcon) => memIcon.asSpec())]);
        const components = [
            ...iconComp,
            ...(spec.text.isSome() ? [translatedTextComponed] : [])
        ];
        const iconButtonSpec = renderCommonSpec(buttonSpec, Optional.some(action), extraBehaviours, dom, components, spec.tooltip, providers);
        return Button.sketch(iconButtonSpec);
    };
    const renderFooterButton = (spec, buttonType, backstage) => {
        if (isMenuFooterButtonSpec(spec, buttonType)) {
            const getButton = () => memButton;
            const menuButtonSpec = spec;
            const fixedSpec = {
                ...spec,
                buttonType: 'default',
                type: 'menubutton',
                // Currently, dialog-based menu buttons cannot be searchable.
                search: Optional.none(),
                onSetup: (api) => {
                    api.setEnabled(spec.enabled);
                    return noop;
                },
                fetch: getFetch(menuButtonSpec.items, getButton, backstage)
            };
            const memButton = record(renderMenuButton(fixedSpec, "tox-tbtn" /* ToolbarButtonClasses.Button */, backstage, Optional.none(), true, spec.text.or(spec.tooltip).getOrUndefined()));
            return memButton.asSpec();
        }
        else if (isNormalFooterButtonSpec(spec, buttonType)) {
            const action = getAction(spec.name, buttonType);
            const buttonSpec = {
                ...spec,
                context: buttonType === 'cancel' ? 'any' : spec.context,
                borderless: false
            };
            return renderButton$1(buttonSpec, action, backstage.shared.providers, []);
        }
        else if (isToggleButtonSpec(spec, buttonType)) {
            return renderToggleButton(spec, backstage.shared.providers, spec.text.or(spec.tooltip).getOrUndefined());
        }
        else {
            // eslint-disable-next-line no-console
            console.error('Unknown footer button type: ', buttonType);
            throw new Error('Unknown footer button type');
        }
    };
    const renderDialogButton = (spec, providersBackstage) => {
        const action = getAction(spec.name, 'custom');
        return renderFormField(Optional.none(), FormField.parts.field({
            factory: Button,
            ...renderButtonSpec(spec, Optional.some(action), providersBackstage, [
                memory(''),
                ComposingConfigs.self()
            ])
        }));
    };

    const separator$1 = {
        type: 'separator'
    };
    const toMenuItem = (target) => ({
        type: 'menuitem',
        value: target.url,
        text: target.title,
        meta: {
            attach: target.attach
        },
        onAction: noop
    });
    const staticMenuItem = (title, url) => ({
        type: 'menuitem',
        value: url,
        text: title,
        meta: {
            attach: undefined
        },
        onAction: noop
    });
    const toMenuItems = (targets) => map$2(targets, toMenuItem);
    const filterLinkTargets = (type, targets) => filter$2(targets, (target) => target.type === type);
    const filteredTargets = (type, targets) => toMenuItems(filterLinkTargets(type, targets));
    const headerTargets = (linkInfo) => filteredTargets('header', linkInfo.targets);
    const anchorTargets = (linkInfo) => filteredTargets('anchor', linkInfo.targets);
    const anchorTargetTop = (linkInfo) => Optional.from(linkInfo.anchorTop).map((url) => staticMenuItem('<top>', url)).toArray();
    const anchorTargetBottom = (linkInfo) => Optional.from(linkInfo.anchorBottom).map((url) => staticMenuItem('<bottom>', url)).toArray();
    const historyTargets = (history) => map$2(history, (url) => staticMenuItem(url, url));
    const joinMenuLists = (items) => {
        return foldl(items, (a, b) => {
            const bothEmpty = a.length === 0 || b.length === 0;
            return bothEmpty ? a.concat(b) : a.concat(separator$1, b);
        }, []);
    };
    const filterByQuery = (term, menuItems) => {
        const lowerCaseTerm = term.toLowerCase();
        return filter$2(menuItems, (item) => {
            var _a;
            const text = item.meta !== undefined && item.meta.text !== undefined ? item.meta.text : item.text;
            const value = (_a = item.value) !== null && _a !== void 0 ? _a : '';
            return contains$1(text.toLowerCase(), lowerCaseTerm) || contains$1(value.toLowerCase(), lowerCaseTerm);
        });
    };

    const getItems = (fileType, input, urlBackstage) => {
        var _a, _b;
        const urlInputValue = Representing.getValue(input);
        const term = (_b = (_a = urlInputValue === null || urlInputValue === void 0 ? void 0 : urlInputValue.meta) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : urlInputValue.value;
        const info = urlBackstage.getLinkInformation();
        return info.fold(() => [], (linkInfo) => {
            const history = filterByQuery(term, historyTargets(urlBackstage.getHistory(fileType)));
            return fileType === 'file' ? joinMenuLists([
                history,
                filterByQuery(term, headerTargets(linkInfo)),
                filterByQuery(term, flatten([
                    anchorTargetTop(linkInfo),
                    anchorTargets(linkInfo),
                    anchorTargetBottom(linkInfo)
                ]))
            ])
                : history;
        });
    };
    const errorId = generate$6('aria-invalid');
    const renderUrlInput = (spec, backstage, urlBackstage, initialData) => {
        const providersBackstage = backstage.shared.providers;
        const updateHistory = (component) => {
            const urlEntry = Representing.getValue(component);
            urlBackstage.addToHistory(urlEntry.value, spec.filetype);
        };
        // TODO: Make alloy's typeahead only swallow enter and escape if menu is open
        const typeaheadSpec = {
            ...initialData.map((initialData) => ({ initialData })).getOr({}),
            dismissOnBlur: true,
            inputClasses: ['tox-textfield'],
            sandboxClasses: ['tox-dialog__popups'],
            inputAttributes: {
                'aria-errormessage': errorId,
                'type': 'url'
            },
            minChars: 0,
            responseTime: 0,
            fetch: (input) => {
                const items = getItems(spec.filetype, input, urlBackstage);
                const tdata = build(items, ItemResponse$1.BUBBLE_TO_SANDBOX, backstage, {
                    isHorizontalMenu: false,
                    search: Optional.none()
                });
                return Future.pure(tdata);
            },
            getHotspot: (comp) => memUrlBox.getOpt(comp),
            onSetValue: (comp, _newValue) => {
                if (comp.hasConfigured(Invalidating)) {
                    Invalidating.run(comp).get(noop);
                }
            },
            typeaheadBehaviours: derive$1([
                ...urlBackstage.getValidationHandler().map((handler) => Invalidating.config({
                    getRoot: (comp) => parentElement(comp.element),
                    invalidClass: 'tox-control-wrap--status-invalid',
                    notify: {
                        onInvalid: (comp, err) => {
                            memInvalidIcon.getOpt(comp).each((invalidComp) => {
                                set$9(invalidComp.element, 'title', providersBackstage.translate(err));
                            });
                        }
                    },
                    validator: {
                        validate: (input) => {
                            const urlEntry = Representing.getValue(input);
                            return FutureResult.nu((completer) => {
                                handler({ type: spec.filetype, url: urlEntry.value }, (validation) => {
                                    if (validation.status === 'invalid') {
                                        const err = Result.error(validation.message);
                                        completer(err);
                                    }
                                    else {
                                        const val = Result.value(validation.message);
                                        completer(val);
                                    }
                                });
                            });
                        },
                        validateOnLoad: false
                    }
                })).toArray(),
                Disabling.config({
                    disabled: () => !spec.enabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable
                }),
                Tabstopping.config({}),
                config('urlinput-events', 
                // We want to get fast feedback for the link dialog, but not sure about others
                [
                    run$1(input(), (comp) => {
                        const currentValue = get$5(comp.element);
                        const trimmedValue = currentValue.trim();
                        if (trimmedValue !== currentValue) {
                            set$4(comp.element, trimmedValue);
                        }
                        if (spec.filetype === 'file') {
                            emitWith(comp, formChangeEvent, { name: spec.name });
                        }
                    }),
                    run$1(change(), (comp) => {
                        emitWith(comp, formChangeEvent, { name: spec.name });
                        updateHistory(comp);
                    }),
                    run$1(postPaste(), (comp) => {
                        emitWith(comp, formChangeEvent, { name: spec.name });
                        updateHistory(comp);
                    })
                ])
            ]),
            eventOrder: {
                [input()]: ['streaming', 'urlinput-events', 'invalidating']
            },
            model: {
                getDisplayText: (itemData) => itemData.value,
                selectsOver: false,
                populateFromBrowse: false
            },
            markers: {
                openClass: 'tox-textfield--popup-open'
            },
            lazySink: backstage.shared.getSink,
            parts: {
                menu: part(false, 1, 'normal')
            },
            onExecute: (_menu, component, _entry) => {
                emitWith(component, formSubmitEvent, {});
            },
            onItemExecute: (typeahead, _sandbox, _item, _value) => {
                updateHistory(typeahead);
                emitWith(typeahead, formChangeEvent, { name: spec.name });
            }
        };
        const pField = FormField.parts.field({
            ...typeaheadSpec,
            factory: Typeahead
        });
        const pLabel = spec.label.map((label) => renderLabel$3(label, providersBackstage));
        // TODO: Consider a way of merging with Checkbox.
        const makeIcon = (name, errId, icon = name, label = name) => render$4(icon, {
            tag: 'div',
            classes: ['tox-icon', 'tox-control-wrap__status-icon-' + name],
            attributes: {
                'title': providersBackstage.translate(label),
                'aria-live': 'polite',
                ...errId.fold(() => ({}), (id) => ({ id }))
            }
        }, providersBackstage.icons);
        const memInvalidIcon = record(makeIcon('invalid', Optional.some(errorId), 'warning'));
        const memStatus = record({
            dom: {
                tag: 'div',
                classes: ['tox-control-wrap__status-icon-wrap']
            },
            components: [
                // Include the 'valid' and 'unknown' icons here only if they are to be displayed
                memInvalidIcon.asSpec()
            ]
        });
        const optUrlPicker = urlBackstage.getUrlPicker(spec.filetype);
        const browseUrlEvent = generate$6('browser.url.event');
        const memUrlBox = record({
            dom: {
                tag: 'div',
                classes: ['tox-control-wrap']
            },
            components: [pField, memStatus.asSpec()],
            behaviours: derive$1([
                Disabling.config({
                    disabled: () => !spec.enabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable
                })
            ])
        });
        const memUrlPickerButton = record(renderButton$1({
            context: spec.context,
            name: spec.name,
            icon: Optional.some('browse'),
            text: spec.picker_text.or(spec.label).getOr(''),
            enabled: spec.enabled,
            primary: false,
            buttonType: Optional.none(),
            borderless: true
        }, (component) => emit(component, browseUrlEvent), providersBackstage, [], ['tox-browse-url']));
        const controlHWrapper = () => ({
            dom: {
                tag: 'div',
                classes: ['tox-form__controls-h-stack']
            },
            components: flatten([
                [memUrlBox.asSpec()],
                optUrlPicker.map(() => memUrlPickerButton.asSpec()).toArray()
            ])
        });
        const openUrlPicker = (comp) => {
            Composing.getCurrent(comp).each((field) => {
                const componentData = Representing.getValue(field);
                const urlData = {
                    fieldname: spec.name,
                    ...componentData
                };
                optUrlPicker.each((picker) => {
                    picker(urlData).get((chosenData) => {
                        Representing.setValue(field, chosenData);
                        emitWith(comp, formChangeEvent, { name: spec.name });
                    });
                });
            });
        };
        return FormField.sketch({
            dom: renderFormFieldDom(),
            components: pLabel.toArray().concat([
                controlHWrapper()
            ]),
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: () => !spec.enabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable,
                    onDisabled: (comp) => {
                        FormField.getField(comp).each(Disabling.disable);
                        memUrlPickerButton.getOpt(comp).each(Disabling.disable);
                    },
                    onEnabled: (comp) => {
                        FormField.getField(comp).each(Disabling.enable);
                        memUrlPickerButton.getOpt(comp).each(Disabling.enable);
                    }
                }),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context)),
                config('url-input-events', [
                    run$1(browseUrlEvent, openUrlPicker)
                ])
            ])
        });
    };

    const renderAlertBanner = (spec, providersBackstage) => {
        const icon = get(spec.icon, providersBackstage.icons);
        // For using the alert banner inside a dialog
        return Container.sketch({
            dom: {
                tag: 'div',
                attributes: {
                    role: 'alert'
                },
                classes: ['tox-notification', 'tox-notification--in', `tox-notification--${spec.level}`]
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-notification__icon'],
                        innerHtml: !spec.url ? icon : undefined
                    },
                    components: spec.url ? [
                        Button.sketch({
                            dom: {
                                tag: 'button',
                                classes: ['tox-button', 'tox-button--naked', 'tox-button--icon'],
                                innerHtml: icon,
                                attributes: {
                                    title: providersBackstage.translate(spec.iconTooltip)
                                }
                            },
                            // TODO: aria label this button!
                            action: (comp) => emitWith(comp, formActionEvent, { name: 'alert-banner', value: spec.url }),
                            buttonBehaviours: derive$1([
                                addFocusableBehaviour()
                            ])
                        })
                    ] : undefined
                },
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-notification__body'],
                        // TODO: AP-247: Escape this text so that it can't contain script tags
                        innerHtml: providersBackstage.translate(spec.text)
                    }
                }
            ]
        });
    };

    const renderCheckbox = (spec, providerBackstage, initialData) => {
        const toggleCheckboxHandler = (comp) => {
            comp.element.dom.click();
            return Optional.some(true);
        };
        const pField = FormField.parts.field({
            factory: { sketch: identity },
            dom: {
                tag: 'input',
                classes: ['tox-checkbox__input'],
                attributes: {
                    type: 'checkbox'
                }
            },
            behaviours: derive$1([
                ComposingConfigs.self(),
                Disabling.config({
                    disabled: () => !spec.enabled || providerBackstage.checkUiComponentContext(spec.context).shouldDisable,
                    onDisabled: (component) => {
                        parentElement(component.element).each((element) => add$2(element, 'tox-checkbox--disabled'));
                    },
                    onEnabled: (component) => {
                        parentElement(component.element).each((element) => remove$3(element, 'tox-checkbox--disabled'));
                    }
                }),
                Tabstopping.config({}),
                Focusing.config({}),
                withElement(initialData, get$9, set$5),
                Keying.config({
                    mode: 'special',
                    onEnter: toggleCheckboxHandler,
                    onSpace: toggleCheckboxHandler,
                    stopSpaceKeyup: true
                }),
                config('checkbox-events', [
                    run$1(change(), (component, _) => {
                        emitWith(component, formChangeEvent, { name: spec.name });
                    })
                ])
            ])
        });
        const pLabel = FormField.parts.label({
            dom: {
                tag: 'span',
                classes: ['tox-checkbox__label']
            },
            components: [
                text$2(providerBackstage.translate(spec.label))
            ],
            behaviours: derive$1([
                Unselecting.config({})
            ])
        });
        const makeIcon = (className) => {
            const iconName = className === 'checked' ? 'selected' : 'unselected';
            return render$4(iconName, { tag: 'span', classes: ['tox-icon', 'tox-checkbox-icon__' + className] }, providerBackstage.icons);
        };
        const memIcons = record({
            dom: {
                tag: 'div',
                classes: ['tox-checkbox__icons']
            },
            components: [
                makeIcon('checked'),
                makeIcon('unchecked')
            ]
        });
        return FormField.sketch({
            dom: {
                tag: 'label',
                classes: ['tox-checkbox']
            },
            components: [
                pField,
                memIcons.asSpec(),
                pLabel
            ],
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: () => !spec.enabled || providerBackstage.checkUiComponentContext(spec.context).shouldDisable,
                }),
                toggleOnReceive(() => providerBackstage.checkUiComponentContext(spec.context))
            ])
        });
    };

    const renderHtmlPanel = (spec, providersBackstage) => {
        const classes = ['tox-form__group', ...(spec.stretched ? ['tox-form__group--stretched'] : [])];
        const init = config('htmlpanel', [
            runOnAttached((comp) => {
                spec.onInit(comp.element.dom);
            })
        ]);
        if (spec.presets === 'presentation') {
            return Container.sketch({
                dom: {
                    tag: 'div',
                    classes,
                    innerHtml: spec.html
                },
                containerBehaviours: derive$1([
                    Tooltipping.config({
                        ...providersBackstage.tooltips.getConfig({
                            tooltipText: '',
                            onShow: (comp) => {
                                descendant(comp.element, '[data-mce-tooltip]:hover').orThunk(() => search(comp.element))
                                    .each((current) => {
                                    getOpt(current, 'data-mce-tooltip').each((text) => {
                                        Tooltipping.setComponents(comp, providersBackstage.tooltips.getComponents({ tooltipText: text }));
                                    });
                                });
                            },
                        }),
                        mode: 'children-normal',
                        anchor: (comp) => ({
                            type: 'node',
                            node: descendant(comp.element, '[data-mce-tooltip]:hover')
                                .orThunk(() => search(comp.element).filter((current) => getOpt(current, 'data-mce-tooltip').isSome())),
                            root: comp.element,
                            layouts: {
                                onLtr: constant$1([south$2, north$2, southeast$2, northeast$2, southwest$2, northwest$2]),
                                onRtl: constant$1([south$2, north$2, southeast$2, northeast$2, southwest$2, northwest$2])
                            },
                            bubble: nu$6(0, -2, {}),
                        })
                    }),
                    init
                ])
            });
        }
        else {
            return Container.sketch({
                dom: {
                    tag: 'div',
                    classes,
                    innerHtml: spec.html,
                    attributes: {
                        role: 'document'
                    }
                },
                containerBehaviours: derive$1([
                    Tabstopping.config({}),
                    Focusing.config({}),
                    init
                ])
            });
        }
    };

    const make$1 = (render) => {
        return (parts, spec, dialogData, backstage, getCompByName) => get$h(spec, 'name').fold(() => render(spec, backstage, Optional.none(), getCompByName), (fieldName) => parts.field(fieldName, render(spec, backstage, get$h(dialogData, fieldName), getCompByName)));
    };
    const makeIframe = (render) => (parts, spec, dialogData, backstage, getCompByName) => {
        const iframeSpec = deepMerge(spec, {
            source: 'dynamic'
        });
        return make$1(render)(parts, iframeSpec, dialogData, backstage, getCompByName);
    };
    const factories = {
        bar: make$1((spec, backstage) => renderBar(spec, backstage.shared)),
        collection: make$1((spec, backstage, data) => renderCollection(spec, backstage.shared.providers, data)),
        alertbanner: make$1((spec, backstage) => renderAlertBanner(spec, backstage.shared.providers)),
        input: make$1((spec, backstage, data) => renderInput(spec, backstage.shared.providers, data)),
        textarea: make$1((spec, backstage, data) => renderTextarea(spec, backstage.shared.providers, data)),
        label: make$1((spec, backstage, _data, getCompByName) => renderLabel$2(spec, backstage.shared, getCompByName)),
        iframe: makeIframe((spec, backstage, data) => renderIFrame(spec, backstage.shared.providers, data)),
        button: make$1((spec, backstage) => renderDialogButton(spec, backstage.shared.providers)),
        checkbox: make$1((spec, backstage, data) => renderCheckbox(spec, backstage.shared.providers, data)),
        colorinput: make$1((spec, backstage, data) => renderColorInput(spec, backstage.shared, backstage.colorinput, data)),
        colorpicker: make$1((spec, backstage, data) => renderColorPicker(spec, backstage.shared.providers, data)), // Not sure if this needs name.
        dropzone: make$1((spec, backstage, data) => renderDropZone(spec, backstage.shared.providers, data)),
        grid: make$1((spec, backstage) => renderGrid(spec, backstage.shared)),
        listbox: make$1((spec, backstage, data) => renderListBox(spec, backstage, data)),
        selectbox: make$1((spec, backstage, data) => renderSelectBox(spec, backstage.shared.providers, data)),
        sizeinput: make$1((spec, backstage) => renderSizeInput(spec, backstage.shared.providers)),
        slider: make$1((spec, backstage, data) => renderSlider(spec, backstage.shared.providers, data)),
        urlinput: make$1((spec, backstage, data) => renderUrlInput(spec, backstage, backstage.urlinput, data)),
        customeditor: make$1(renderCustomEditor),
        htmlpanel: make$1((spec, backstage) => renderHtmlPanel(spec, backstage.shared.providers)),
        imagepreview: make$1((spec, _, data) => renderImagePreview(spec, data)),
        table: make$1((spec, backstage) => renderTable(spec, backstage.shared.providers)),
        tree: make$1((spec, backstage) => renderTree(spec, backstage)),
        panel: make$1((spec, backstage) => renderPanel(spec, backstage))
    };
    const noFormParts = {
        // This is cast as we only actually want an alloy spec and don't need the actual part here
        field: (_name, spec) => spec,
        record: constant$1([])
    };
    const interpretInForm = (parts, spec, dialogData, oldBackstage, getCompByName) => {
        // Now, we need to update the backstage to use the parts variant.
        const newBackstage = deepMerge(oldBackstage, {
            // Add the interpreter based on the form parts.
            shared: {
                interpreter: (childSpec) => interpretParts(parts, childSpec, dialogData, newBackstage, getCompByName)
            }
        });
        return interpretParts(parts, spec, dialogData, newBackstage, getCompByName);
    };
    const interpretParts = (parts, spec, dialogData, backstage, getCompByName) => get$h(factories, spec.type).fold(() => {
        console.error(`Unknown factory type "${spec.type}", defaulting to container: `, spec);
        return spec;
    }, (factory) => factory(parts, spec, dialogData, backstage, getCompByName));
    const interpretWithoutForm = (spec, dialogData, backstage, getCompByName) => interpretParts(noFormParts, spec, dialogData, backstage, getCompByName);

    const bubbleAlignments$2 = {
        valignCentre: [],
        alignCentre: [],
        alignLeft: [],
        alignRight: [],
        right: [],
        left: [],
        bottom: [],
        top: []
    };
    const getInlineDialogAnchor = (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) => {
        const bubbleSize = 12;
        const overrides = {
            maxHeightFunction: expandable$1()
        };
        const editableAreaAnchor = () => ({
            type: 'node',
            root: getContentContainer(getRootNode(contentAreaElement())),
            node: Optional.from(contentAreaElement()),
            bubble: nu$6(bubbleSize, bubbleSize, bubbleAlignments$2),
            layouts: {
                onRtl: () => [northeast$1],
                onLtr: () => [northwest$1]
            },
            overrides
        });
        const standardAnchor = () => ({
            type: 'hotspot',
            hotspot: lazyAnchorbar(),
            bubble: nu$6(-bubbleSize, bubbleSize, bubbleAlignments$2),
            layouts: {
                onRtl: () => [southeast$2, southwest$2, south$2],
                onLtr: () => [southwest$2, southeast$2, south$2]
            },
            overrides
        });
        return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
    };
    const getInlineBottomDialogAnchor = (inline, contentAreaElement, lazyBottomAnchorBar, lazyUseEditableAreaAnchor) => {
        const bubbleSize = 12;
        const overrides = {
            maxHeightFunction: expandable$1()
        };
        const editableAreaAnchor = () => ({
            type: 'node',
            root: getContentContainer(getRootNode(contentAreaElement())),
            node: Optional.from(contentAreaElement()),
            bubble: nu$6(bubbleSize, bubbleSize, bubbleAlignments$2),
            layouts: {
                onRtl: () => [north$1],
                onLtr: () => [north$1]
            },
            overrides
        });
        const standardAnchor = () => inline ?
            ({
                type: 'node',
                root: getContentContainer(getRootNode(contentAreaElement())),
                node: Optional.from(contentAreaElement()),
                bubble: nu$6(0, -getOuter$1(contentAreaElement()), bubbleAlignments$2),
                layouts: {
                    onRtl: () => [north$2],
                    onLtr: () => [north$2]
                },
                overrides
            })
            : ({
                type: 'hotspot',
                hotspot: lazyBottomAnchorBar(),
                bubble: nu$6(0, 0, bubbleAlignments$2),
                layouts: {
                    onRtl: () => [north$2],
                    onLtr: () => [north$2]
                },
                overrides
            });
        return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
    };
    const getBannerAnchor = (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) => {
        const editableAreaAnchor = () => ({
            type: 'node',
            root: getContentContainer(getRootNode(contentAreaElement())),
            node: Optional.from(contentAreaElement()),
            layouts: {
                onRtl: () => [north$1],
                onLtr: () => [north$1]
            }
        });
        const standardAnchor = () => ({
            type: 'hotspot',
            hotspot: lazyAnchorbar(),
            layouts: {
                onRtl: () => [south$2],
                onLtr: () => [south$2]
            }
        });
        return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
    };
    const getCursorAnchor = (editor, bodyElement) => () => ({
        type: 'selection',
        root: bodyElement(),
        getSelection: () => {
            const rng = editor.selection.getRng();
            // Only return a range if there is a selection of more than one cell.
            const selectedCells = editor.model.table.getSelectedCells();
            if (selectedCells.length > 1) {
                const firstCell = selectedCells[0];
                const lastCell = selectedCells[selectedCells.length - 1];
                const selectionTableCellRange = {
                    firstCell: SugarElement.fromDom(firstCell),
                    lastCell: SugarElement.fromDom(lastCell)
                };
                return Optional.some(selectionTableCellRange);
            }
            return Optional.some(SimSelection.range(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
        }
    });
    const getNodeAnchor$1 = (bodyElement) => (element) => ({
        type: 'node',
        root: bodyElement(),
        node: element
    });
    const getAnchors = (editor, lazyAnchorbar, lazyBottomAnchorBar, isToolbarTop) => {
        const useFixedToolbarContainer = useFixedContainer(editor);
        const bodyElement = () => SugarElement.fromDom(editor.getBody());
        const contentAreaElement = () => SugarElement.fromDom(editor.getContentAreaContainer());
        // If using fixed_toolbar_container or if the toolbar is positioned at the bottom
        // of the editor, some things should anchor to the top of the editable area.
        const lazyUseEditableAreaAnchor = () => useFixedToolbarContainer || !isToolbarTop();
        return {
            inlineDialog: getInlineDialogAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
            inlineBottomDialog: getInlineBottomDialogAnchor(editor.inline, contentAreaElement, lazyBottomAnchorBar, lazyUseEditableAreaAnchor),
            banner: getBannerAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
            cursor: getCursorAnchor(editor, bodyElement),
            node: getNodeAnchor$1(bodyElement)
        };
    };

    const colorPicker = (editor) => (callback, value) => {
        const dialog = colorPickerDialog(editor);
        dialog(callback, value);
    };
    const hasCustomColors = (editor) => () => hasCustomColors$1(editor);
    const getColors = (editor) => (id) => getColors$2(editor, id);
    const getColorCols = (editor) => (id) => getColorCols$1(editor, id);
    const ColorInputBackstage = (editor) => ({
        colorPicker: colorPicker(editor),
        hasCustomColors: hasCustomColors(editor),
        getColors: getColors(editor),
        getColorCols: getColorCols(editor)
    });

    const isDraggableModal = (editor) => () => isDraggableModal$1(editor);
    const DialogBackstage = (editor) => ({
        isDraggableModal: isDraggableModal(editor)
    });

    const HeaderBackstage = (editor) => {
        const mode = Cell(isToolbarLocationBottom(editor) ? 'bottom' : 'top');
        return {
            isPositionedAtTop: () => mode.get() === 'top',
            getDockingMode: mode.get,
            setDockingMode: mode.set
        };
    };

    const isNestedFormat = (format) => hasNonNullableKey(format, 'items');
    const isFormatReference = (format) => hasNonNullableKey(format, 'format');
    const defaultStyleFormats = [
        {
            title: 'Headings', items: [
                { title: 'Heading 1', format: 'h1' },
                { title: 'Heading 2', format: 'h2' },
                { title: 'Heading 3', format: 'h3' },
                { title: 'Heading 4', format: 'h4' },
                { title: 'Heading 5', format: 'h5' },
                { title: 'Heading 6', format: 'h6' }
            ]
        },
        {
            title: 'Inline', items: [
                { title: 'Bold', format: 'bold' },
                { title: 'Italic', format: 'italic' },
                { title: 'Underline', format: 'underline' },
                { title: 'Strikethrough', format: 'strikethrough' },
                { title: 'Superscript', format: 'superscript' },
                { title: 'Subscript', format: 'subscript' },
                { title: 'Code', format: 'code' }
            ]
        },
        {
            title: 'Blocks', items: [
                { title: 'Paragraph', format: 'p' },
                { title: 'Blockquote', format: 'blockquote' },
                { title: 'Div', format: 'div' },
                { title: 'Pre', format: 'pre' }
            ]
        },
        {
            title: 'Align', items: [
                { title: 'Left', format: 'alignleft' },
                { title: 'Center', format: 'aligncenter' },
                { title: 'Right', format: 'alignright' },
                { title: 'Justify', format: 'alignjustify' }
            ]
        }
    ];
    // Note: Need to cast format below to expected type, as Obj.has uses "K keyof T", which doesn't work with aliases
    const isNestedFormats = (format) => has$2(format, 'items');
    const isBlockFormat = (format) => has$2(format, 'block');
    const isInlineFormat = (format) => has$2(format, 'inline');
    const isSelectorFormat = (format) => has$2(format, 'selector');
    const mapFormats = (userFormats) => foldl(userFormats, (acc, fmt) => {
        if (isNestedFormats(fmt)) {
            // Map the child formats
            const result = mapFormats(fmt.items);
            return {
                customFormats: acc.customFormats.concat(result.customFormats),
                formats: acc.formats.concat([{ title: fmt.title, items: result.formats }])
            };
        }
        else if (isInlineFormat(fmt) || isBlockFormat(fmt) || isSelectorFormat(fmt)) {
            // Convert the format to a reference and add the original to the custom formats to be registered
            const formatName = isString(fmt.name) ? fmt.name : fmt.title.toLowerCase();
            const formatNameWithPrefix = `custom-${formatName}`;
            return {
                customFormats: acc.customFormats.concat([{ name: formatNameWithPrefix, format: fmt }]),
                formats: acc.formats.concat([{ title: fmt.title, format: formatNameWithPrefix, icon: fmt.icon }])
            };
        }
        else {
            return { ...acc, formats: acc.formats.concat(fmt) };
        }
    }, { customFormats: [], formats: [] });
    const registerCustomFormats = (editor, userFormats) => {
        const result = mapFormats(userFormats);
        const registerFormats = (customFormats) => {
            each$1(customFormats, (fmt) => {
                // Only register the custom format with the editor, if it's not already registered
                if (!editor.formatter.has(fmt.name)) {
                    editor.formatter.register(fmt.name, fmt.format);
                }
            });
        };
        // The editor may not yet be initialized, so check for that
        if (editor.formatter) {
            registerFormats(result.customFormats);
        }
        else {
            editor.on('init', () => {
                registerFormats(result.customFormats);
            });
        }
        return result.formats;
    };
    const getStyleFormats = (editor) => getUserStyleFormats(editor).map((userFormats) => {
        // Ensure that any custom formats specified by the user are registered with the editor
        const registeredUserFormats = registerCustomFormats(editor, userFormats);
        // Merge the default formats with the custom formats if required
        return shouldMergeStyleFormats(editor) ? defaultStyleFormats.concat(registeredUserFormats) : registeredUserFormats;
    }).getOr(defaultStyleFormats);

    const isSeparator$1 = (format) => {
        const keys$1 = keys(format);
        return keys$1.length === 1 && contains$2(keys$1, 'title');
    };
    const processBasic = (item, isSelectedFor, getPreviewFor) => ({
        ...item,
        type: 'formatter',
        isSelected: isSelectedFor(item.format),
        getStylePreview: getPreviewFor(item.format)
    });
    // TODO: This is adapted from StyleFormats in the mobile theme. Consolidate.
    const register$b = (editor, formats, isSelectedFor, getPreviewFor) => {
        const enrichSupported = (item) => processBasic(item, isSelectedFor, getPreviewFor);
        // Item that triggers a submenu
        const enrichMenu = (item) => {
            const newItems = doEnrich(item.items);
            return {
                ...item,
                type: 'submenu',
                getStyleItems: constant$1(newItems)
            };
        };
        const enrichCustom = (item) => {
            const formatName = isString(item.name) ? item.name : generate$6(item.title);
            const formatNameWithPrefix = `custom-${formatName}`;
            const newItem = {
                ...item,
                type: 'formatter',
                format: formatNameWithPrefix,
                isSelected: isSelectedFor(formatNameWithPrefix),
                getStylePreview: getPreviewFor(formatNameWithPrefix)
            };
            editor.formatter.register(formatName, newItem);
            return newItem;
        };
        const doEnrich = (items) => map$2(items, (item) => {
            // If it is a submenu, enrich all the subitems.
            if (isNestedFormat(item)) {
                return enrichMenu(item);
            }
            else if (isFormatReference(item)) {
                return enrichSupported(item);
                // NOTE: This branch is added from the original StyleFormats in mobile
            }
            else if (isSeparator$1(item)) {
                return { ...item, type: 'separator' };
            }
            else {
                return enrichCustom(item);
            }
        });
        return doEnrich(formats);
    };

    const init$1 = (editor) => {
        const isSelectedFor = (format) => () => editor.formatter.match(format);
        const getPreviewFor = (format) => () => {
            const fmt = editor.formatter.get(format);
            return fmt !== undefined ? Optional.some({
                tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',
                styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
            }) : Optional.none();
        };
        const settingsFormats = Cell([]);
        const eventsFormats = Cell([]);
        const replaceSettings = Cell(false);
        editor.on('PreInit', (_e) => {
            const formats = getStyleFormats(editor);
            const enriched = register$b(editor, formats, isSelectedFor, getPreviewFor);
            settingsFormats.set(enriched);
        });
        editor.on('addStyleModifications', (e) => {
            // Is there going to be an order issue here?
            const modifications = register$b(editor, e.items, isSelectedFor, getPreviewFor);
            eventsFormats.set(modifications);
            replaceSettings.set(e.replace);
        });
        const getData = () => {
            const fromSettings = replaceSettings.get() ? [] : settingsFormats.get();
            const fromEvents = eventsFormats.get();
            return fromSettings.concat(fromEvents);
        };
        return {
            getData
        };
    };

    const TooltipsBackstage = (getSink) => {
        const tooltipDelay = 300;
        const intervalDelay = tooltipDelay * 0.2; // Arbitrary value
        let numActiveTooltips = 0;
        const alreadyShowingTooltips = () => numActiveTooltips > 0;
        const getComponents = (spec) => {
            return [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-tooltip__body']
                    },
                    components: [
                        text$2(spec.tooltipText)
                    ]
                }
            ];
        };
        const getConfig = (spec) => {
            return {
                delayForShow: () => alreadyShowingTooltips() ? intervalDelay : tooltipDelay,
                delayForHide: constant$1(tooltipDelay),
                exclusive: true,
                lazySink: getSink,
                tooltipDom: {
                    tag: 'div',
                    classes: ['tox-tooltip', 'tox-tooltip--up']
                },
                tooltipComponents: getComponents(spec),
                onShow: (comp, tooltip) => {
                    numActiveTooltips++;
                    if (spec.onShow) {
                        spec.onShow(comp, tooltip);
                    }
                },
                onHide: (comp, tooltip) => {
                    numActiveTooltips--;
                    if (spec.onHide) {
                        spec.onHide(comp, tooltip);
                    }
                },
                onSetup: spec.onSetup,
            };
        };
        return {
            getConfig,
            getComponents
        };
    };

    const isElement = (node) => isNonNullable(node) && node.nodeType === 1;
    const trim = global$2.trim;
    const hasContentEditableState = (value) => {
        return (node) => {
            if (isElement(node)) {
                if (node.contentEditable === value) {
                    return true;
                }
                if (node.getAttribute('data-mce-contenteditable') === value) {
                    return true;
                }
            }
            return false;
        };
    };
    const isContentEditableTrue = hasContentEditableState('true');
    const isContentEditableFalse = hasContentEditableState('false');
    const create = (type, title, url, level, attach) => ({
        type,
        title,
        url,
        level,
        attach
    });
    const isChildOfContentEditableTrue = (node) => {
        let tempNode = node;
        while ((tempNode = tempNode.parentNode)) {
            const value = tempNode.contentEditable;
            if (value && value !== 'inherit') {
                return isContentEditableTrue(tempNode);
            }
        }
        return false;
    };
    const select = (selector, root) => {
        return map$2(descendants(SugarElement.fromDom(root), selector), (element) => {
            return element.dom;
        });
    };
    const getElementText = (elm) => {
        return elm.innerText || elm.textContent;
    };
    const getOrGenerateId = (elm) => {
        return elm.id ? elm.id : generate$6('h');
    };
    const isAnchor = (elm) => {
        return elm && elm.nodeName === 'A' && (elm.id || elm.name) !== undefined;
    };
    const isValidAnchor = (elm) => {
        return isAnchor(elm) && isEditable(elm);
    };
    const isHeader = (elm) => {
        return elm && /^(H[1-6])$/.test(elm.nodeName);
    };
    const isEditable = (elm) => {
        return isChildOfContentEditableTrue(elm) && !isContentEditableFalse(elm);
    };
    const isValidHeader = (elm) => {
        return isHeader(elm) && isEditable(elm);
    };
    const getLevel = (elm) => {
        return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;
    };
    const headerTarget = (elm) => {
        var _a;
        const headerId = getOrGenerateId(elm);
        const attach = () => {
            elm.id = headerId;
        };
        return create('header', (_a = getElementText(elm)) !== null && _a !== void 0 ? _a : '', '#' + headerId, getLevel(elm), attach);
    };
    const anchorTarget = (elm) => {
        const anchorId = elm.id || elm.name;
        const anchorText = getElementText(elm);
        return create('anchor', anchorText ? anchorText : '#' + anchorId, '#' + anchorId, 0, noop);
    };
    const getHeaderTargets = (elms) => {
        return map$2(filter$2(elms, isValidHeader), headerTarget);
    };
    const getAnchorTargets = (elms) => {
        return map$2(filter$2(elms, isValidAnchor), anchorTarget);
    };
    const getTargetElements = (elm) => {
        const elms = select('h1,h2,h3,h4,h5,h6,a:not([href])', elm);
        return elms;
    };
    const hasTitle = (target) => {
        return trim(target.title).length > 0;
    };
    const find = (elm) => {
        const elms = getTargetElements(elm);
        return filter$2(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);
    };
    const LinkTargets = {
        find
    };

    const STORAGE_KEY = 'tinymce-url-history';
    const HISTORY_LENGTH = 5;
    // validation functions
    const isHttpUrl = (url) => isString(url) && /^https?/.test(url);
    const isArrayOfUrl = (a) => isArray(a) && a.length <= HISTORY_LENGTH && forall(a, isHttpUrl);
    const isRecordOfUrlArray = (r) => isObject(r) && find$4(r, (value) => !isArrayOfUrl(value)).isNone();
    const getAllHistory = () => {
        const unparsedHistory = global$5.getItem(STORAGE_KEY);
        if (unparsedHistory === null) {
            return {};
        }
        // parse history
        let history;
        try {
            history = JSON.parse(unparsedHistory);
        }
        catch (e) {
            if (e instanceof SyntaxError) {
                // eslint-disable-next-line no-console
                console.log('Local storage ' + STORAGE_KEY + ' was not valid JSON', e);
                return {};
            }
            throw e;
        }
        // validate the parsed value
        if (!isRecordOfUrlArray(history)) {
            // eslint-disable-next-line no-console
            console.log('Local storage ' + STORAGE_KEY + ' was not valid format', history);
            return {};
        }
        return history;
    };
    const setAllHistory = (history) => {
        if (!isRecordOfUrlArray(history)) {
            throw new Error('Bad format for history:\n' + JSON.stringify(history));
        }
        global$5.setItem(STORAGE_KEY, JSON.stringify(history));
    };
    const getHistory = (fileType) => {
        const history = getAllHistory();
        return get$h(history, fileType).getOr([]);
    };
    const addToHistory = (url, fileType) => {
        if (!isHttpUrl(url)) {
            return;
        }
        const history = getAllHistory();
        const items = get$h(history, fileType).getOr([]);
        const itemsWithoutUrl = filter$2(items, (item) => item !== url);
        history[fileType] = [url].concat(itemsWithoutUrl).slice(0, HISTORY_LENGTH);
        setAllHistory(history);
    };

    const isTruthy = (value) => !!value;
    const makeMap = (value) => map$1(global$2.makeMap(value, /[, ]/), isTruthy);
    const getPicker = (editor) => Optional.from(getFilePickerCallback(editor));
    const getPickerTypes = (editor) => {
        const optFileTypes = Optional.from(getFilePickerTypes(editor)).filter(isTruthy).map(makeMap);
        return getPicker(editor).fold(never, (_picker) => optFileTypes.fold(always, (types) => keys(types).length > 0 ? types : false));
    };
    const getPickerSetting = (editor, filetype) => {
        const pickerTypes = getPickerTypes(editor);
        if (isBoolean(pickerTypes)) {
            return pickerTypes ? getPicker(editor) : Optional.none();
        }
        else {
            return pickerTypes[filetype] ? getPicker(editor) : Optional.none();
        }
    };
    const getUrlPicker = (editor, filetype) => getPickerSetting(editor, filetype).map((picker) => (entry) => Future.nu((completer) => {
        const handler = (value, meta) => {
            if (!isString(value)) {
                throw new Error('Expected value to be string');
            }
            if (meta !== undefined && !isObject(meta)) {
                throw new Error('Expected meta to be a object');
            }
            const r = { value, meta };
            completer(r);
        };
        const meta = {
            filetype,
            fieldname: entry.fieldname,
            ...Optional.from(entry.meta).getOr({})
        };
        // file_picker_callback(callback, currentValue, metaData)
        picker.call(editor, handler, entry.value, meta);
    }));
    const getTextSetting = (value) => Optional.from(value).filter(isString).getOrUndefined();
    const getLinkInformation = (editor) => {
        if (!useTypeaheadUrls(editor)) {
            return Optional.none();
        }
        return Optional.some({
            targets: LinkTargets.find(editor.getBody()),
            anchorTop: getTextSetting(getAnchorTop(editor)),
            anchorBottom: getTextSetting(getAnchorBottom(editor))
        });
    };
    const getValidationHandler = (editor) => Optional.from(getFilePickerValidatorHandler(editor));
    const UrlInputBackstage = (editor) => ({
        getHistory,
        addToHistory,
        getLinkInformation: () => getLinkInformation(editor),
        getValidationHandler: () => getValidationHandler(editor),
        getUrlPicker: (filetype) => getUrlPicker(editor, filetype)
    });

    const init = (lazySinks, editor, lazyAnchorbar, lazyBottomAnchorBar) => {
        const contextMenuState = Cell(false);
        const toolbar = HeaderBackstage(editor);
        const providers = {
            icons: () => editor.ui.registry.getAll().icons,
            menuItems: () => editor.ui.registry.getAll().menuItems,
            translate: global$6.translate,
            isDisabled: () => !editor.ui.isEnabled(),
            getOption: editor.options.get,
            tooltips: TooltipsBackstage(lazySinks.dialog),
            checkUiComponentContext: (specContext) => {
                if (isDisabled(editor)) {
                    return {
                        contextType: 'disabled',
                        shouldDisable: true
                    };
                }
                const [key, value = ''] = specContext.split(':');
                const contexts = editor.ui.registry.getAll().contexts;
                const enabledInContext = get$h(contexts, key)
                    .fold(
                // Fallback to 'mode:design' if key is not found
                () => get$h(contexts, 'mode').map((pred) => pred('design')).getOr(false), (pred) => value.charAt(0) === '!' ? !pred(value.slice(1)) : pred(value));
                return {
                    contextType: key,
                    shouldDisable: !enabledInContext
                };
            }
        };
        const urlinput = UrlInputBackstage(editor);
        const styles = init$1(editor);
        const colorinput = ColorInputBackstage(editor);
        const dialogSettings = DialogBackstage(editor);
        const isContextMenuOpen = () => contextMenuState.get();
        const setContextMenuState = (state) => contextMenuState.set(state);
        const commonBackstage = {
            shared: {
                providers,
                anchors: getAnchors(editor, lazyAnchorbar, lazyBottomAnchorBar, toolbar.isPositionedAtTop),
                header: toolbar,
            },
            urlinput,
            styles,
            colorinput,
            dialog: dialogSettings,
            isContextMenuOpen,
            setContextMenuState
        };
        const getCompByName = (_name) => Optional.none();
        const popupBackstage = {
            ...commonBackstage,
            shared: {
                ...commonBackstage.shared,
                interpreter: (s) => interpretWithoutForm(s, {}, popupBackstage, getCompByName),
                getSink: lazySinks.popup
            }
        };
        const dialogBackstage = {
            ...commonBackstage,
            shared: {
                ...commonBackstage.shared,
                interpreter: (s) => interpretWithoutForm(s, {}, dialogBackstage, getCompByName),
                getSink: lazySinks.dialog
            }
        };
        return {
            popup: popupBackstage,
            dialog: dialogBackstage
        };
    };

    const migrationFrom7x = 'https://www.tiny.cloud/docs/tinymce/latest/migration-from-7x/';
    const deprecatedFeatures = {
        skipFocus: `ToggleToolbarDrawer skipFocus is deprecated see migration guide: ${migrationFrom7x}`,
    };
    const logFeatureDeprecationWarning = (feature) => {
        // eslint-disable-next-line no-console
        console.warn(deprecatedFeatures[feature], new Error().stack);
    };

    const setup$b = (editor, mothership, uiMotherships) => {
        const broadcastEvent = (name, evt) => {
            each$1([mothership, ...uiMotherships], (m) => {
                m.broadcastEvent(name, evt);
            });
        };
        const broadcastOn = (channel, message) => {
            each$1([mothership, ...uiMotherships], (m) => {
                m.broadcastOn([channel], message);
            });
        };
        const fireDismissPopups = (evt) => broadcastOn(dismissPopups(), { target: evt.target });
        const fireCloseTooltips = (event) => {
            broadcastOn(closeTooltips(), {
                closedTooltip: () => {
                    event.preventDefault();
                }
            });
        };
        // Document touch events
        const doc = getDocument();
        const onTouchstart = bind$1(doc, 'touchstart', fireDismissPopups);
        const onTouchmove = bind$1(doc, 'touchmove', (evt) => broadcastEvent(documentTouchmove(), evt));
        const onTouchend = bind$1(doc, 'touchend', (evt) => broadcastEvent(documentTouchend(), evt));
        // Document mouse events
        const onMousedown = bind$1(doc, 'mousedown', fireDismissPopups);
        const onMouseup = bind$1(doc, 'mouseup', (evt) => {
            if (evt.raw.button === 0) {
                broadcastOn(mouseReleased(), { target: evt.target });
            }
        });
        // Editor content events
        const onContentClick = (raw) => broadcastOn(dismissPopups(), { target: SugarElement.fromDom(raw.target) });
        const onContentMouseup = (raw) => {
            if (raw.button === 0) {
                broadcastOn(mouseReleased(), { target: SugarElement.fromDom(raw.target) });
            }
        };
        const onContentMousedown = () => {
            each$1(editor.editorManager.get(), (loopEditor) => {
                if (editor !== loopEditor) {
                    loopEditor.dispatch('DismissPopups', { relatedTarget: editor });
                }
            });
        };
        // Window events
        const onWindowScroll = (evt) => broadcastEvent(windowScroll(), fromRawEvent(evt));
        const onWindowResize = (evt) => {
            broadcastOn(repositionPopups(), {});
            broadcastEvent(windowResize(), fromRawEvent(evt));
        };
        // TINY-9425: At the moment, we are only supporting situations where the scrolling container
        // is *inside* the shadow root - which is why we bind to the root node, instead of just the outer
        // document. However, if we needed to support scrolling containers that *contained* the shadow root,
        // we would need to listen to the outer document (or at the least, the root node of the scrolling div in
        // the case of muliple layers of shadow roots).
        const dos = getRootNode(SugarElement.fromDom(editor.getElement()));
        const onElementScroll = capture(dos, 'scroll', (evt) => {
            requestAnimationFrame(() => {
                const c = editor.getContainer();
                // Because this can fire before the editor is rendered, we need to stop that from happening.
                // Some tests can create this situation, and then we get a Node name null or defined error.
                if (c !== undefined && c !== null) {
                    const optScrollingContext = detectWhenSplitUiMode(editor, mothership.element);
                    const scrollers = optScrollingContext.map((sc) => [sc.element, ...sc.others]).getOr([]);
                    if (exists(scrollers, (s) => eq(s, evt.target))) {
                        editor.dispatch('ElementScroll', { target: evt.target.dom });
                        broadcastEvent(externalElementScroll(), evt);
                    }
                }
            });
        });
        const onEditorResize = () => broadcastOn(repositionPopups(), {});
        const onEditorProgress = (evt) => {
            if (evt.state) {
                broadcastOn(dismissPopups(), { target: SugarElement.fromDom(editor.getContainer()) });
            }
        };
        const onDismissPopups = (event) => {
            broadcastOn(dismissPopups(), { target: SugarElement.fromDom(event.relatedTarget.getContainer()) });
        };
        const onFocusIn = (event) => editor.dispatch('focusin', event);
        const onFocusOut = (event) => editor.dispatch('focusout', event);
        // Don't start listening to events until the UI has rendered
        editor.on('PostRender', () => {
            editor.on('click', onContentClick);
            editor.on('tap', onContentClick);
            editor.on('mouseup', onContentMouseup);
            editor.on('mousedown', onContentMousedown);
            editor.on('ScrollWindow', onWindowScroll);
            editor.on('ResizeWindow', onWindowResize);
            editor.on('ResizeEditor', onEditorResize);
            editor.on('AfterProgressState', onEditorProgress);
            editor.on('DismissPopups', onDismissPopups);
            editor.on('CloseActiveTooltips', fireCloseTooltips);
            each$1([mothership, ...uiMotherships], (gui) => {
                gui.element.dom.addEventListener('focusin', onFocusIn);
                gui.element.dom.addEventListener('focusout', onFocusOut);
            });
        });
        editor.on('remove', () => {
            // We probably don't need these unbinds, but it helps to have them if we move this code out.
            editor.off('click', onContentClick);
            editor.off('tap', onContentClick);
            editor.off('mouseup', onContentMouseup);
            editor.off('mousedown', onContentMousedown);
            editor.off('ScrollWindow', onWindowScroll);
            editor.off('ResizeWindow', onWindowResize);
            editor.off('ResizeEditor', onEditorResize);
            editor.off('AfterProgressState', onEditorProgress);
            editor.off('DismissPopups', onDismissPopups);
            editor.off('CloseActiveTooltips', fireCloseTooltips);
            each$1([mothership, ...uiMotherships], (gui) => {
                gui.element.dom.removeEventListener('focusin', onFocusIn);
                gui.element.dom.removeEventListener('focusout', onFocusOut);
            });
            onMousedown.unbind();
            onTouchstart.unbind();
            onTouchmove.unbind();
            onTouchend.unbind();
            onMouseup.unbind();
            onElementScroll.unbind();
        });
        editor.on('detach', () => {
            each$1([mothership, ...uiMotherships], detachSystem);
            each$1([mothership, ...uiMotherships], (m) => m.destroy());
        });
    };

    const setup$a = noop;
    const isDocked$1 = never;
    const getBehaviours$1 = constant$1([]);

    var StaticHeader = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setup: setup$a,
        isDocked: isDocked$1,
        getBehaviours: getBehaviours$1
    });

    const toolbarHeightChange = constant$1(generate$6('toolbar-height-change'));

    const visibility = {
        fadeInClass: 'tox-editor-dock-fadein',
        fadeOutClass: 'tox-editor-dock-fadeout',
        transitionClass: 'tox-editor-dock-transition'
    };
    const editorStickyOnClass = 'tox-tinymce--toolbar-sticky-on';
    const editorStickyOffClass = 'tox-tinymce--toolbar-sticky-off';
    const scrollFromBehindHeader = (e, containerHeader) => {
        const doc = owner$4(containerHeader);
        const win = defaultView(containerHeader);
        const viewHeight = win.dom.innerHeight;
        const scrollPos = get$b(doc);
        const markerElement = SugarElement.fromDom(e.elm);
        const markerPos = absolute$2(markerElement);
        const markerHeight = get$d(markerElement);
        const markerTop = markerPos.y;
        const markerBottom = markerTop + markerHeight;
        const editorHeaderPos = absolute$3(containerHeader);
        const editorHeaderHeight = get$d(containerHeader);
        const editorHeaderTop = editorHeaderPos.top;
        const editorHeaderBottom = editorHeaderTop + editorHeaderHeight;
        // Check to see if the header is docked to the top/bottom of the page (eg is floating)
        const editorHeaderDockedAtTop = Math.abs(editorHeaderTop - scrollPos.top) < 2;
        const editorHeaderDockedAtBottom = Math.abs(editorHeaderBottom - (scrollPos.top + viewHeight)) < 2;
        // If the element is behind the header at the top of the page, then
        // scroll the element down by the header height
        if (editorHeaderDockedAtTop && markerTop < editorHeaderBottom) {
            to(scrollPos.left, markerTop - editorHeaderHeight, doc);
            // If the element is behind the header at the bottom of the page, then
            // scroll the element up by the header height
        }
        else if (editorHeaderDockedAtBottom && markerBottom > editorHeaderTop) {
            const y = (markerTop - viewHeight) + markerHeight + editorHeaderHeight;
            to(scrollPos.left, y, doc);
        }
    };
    const isDockedMode = (header, mode) => contains$2(Docking.getModes(header), mode);
    const updateIframeContentFlow = (header) => {
        const getOccupiedHeight = (elm) => getOuter$1(elm) +
            (parseInt(get$e(elm, 'margin-top'), 10) || 0) +
            (parseInt(get$e(elm, 'margin-bottom'), 10) || 0);
        const elm = header.element;
        parentElement(elm).each((parentElem) => {
            const padding = 'padding-' + Docking.getModes(header)[0];
            if (Docking.isDocked(header)) {
                const parentWidth = get$c(parentElem);
                set$7(elm, 'width', parentWidth + 'px');
                set$7(parentElem, padding, getOccupiedHeight(elm) + 'px');
            }
            else {
                remove$6(elm, 'width');
                remove$6(parentElem, padding);
            }
        });
    };
    const updateSinkVisibility = (sinkElem, visible) => {
        if (visible) {
            remove$3(sinkElem, visibility.fadeOutClass);
            add$1(sinkElem, [visibility.transitionClass, visibility.fadeInClass]);
        }
        else {
            remove$3(sinkElem, visibility.fadeInClass);
            add$1(sinkElem, [visibility.fadeOutClass, visibility.transitionClass]);
        }
    };
    const updateEditorClasses = (editor, docked) => {
        const editorContainer = SugarElement.fromDom(editor.getContainer());
        if (docked) {
            add$2(editorContainer, editorStickyOnClass);
            remove$3(editorContainer, editorStickyOffClass);
        }
        else {
            add$2(editorContainer, editorStickyOffClass);
            remove$3(editorContainer, editorStickyOnClass);
        }
    };
    const restoreFocus = (headerElem, focusedElem) => {
        // When the header is hidden, then the element that was focused will be lost
        // so we need to restore it if nothing else has already been focused (eg anything other than the body)
        const ownerDoc = owner$4(focusedElem);
        active$1(ownerDoc).filter((activeElm) => 
        // Don't try to refocus the same element
        !eq(focusedElem, activeElm)).filter((activeElm) => 
        // Only attempt to refocus if the current focus is the body or is in the header element
        eq(activeElm, SugarElement.fromDom(ownerDoc.dom.body)) || contains(headerElem, activeElm)).each(() => focus$4(focusedElem));
    };
    const findFocusedElem = (rootElm, lazySink) => 
    // Check to see if an element is focused inside the header or inside the sink
    // and if so store the element so we can restore it later
    search(rootElm).orThunk(() => lazySink().toOptional().bind((sink) => search(sink.element)));
    const setup$9 = (editor, sharedBackstage, lazyHeader) => {
        if (!editor.inline) {
            // If using bottom toolbar then when the editor resizes we need to reset docking
            // otherwise it won't know the original toolbar position has moved
            if (!sharedBackstage.header.isPositionedAtTop()) {
                editor.on('ResizeEditor', () => {
                    lazyHeader().each(Docking.reset);
                });
            }
            // No need to update the content flow in inline mode as the header always floats
            editor.on('ResizeWindow ResizeEditor', () => {
                lazyHeader().each(updateIframeContentFlow);
            });
            // Need to reset the docking position on skin loaded as the original position will have
            // changed due the skins styles being applied.
            // Note: Inline handles it's own skin loading, as it needs to do other initial positioning
            editor.on('SkinLoaded', () => {
                lazyHeader().each((comp) => {
                    Docking.isDocked(comp) ? Docking.reset(comp) : Docking.refresh(comp);
                });
            });
            // Need to reset when we go fullscreen so that if the header is docked,
            // then it'll undock and viceversa
            editor.on('FullscreenStateChanged', () => {
                lazyHeader().each(Docking.reset);
            });
        }
        // If inline or sticky toolbars is enabled, then when scrolling into view we may still be
        // behind the editor header so we need to adjust the scroll position to account for that
        editor.on('AfterScrollIntoView', (e) => {
            lazyHeader().each((header) => {
                // We need to make sure the header docking has refreshed, otherwise if a large scroll occurred
                // the header may have gone off page and need to be docked before doing calculations
                Docking.refresh(header);
                // If the header element is still visible, then adjust the scroll position if required
                const headerElem = header.element;
                if (isVisible(headerElem)) {
                    scrollFromBehindHeader(e, headerElem);
                }
            });
        });
        // Update the editor classes once initial rendering has completed
        editor.on('PostRender', () => {
            updateEditorClasses(editor, false);
        });
    };
    const isDocked = (lazyHeader) => lazyHeader().map(Docking.isDocked).getOr(false);
    const getIframeBehaviours = () => [
        Receiving.config({
            channels: {
                [toolbarHeightChange()]: {
                    onReceive: updateIframeContentFlow
                }
            }
        })
    ];
    const getBehaviours = (editor, sharedBackstage) => {
        const focusedElm = value$2();
        const lazySink = sharedBackstage.getSink;
        const runOnSinkElement = (f) => {
            lazySink().each((sink) => f(sink.element));
        };
        const onDockingSwitch = (comp) => {
            if (!editor.inline) {
                updateIframeContentFlow(comp);
            }
            updateEditorClasses(editor, Docking.isDocked(comp));
            // TINY-9223: This will only reposition the popups in the same mothership as the StickyHeader
            // and its sink. If we need to reposition the popups in all motherships (in the two sink
            // model) then we'll need a reference to all motherships here.
            comp.getSystem().broadcastOn([repositionPopups()], {});
            lazySink().each((sink) => sink.getSystem().broadcastOn([repositionPopups()], {}));
        };
        const additionalBehaviours = editor.inline ? [] : getIframeBehaviours();
        return [
            Focusing.config({}),
            Docking.config({
                contextual: {
                    lazyContext: (comp) => {
                        const headerHeight = getOuter$1(comp.element);
                        const container = editor.inline ? editor.getContentAreaContainer() : editor.getContainer();
                        return Optional.from(container).map((c) => {
                            const box = box$1(SugarElement.fromDom(c));
                            const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);
                            return optScrollingContext.fold(() => {
                                // Force the header to hide before it overflows outside the container
                                const boxHeight = box.height - headerHeight;
                                const topBound = box.y + (isDockedMode(comp, 'top') ? 0 : headerHeight);
                                return bounds(box.x, topBound, box.width, boxHeight);
                            }, (scrollEnv) => {
                                const constrainedBounds = constrain(box, getBoundsFrom(scrollEnv));
                                // When the toolbar location is set to the top, y is the top of the container and height is the available container height minus the header height, as the toolbar will be placed at the top of the container
                                // This is so that as you scroll the scrollable container/the page, it will dock at the top and when there's insufficient height/space (that's the reason of deducting the headerHeight for the available height), it will be hidden.
                                // When the toolbar location is set to the bottom, y is the top of the container plus the header height, as the toolbar will be placed at the bottom of the container, beyond the container, so that's why we need to add the headerHeight
                                // When there's insufficient height/space, it will be hidden, and when you scroll past the editor, it will be hidden
                                const constrainedBoundsY = isDockedMode(comp, 'top')
                                    ? constrainedBounds.y
                                    : constrainedBounds.y + headerHeight;
                                return bounds(constrainedBounds.x, 
                                // ASSUMPTION: The constrainedBounds removes the need for us to set this to 0px
                                // for docked mode. Also, docking in a scrolling environment will often be
                                // at the scroller top, not the window top
                                constrainedBoundsY, constrainedBounds.width, constrainedBounds.height - headerHeight);
                            });
                        });
                    },
                    onShow: () => {
                        runOnSinkElement((elem) => updateSinkVisibility(elem, true));
                    },
                    onShown: (comp) => {
                        runOnSinkElement((elem) => remove$2(elem, [visibility.transitionClass, visibility.fadeInClass]));
                        // Restore focus and reset the stored focused element
                        focusedElm.get().each((elem) => {
                            restoreFocus(comp.element, elem);
                            focusedElm.clear();
                        });
                    },
                    onHide: (comp) => {
                        findFocusedElem(comp.element, lazySink).fold(focusedElm.clear, focusedElm.set);
                        runOnSinkElement((elem) => updateSinkVisibility(elem, false));
                    },
                    onHidden: () => {
                        runOnSinkElement((elem) => remove$2(elem, [visibility.transitionClass]));
                    },
                    ...visibility
                },
                lazyViewport: (comp) => {
                    const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);
                    return optScrollingContext.fold(() => {
                        const boundsWithoutOffset = win();
                        const offset = getStickyToolbarOffset(editor);
                        const top = boundsWithoutOffset.y + (isDockedMode(comp, 'top') && !isFullscreen(editor) ? offset : 0);
                        const height = boundsWithoutOffset.height - (isDockedMode(comp, 'bottom') ? offset : 0);
                        // No scrolling context, so just window
                        return {
                            bounds: bounds(boundsWithoutOffset.x, top, boundsWithoutOffset.width, height),
                            optScrollEnv: Optional.none()
                        };
                    }, (sc) => {
                        // TINY-9411: Implement sticky toolbar offsets in scrollable containers
                        const combinedBounds = getBoundsFrom(sc);
                        return {
                            bounds: combinedBounds,
                            optScrollEnv: Optional.some({
                                currentScrollTop: sc.element.dom.scrollTop,
                                scrollElmTop: absolute$3(sc.element).top
                            })
                        };
                    });
                },
                modes: [sharedBackstage.header.getDockingMode()],
                onDocked: onDockingSwitch,
                onUndocked: onDockingSwitch
            }),
            ...additionalBehaviours
        ];
    };

    var StickyHeader = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setup: setup$9,
        isDocked: isDocked,
        getBehaviours: getBehaviours
    });

    const renderHeader = (spec) => {
        const editor = spec.editor;
        const getBehaviours$2 = spec.sticky ? getBehaviours : getBehaviours$1;
        return {
            uid: spec.uid,
            dom: spec.dom,
            components: spec.components,
            behaviours: derive$1(getBehaviours$2(editor, spec.sharedBackstage))
        };
    };

    const factory$3 = (detail, spec) => {
        const setMenus = (comp, menus) => {
            const newMenus = map$2(menus, (m) => {
                const buttonSpec = {
                    type: 'menubutton',
                    text: m.text,
                    fetch: (callback) => {
                        callback(m.getItems());
                    },
                    context: 'any'
                };
                // Convert to an internal bridge spec
                const internal = createMenuButton(buttonSpec).mapError((errInfo) => formatError(errInfo)).getOrDie();
                return renderMenuButton(internal, "tox-mbtn" /* MenuButtonClasses.Button */, spec.backstage, 
                // https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-2/menubar-2.html
                Optional.some('menuitem'));
            });
            Replacing.set(comp, newMenus);
        };
        const apis = {
            focus: Keying.focusIn,
            setMenus
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: [],
            behaviours: derive$1([
                Replacing.config({}),
                config('menubar-events', [
                    runOnAttached((component) => {
                        detail.onSetup(component);
                    }),
                    run$1(mouseover(), (comp, se) => {
                        // TODO: Use constants
                        descendant(comp.element, '.' + "tox-mbtn--active" /* MenuButtonClasses.Active */).each((activeButton) => {
                            closest$3(se.event.target, '.' + "tox-mbtn" /* MenuButtonClasses.Button */).each((hoveredButton) => {
                                if (!eq(activeButton, hoveredButton)) {
                                    // Now, find the components, and expand the hovered one, and close the active one
                                    comp.getSystem().getByDom(activeButton).each((activeComp) => {
                                        comp.getSystem().getByDom(hoveredButton).each((hoveredComp) => {
                                            Dropdown.expand(hoveredComp);
                                            Dropdown.close(activeComp);
                                            Focusing.focus(hoveredComp);
                                        });
                                    });
                                }
                            });
                        });
                    }),
                    run$1(focusShifted(), (comp, se) => {
                        se.event.prevFocus.bind((prev) => comp.getSystem().getByDom(prev).toOptional()).each((prev) => {
                            se.event.newFocus.bind((nu) => comp.getSystem().getByDom(nu).toOptional()).each((nu) => {
                                if (Dropdown.isOpen(prev)) {
                                    Dropdown.expand(nu);
                                    Dropdown.close(prev);
                                }
                            });
                        });
                    })
                ]),
                Keying.config({
                    mode: 'flow',
                    selector: '.' + "tox-mbtn" /* MenuButtonClasses.Button */,
                    onEscape: (comp) => {
                        detail.onEscape(comp);
                        return Optional.some(true);
                    }
                }),
                Tabstopping.config({})
            ]),
            apis,
            domModification: {
                attributes: {
                    role: 'menubar'
                }
            }
        };
    };
    var SilverMenubar = single({
        factory: factory$3,
        name: 'silver.Menubar',
        configFields: [
            required$1('dom'),
            required$1('uid'),
            required$1('onEscape'),
            required$1('backstage'),
            defaulted('onSetup', noop)
        ],
        apis: {
            focus: (apis, comp) => {
                apis.focus(comp);
            },
            setMenus: (apis, comp, menus) => {
                apis.setMenus(comp, menus);
            }
        }
    });

    const promotionMessage = ' Get all features';
    const promotionLink = 'https://www.tiny.cloud/tinymce-upgrade-to-cloud/?utm_campaign=self_hosted_upgrade_promo&utm_source=tiny&utm_medium=referral';
    const renderPromotion = (spec) => {
        const components = spec.promotionLink ? [
            {
                dom: {
                    tag: 'a',
                    attributes: {
                        'href': promotionLink,
                        'rel': 'noopener',
                        'target': '_blank',
                        'aria-hidden': 'true'
                    },
                    classes: ['tox-promotion-link'],
                    innerHtml: promotionMessage
                }
            }
        ] : [];
        return {
            uid: spec.uid,
            dom: spec.dom,
            components
        };
    };

    const setup$8 = (editor) => {
        const { sidebars } = editor.ui.registry.getAll();
        // Setup each registered sidebar
        each$1(keys(sidebars), (name) => {
            const spec = sidebars[name];
            const isActive = () => is$1(Optional.from(editor.queryCommandValue('ToggleSidebar')), name);
            editor.ui.registry.addToggleButton(name, {
                icon: spec.icon,
                tooltip: spec.tooltip,
                onAction: (buttonApi) => {
                    editor.execCommand('ToggleSidebar', false, name);
                    buttonApi.setActive(isActive());
                },
                onSetup: (buttonApi) => {
                    buttonApi.setActive(isActive());
                    const handleToggle = () => buttonApi.setActive(isActive());
                    editor.on('ToggleSidebar', handleToggle);
                    return () => {
                        editor.off('ToggleSidebar', handleToggle);
                    };
                },
                context: 'any'
            });
        });
    };
    const getApi = (comp) => ({
        element: () => comp.element.dom
    });
    const makePanels = (parts, panelConfigs) => {
        const specs = map$2(keys(panelConfigs), (name) => {
            const spec = panelConfigs[name];
            const bridged = getOrDie(createSidebar(spec));
            return {
                name,
                getApi,
                onSetup: bridged.onSetup,
                onShow: bridged.onShow,
                onHide: bridged.onHide
            };
        });
        return map$2(specs, (spec) => {
            const editorOffCell = Cell(noop);
            return parts.slot(spec.name, {
                dom: {
                    tag: 'div',
                    classes: ['tox-sidebar__pane']
                },
                behaviours: SimpleBehaviours.unnamedEvents([
                    onControlAttached(spec, editorOffCell),
                    onControlDetached(spec, editorOffCell),
                    run$1(slotVisibility(), (sidepanel, se) => {
                        const data = se.event;
                        const optSidePanelSpec = find$5(specs, (config) => config.name === data.name);
                        optSidePanelSpec.each((sidePanelSpec) => {
                            const handler = data.visible ? sidePanelSpec.onShow : sidePanelSpec.onHide;
                            handler(sidePanelSpec.getApi(sidepanel));
                        });
                    })
                ])
            });
        });
    };
    const makeSidebar = (panelConfigs) => SlotContainer.sketch((parts) => ({
        dom: {
            tag: 'div',
            classes: ['tox-sidebar__pane-container']
        },
        components: makePanels(parts, panelConfigs),
        slotBehaviours: SimpleBehaviours.unnamedEvents([
            runOnAttached((slotContainer) => SlotContainer.hideAllSlots(slotContainer))
        ])
    }));
    const setSidebar = (sidebar, panelConfigs, showSidebar) => {
        const optSlider = Composing.getCurrent(sidebar);
        optSlider.each((slider) => {
            Replacing.set(slider, [makeSidebar(panelConfigs)]);
            // Show the default sidebar
            const configKey = showSidebar === null || showSidebar === void 0 ? void 0 : showSidebar.toLowerCase();
            if (isString(configKey) && has$2(panelConfigs, configKey)) {
                Composing.getCurrent(slider).each((slotContainer) => {
                    SlotContainer.showSlot(slotContainer, configKey);
                    Sliding.immediateGrow(slider);
                    // TINY-8710: Remove the width as since the skins/styles won't have loaded yet, so it's going to be incorrect
                    remove$6(slider.element, 'width');
                    updateSidebarRoleOnToggle(sidebar.element, "region" /* SidebarStateRoleAttr.Grown */);
                });
            }
        });
    };
    const updateSidebarRoleOnToggle = (sidebar, sidebarState) => {
        set$9(sidebar, 'role', sidebarState);
    };
    const toggleSidebar = (sidebar, name) => {
        const optSlider = Composing.getCurrent(sidebar);
        optSlider.each((slider) => {
            const optSlotContainer = Composing.getCurrent(slider);
            optSlotContainer.each((slotContainer) => {
                if (Sliding.hasGrown(slider)) {
                    if (SlotContainer.isShowing(slotContainer, name)) {
                        // close the slider and then hide the slot after the animation finishes
                        Sliding.shrink(slider);
                        updateSidebarRoleOnToggle(sidebar.element, "presentation" /* SidebarStateRoleAttr.Shrunk */);
                    }
                    else {
                        SlotContainer.hideAllSlots(slotContainer);
                        SlotContainer.showSlot(slotContainer, name);
                        updateSidebarRoleOnToggle(sidebar.element, "region" /* SidebarStateRoleAttr.Grown */);
                    }
                }
                else {
                    // Should already be hidden if the animation has finished but if it has not we hide them
                    SlotContainer.hideAllSlots(slotContainer);
                    SlotContainer.showSlot(slotContainer, name);
                    Sliding.grow(slider);
                    updateSidebarRoleOnToggle(sidebar.element, "region" /* SidebarStateRoleAttr.Grown */);
                }
            });
        });
    };
    const whichSidebar = (sidebar) => {
        const optSlider = Composing.getCurrent(sidebar);
        return optSlider.bind((slider) => {
            const sidebarOpen = Sliding.isGrowing(slider) || Sliding.hasGrown(slider);
            if (sidebarOpen) {
                const optSlotContainer = Composing.getCurrent(slider);
                return optSlotContainer.bind((slotContainer) => find$5(SlotContainer.getSlotNames(slotContainer), (name) => SlotContainer.isShowing(slotContainer, name)));
            }
            else {
                return Optional.none();
            }
        });
    };
    const fixSize = generate$6('FixSizeEvent');
    const autoSize = generate$6('AutoSizeEvent');
    const renderSidebar = (spec) => ({
        uid: spec.uid,
        dom: {
            tag: 'div',
            classes: ['tox-sidebar'],
            attributes: {
                role: "presentation" /* SidebarStateRoleAttr.Shrunk */
            }
        },
        components: [
            {
                dom: {
                    tag: 'div',
                    classes: ['tox-sidebar__slider']
                },
                components: [
                // this will be replaced on setSidebar
                ],
                behaviours: derive$1([
                    Tabstopping.config({}),
                    Focusing.config({}), // TODO use Keying and use focusIn, but need to handle if sidebar contains nothing
                    Sliding.config({
                        dimension: {
                            property: 'width'
                        },
                        closedClass: 'tox-sidebar--sliding-closed',
                        openClass: 'tox-sidebar--sliding-open',
                        shrinkingClass: 'tox-sidebar--sliding-shrinking',
                        growingClass: 'tox-sidebar--sliding-growing',
                        onShrunk: (slider) => {
                            const optSlotContainer = Composing.getCurrent(slider);
                            optSlotContainer.each(SlotContainer.hideAllSlots);
                            emit(slider, autoSize);
                        },
                        onGrown: (slider) => {
                            emit(slider, autoSize);
                        },
                        onStartGrow: (slider) => {
                            emitWith(slider, fixSize, { width: getRaw(slider.element, 'width').getOr('') });
                        },
                        onStartShrink: (slider) => {
                            emitWith(slider, fixSize, { width: get$c(slider.element) + 'px' });
                        }
                    }),
                    Replacing.config({}),
                    Composing.config({
                        find: (comp) => {
                            const children = Replacing.contents(comp);
                            return head(children);
                        }
                    })
                ])
            }
        ],
        behaviours: derive$1([
            ComposingConfigs.childAt(0),
            config('sidebar-sliding-events', [
                run$1(fixSize, (comp, se) => {
                    set$7(comp.element, 'width', se.event.width);
                }),
                run$1(autoSize, (comp, _se) => {
                    remove$6(comp.element, 'width');
                })
            ])
        ])
    });

    const getBusySpec$1 = (providerBackstage) => (_root, _behaviours) => ({
        dom: {
            tag: 'div',
            attributes: {
                'aria-label': providerBackstage.translate('Loading...'),
                'tabindex': '0'
            },
            classes: ['tox-throbber__busy-spinner']
        },
        components: [
            {
                dom: fromHtml('<div class="tox-spinner"><div></div><div></div><div></div></div>')
            }
        ],
    });
    const focusBusyComponent = (throbber) => Composing.getCurrent(throbber).each((comp) => focus$4(comp.element, true));
    // When the throbber is enabled, prevent the iframe from being part of the sequential keyboard navigation when Tabbing
    // TODO: TINY-7500 Only works for iframe mode at this stage
    const toggleEditorTabIndex = (editor, state) => {
        const tabIndexAttr = 'tabindex';
        const dataTabIndexAttr = `data-mce-${tabIndexAttr}`;
        Optional.from(editor.iframeElement)
            .map(SugarElement.fromDom)
            .each((iframe) => {
            if (state) {
                getOpt(iframe, tabIndexAttr).each((tabIndex) => set$9(iframe, dataTabIndexAttr, tabIndex));
                set$9(iframe, tabIndexAttr, -1);
            }
            else {
                remove$8(iframe, tabIndexAttr);
                getOpt(iframe, dataTabIndexAttr).each((tabIndex) => {
                    set$9(iframe, tabIndexAttr, tabIndex);
                    remove$8(iframe, dataTabIndexAttr);
                });
            }
        });
    };
    /*
    * If the throbber has been toggled on, only focus the throbber if the editor had focus as we don't to steal focus if it is on an input or dialog
    * If the throbber has been toggled off, only put focus back on the editor if the throbber had focus.
    * The next logical focus transition from the throbber is to put it back on the editor
    */
    const toggleThrobber = (editor, comp, state, providerBackstage) => {
        const element = comp.element;
        toggleEditorTabIndex(editor, state);
        if (state) {
            Blocking.block(comp, getBusySpec$1(providerBackstage));
            remove$6(element, 'display');
            remove$8(element, 'aria-hidden');
            if (editor.hasFocus()) {
                focusBusyComponent(comp);
            }
        }
        else {
            // Get the focus of the busy component before it is removed from the DOM
            const throbberFocus = Composing.getCurrent(comp).exists((busyComp) => hasFocus(busyComp.element));
            Blocking.unblock(comp);
            set$7(element, 'display', 'none');
            set$9(element, 'aria-hidden', 'true');
            if (throbberFocus) {
                editor.focus();
            }
        }
    };
    const renderThrobber = (spec) => ({
        uid: spec.uid,
        dom: {
            tag: 'div',
            attributes: {
                'aria-hidden': 'true'
            },
            classes: ['tox-throbber'],
            styles: {
                display: 'none'
            }
        },
        behaviours: derive$1([
            Replacing.config({}),
            Blocking.config({
                focus: false
            }),
            Composing.config({
                find: (comp) => head(comp.components())
            })
        ]),
        components: []
    });
    const isFocusEvent = (event) => event.type === 'focusin';
    const isPasteBinTarget = (event) => {
        if (isFocusEvent(event)) {
            const node = event.composed ? head(event.composedPath()) : Optional.from(event.target);
            return node
                .map(SugarElement.fromDom)
                .filter(isElement$1)
                .exists((targetElm) => has(targetElm, 'mce-pastebin'));
        }
        else {
            return false;
        }
    };
    const setup$7 = (editor, lazyThrobber, sharedBackstage) => {
        const throbberState = Cell(false);
        const timer = value$2();
        const stealFocus = (e) => {
            if (throbberState.get() && !isPasteBinTarget(e)) {
                e.preventDefault();
                focusBusyComponent(lazyThrobber());
                editor.editorManager.setActive(editor);
            }
        };
        // TODO: TINY-7500 Only worrying about iframe mode at this stage since inline mode has a number of other issues
        if (!editor.inline) {
            editor.on('PreInit', () => {
                // Cover focus when the editor is focused natively
                editor.dom.bind(editor.getWin(), 'focusin', stealFocus);
                // Cover stealing focus when editor.focus() is called
                editor.on('BeforeExecCommand', (e) => {
                    // If skipFocus is specified as true in the command, don't focus the Throbber
                    if (e.command.toLowerCase() === 'mcefocus' && e.value !== true) {
                        stealFocus(e);
                    }
                });
            });
        }
        const toggle = (state) => {
            if (state !== throbberState.get()) {
                throbberState.set(state);
                toggleThrobber(editor, lazyThrobber(), state, sharedBackstage.providers);
                fireAfterProgressState(editor, state);
            }
        };
        editor.on('ProgressState', (e) => {
            timer.on(clearTimeout);
            if (isNumber(e.time)) {
                const timerId = global$a.setEditorTimeout(editor, () => toggle(e.state), e.time);
                timer.set(timerId);
            }
            else {
                toggle(e.state);
                timer.clear();
            }
        });
    };

    const renderToolbarGroupCommon = (toolbarGroup) => {
        const attributes = toolbarGroup.label.isNone() ?
            toolbarGroup.title.fold(() => ({}), (title) => ({ attributes: { 'aria-label': title } }))
            : toolbarGroup.label.fold(() => ({}), (label) => ({ attributes: { 'aria-label': label } }));
        return {
            dom: {
                tag: 'div',
                classes: ['tox-toolbar__group'].concat(toolbarGroup.label.isSome() ? ['tox-toolbar__group_with_label'] : []),
                ...attributes
            },
            components: [
                ...(toolbarGroup.label.map((label) => {
                    return {
                        dom: {
                            tag: 'span',
                            classes: ['tox-label', 'tox-label--context-toolbar'],
                        },
                        components: [text$2(label)]
                    };
                }).toArray()),
                ToolbarGroup.parts.items({})
            ],
            items: toolbarGroup.items,
            markers: {
                // nav within a group breaks if disabled buttons are first in their group so skip them
                itemSelector: '.tox-tbtn:not([disabled]), ' +
                    '.tox-toolbar-nav-item:not([disabled]), ' +
                    '.tox-number-input:not([disabled])'
            },
            tgroupBehaviours: derive$1([
                Tabstopping.config({}),
                Focusing.config({
                    ignore: true
                })
            ])
        };
    };
    const renderToolbarGroup = (toolbarGroup) => ToolbarGroup.sketch(renderToolbarGroupCommon(toolbarGroup));
    const getToolbarBehaviours = (toolbarSpec, modeName) => {
        const onAttached = runOnAttached((component) => {
            const groups = map$2(toolbarSpec.initGroups, renderToolbarGroup);
            Toolbar.setGroups(component, groups);
        });
        return derive$1([
            DisablingConfigs.toolbarButton(() => toolbarSpec.providers.checkUiComponentContext('any').shouldDisable),
            toggleOnReceive(() => toolbarSpec.providers.checkUiComponentContext('any')),
            Keying.config({
                // Tabs between groups
                mode: modeName,
                onEscape: toolbarSpec.onEscape,
                visibilitySelector: '.tox-toolbar__overflow',
                selector: '.tox-toolbar__group'
            }),
            config('toolbar-events', [onAttached])
        ]);
    };
    const renderMoreToolbarCommon = (toolbarSpec) => {
        const modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';
        return {
            uid: toolbarSpec.uid,
            dom: {
                tag: 'div',
                classes: ['tox-toolbar-overlord']
            },
            parts: {
                // This already knows it is a toolbar group
                'overflow-group': renderToolbarGroupCommon({
                    title: Optional.none(),
                    label: Optional.none(),
                    items: []
                }),
                'overflow-button': renderIconButtonSpec({
                    context: 'any',
                    name: 'more',
                    icon: Optional.some('more-drawer'),
                    enabled: true,
                    tooltip: Optional.some('Reveal or hide additional toolbar items'),
                    primary: false,
                    buttonType: Optional.none(),
                    borderless: false
                }, Optional.none(), toolbarSpec.providers, [], 'overflow-button')
            },
            splitToolbarBehaviours: getToolbarBehaviours(toolbarSpec, modeName)
        };
    };
    const renderFloatingMoreToolbar = (toolbarSpec) => {
        const baseSpec = renderMoreToolbarCommon(toolbarSpec);
        const overflowXOffset = 4;
        const primary = SplitFloatingToolbar.parts.primary({
            dom: {
                tag: 'div',
                classes: ['tox-toolbar__primary']
            }
        });
        return SplitFloatingToolbar.sketch({
            ...baseSpec,
            lazySink: toolbarSpec.getSink,
            getOverflowBounds: () => {
                // Restrict the left/right bounds to the editor header width, but don't restrict the top/bottom
                const headerElem = toolbarSpec.moreDrawerData.lazyHeader().element;
                const headerBounds = absolute$2(headerElem);
                const docElem = documentElement(headerElem);
                const docBounds = absolute$2(docElem);
                const height = Math.max(docElem.dom.scrollHeight, docBounds.height);
                return bounds(headerBounds.x + overflowXOffset, docBounds.y, headerBounds.width - overflowXOffset * 2, height);
            },
            parts: {
                ...baseSpec.parts,
                overflow: {
                    dom: {
                        tag: 'div',
                        classes: ['tox-toolbar__overflow'],
                        attributes: toolbarSpec.attributes
                    }
                }
            },
            components: [primary],
            markers: {
                overflowToggledClass: "tox-tbtn--enabled" /* ToolbarButtonClasses.Ticked */
            },
            onOpened: (comp) => toolbarSpec.onToggled(comp, true),
            onClosed: (comp) => toolbarSpec.onToggled(comp, false)
        });
    };
    const renderSlidingMoreToolbar = (toolbarSpec) => {
        const primary = SplitSlidingToolbar.parts.primary({
            dom: {
                tag: 'div',
                classes: ['tox-toolbar__primary']
            }
        });
        const overflow = SplitSlidingToolbar.parts.overflow({
            dom: {
                tag: 'div',
                classes: ['tox-toolbar__overflow']
            }
        });
        const baseSpec = renderMoreToolbarCommon(toolbarSpec);
        return SplitSlidingToolbar.sketch({
            ...baseSpec,
            components: [primary, overflow],
            markers: {
                openClass: 'tox-toolbar__overflow--open',
                closedClass: 'tox-toolbar__overflow--closed',
                growingClass: 'tox-toolbar__overflow--growing',
                shrinkingClass: 'tox-toolbar__overflow--shrinking',
                overflowToggledClass: "tox-tbtn--enabled" /* ToolbarButtonClasses.Ticked */
            },
            onOpened: (comp) => {
                // TINY-9223: This will only broadcast to the same mothership as the toolbar
                comp.getSystem().broadcastOn([toolbarHeightChange()], { type: 'opened' });
                toolbarSpec.onToggled(comp, true);
            },
            onClosed: (comp) => {
                // TINY-9223: This will only broadcast to the same mothership as the toolbar
                comp.getSystem().broadcastOn([toolbarHeightChange()], { type: 'closed' });
                toolbarSpec.onToggled(comp, false);
            }
        });
    };
    const renderToolbar = (toolbarSpec) => {
        const modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';
        return Toolbar.sketch({
            uid: toolbarSpec.uid,
            dom: {
                tag: 'div',
                classes: ['tox-toolbar'].concat(toolbarSpec.type === ToolbarMode$1.scrolling ? ['tox-toolbar--scrolling'] : [])
            },
            components: [
                Toolbar.parts.groups({})
            ],
            toolbarBehaviours: getToolbarBehaviours(toolbarSpec, modeName)
        });
    };

    const renderButton = (spec, providers) => {
        var _a, _b;
        const isToggleButton = spec.type === 'togglebutton';
        const optMemIcon = spec.icon
            .map((memIcon) => renderReplaceableIconFromPack(memIcon, providers.icons))
            .map(record);
        const getAction = () => (comp) => {
            const setIcon = (newIcon) => {
                optMemIcon.map((memIcon) => memIcon.getOpt(comp).each((displayIcon) => {
                    Replacing.set(displayIcon, [
                        renderReplaceableIconFromPack(newIcon, providers.icons)
                    ]);
                }));
            };
            const setActive = (state) => {
                const elm = comp.element;
                if (state) {
                    add$2(elm, "tox-button--enabled" /* ViewButtonClasses.Ticked */);
                    set$9(elm, 'aria-pressed', true);
                }
                else {
                    remove$3(elm, "tox-button--enabled" /* ViewButtonClasses.Ticked */);
                    remove$8(elm, 'aria-pressed');
                }
            };
            const isActive = () => has(comp.element, "tox-button--enabled" /* ViewButtonClasses.Ticked */);
            const focus = () => focus$4(comp.element);
            if (isToggleButton) {
                return spec.onAction({ setIcon, setActive, isActive, focus });
            }
            if (spec.type === 'button') {
                return spec.onAction({ setIcon });
            }
        };
        const action = getAction();
        const buttonSpec = {
            ...spec,
            name: isToggleButton ? spec.text.getOr(spec.icon.getOr('')) : (_a = spec.text) !== null && _a !== void 0 ? _a : spec.icon.getOr(''),
            primary: spec.buttonType === 'primary',
            buttonType: Optional.from(spec.buttonType),
            tooltip: spec.tooltip,
            icon: spec.icon,
            enabled: true,
            borderless: spec.borderless
        };
        const buttonTypeClasses = calculateClassesFromButtonType((_b = spec.buttonType) !== null && _b !== void 0 ? _b : 'secondary');
        const optTranslatedText = isToggleButton ? spec.text.map(providers.translate) : Optional.some(providers.translate(spec.text));
        const optTranslatedTextComponed = optTranslatedText.map(text$2);
        const ariaLabelAttributes = buttonSpec.tooltip.or(optTranslatedText).map((al) => ({
            'aria-label': providers.translate(al),
        })).getOr({});
        const optIconSpec = optMemIcon.map((memIcon) => memIcon.asSpec());
        const components = componentRenderPipeline([optIconSpec, optTranslatedTextComponed]);
        const hasIconAndText = spec.icon.isSome() && optTranslatedTextComponed.isSome();
        const dom = {
            tag: 'button',
            classes: buttonTypeClasses
                .concat(...spec.icon.isSome() && !hasIconAndText ? ['tox-button--icon'] : [])
                .concat(...hasIconAndText ? ['tox-button--icon-and-text'] : [])
                .concat(...spec.borderless ? ['tox-button--naked'] : [])
                .concat(...spec.type === 'togglebutton' && spec.active ? ["tox-button--enabled" /* ViewButtonClasses.Ticked */] : []),
            attributes: ariaLabelAttributes
        };
        const extraBehaviours = [];
        const iconButtonSpec = renderCommonSpec(buttonSpec, Optional.some(action), extraBehaviours, dom, components, spec.tooltip, providers);
        return Button.sketch(iconButtonSpec);
    };

    const renderViewButton = (spec, providers) => renderButton(spec, providers);
    const renderButtonsGroup = (spec, providers) => {
        return {
            dom: {
                tag: 'div',
                classes: ['tox-view__toolbar__group'],
            },
            components: map$2(spec.buttons, (button) => renderViewButton(button, providers))
        };
    };
    const deviceDetection = detect$1().deviceType;
    const isPhone = deviceDetection.isPhone();
    const isTablet = deviceDetection.isTablet();
    const renderViewHeader = (spec) => {
        let hasGroups = false;
        const endButtons = map$2(spec.buttons, (btnspec) => {
            if (btnspec.type === 'group') {
                hasGroups = true;
                return renderButtonsGroup(btnspec, spec.providers);
            }
            else {
                return renderViewButton(btnspec, spec.providers);
            }
        });
        return {
            uid: spec.uid,
            dom: {
                tag: 'div',
                classes: [
                    !hasGroups ? 'tox-view__header' : 'tox-view__toolbar',
                    ...(isPhone || isTablet ? ['tox-view--mobile', 'tox-view--scrolling'] : [])
                ]
            },
            behaviours: derive$1([
                Focusing.config({}),
                Keying.config({
                    mode: 'flow',
                    selector: 'button, .tox-button',
                    focusInside: FocusInsideModes.OnEnterOrSpaceMode
                })
            ]),
            components: hasGroups ?
                endButtons
                : [
                    Container.sketch({
                        dom: {
                            tag: 'div',
                            classes: ['tox-view__header-start']
                        },
                        components: []
                    }),
                    Container.sketch({
                        dom: {
                            tag: 'div',
                            classes: ['tox-view__header-end']
                        },
                        components: endButtons
                    })
                ]
        };
    };
    const renderViewPane = (spec) => {
        return {
            uid: spec.uid,
            behaviours: derive$1([
                Focusing.config({}),
                Tabstopping.config({})
            ]),
            dom: {
                tag: 'div',
                classes: ['tox-view__pane']
            }
        };
    };
    const factory$2 = (detail, components, _spec, _externals) => {
        const apis = {
            getPane: (comp) => parts$g.getPart(comp, detail, 'pane'),
            getOnShow: (_comp) => detail.viewConfig.onShow,
            getOnHide: (_comp) => detail.viewConfig.onHide,
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: derive$1([
                Focusing.config({}),
                Keying.config({
                    mode: 'cyclic',
                    focusInside: FocusInsideModes.OnEnterOrSpaceMode
                })
            ]),
            apis
        };
    };
    var View = composite({
        name: 'silver.View',
        configFields: [
            required$1('viewConfig'),
        ],
        partFields: [
            optional({
                factory: {
                    sketch: renderViewHeader
                },
                schema: [
                    required$1('buttons'),
                    required$1('providers')
                ],
                name: 'header'
            }),
            optional({
                factory: {
                    sketch: renderViewPane
                },
                schema: [],
                name: 'pane'
            })
        ],
        factory: factory$2,
        apis: {
            getPane: (apis, comp) => apis.getPane(comp),
            getOnShow: (apis, comp) => apis.getOnShow(comp),
            getOnHide: (apis, comp) => apis.getOnHide(comp)
        }
    });

    const makeViews = (parts, viewConfigs, providers) => {
        return mapToArray(viewConfigs, (config, name) => {
            const internalViewConfig = getOrDie(createView(config));
            return parts.slot(name, View.sketch({
                dom: {
                    tag: 'div',
                    classes: ['tox-view']
                },
                viewConfig: internalViewConfig,
                components: [
                    ...internalViewConfig.buttons.length > 0 ? [
                        View.parts.header({
                            buttons: internalViewConfig.buttons,
                            providers
                        })
                    ] : [],
                    View.parts.pane({})
                ]
            }));
        });
    };
    const makeSlotContainer = (viewConfigs, providers) => SlotContainer.sketch((parts) => ({
        dom: {
            tag: 'div',
            classes: ['tox-view-wrap__slot-container']
        },
        components: makeViews(parts, viewConfigs, providers),
        slotBehaviours: SimpleBehaviours.unnamedEvents([
            runOnAttached((slotContainer) => SlotContainer.hideAllSlots(slotContainer))
        ])
    }));
    const getCurrentName = (slotContainer) => {
        return find$5(SlotContainer.getSlotNames(slotContainer), (name) => SlotContainer.isShowing(slotContainer, name));
    };
    const hideContainer = (comp) => {
        const element = comp.element;
        set$7(element, 'display', 'none');
        set$9(element, 'aria-hidden', 'true');
    };
    const showContainer = (comp) => {
        const element = comp.element;
        remove$6(element, 'display');
        remove$8(element, 'aria-hidden');
    };
    const makeViewInstanceApi = (slot) => ({
        getContainer: constant$1(slot)
    });
    const runOnPaneWithInstanceApi = (slotContainer, name, get) => {
        SlotContainer.getSlot(slotContainer, name).each((view) => {
            View.getPane(view).each((pane) => {
                const onCallback = get(view);
                onCallback(makeViewInstanceApi(pane.element.dom));
            });
        });
    };
    const runOnShow = (slotContainer, name) => runOnPaneWithInstanceApi(slotContainer, name, View.getOnShow);
    const runOnHide = (slotContainer, name) => runOnPaneWithInstanceApi(slotContainer, name, View.getOnHide);
    const factory$1 = (detail, spec) => {
        const setViews = (comp, viewConfigs) => {
            Replacing.set(comp, [makeSlotContainer(viewConfigs, spec.backstage.shared.providers)]);
        };
        const whichView = (comp) => {
            return Composing.getCurrent(comp).bind(getCurrentName);
        };
        const toggleView = (comp, showMainView, hideMainView, name) => {
            return Composing.getCurrent(comp).exists((slotContainer) => {
                const optCurrentSlotName = getCurrentName(slotContainer);
                const isTogglingCurrentView = optCurrentSlotName.exists((current) => name === current);
                const exists = SlotContainer.getSlot(slotContainer, name).isSome();
                if (exists) {
                    SlotContainer.hideAllSlots(slotContainer);
                    if (!isTogglingCurrentView) {
                        hideMainView();
                        showContainer(comp);
                        SlotContainer.showSlot(slotContainer, name);
                        runOnShow(slotContainer, name);
                    }
                    else {
                        hideContainer(comp);
                        showMainView();
                    }
                    optCurrentSlotName.each((prevName) => runOnHide(slotContainer, prevName));
                }
                return exists;
            });
        };
        const apis = {
            setViews,
            whichView,
            toggleView
        };
        return {
            uid: detail.uid,
            dom: {
                tag: 'div',
                classes: ['tox-view-wrap'],
                attributes: { 'aria-hidden': 'true' },
                styles: { display: 'none' }
            },
            components: [
            // this will be replaced on setViews
            ],
            behaviours: derive$1([
                Replacing.config({}),
                Composing.config({
                    find: (comp) => {
                        const children = Replacing.contents(comp);
                        return head(children);
                    }
                })
            ]),
            apis
        };
    };
    var ViewWrapper = single({
        factory: factory$1,
        name: 'silver.ViewWrapper',
        configFields: [
            required$1('backstage')
        ],
        apis: {
            setViews: (apis, comp, views) => apis.setViews(comp, views),
            toggleView: (apis, comp, outerContainer, editorCont, name) => apis.toggleView(comp, outerContainer, editorCont, name),
            whichView: (apis, comp) => apis.whichView(comp)
        }
    });

    const factory = (detail, components, _spec) => {
        let toolbarDrawerOpenState = false;
        const toggleStatusbar = (editorContainer) => {
            sibling(editorContainer, '.tox-statusbar').each((statusBar) => {
                if (get$e(statusBar, 'display') === 'none' && get$g(statusBar, 'aria-hidden') === 'true') {
                    remove$6(statusBar, 'display');
                    remove$8(statusBar, 'aria-hidden');
                }
                else {
                    set$7(statusBar, 'display', 'none');
                    set$9(statusBar, 'aria-hidden', 'true');
                }
            });
        };
        const apis = {
            getSocket: (comp) => {
                return parts$g.getPart(comp, detail, 'socket');
            },
            setSidebar: (comp, panelConfigs, showSidebar) => {
                parts$g.getPart(comp, detail, 'sidebar').each((sidebar) => setSidebar(sidebar, panelConfigs, showSidebar));
            },
            toggleSidebar: (comp, name) => {
                parts$g.getPart(comp, detail, 'sidebar').each((sidebar) => toggleSidebar(sidebar, name));
            },
            whichSidebar: (comp) => {
                return parts$g.getPart(comp, detail, 'sidebar').bind(whichSidebar).getOrNull();
            },
            getHeader: (comp) => {
                return parts$g.getPart(comp, detail, 'header');
            },
            getToolbar: (comp) => {
                return parts$g.getPart(comp, detail, 'toolbar');
            },
            setToolbar: (comp, groups) => {
                parts$g.getPart(comp, detail, 'toolbar').each((toolbar) => {
                    const renderedGroups = map$2(groups, renderToolbarGroup);
                    toolbar.getApis().setGroups(toolbar, renderedGroups);
                });
            },
            setToolbars: (comp, toolbars) => {
                parts$g.getPart(comp, detail, 'multiple-toolbar').each((mToolbar) => {
                    const renderedToolbars = map$2(toolbars, (g) => map$2(g, renderToolbarGroup));
                    CustomList.setItems(mToolbar, renderedToolbars);
                });
            },
            refreshToolbar: (comp) => {
                const toolbar = parts$g.getPart(comp, detail, 'toolbar');
                toolbar.each((toolbar) => toolbar.getApis().refresh(toolbar));
            },
            toggleToolbarDrawer: (comp) => {
                parts$g.getPart(comp, detail, 'toolbar').each((toolbar) => {
                    mapFrom(toolbar.getApis().toggle, (toggle) => toggle(toolbar));
                });
            },
            toggleToolbarDrawerWithoutFocusing: (comp) => {
                parts$g.getPart(comp, detail, 'toolbar').each((toolbar) => {
                    mapFrom(toolbar.getApis().toggleWithoutFocusing, (toggleWithoutFocusing) => toggleWithoutFocusing(toolbar));
                });
            },
            isToolbarDrawerToggled: (comp) => {
                // isOpen may not be defined on all toolbars e.g. 'scrolling' and 'wrap'
                return parts$g.getPart(comp, detail, 'toolbar')
                    .bind((toolbar) => Optional.from(toolbar.getApis().isOpen).map((isOpen) => isOpen(toolbar)))
                    .getOr(false);
            },
            getThrobber: (comp) => {
                return parts$g.getPart(comp, detail, 'throbber');
            },
            focusToolbar: (comp) => {
                const optToolbar = parts$g.getPart(comp, detail, 'toolbar').orThunk(() => parts$g.getPart(comp, detail, 'multiple-toolbar'));
                optToolbar.each((toolbar) => {
                    Keying.focusIn(toolbar);
                });
            },
            setMenubar: (comp, menus) => {
                parts$g.getPart(comp, detail, 'menubar').each((menubar) => {
                    SilverMenubar.setMenus(menubar, menus);
                });
            },
            focusMenubar: (comp) => {
                parts$g.getPart(comp, detail, 'menubar').each((menubar) => {
                    SilverMenubar.focus(menubar);
                });
            },
            setViews: (comp, viewConfigs) => {
                parts$g.getPart(comp, detail, 'viewWrapper').each((wrapper) => {
                    ViewWrapper.setViews(wrapper, viewConfigs);
                });
            },
            toggleView: (comp, name) => {
                return parts$g.getPart(comp, detail, 'viewWrapper').exists((wrapper) => ViewWrapper.toggleView(wrapper, () => apis.showMainView(comp), () => apis.hideMainView(comp), name));
            },
            whichView: (comp) => {
                return parts$g.getPart(comp, detail, 'viewWrapper').bind(ViewWrapper.whichView).getOrNull();
            },
            hideMainView: (comp) => {
                toolbarDrawerOpenState = apis.isToolbarDrawerToggled(comp);
                if (toolbarDrawerOpenState) {
                    apis.toggleToolbarDrawer(comp);
                }
                parts$g.getPart(comp, detail, 'editorContainer').each((editorContainer) => {
                    const element = editorContainer.element;
                    toggleStatusbar(element);
                    set$7(element, 'display', 'none');
                    set$9(element, 'aria-hidden', 'true');
                });
            },
            showMainView: (comp) => {
                if (toolbarDrawerOpenState) {
                    apis.toggleToolbarDrawer(comp);
                }
                parts$g.getPart(comp, detail, 'editorContainer').each((editorContainer) => {
                    const element = editorContainer.element;
                    toggleStatusbar(element);
                    remove$6(element, 'display');
                    remove$8(element, 'aria-hidden');
                });
            }
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            apis,
            behaviours: detail.behaviours
        };
    };
    const partMenubar = partType$1.optional({
        factory: SilverMenubar,
        name: 'menubar',
        schema: [
            required$1('backstage')
        ]
    });
    const toolbarFactory = (spec) => {
        if (spec.type === ToolbarMode$1.sliding) {
            return renderSlidingMoreToolbar;
        }
        else if (spec.type === ToolbarMode$1.floating) {
            return renderFloatingMoreToolbar;
        }
        else {
            return renderToolbar;
        }
    };
    const partMultipleToolbar = partType$1.optional({
        factory: {
            sketch: (spec) => CustomList.sketch({
                uid: spec.uid,
                dom: spec.dom,
                listBehaviours: derive$1([
                    Keying.config({
                        mode: 'acyclic',
                        selector: '.tox-toolbar'
                    })
                ]),
                makeItem: () => renderToolbar({
                    type: spec.type,
                    uid: generate$6('multiple-toolbar-item'),
                    cyclicKeying: false,
                    initGroups: [],
                    providers: spec.providers,
                    onEscape: () => {
                        spec.onEscape();
                        return Optional.some(true);
                    }
                }),
                setupItem: (_mToolbar, tc, data, _index) => {
                    Toolbar.setGroups(tc, data);
                },
                shell: true
            })
        },
        name: 'multiple-toolbar',
        schema: [
            required$1('dom'),
            required$1('onEscape')
        ]
    });
    const partToolbar = partType$1.optional({
        factory: {
            sketch: (spec) => {
                const renderer = toolbarFactory(spec);
                const toolbarSpec = {
                    type: spec.type,
                    uid: spec.uid,
                    onEscape: () => {
                        spec.onEscape();
                        return Optional.some(true);
                    },
                    onToggled: (_comp, state) => spec.onToolbarToggled(state),
                    cyclicKeying: false,
                    initGroups: [],
                    getSink: spec.getSink,
                    providers: spec.providers,
                    moreDrawerData: {
                        lazyToolbar: spec.lazyToolbar,
                        lazyMoreButton: spec.lazyMoreButton,
                        lazyHeader: spec.lazyHeader
                    },
                    attributes: spec.attributes
                };
                return renderer(toolbarSpec);
            }
        },
        name: 'toolbar',
        schema: [
            required$1('dom'),
            required$1('onEscape'),
            required$1('getSink')
        ]
    });
    const partHeader = partType$1.optional({
        factory: {
            sketch: renderHeader
        },
        name: 'header',
        schema: [
            required$1('dom')
        ]
    });
    const partPromotion = partType$1.optional({
        factory: {
            sketch: renderPromotion
        },
        name: 'promotion',
        schema: [
            required$1('dom'),
            required$1('promotionLink')
        ]
    });
    const partSocket = partType$1.optional({
        // factory: Fun.identity,
        name: 'socket',
        schema: [
            required$1('dom')
        ]
    });
    const partSidebar = partType$1.optional({
        factory: {
            sketch: renderSidebar
        },
        name: 'sidebar',
        schema: [
            required$1('dom')
        ]
    });
    const partThrobber = partType$1.optional({
        factory: {
            sketch: renderThrobber
        },
        name: 'throbber',
        schema: [
            required$1('dom')
        ]
    });
    const partViewWrapper = partType$1.optional({
        factory: ViewWrapper,
        name: 'viewWrapper',
        schema: [
            required$1('backstage')
        ]
    });
    const renderEditorContainer = (spec) => ({
        uid: spec.uid,
        dom: {
            tag: 'div',
            classes: ['tox-editor-container']
        },
        components: spec.components
    });
    const partEditorContainer = partType$1.optional({
        factory: {
            sketch: renderEditorContainer
        },
        name: 'editorContainer',
        schema: []
    });
    var OuterContainer = composite({
        name: 'OuterContainer',
        factory,
        configFields: [
            required$1('dom'),
            required$1('behaviours')
        ],
        partFields: [
            partHeader,
            partMenubar,
            partToolbar,
            partMultipleToolbar,
            partSocket,
            partSidebar,
            partPromotion,
            partThrobber,
            partViewWrapper,
            partEditorContainer
        ],
        apis: {
            getSocket: (apis, comp) => {
                return apis.getSocket(comp);
            },
            setSidebar: (apis, comp, panelConfigs, showSidebar) => {
                apis.setSidebar(comp, panelConfigs, showSidebar);
            },
            toggleSidebar: (apis, comp, name) => {
                apis.toggleSidebar(comp, name);
            },
            whichSidebar: (apis, comp) => {
                return apis.whichSidebar(comp);
            },
            getHeader: (apis, comp) => {
                return apis.getHeader(comp);
            },
            getToolbar: (apis, comp) => {
                return apis.getToolbar(comp);
            },
            setToolbar: (apis, comp, groups) => {
                apis.setToolbar(comp, groups);
            },
            setToolbars: (apis, comp, toolbars) => {
                apis.setToolbars(comp, toolbars);
            },
            refreshToolbar: (apis, comp) => {
                return apis.refreshToolbar(comp);
            },
            toggleToolbarDrawer: (apis, comp) => {
                apis.toggleToolbarDrawer(comp);
            },
            toggleToolbarDrawerWithoutFocusing: (apis, comp) => {
                apis.toggleToolbarDrawerWithoutFocusing(comp);
            },
            isToolbarDrawerToggled: (apis, comp) => {
                return apis.isToolbarDrawerToggled(comp);
            },
            getThrobber: (apis, comp) => {
                return apis.getThrobber(comp);
            },
            // FIX: Dupe
            setMenubar: (apis, comp, menus) => {
                apis.setMenubar(comp, menus);
            },
            focusMenubar: (apis, comp) => {
                apis.focusMenubar(comp);
            },
            focusToolbar: (apis, comp) => {
                apis.focusToolbar(comp);
            },
            setViews: (apis, comp, views) => {
                apis.setViews(comp, views);
            },
            toggleView: (apis, comp, name) => {
                return apis.toggleView(comp, name);
            },
            whichView: (apis, comp) => {
                return apis.whichView(comp);
            },
        }
    });

    const defaultMenubar = 'file edit view insert format tools table help';
    const defaultMenus = {
        file: { title: 'File', items: 'newdocument restoredraft | preview | importword exportpdf exportword | export print | deleteallconversations' },
        edit: { title: 'Edit', items: 'undo redo | cut copy paste pastetext | selectall | searchreplace' },
        view: { title: 'View', items: 'code suggestededits revisionhistory | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments' },
        insert: { title: 'Insert', items: 'image link media addcomment pageembed inserttemplate codesample inserttable accordion math | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime' },
        format: { title: 'Format', items: 'bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat' },
        tools: { title: 'Tools', items: 'aidialog aishortcuts | spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate' },
        table: { title: 'Table', items: 'inserttable | cell row column | advtablesort | tableprops deletetable' },
        help: { title: 'Help', items: 'help' }
    };
    const make = (menu, registry, editor) => {
        const removedMenuItems = getRemovedMenuItems(editor).split(/[ ,]/);
        return {
            text: menu.title,
            getItems: () => bind$3(menu.items, (i) => {
                const itemName = i.toLowerCase();
                if (itemName.trim().length === 0) {
                    return [];
                }
                else if (exists(removedMenuItems, (removedMenuItem) => removedMenuItem === itemName)) {
                    return [];
                }
                else if (itemName === 'separator' || itemName === '|') {
                    return [{
                            type: 'separator'
                        }];
                }
                else if (registry.menuItems[itemName]) {
                    return [registry.menuItems[itemName]];
                }
                else {
                    return [];
                }
            })
        };
    };
    const parseItemsString = (items) => {
        return items.split(' ');
    };
    const identifyMenus = (editor, registry) => {
        const rawMenuData = { ...defaultMenus, ...registry.menus };
        const userDefinedMenus = keys(registry.menus).length > 0;
        const menubar = registry.menubar === undefined || registry.menubar === true ? parseItemsString(defaultMenubar) : parseItemsString(registry.menubar === false ? '' : registry.menubar);
        const validMenus = filter$2(menubar, (menuName) => {
            const isDefaultMenu = has$2(defaultMenus, menuName);
            if (userDefinedMenus) {
                return isDefaultMenu || get$h(registry.menus, menuName).exists((menu) => has$2(menu, 'items'));
            }
            else {
                return isDefaultMenu;
            }
        });
        const menus = map$2(validMenus, (menuName) => {
            const menuData = rawMenuData[menuName];
            return make({ title: menuData.title, items: parseItemsString(menuData.items) }, registry, editor);
        });
        return filter$2(menus, (menu) => {
            // Filter out menus that have no items, or only separators
            const isNotSeparator = (item) => isString(item) || item.type !== 'separator';
            return menu.getItems().length > 0 && exists(menu.getItems(), isNotSeparator);
        });
    };

    const fireSkinLoaded = (editor) => {
        const done = () => {
            editor._skinLoaded = true;
            fireSkinLoaded$1(editor);
        };
        return () => {
            if (editor.initialized) {
                done();
            }
            else {
                editor.on('init', done);
            }
        };
    };
    const fireSkinLoadError = (editor, err) => () => fireSkinLoadError$1(editor, { message: err });

    const getSkinResourceIdentifier = (editor) => {
        const skin = getSkin(editor);
        // Use falsy check to cover false, undefined/null and empty string
        if (!skin) {
            return Optional.none();
        }
        else {
            return Optional.from(skin);
        }
    };
    const loadStylesheet = (editor, stylesheetUrl, styleSheetLoader) => {
        // Ensure the stylesheet is cleaned up when the editor is destroyed
        editor.on('remove', () => styleSheetLoader.unload(stylesheetUrl));
        return styleSheetLoader.load(stylesheetUrl);
    };
    const loadRawCss = (editor, key, css, styleSheetLoader) => {
        // Ensure the stylesheet is cleaned up when the editor is destroyed
        editor.on('remove', () => styleSheetLoader.unloadRawCss(key));
        return styleSheetLoader.loadRawCss(key, css);
    };
    const skinIdentifierToResourceKey = (identifier, filename) => 'ui/' + identifier + '/' + filename;
    const getResourceValue = (resourceKey) => Optional.from(tinymce.Resource.get(resourceKey)).filter(isString);
    const determineCSSDecision = (editor, filenameBase, skinUrl = '') => {
        const resourceKey = getSkinResourceIdentifier(editor)
            .map((identifier) => skinIdentifierToResourceKey(identifier, `${filenameBase}.css`));
        const resourceValue = resourceKey.bind(getResourceValue);
        return lift2(resourceKey, resourceValue, (key, css) => {
            return { _kind: 'load-raw', key, css };
        }).getOrThunk(() => {
            const suffix = editor.editorManager.suffix;
            const skinUiCssUrl = skinUrl + `/${filenameBase}${suffix}.css`;
            return { _kind: 'load-stylesheet', url: skinUiCssUrl };
        });
    };
    const loadUiSkins = (editor, skinUrl) => {
        const loader = editor.ui.styleSheetLoader;
        const decision = determineCSSDecision(editor, 'skin', skinUrl);
        switch (decision._kind) {
            case 'load-raw':
                const { key, css } = decision;
                loadRawCss(editor, key, css, loader);
                return Promise.resolve();
            case 'load-stylesheet':
                const { url } = decision;
                return loadStylesheet(editor, url, loader);
            default:
                return Promise.resolve();
        }
    };
    const loadShadowDomUiSkins = (editor, skinUrl) => {
        const isInShadowRoot$1 = isInShadowRoot(SugarElement.fromDom(editor.getElement()));
        if (!isInShadowRoot$1) {
            return Promise.resolve();
        }
        else {
            const loader = global$9.DOM.styleSheetLoader;
            const decision = determineCSSDecision(editor, 'skin.shadowdom', skinUrl);
            switch (decision._kind) {
                case 'load-raw':
                    const { key, css } = decision;
                    loadRawCss(editor, key, css, loader);
                    return Promise.resolve();
                case 'load-stylesheet':
                    const { url } = decision;
                    return loadStylesheet(editor, url, loader);
                default:
                    return Promise.resolve();
            }
        }
    };
    const loadUiContentCSS = (editor, isInline, skinUrl) => {
        const filenameBase = isInline ? 'content.inline' : 'content';
        const decision = determineCSSDecision(editor, filenameBase, skinUrl);
        switch (decision._kind) {
            case 'load-raw':
                const { key, css } = decision;
                if (isInline) {
                    loadRawCss(editor, key, css, editor.ui.styleSheetLoader);
                }
                else {
                    // Need to wait until the iframe is in the DOM before trying to load
                    // the style into the iframe document
                    editor.on('PostRender', () => {
                        loadRawCss(editor, key, css, editor.dom.styleSheetLoader);
                    });
                }
                return Promise.resolve();
            case 'load-stylesheet':
                const { url } = decision;
                if (skinUrl) {
                    editor.contentCSS.push(url);
                }
                return Promise.resolve();
            default:
                return Promise.resolve();
        }
    };
    const loadUrlSkin = async (isInline, editor) => {
        const skinUrl = getSkinUrl(editor);
        await loadUiContentCSS(editor, isInline, skinUrl);
        // In Modern Inline, this is explicitly called in editor.on('focus', ...) as well as in render().
        // Seems to work without, but adding a note in case things break later
        if (!isSkinDisabled(editor) && isString(skinUrl)) {
            return Promise.all([
                loadUiSkins(editor, skinUrl),
                loadShadowDomUiSkins(editor, skinUrl)
            ]).then();
        }
    };
    const loadSkin = (isInline, editor) => {
        return loadUrlSkin(isInline, editor).then(fireSkinLoaded(editor), fireSkinLoadError(editor, 'Skin could not be loaded'));
    };
    const iframe = curry(loadSkin, false);
    const inline = curry(loadSkin, true);

    const getButtonApi = (component) => ({
        isEnabled: () => !Disabling.isDisabled(component),
        setEnabled: (state) => Disabling.set(component, !state),
        setText: (text) => emitWith(component, updateMenuText, {
            text
        }),
        setIcon: (icon) => emitWith(component, updateMenuIcon, {
            icon
        })
    });
    const getToggleApi = (component) => ({
        setActive: (state) => {
            Toggling.set(component, state);
        },
        isActive: () => Toggling.isOn(component),
        isEnabled: () => !Disabling.isDisabled(component),
        setEnabled: (state) => Disabling.set(component, !state),
        setText: (text) => emitWith(component, updateMenuText, {
            text
        }),
        setIcon: (icon) => emitWith(component, updateMenuIcon, {
            icon
        })
    });
    const getTooltipAttributes = (tooltip, providersBackstage) => tooltip.map((tooltip) => ({
        'aria-label': providersBackstage.translate(tooltip),
    })).getOr({});
    const focusButtonEvent = generate$6('focus-button');
    const renderCommonStructure = (optIcon, optText, tooltip, behaviours, providersBackstage, context, btnName) => {
        const optMemDisplayText = optText.map((text) => record(renderLabel$1(text, "tox-tbtn" /* ToolbarButtonClasses.Button */, providersBackstage)));
        const optMemDisplayIcon = optIcon.map((icon) => record(renderReplaceableIconFromPack(icon, providersBackstage.icons)));
        return {
            dom: {
                tag: 'button',
                classes: ["tox-tbtn" /* ToolbarButtonClasses.Button */].concat(optText.isSome() ? ["tox-tbtn--select" /* ToolbarButtonClasses.MatchWidth */] : []),
                attributes: {
                    ...getTooltipAttributes(tooltip, providersBackstage),
                    ...(isNonNullable(btnName) ? { 'data-mce-name': btnName } : {})
                }
            },
            components: componentRenderPipeline([
                optMemDisplayIcon.map((mem) => mem.asSpec()),
                optMemDisplayText.map((mem) => mem.asSpec()),
            ]),
            eventOrder: {
                [mousedown()]: [
                    'focusing',
                    'alloy.base.behaviour',
                    commonButtonDisplayEvent
                ],
                [attachedToDom()]: [commonButtonDisplayEvent, 'toolbar-group-button-events'],
                [detachedFromDom()]: [commonButtonDisplayEvent, 'toolbar-group-button-events', 'tooltipping']
            },
            buttonBehaviours: derive$1([
                DisablingConfigs.toolbarButton(() => providersBackstage.checkUiComponentContext(context).shouldDisable),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext(context)),
                config(commonButtonDisplayEvent, [
                    runOnAttached((comp, _se) => forceInitialSize(comp)),
                    run$1(updateMenuText, (comp, se) => {
                        optMemDisplayText.bind((mem) => mem.getOpt(comp)).each((displayText) => {
                            Replacing.set(displayText, [text$2(providersBackstage.translate(se.event.text))]);
                        });
                    }),
                    run$1(updateMenuIcon, (comp, se) => {
                        optMemDisplayIcon.bind((mem) => mem.getOpt(comp)).each((displayIcon) => {
                            Replacing.set(displayIcon, [renderReplaceableIconFromPack(se.event.icon, providersBackstage.icons)]);
                        });
                    }),
                    run$1(mousedown(), (button, se) => {
                        se.event.prevent();
                        emit(button, focusButtonEvent);
                    })
                ])
            ].concat(behaviours.getOr([])))
        };
    };
    const renderFloatingToolbarButton = (spec, backstage, identifyButtons, attributes, btnName) => {
        const sharedBackstage = backstage.shared;
        const editorOffCell = Cell(noop);
        const specialisation = {
            toolbarButtonBehaviours: [],
            getApi: getButtonApi,
            onSetup: spec.onSetup
        };
        const behaviours = [
            config('toolbar-group-button-events', [
                onControlAttached(specialisation, editorOffCell),
                onControlDetached(specialisation, editorOffCell)
            ]),
            ...(spec.tooltip.map((t) => Tooltipping.config(backstage.shared.providers.tooltips.getConfig({
                tooltipText: backstage.shared.providers.translate(t),
            })))).toArray()
        ];
        return FloatingToolbarButton.sketch({
            lazySink: sharedBackstage.getSink,
            fetch: () => Future.nu((resolve) => {
                resolve(map$2(identifyButtons(spec.items), renderToolbarGroup));
            }),
            markers: {
                toggledClass: "tox-tbtn--enabled" /* ToolbarButtonClasses.Ticked */
            },
            parts: {
                button: renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.some(behaviours), sharedBackstage.providers, spec.context, btnName),
                toolbar: {
                    dom: {
                        tag: 'div',
                        classes: ['tox-toolbar__overflow'],
                        attributes
                    }
                }
            }
        });
    };
    const renderCommonToolbarButton = (spec, specialisation, providersBackstage, btnName) => {
        var _a;
        const editorOffCell = Cell(noop);
        const structure = renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), providersBackstage, spec.context, btnName);
        return Button.sketch({
            dom: structure.dom,
            components: structure.components,
            eventOrder: toolbarButtonEventOrder,
            buttonBehaviours: {
                ...derive$1([
                    config('toolbar-button-events', [
                        onToolbarButtonExecute({
                            onAction: spec.onAction,
                            getApi: specialisation.getApi
                        }),
                        onControlAttached(specialisation, editorOffCell),
                        onControlDetached(specialisation, editorOffCell)
                    ]),
                    ...(spec.tooltip.map((t) => Tooltipping.config(providersBackstage.tooltips.getConfig({
                        tooltipText: providersBackstage.translate(t) + spec.shortcut.map((shortcut) => ` (${convertText(shortcut)})`).getOr(''),
                    })))).toArray(),
                    // Enable toolbar buttons by default
                    DisablingConfigs.toolbarButton(() => !spec.enabled || providersBackstage.checkUiComponentContext(spec.context).shouldDisable),
                    toggleOnReceive(() => providersBackstage.checkUiComponentContext(spec.context))
                ].concat(specialisation.toolbarButtonBehaviours)),
                // Here we add the commonButtonDisplayEvent behaviour from the structure so we can listen
                // to updateMenuIcon and updateMenuText events and run the defined callbacks as they are
                // defined in the renderCommonStructure function and fix the size of the button onAttached.
                [commonButtonDisplayEvent]: (_a = structure.buttonBehaviours) === null || _a === void 0 ? void 0 : _a[commonButtonDisplayEvent],
            }
        });
    };
    const renderToolbarButton = (spec, providersBackstage, btnName) => renderToolbarButtonWith(spec, providersBackstage, [], btnName);
    const renderToolbarButtonWith = (spec, providersBackstage, bonusEvents, btnName) => renderCommonToolbarButton(spec, {
        toolbarButtonBehaviours: (bonusEvents.length > 0 ? [
            // TODO: May have to pass through eventOrder if events start clashing
            config('toolbarButtonWith', bonusEvents)
        ] : []),
        getApi: getButtonApi,
        onSetup: spec.onSetup
    }, providersBackstage, btnName);
    const renderToolbarToggleButton = (spec, providersBackstage, btnName) => renderToolbarToggleButtonWith(spec, providersBackstage, [], btnName);
    const renderToolbarToggleButtonWith = (spec, providersBackstage, bonusEvents, btnName) => renderCommonToolbarButton(spec, {
        toolbarButtonBehaviours: [
            Replacing.config({}),
            Toggling.config({ toggleClass: "tox-tbtn--enabled" /* ToolbarButtonClasses.Ticked */, aria: { mode: 'pressed' }, toggleOnExecute: false })
        ].concat(bonusEvents.length > 0 ? [
            // TODO: May have to pass through eventOrder if events start clashing
            config('toolbarToggleButtonWith', bonusEvents)
        ] : []),
        getApi: getToggleApi,
        onSetup: spec.onSetup
    }, providersBackstage, btnName);
    const fetchChoices = (getApi, spec, providersBackstage) => (comp) => Future.nu((callback) => spec.fetch(callback))
        .map((items) => Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, (value) => {
        spec.onItemAction(getApi(comp), value);
    }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), providersBackstage), {
        movement: deriveMenuMovement(spec.columns, spec.presets),
        menuBehaviours: SimpleBehaviours.unnamedEvents(spec.columns !== 'auto' ? [] : [
            runOnAttached((comp, _se) => {
                detectSize(comp, 4, classForPreset(spec.presets)).each(({ numRows, numColumns }) => {
                    Keying.setGridSize(comp, numRows, numColumns);
                });
            })
        ])
    }))));
    const makeSplitButtonApi = (tooltipString, sharedBackstage, spec) => (component) => {
        const system = component.getSystem();
        const element = component.element;
        const getComponents = () => {
            const isChevron = has(element, 'tox-split-button__chevron');
            const mainOpt = isChevron ?
                prevSibling(element).bind((el) => system.getByDom(el).toOptional()) :
                Optional.some(component);
            const chevronOpt = isChevron ?
                Optional.some(component) :
                nextSibling(element).bind((el) => system.getByDom(el).toOptional().filter((comp) => has(comp.element, 'tox-split-button__chevron')));
            return { mainOpt, chevronOpt };
        };
        const applyBoth = (f) => {
            const { mainOpt, chevronOpt } = getComponents();
            mainOpt.each(f);
            chevronOpt.each(f);
        };
        return {
            isEnabled: () => {
                const { mainOpt } = getComponents();
                return mainOpt.exists((c) => !Disabling.isDisabled(c));
            },
            setEnabled: (state) => applyBoth((c) => Disabling.set(c, !state)),
            setText: (text) => {
                const { mainOpt } = getComponents();
                mainOpt.each((c) => emitWith(c, updateMenuText, { text }));
            },
            setIcon: (icon) => {
                const { mainOpt } = getComponents();
                mainOpt.each((c) => emitWith(c, updateMenuIcon, { icon }));
            },
            setIconFill: (id, value) => applyBoth((c) => {
                descendant(c.element, `svg path[class="${id}"], rect[class="${id}"]`).each((underlinePath) => {
                    set$9(underlinePath, 'fill', value);
                });
            }),
            isActive: () => {
                const { mainOpt } = getComponents();
                return mainOpt.exists((c) => Toggling.isOn(c));
            },
            setActive: (state) => {
                const { mainOpt } = getComponents();
                mainOpt.each((c) => Toggling.set(c, state));
            },
            setTooltip: (tooltip) => {
                tooltipString.set(tooltip);
                const { mainOpt, chevronOpt } = getComponents();
                mainOpt.each((c) => set$9(c.element, 'aria-label', sharedBackstage.providers.translate(tooltip)));
                // For chevron, use the explicit chevronTooltip if provided, otherwise fall back to default behavior
                const chevronTooltipText = spec.chevronTooltip
                    .map((chevronTooltip) => sharedBackstage.providers.translate(chevronTooltip))
                    .getOr(sharedBackstage.providers.translate(`${tooltip} menu`));
                chevronOpt.each((c) => set$9(c.element, 'aria-label', chevronTooltipText));
            }
        };
    };
    const renderSplitButton = (spec, sharedBackstage, btnName) => {
        const editorOffCell = Cell(noop);
        const tooltipString = Cell(spec.tooltip.getOr(''));
        const getApi = makeSplitButtonApi(tooltipString, sharedBackstage, spec);
        const menuId = generate$6('tox-split-menu');
        const expandedCell = Cell(false);
        const getAriaAttributes = () => ({
            'aria-haspopup': 'menu',
            'aria-expanded': String(expandedCell.get()),
            'aria-controls': menuId
        });
        // Helper to get ARIA label for the main button
        const getMainButtonAriaLabel = () => {
            return spec.tooltip.map((tooltip) => sharedBackstage.providers.translate(tooltip))
                .getOr(sharedBackstage.providers.translate('Text color'));
        };
        // Helper to get ARIA label and tooltip for the chevron/dropdown button
        const getChevronTooltip = () => {
            return spec.chevronTooltip
                .map((tooltip) => sharedBackstage.providers.translate(tooltip))
                .getOrThunk(() => {
                const mainLabel = getMainButtonAriaLabel();
                return sharedBackstage.providers.translate(['{0} menu', mainLabel]);
            });
        };
        const updateAriaExpanded = (expanded, comp) => {
            expandedCell.set(expanded);
            set$9(comp.element, 'aria-expanded', String(expanded));
        };
        const arrow = Dropdown.sketch({
            dom: {
                tag: 'button',
                classes: ["tox-tbtn" /* ToolbarButtonClasses.Button */, 'tox-split-button__chevron'],
                innerHtml: get('chevron-down', sharedBackstage.providers.icons),
                attributes: {
                    'aria-label': getChevronTooltip(),
                    ...(isNonNullable(btnName) ? { 'data-mce-name': btnName + '-chevron' } : {}),
                    ...getAriaAttributes()
                }
            },
            components: [],
            toggleClass: "tox-tbtn--enabled" /* ToolbarButtonClasses.Ticked */,
            dropdownBehaviours: derive$1([
                config('split-dropdown-events', [
                    runOnAttached((comp, _se) => forceInitialSize(comp)),
                    onControlAttached({ getApi, onSetup: spec.onSetup }, editorOffCell),
                    run$1('alloy-dropdown-open', (comp) => updateAriaExpanded(true, comp)),
                    run$1('alloy-dropdown-close', (comp) => updateAriaExpanded(false, comp)),
                ]),
                DisablingConfigs.toolbarButton(() => sharedBackstage.providers.checkUiComponentContext(spec.context).shouldDisable),
                toggleOnReceive(() => sharedBackstage.providers.checkUiComponentContext(spec.context)),
                Unselecting.config({}),
                Tooltipping.config(sharedBackstage.providers.tooltips.getConfig({
                    tooltipText: getChevronTooltip(),
                    onShow: (comp) => {
                        if (tooltipString.get() !== spec.tooltip.getOr('')) {
                            const chevronTooltipText = spec.chevronTooltip
                                .map((chevronTooltip) => sharedBackstage.providers.translate(chevronTooltip))
                                .getOr(`${sharedBackstage.providers.translate(tooltipString.get())} menu`);
                            Tooltipping.setComponents(comp, sharedBackstage.providers.tooltips.getComponents({ tooltipText: chevronTooltipText }));
                        }
                    }
                }))
            ]),
            lazySink: sharedBackstage.getSink,
            fetch: fetchChoices(getApi, spec, sharedBackstage.providers),
            getHotspot: (comp) => prevSibling(comp.element).bind((el) => comp.getSystem().getByDom(el).toOptional()),
            onOpen: (_anchor, _comp, menu) => {
                Highlighting.highlightBy(menu, (item) => has(item.element, 'tox-collection__item--active'));
                Highlighting.getHighlighted(menu).each(Keying.focusIn);
            },
            parts: {
                menu: {
                    ...part(false, spec.columns, spec.presets),
                    dom: {
                        ...part(false, spec.columns, spec.presets).dom,
                        tag: 'div',
                        attributes: {
                            id: menuId
                        }
                    }
                }
            }
        });
        const mainButton = Button.sketch({
            ...renderCommonStructure(spec.icon, spec.text, Optional.none(), Optional.some([
                Toggling.config({
                    toggleClass: "tox-tbtn--enabled" /* ToolbarButtonClasses.Ticked */,
                    aria: spec.presets === 'color' ? { mode: 'none' } : { mode: 'pressed' },
                    toggleOnExecute: false
                }),
                DisablingConfigs.toolbarButton(() => sharedBackstage.providers.checkUiComponentContext(spec.context).shouldDisable),
                toggleOnReceive(() => sharedBackstage.providers.checkUiComponentContext(spec.context)),
                config('split-main-aria-events', []),
                ...(spec.tooltip.isSome() ? [
                    Tooltipping.config(sharedBackstage.providers.tooltips.getConfig({
                        tooltipText: sharedBackstage.providers.translate(spec.tooltip.getOr('')),
                        onShow: (comp) => {
                            if (tooltipString.get() !== spec.tooltip.getOr('')) {
                                const translated = sharedBackstage.providers.translate(tooltipString.get());
                                Tooltipping.setComponents(comp, sharedBackstage.providers.tooltips.getComponents({ tooltipText: translated }));
                            }
                        }
                    }))
                ] : [])
            ]), sharedBackstage.providers, spec.context, btnName),
            dom: {
                ...renderCommonStructure(spec.icon, spec.text, Optional.none(), Optional.none(), sharedBackstage.providers, spec.context, btnName).dom,
                classes: ["tox-tbtn" /* ToolbarButtonClasses.Button */, 'tox-split-button__main'],
                attributes: {
                    'aria-label': getMainButtonAriaLabel(),
                    ...(isNonNullable(btnName) ? { 'data-mce-name': btnName } : {})
                }
            },
            action: (button) => {
                if (spec.onAction) {
                    const api = getApi(button);
                    if (api.isEnabled()) {
                        spec.onAction(api);
                    }
                }
            }
        });
        return [mainButton, arrow];
    };

    const contextFormInputSelector = '.tox-toolbar-slider__input,.tox-toolbar-textfield';
    const focusIn = (contextbar) => {
        InlineView.getContent(contextbar).each((comp) => {
            descendant(comp.element, contextFormInputSelector).fold(() => Keying.focusIn(comp), focus$4);
        });
    };
    // TODO: Is this really the best way to move focus out of the input when it gets disabled #TINY-11527
    const focusParent = (comp) => search(comp.element).each((focus) => {
        ancestor$1(focus, '[tabindex="-1"]').each((parent) => {
            focus$4(parent);
        });
    });

    const forwardSlideEvent = generate$6('forward-slide');
    const backSlideEvent = generate$6('backward-slide');
    const changeSlideEvent = generate$6('change-slide-event');
    const resizingClass = 'tox-pop--resizing';
    const renderContextToolbar = (spec) => {
        const stack = Cell([]);
        const sketch = InlineView.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-pop']
            },
            fireDismissalEventInstead: {
                event: 'doNotDismissYet'
            },
            onShow: (comp) => {
                stack.set([]);
                InlineView.getContent(comp).each((c) => {
                    remove$6(c.element, 'visibility');
                });
                remove$3(comp.element, resizingClass);
                remove$6(comp.element, 'width');
            },
            onHide: () => {
                stack.set([]);
                spec.onHide();
            },
            inlineBehaviours: derive$1([
                config('context-toolbar-events', [
                    runOnSource(transitionend(), (comp, se) => {
                        if (se.event.raw.propertyName === 'width') {
                            remove$3(comp.element, resizingClass);
                            remove$6(comp.element, 'width');
                        }
                    }),
                    run$1(changeSlideEvent, (comp, se) => {
                        const elem = comp.element;
                        // If it was partially through a slide, clear that and measure afresh
                        remove$6(elem, 'width');
                        const currentWidth = get$c(elem);
                        const hadFocus = search(comp.element).isSome();
                        // Remove these so that we can property measure the width of the context form content
                        remove$6(elem, 'left');
                        remove$6(elem, 'right');
                        remove$6(elem, 'max-width');
                        InlineView.setContent(comp, se.event.contents);
                        add$2(elem, resizingClass);
                        const newWidth = get$c(elem);
                        // Reposition without transition to avoid it from being animated from previous position
                        set$7(elem, 'transition', 'none');
                        InlineView.reposition(comp);
                        remove$6(elem, 'transition');
                        set$7(elem, 'width', currentWidth + 'px');
                        se.event.focus.fold(() => {
                            if (hadFocus) {
                                focusIn(comp);
                            }
                        }, (f) => {
                            active$1(getRootNode(comp.element)).fold(() => focus$4(f), (active) => {
                                // We need this extra check since if the focus is aleady on the iframe we don't want to call focus on it again since that closes the context toolbar
                                if (!eq(active, f)) {
                                    spec.focusElement(f);
                                }
                            });
                        });
                        setTimeout(() => {
                            set$7(comp.element, 'width', newWidth + 'px');
                        }, 0);
                    }),
                    run$1(forwardSlideEvent, (comp, se) => {
                        InlineView.getContent(comp).each((oldContents) => {
                            stack.set(stack.get().concat([
                                {
                                    bar: oldContents,
                                    focus: active$1(getRootNode(comp.element))
                                }
                            ]));
                        });
                        emitWith(comp, changeSlideEvent, {
                            contents: se.event.forwardContents,
                            focus: Optional.none()
                        });
                    }),
                    run$1(backSlideEvent, (comp, _se) => {
                        spec.onBack();
                        last$1(stack.get()).each((last) => {
                            stack.set(stack.get().slice(0, stack.get().length - 1));
                            emitWith(comp, changeSlideEvent, {
                                // Because we are using premade, we should have access to the same element
                                // to give focus (although it isn't working)
                                contents: premade(last.bar),
                                focus: last.focus
                            });
                        });
                    })
                ]),
                Keying.config({
                    mode: 'special',
                    onEscape: (comp) => last$1(stack.get()).fold(() => 
                    // Escape just focuses the content. It no longer closes the toolbar.
                    spec.onEscape(), (_) => {
                        emit(comp, backSlideEvent);
                        return Optional.some(true);
                    })
                })
            ]),
            lazySink: () => Result.value(spec.sink)
        });
        return {
            sketch,
            inSubtoolbar: () => stack.get().length > 0
        };
    };

    const createNavigateBackButton = (editor, backstage) => {
        const bridged = getOrDie(createToolbarButton({
            type: 'button',
            icon: 'chevron-left',
            tooltip: 'Back',
            onAction: noop
        }));
        return renderToolbarButtonWith(bridged, backstage.shared.providers, [
            run$1(internalToolbarButtonExecute, (comp) => {
                emit(comp, backSlideEvent);
            })
        ]);
    };

    const makeTooltipText = (editor, labelWithPlaceholder, value) => isEmpty(value) ? editor.translate(labelWithPlaceholder) : editor.translate([labelWithPlaceholder, editor.translate(value)]);

    const generateSelectItems = (backstage, spec) => {
        const generateItem = (rawItem, response, invalid, value) => {
            const translatedText = backstage.shared.providers.translate(rawItem.title);
            if (rawItem.type === 'separator') {
                return Optional.some({
                    type: 'separator',
                    text: translatedText
                });
            }
            else if (rawItem.type === 'submenu') {
                const items = bind$3(rawItem.getStyleItems(), (si) => validate(si, response, value));
                if (response === 0 /* IrrelevantStyleItemResponse.Hide */ && items.length <= 0) {
                    return Optional.none();
                }
                else {
                    return Optional.some({
                        type: 'nestedmenuitem',
                        text: translatedText,
                        enabled: items.length > 0,
                        getSubmenuItems: () => bind$3(rawItem.getStyleItems(), (si) => validate(si, response, value))
                    });
                }
            }
            else {
                return Optional.some({
                    // ONLY TOGGLEMENUITEMS HANDLE STYLE META.
                    // See ToggleMenuItem and ItemStructure for how it's handled.
                    // If this type ever changes, we'll need to change that too
                    type: 'togglemenuitem',
                    text: translatedText,
                    icon: rawItem.icon,
                    active: rawItem.isSelected(value),
                    enabled: !invalid,
                    onAction: spec.onAction(rawItem),
                    ...rawItem.getStylePreview().fold(() => ({}), (preview) => ({ meta: { style: preview } }))
                });
            }
        };
        const validate = (item, response, value) => {
            const invalid = item.type === 'formatter' && spec.isInvalid(item);
            // If we are making them disappear based on some setting
            if (response === 0 /* IrrelevantStyleItemResponse.Hide */) {
                return invalid ? [] : generateItem(item, response, false, value).toArray();
            }
            else {
                return generateItem(item, response, invalid, value).toArray();
            }
        };
        const validateItems = (preItems) => {
            const value = spec.getCurrentValue();
            const response = spec.shouldHide ? 0 /* IrrelevantStyleItemResponse.Hide */ : 1 /* IrrelevantStyleItemResponse.Disable */;
            return bind$3(preItems, (item) => validate(item, response, value));
        };
        const getFetch = (backstage, getStyleItems) => (comp, callback) => {
            const preItems = getStyleItems();
            const items = validateItems(preItems);
            const menu = build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
                isHorizontalMenu: false,
                search: Optional.none()
            });
            callback(menu);
        };
        return {
            validateItems,
            getFetch
        };
    };
    const createMenuItems = (backstage, spec) => {
        const dataset = spec.dataset; // needs to be a var for tsc to understand the ternary
        const getStyleItems = dataset.type === 'basic' ?
            () => map$2(dataset.data, (d) => processBasic(d, spec.isSelectedFor, spec.getPreviewFor)) :
            dataset.getData;
        return {
            items: generateSelectItems(backstage, spec),
            getStyleItems
        };
    };
    const createSelectButton = (editor, backstage, spec, getTooltip, textUpdateEventName, btnName) => {
        const { items, getStyleItems } = createMenuItems(backstage, spec);
        const tooltipString = Cell(spec.tooltip);
        const getApi = (comp) => ({
            getComponent: constant$1(comp),
            setTooltip: (tooltip) => {
                const translatedTooltip = backstage.shared.providers.translate(tooltip);
                set$9(comp.element, 'aria-label', translatedTooltip);
                tooltipString.set(tooltip);
            }
        });
        // Set the initial text when the component is attached and then update on node changes
        const onSetup = (api) => {
            const handler = (e) => api.setTooltip(makeTooltipText(editor, getTooltip(e.value), e.value));
            editor.on(textUpdateEventName, handler);
            return composeUnbinders(onSetupEvent(editor, 'NodeChange', (api) => {
                const comp = api.getComponent();
                spec.updateText(comp);
                Disabling.set(api.getComponent(), (!editor.selection.isEditable() || getStyleItems().length === 0));
            })(api), () => editor.off(textUpdateEventName, handler));
        };
        return renderCommonDropdown({
            context: 'mode:design',
            text: spec.icon.isSome() ? Optional.none() : spec.text,
            icon: spec.icon,
            ariaLabel: Optional.some(spec.tooltip),
            tooltip: Optional.none(), // TINY-10474 - Using own tooltip config
            role: Optional.none(),
            fetch: items.getFetch(backstage, getStyleItems),
            onSetup,
            getApi,
            columns: 1,
            presets: 'normal',
            classes: spec.icon.isSome() ? [] : ['bespoke'],
            dropdownBehaviours: [
                Tooltipping.config({
                    ...backstage.shared.providers.tooltips.getConfig({
                        tooltipText: backstage.shared.providers.translate(spec.tooltip),
                        onShow: (comp) => {
                            if (spec.tooltip !== tooltipString.get()) {
                                const translatedTooltip = backstage.shared.providers.translate(tooltipString.get());
                                Tooltipping.setComponents(comp, backstage.shared.providers.tooltips.getComponents({ tooltipText: translatedTooltip }));
                            }
                        }
                    }),
                })
            ]
        }, "tox-tbtn" /* ToolbarButtonClasses.Button */, backstage.shared, btnName);
    };

    const process = (rawFormats) => map$2(rawFormats, (item) => {
        let title = item, format = item;
        // Allow text=value block formats
        const values = item.split('=');
        if (values.length > 1) {
            title = values[0];
            format = values[1];
        }
        return { title, format };
    });
    const buildBasicStaticDataset = (data) => ({
        type: 'basic',
        data
    });
    var Delimiter;
    (function (Delimiter) {
        Delimiter[Delimiter["SemiColon"] = 0] = "SemiColon";
        Delimiter[Delimiter["Space"] = 1] = "Space";
    })(Delimiter || (Delimiter = {}));
    const split = (rawFormats, delimiter) => {
        if (delimiter === Delimiter.SemiColon) {
            return rawFormats.replace(/;$/, '').split(';');
        }
        else {
            return rawFormats.split(' ');
        }
    };
    const buildBasicSettingsDataset = (editor, settingName, delimiter) => {
        // eslint-disable-next-line @tinymce/no-direct-editor-options
        const rawFormats = editor.options.get(settingName);
        const data = process(split(rawFormats, delimiter));
        return {
            type: 'basic',
            data
        };
    };

    const menuTitle$4 = 'Align';
    const getTooltipPlaceholder$4 = constant$1('Alignment {0}');
    const fallbackAlignment = 'left';
    const alignMenuItems = [
        { title: 'Left', icon: 'align-left', format: 'alignleft', command: 'JustifyLeft' },
        { title: 'Center', icon: 'align-center', format: 'aligncenter', command: 'JustifyCenter' },
        { title: 'Right', icon: 'align-right', format: 'alignright', command: 'JustifyRight' },
        { title: 'Justify', icon: 'align-justify', format: 'alignjustify', command: 'JustifyFull' }
    ];
    const getSpec$4 = (editor) => {
        const getMatchingValue = () => find$5(alignMenuItems, (item) => editor.formatter.match(item.format));
        const isSelectedFor = (format) => () => editor.formatter.match(format);
        const getPreviewFor = (_format) => Optional.none;
        const updateSelectMenuIcon = (comp) => {
            const match = getMatchingValue();
            const alignment = match.fold(constant$1(fallbackAlignment), (item) => item.title.toLowerCase());
            emitWith(comp, updateMenuIcon, {
                icon: `align-${alignment}`
            });
            fireAlignTextUpdate(editor, { value: alignment });
        };
        const dataset = buildBasicStaticDataset(alignMenuItems);
        const onAction = (rawItem) => () => find$5(alignMenuItems, (item) => item.format === rawItem.format)
            .each((item) => editor.execCommand(item.command));
        return {
            tooltip: makeTooltipText(editor, getTooltipPlaceholder$4(), fallbackAlignment),
            text: Optional.none(),
            icon: Optional.some('align-left'),
            isSelectedFor,
            getCurrentValue: Optional.none,
            getPreviewFor,
            onAction,
            updateText: updateSelectMenuIcon,
            dataset,
            shouldHide: false,
            isInvalid: (item) => !editor.formatter.canApply(item.format)
        };
    };
    const createAlignButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$4(editor), getTooltipPlaceholder$4, 'AlignTextUpdate', 'align');
    const createAlignMenu = (editor, backstage) => {
        const menuItems = createMenuItems(backstage, getSpec$4(editor));
        editor.ui.registry.addNestedMenuItem('align', {
            text: backstage.shared.providers.translate(menuTitle$4),
            onSetup: onSetupEditableToggle(editor),
            getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
        });
    };

    const findNearest = (editor, getStyles) => {
        const styles = getStyles();
        const formats = map$2(styles, (style) => style.format);
        return Optional.from(editor.formatter.closest(formats)).bind((fmt) => find$5(styles, (data) => data.format === fmt));
    };

    const menuTitle$3 = 'Blocks';
    const getTooltipPlaceholder$3 = constant$1('Block {0}');
    const fallbackFormat = 'Paragraph';
    const getSpec$3 = (editor) => {
        const isSelectedFor = (format) => () => editor.formatter.match(format);
        const getPreviewFor = (format) => () => {
            const fmt = editor.formatter.get(format);
            if (fmt) {
                return Optional.some({
                    tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',
                    styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
                });
            }
            else {
                return Optional.none();
            }
        };
        const updateSelectMenuText = (comp) => {
            const detectedFormat = findNearest(editor, () => dataset.data);
            const text = detectedFormat.fold(constant$1(fallbackFormat), (fmt) => fmt.title);
            emitWith(comp, updateMenuText, {
                text
            });
            fireBlocksTextUpdate(editor, { value: text });
        };
        const dataset = buildBasicSettingsDataset(editor, 'block_formats', Delimiter.SemiColon);
        return {
            tooltip: makeTooltipText(editor, getTooltipPlaceholder$3(), fallbackFormat),
            text: Optional.some(fallbackFormat),
            icon: Optional.none(),
            isSelectedFor,
            getCurrentValue: Optional.none,
            getPreviewFor,
            onAction: onActionToggleFormat$1(editor),
            updateText: updateSelectMenuText,
            dataset,
            shouldHide: false,
            isInvalid: (item) => !editor.formatter.canApply(item.format)
        };
    };
    const createBlocksButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$3(editor), getTooltipPlaceholder$3, 'BlocksTextUpdate', 'blocks');
    // FIX: Test this!
    const createBlocksMenu = (editor, backstage) => {
        const menuItems = createMenuItems(backstage, getSpec$3(editor));
        editor.ui.registry.addNestedMenuItem('blocks', {
            text: menuTitle$3,
            onSetup: onSetupEditableToggle(editor),
            getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
        });
    };

    const menuTitle$2 = 'Fonts';
    const getTooltipPlaceholder$2 = constant$1('Font {0}');
    const systemFont = 'System Font';
    // A list of fonts that must be in a font family for the font to be recognised as the system stack
    // Note: Don't include 'BlinkMacSystemFont', as Chrome on Mac converts it to different names
    // The system font stack will be similar to the following. (Note: each has minor variants)
    // Oxide: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    // Bootstrap: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    // Wordpress: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
    const systemStackFonts = ['-apple-system', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'sans-serif'];
    // Split the fonts into an array and strip away any start/end quotes
    const splitFonts = (fontFamily) => {
        const fonts = fontFamily.split(/\s*,\s*/);
        return map$2(fonts, (font) => font.replace(/^['"]+|['"]+$/g, ''));
    };
    const matchesStack = (fonts, stack) => stack.length > 0 && forall(stack, (font) => fonts.indexOf(font.toLowerCase()) > -1);
    const isSystemFontStack = (fontFamily, userStack) => {
        if (fontFamily.indexOf('-apple-system') === 0 || userStack.length > 0) {
            const fonts = splitFonts(fontFamily.toLowerCase());
            return matchesStack(fonts, systemStackFonts) || matchesStack(fonts, userStack);
        }
        else {
            return false;
        }
    };
    const getSpec$2 = (editor) => {
        const getMatchingValue = () => {
            const getFirstFont = (fontFamily) => fontFamily ? splitFonts(fontFamily)[0] : '';
            const fontFamily = editor.queryCommandValue('FontName');
            const items = dataset.data;
            const font = fontFamily ? fontFamily.toLowerCase() : '';
            const userStack = getDefaultFontStack(editor);
            const matchOpt = find$5(items, (item) => {
                const format = item.format;
                return (format.toLowerCase() === font) || (getFirstFont(format).toLowerCase() === getFirstFont(font).toLowerCase());
            }).orThunk(() => {
                return someIf(isSystemFontStack(font, userStack), {
                    title: systemFont,
                    format: font
                });
            });
            return { matchOpt, font: fontFamily };
        };
        const isSelectedFor = (item) => (valueOpt) => valueOpt.exists((value) => value.format === item);
        const getCurrentValue = () => {
            const { matchOpt } = getMatchingValue();
            return matchOpt;
        };
        const getPreviewFor = (item) => () => Optional.some({
            tag: 'div',
            styles: item.indexOf('dings') === -1 ? { 'font-family': item } : {}
        });
        const onAction = (rawItem) => () => {
            editor.undoManager.transact(() => {
                editor.focus();
                editor.execCommand('FontName', false, rawItem.format);
            });
        };
        const updateSelectMenuText = (comp) => {
            const { matchOpt, font } = getMatchingValue();
            const text = matchOpt.fold(constant$1(font), (item) => item.title);
            emitWith(comp, updateMenuText, {
                text
            });
            fireFontFamilyTextUpdate(editor, { value: text });
        };
        const dataset = buildBasicSettingsDataset(editor, 'font_family_formats', Delimiter.SemiColon);
        return {
            tooltip: makeTooltipText(editor, getTooltipPlaceholder$2(), systemFont),
            text: Optional.some(systemFont),
            icon: Optional.none(),
            isSelectedFor,
            getCurrentValue,
            getPreviewFor,
            onAction,
            updateText: updateSelectMenuText,
            dataset,
            shouldHide: false,
            isInvalid: never
        };
    };
    const createFontFamilyButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$2(editor), getTooltipPlaceholder$2, 'FontFamilyTextUpdate', 'fontfamily');
    // TODO: Test this!
    const createFontFamilyMenu = (editor, backstage) => {
        const menuItems = createMenuItems(backstage, getSpec$2(editor));
        editor.ui.registry.addNestedMenuItem('fontfamily', {
            text: backstage.shared.providers.translate(menuTitle$2),
            onSetup: onSetupEditableToggle(editor),
            getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
        });
    };

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.VK');

    const createBespokeNumberInput = (editor, backstage, spec, btnName) => {
        let currentComp = Optional.none();
        const getValueFromCurrentComp = (comp) => comp.map((alloyComp) => Representing.getValue(alloyComp)).getOr('');
        const onSetup = onSetupEvent(editor, 'NodeChange SwitchMode DisabledStateChange', (api) => {
            const comp = api.getComponent();
            currentComp = Optional.some(comp);
            spec.updateInputValue(comp);
            Disabling.set(comp, !editor.selection.isEditable() || isDisabled(editor));
        });
        const getApi = (comp) => ({ getComponent: constant$1(comp) });
        const editorOffCell = Cell(noop);
        const customEvents = generate$6('custom-number-input-events');
        const changeValue = (f, fromInput, focusBack) => {
            const text = getValueFromCurrentComp(currentComp);
            const newValue = spec.getNewValue(text, f);
            const lenghtDelta = text.length - `${newValue}`.length;
            const oldStart = currentComp.map((comp) => comp.element.dom.selectionStart - lenghtDelta);
            const oldEnd = currentComp.map((comp) => comp.element.dom.selectionEnd - lenghtDelta);
            spec.onAction(newValue, focusBack);
            currentComp.each((comp) => {
                Representing.setValue(comp, newValue);
                if (fromInput) {
                    oldStart.each((oldStart) => comp.element.dom.selectionStart = oldStart);
                    oldEnd.each((oldEnd) => comp.element.dom.selectionEnd = oldEnd);
                }
            });
        };
        const decrease = (fromInput, focusBack) => changeValue((n, s) => n - s, fromInput, focusBack);
        const increase = (fromInput, focusBack) => changeValue((n, s) => n + s, fromInput, focusBack);
        const goToParent = (comp) => parentElement(comp.element).fold(Optional.none, (parent) => {
            focus$4(parent);
            return Optional.some(true);
        });
        const focusInput = (comp) => {
            if (hasFocus(comp.element)) {
                firstChild(comp.element).each((input) => focus$4(input));
                return Optional.some(true);
            }
            else {
                return Optional.none();
            }
        };
        const makeStepperButton = (action, title, tooltip, classes) => {
            const editorOffCellStepButton = Cell(noop);
            const translatedTooltip = backstage.shared.providers.translate(tooltip);
            const altExecuting = generate$6('altExecuting');
            const onSetup = onSetupEvent(editor, 'NodeChange SwitchMode DisabledStateChange', (api) => {
                Disabling.set(api.getComponent(), !editor.selection.isEditable() || isDisabled(editor));
            });
            const onClick = (comp) => {
                if (!Disabling.isDisabled(comp)) {
                    action(true);
                }
            };
            return Button.sketch({
                dom: {
                    tag: 'button',
                    attributes: {
                        'aria-label': translatedTooltip,
                        'data-mce-name': title
                    },
                    classes: classes.concat(title)
                },
                components: [
                    renderIconFromPack$1(title, backstage.shared.providers.icons)
                ],
                buttonBehaviours: derive$1([
                    Disabling.config({}),
                    Tooltipping.config(backstage.shared.providers.tooltips.getConfig({
                        tooltipText: translatedTooltip
                    })),
                    config(altExecuting, [
                        onControlAttached({ onSetup, getApi }, editorOffCellStepButton),
                        onControlDetached({ getApi }, editorOffCellStepButton),
                        run$1(keydown(), (comp, se) => {
                            if (se.event.raw.keyCode === global$1.SPACEBAR || se.event.raw.keyCode === global$1.ENTER) {
                                if (!Disabling.isDisabled(comp)) {
                                    action(false);
                                }
                            }
                        }),
                        run$1(click(), onClick),
                        run$1(touchend(), onClick)
                    ])
                ]),
                eventOrder: {
                    [keydown()]: [altExecuting, 'keying'],
                    [click()]: [altExecuting, 'alloy.base.behaviour'],
                    [touchend()]: [altExecuting, 'alloy.base.behaviour'],
                    [attachedToDom()]: ['alloy.base.behaviour', altExecuting, 'tooltipping'],
                    [detachedFromDom()]: [altExecuting, 'tooltipping']
                }
            });
        };
        const memMinus = record(makeStepperButton((focusBack) => decrease(false, focusBack), 'minus', 'Decrease font size', []));
        const memPlus = record(makeStepperButton((focusBack) => increase(false, focusBack), 'plus', 'Increase font size', []));
        const memInput = record({
            dom: {
                tag: 'div',
                classes: ['tox-input-wrapper']
            },
            components: [
                Input.sketch({
                    inputBehaviours: derive$1([
                        Disabling.config({}),
                        config(customEvents, [
                            onControlAttached({ onSetup, getApi }, editorOffCell),
                            onControlDetached({ getApi }, editorOffCell)
                        ]),
                        config('input-update-display-text', [
                            run$1(updateMenuText, (comp, se) => {
                                Representing.setValue(comp, se.event.text);
                            }),
                            run$1(focusout(), (comp) => {
                                spec.onAction(Representing.getValue(comp));
                            }),
                            run$1(change(), (comp) => {
                                spec.onAction(Representing.getValue(comp));
                            })
                        ]),
                        Keying.config({
                            mode: 'special',
                            onEnter: (_comp) => {
                                changeValue(identity, true, true);
                                return Optional.some(true);
                            },
                            onEscape: goToParent,
                            onUp: (_comp) => {
                                increase(true, false);
                                return Optional.some(true);
                            },
                            onDown: (_comp) => {
                                decrease(true, false);
                                return Optional.some(true);
                            },
                            onLeft: (_comp, se) => {
                                se.cut();
                                return Optional.none();
                            },
                            onRight: (_comp, se) => {
                                se.cut();
                                return Optional.none();
                            }
                        })
                    ])
                })
            ],
            behaviours: derive$1([
                Focusing.config({}),
                Keying.config({
                    mode: 'special',
                    onEnter: focusInput,
                    onSpace: focusInput,
                    onEscape: goToParent
                }),
                config('input-wrapper-events', [
                    run$1(mouseover(), (comp) => {
                        each$1([memMinus, memPlus], (button) => {
                            const buttonNode = SugarElement.fromDom(button.get(comp).element.dom);
                            if (hasFocus(buttonNode)) {
                                blur$1(buttonNode);
                            }
                        });
                    })
                ])
            ])
        });
        return {
            dom: {
                tag: 'div',
                classes: ['tox-number-input'],
                attributes: {
                    ...(isNonNullable(btnName) ? { 'data-mce-name': btnName } : {})
                }
            },
            components: [
                memMinus.asSpec(),
                memInput.asSpec(),
                memPlus.asSpec()
            ],
            behaviours: derive$1([
                Focusing.config({}),
                Keying.config({
                    mode: 'flow',
                    focusInside: FocusInsideModes.OnEnterOrSpaceMode,
                    cycles: false,
                    selector: 'button, .tox-input-wrapper',
                    onEscape: (wrapperComp) => {
                        if (hasFocus(wrapperComp.element)) {
                            return Optional.none();
                        }
                        else {
                            focus$4(wrapperComp.element);
                            return Optional.some(true);
                        }
                    },
                })
            ])
        };
    };

    const menuTitle$1 = 'Font sizes';
    const getTooltipPlaceholder$1 = constant$1('Font size {0}');
    const fallbackFontSize = '12pt';
    // See https://websemantics.uk/articles/font-size-conversion/ for conversions
    const legacyFontSizes = {
        '8pt': '1',
        '10pt': '2',
        '12pt': '3',
        '14pt': '4',
        '18pt': '5',
        '24pt': '6',
        '36pt': '7'
    };
    // Note: 'xx-small', 'x-small' and 'large' are rounded up to nearest whole pt
    const keywordFontSizes = {
        'xx-small': '7pt',
        'x-small': '8pt',
        'small': '10pt',
        'medium': '12pt',
        'large': '14pt',
        'x-large': '18pt',
        'xx-large': '24pt'
    };
    const round = (number, precision) => {
        const factor = Math.pow(10, precision);
        return Math.round(number * factor) / factor;
    };
    const toPt = (fontSize, precision) => {
        if (/[0-9.]+px$/.test(fontSize)) {
            // Round to the nearest 0.5
            return round(parseInt(fontSize, 10) * 72 / 96, precision || 0) + 'pt';
        }
        else {
            return get$h(keywordFontSizes, fontSize).getOr(fontSize);
        }
    };
    const toLegacy = (fontSize) => get$h(legacyFontSizes, fontSize).getOr('');
    const getSpec$1 = (editor) => {
        const getMatchingValue = () => {
            let matchOpt = Optional.none();
            const items = dataset.data;
            const fontSize = editor.queryCommandValue('FontSize');
            if (fontSize) {
                // checking for three digits after decimal point, should be precise enough
                for (let precision = 3; matchOpt.isNone() && precision >= 0; precision--) {
                    const pt = toPt(fontSize, precision);
                    const legacy = toLegacy(pt);
                    matchOpt = find$5(items, (item) => item.format === fontSize || item.format === pt || item.format === legacy);
                }
            }
            return { matchOpt, size: fontSize };
        };
        const isSelectedFor = (item) => (valueOpt) => valueOpt.exists((value) => value.format === item);
        const getCurrentValue = () => {
            const { matchOpt } = getMatchingValue();
            return matchOpt;
        };
        const getPreviewFor = constant$1(Optional.none);
        const onAction = (rawItem) => () => {
            editor.undoManager.transact(() => {
                editor.focus();
                editor.execCommand('FontSize', false, rawItem.format);
            });
        };
        const updateSelectMenuText = (comp) => {
            const { matchOpt, size } = getMatchingValue();
            const text = matchOpt.fold(constant$1(size), (match) => match.title);
            emitWith(comp, updateMenuText, {
                text
            });
            fireFontSizeTextUpdate(editor, { value: text });
        };
        const dataset = buildBasicSettingsDataset(editor, 'font_size_formats', Delimiter.Space);
        return {
            tooltip: makeTooltipText(editor, getTooltipPlaceholder$1(), fallbackFontSize),
            text: Optional.some(fallbackFontSize),
            icon: Optional.none(),
            isSelectedFor,
            getPreviewFor,
            getCurrentValue,
            onAction,
            updateText: updateSelectMenuText,
            dataset,
            shouldHide: false,
            isInvalid: never
        };
    };
    const createFontSizeButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$1(editor), getTooltipPlaceholder$1, 'FontSizeTextUpdate', 'fontsize');
    const getConfigFromUnit = (unit) => {
        var _a;
        const baseConfig = { step: 1 };
        const configs = {
            em: { step: 0.1 },
            cm: { step: 0.1 },
            in: { step: 0.1 },
            pc: { step: 0.1 },
            ch: { step: 0.1 },
            rem: { step: 0.1 }
        };
        return (_a = configs[unit]) !== null && _a !== void 0 ? _a : baseConfig;
    };
    const defaultValue = 16;
    const isValidValue = (value) => value >= 0;
    const getNumberInputSpec = (editor) => {
        const getCurrentValue = () => editor.queryCommandValue('FontSize');
        const updateInputValue = (comp) => emitWith(comp, updateMenuText, {
            text: getCurrentValue()
        });
        return {
            updateInputValue,
            onAction: (format, focusBack) => editor.execCommand('FontSize', false, format, { skip_focus: !focusBack }),
            getNewValue: (text, updateFunction) => {
                parse(text, ['unsupportedLength', 'empty']);
                const currentValue = getCurrentValue();
                const parsedText = parse(text, ['unsupportedLength', 'empty']).or(parse(currentValue, ['unsupportedLength', 'empty']));
                const value = parsedText.map((res) => res.value).getOr(defaultValue);
                const defaultUnit = getFontSizeInputDefaultUnit(editor);
                const unit = parsedText.map((res) => res.unit).filter((u) => u !== '').getOr(defaultUnit);
                const newValue = updateFunction(value, getConfigFromUnit(unit).step);
                const res = `${isValidValue(newValue) ? newValue : value}${unit}`;
                if (res !== currentValue) {
                    fireFontSizeInputTextUpdate(editor, { value: res });
                }
                return res;
            }
        };
    };
    const createFontSizeInputButton = (editor, backstage) => createBespokeNumberInput(editor, backstage, getNumberInputSpec(editor), 'fontsizeinput');
    // TODO: Test this!
    const createFontSizeMenu = (editor, backstage) => {
        const menuItems = createMenuItems(backstage, getSpec$1(editor));
        editor.ui.registry.addNestedMenuItem('fontsize', {
            text: menuTitle$1,
            onSetup: onSetupEditableToggle(editor),
            getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
        });
    };

    const menuTitle = 'Formats';
    const getTooltipPlaceholder = (value) => isEmpty(value) ? 'Formats' : 'Format {0}';
    const getSpec = (editor, dataset) => {
        const fallbackFormat = 'Formats';
        const isSelectedFor = (format) => () => editor.formatter.match(format);
        const getPreviewFor = (format) => () => {
            const fmt = editor.formatter.get(format);
            return fmt !== undefined ? Optional.some({
                tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',
                styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
            }) : Optional.none();
        };
        const updateSelectMenuText = (comp) => {
            const getFormatItems = (fmt) => {
                if (isNestedFormat(fmt)) {
                    return bind$3(fmt.items, getFormatItems);
                }
                else if (isFormatReference(fmt)) {
                    return [{ title: fmt.title, format: fmt.format }];
                }
                else {
                    return [];
                }
            };
            const flattenedItems = bind$3(getStyleFormats(editor), getFormatItems);
            const detectedFormat = findNearest(editor, constant$1(flattenedItems));
            const text = detectedFormat.fold(constant$1({
                title: fallbackFormat,
                tooltipLabel: ''
            }), (fmt) => ({
                title: fmt.title,
                tooltipLabel: fmt.title
            }));
            emitWith(comp, updateMenuText, {
                text: text.title
            });
            fireStylesTextUpdate(editor, { value: text.tooltipLabel });
        };
        return {
            tooltip: makeTooltipText(editor, getTooltipPlaceholder(''), ''),
            text: Optional.some(fallbackFormat),
            icon: Optional.none(),
            isSelectedFor,
            getCurrentValue: Optional.none,
            getPreviewFor,
            onAction: onActionToggleFormat$1(editor),
            updateText: updateSelectMenuText,
            shouldHide: shouldAutoHideStyleFormats(editor),
            isInvalid: (item) => !editor.formatter.canApply(item.format),
            dataset
        };
    };
    const createStylesButton = (editor, backstage) => {
        const dataset = { type: 'advanced', ...backstage.styles };
        return createSelectButton(editor, backstage, getSpec(editor, dataset), getTooltipPlaceholder, 'StylesTextUpdate', 'styles');
    };
    const createStylesMenu = (editor, backstage) => {
        const dataset = { type: 'advanced', ...backstage.styles };
        const menuItems = createMenuItems(backstage, getSpec(editor, dataset));
        editor.ui.registry.addNestedMenuItem('styles', {
            text: menuTitle,
            onSetup: onSetupEditableToggle(editor, () => menuItems.getStyleItems().length > 0),
            getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
        });
    };

    const defaultToolbar = [
        {
            name: 'history', items: ['undo', 'redo']
        },
        {
            name: 'ai', items: ['aidialog', 'aishortcuts']
        },
        {
            name: 'styles', items: ['styles']
        },
        {
            name: 'formatting', items: ['bold', 'italic']
        },
        {
            name: 'alignment', items: ['alignleft', 'aligncenter', 'alignright', 'alignjustify']
        },
        {
            name: 'indentation', items: ['outdent', 'indent']
        },
        {
            name: 'permanent pen', items: ['permanentpen']
        },
        {
            name: 'comments', items: ['addcomment']
        }
    ];
    const renderFromBridge = (bridgeBuilder, render) => (spec, backstage, editor, btnName) => {
        const internal = bridgeBuilder(spec).mapError((errInfo) => formatError(errInfo)).getOrDie();
        return render(internal, backstage, editor, btnName);
    };
    const types = {
        button: renderFromBridge(createToolbarButton, (s, backstage, _, btnName) => renderToolbarButton(s, backstage.shared.providers, btnName)),
        togglebutton: renderFromBridge(createToggleButton, (s, backstage, _, btnName) => renderToolbarToggleButton(s, backstage.shared.providers, btnName)),
        menubutton: renderFromBridge(createMenuButton, (s, backstage, _, btnName) => renderMenuButton(s, "tox-tbtn" /* ToolbarButtonClasses.Button */, backstage, Optional.none(), false, btnName)),
        splitbutton: renderFromBridge(createSplitButton, (s, backstage, _, btnName) => renderSplitButton(s, backstage.shared, btnName)),
        grouptoolbarbutton: renderFromBridge(createGroupToolbarButton, (s, backstage, editor, btnName) => {
            const buttons = editor.ui.registry.getAll().buttons;
            const identify = (toolbar) => identifyButtons(editor, { buttons, toolbar, allowToolbarGroups: false }, backstage, Optional.none());
            const attributes = {
                [Attribute]: backstage.shared.header.isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop
            };
            switch (getToolbarMode(editor)) {
                case ToolbarMode$1.floating:
                    return renderFloatingToolbarButton(s, backstage, identify, attributes, btnName);
                default:
                    // TODO change this message and add a case when sliding is available
                    throw new Error('Toolbar groups are only supported when using floating toolbar mode');
            }
        })
    };
    const extractFrom = (spec, backstage, editor, btnName) => get$h(types, spec.type).fold(() => {
        // eslint-disable-next-line no-console
        console.error('skipping button defined by', spec);
        return Optional.none();
    }, (render) => Optional.some(render(spec, backstage, editor, btnName)));
    const bespokeButtons = {
        styles: createStylesButton,
        fontsize: createFontSizeButton,
        fontsizeinput: createFontSizeInputButton,
        fontfamily: createFontFamilyButton,
        blocks: createBlocksButton,
        align: createAlignButton,
        navigateback: createNavigateBackButton
    };
    const removeUnusedDefaults = (buttons) => {
        const filteredItemGroups = map$2(defaultToolbar, (group) => {
            const items = filter$2(group.items, (subItem) => has$2(buttons, subItem) || has$2(bespokeButtons, subItem));
            return {
                name: group.name,
                items
            };
        });
        return filter$2(filteredItemGroups, (group) => group.items.length > 0);
    };
    const convertStringToolbar = (strToolbar) => {
        const groupsStrings = strToolbar.split('|');
        return map$2(groupsStrings, (g) => ({
            items: g.trim().split(' ')
        }));
    };
    const isToolbarGroupSettingArray = (toolbar) => isArrayOf(toolbar, (t) => (has$2(t, 'name') || has$2(t, 'label')) && has$2(t, 'items'));
    // Toolbar settings
    // false = disabled
    // undefined or true = default
    // string = enabled with specified buttons and groups
    // string array = enabled with specified buttons and groups
    // object array = enabled with specified buttons, groups and group titles
    const createToolbar = (toolbarConfig) => {
        const toolbar = toolbarConfig.toolbar;
        const buttons = toolbarConfig.buttons;
        if (toolbar === false) {
            return [];
        }
        else if (toolbar === undefined || toolbar === true) {
            return removeUnusedDefaults(buttons);
        }
        else if (isString(toolbar)) {
            return convertStringToolbar(toolbar);
        }
        else if (isToolbarGroupSettingArray(toolbar)) {
            return toolbar;
        }
        else {
            // eslint-disable-next-line no-console
            console.error('Toolbar type should be string, string[], boolean or ToolbarGroup[]');
            return [];
        }
    };
    const lookupButton = (editor, buttons, toolbarItem, allowToolbarGroups, backstage, prefixes) => get$h(buttons, toolbarItem.toLowerCase())
        .orThunk(() => prefixes.bind((ps) => findMap(ps, (prefix) => get$h(buttons, prefix + toolbarItem.toLowerCase()))))
        .fold(() => get$h(bespokeButtons, toolbarItem.toLowerCase()).map((r) => r(editor, backstage)), 
    // TODO: Add back after TINY-3232 is implemented
    // .orThunk(() => {
    //   console.error('No representation for toolbarItem: ' + toolbarItem);
    //   return Optional.none();
    // ),
    (spec) => {
        if (spec.type === 'grouptoolbarbutton' && !allowToolbarGroups) {
            // TODO change this message when sliding is available
            // eslint-disable-next-line no-console
            console.warn(`Ignoring the '${toolbarItem}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`);
            return Optional.none();
        }
        else {
            return extractFrom(spec, backstage, editor, toolbarItem.toLowerCase());
        }
    });
    const identifyButtons = (editor, toolbarConfig, backstage, prefixes) => {
        const toolbarGroups = createToolbar(toolbarConfig);
        const groups = map$2(toolbarGroups, (group) => {
            const items = bind$3(group.items, (toolbarItem) => {
                if (toolbarItem.trim().length === 0) {
                    return [];
                }
                return lookupButton(editor, toolbarConfig.buttons, toolbarItem, toolbarConfig.allowToolbarGroups, backstage, prefixes)
                    .map((spec) => Array.isArray(spec) ? spec : [spec])
                    .getOr([]);
            });
            return {
                title: Optional.from(editor.translate(group.name)),
                label: someIf(group.label !== undefined, editor.translate(group.label)),
                items
            };
        });
        return filter$2(groups, (group) => group.items.length > 0);
    };

    // Set toolbar(s) depending on if multiple toolbars is configured or not
    const setToolbar = (editor, uiRefs, rawUiConfig, backstage) => {
        const outerContainer = uiRefs.mainUi.outerContainer;
        const toolbarConfig = rawUiConfig.toolbar;
        const toolbarButtonsConfig = rawUiConfig.buttons;
        // Check if toolbar type is a non-empty string array
        if (isArrayOf(toolbarConfig, isString)) {
            const toolbars = toolbarConfig.map((t) => {
                const config = { toolbar: t, buttons: toolbarButtonsConfig, allowToolbarGroups: rawUiConfig.allowToolbarGroups };
                return identifyButtons(editor, config, backstage, Optional.none());
            });
            OuterContainer.setToolbars(outerContainer, toolbars);
        }
        else {
            OuterContainer.setToolbar(outerContainer, identifyButtons(editor, rawUiConfig, backstage, Optional.none()));
        }
    };

    const detection = detect$1();
    const isiOS12 = detection.os.isiOS() && detection.os.version.major <= 12;
    const setupEvents$1 = (editor, uiRefs) => {
        const { uiMotherships } = uiRefs;
        const dom = editor.dom;
        let contentWindow = editor.getWin();
        const initialDocEle = editor.getDoc().documentElement;
        const lastWindowDimensions = Cell(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));
        const lastDocumentDimensions = Cell(SugarPosition(initialDocEle.offsetWidth, initialDocEle.offsetHeight));
        const resizeWindow = () => {
            // Check if the window dimensions have changed and if so then trigger a content resize event
            const outer = lastWindowDimensions.get();
            if (outer.left !== contentWindow.innerWidth || outer.top !== contentWindow.innerHeight) {
                lastWindowDimensions.set(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));
                fireResizeContent(editor);
            }
        };
        const resizeDocument = () => {
            // Don't use the initial doc ele, as there's a small chance it may have changed
            const docEle = editor.getDoc().documentElement;
            // Check if the document dimensions have changed and if so then trigger a content resize event
            const inner = lastDocumentDimensions.get();
            if (inner.left !== docEle.offsetWidth || inner.top !== docEle.offsetHeight) {
                lastDocumentDimensions.set(SugarPosition(docEle.offsetWidth, docEle.offsetHeight));
                fireResizeContent(editor);
            }
        };
        const scroll = (e) => {
            fireScrollContent(editor, e);
        };
        dom.bind(contentWindow, 'resize', resizeWindow);
        dom.bind(contentWindow, 'scroll', scroll);
        // Bind to async load events and trigger a content resize event if the size has changed
        const elementLoad = capture(SugarElement.fromDom(editor.getBody()), 'load', resizeDocument);
        // We want to hide ALL UI motherships here.
        editor.on('hide', () => {
            each$1(uiMotherships, (m) => {
                set$7(m.element, 'display', 'none');
            });
        });
        editor.on('show', () => {
            each$1(uiMotherships, (m) => {
                remove$6(m.element, 'display');
            });
        });
        editor.on('NodeChange', resizeDocument);
        editor.on('remove', () => {
            elementLoad.unbind();
            dom.unbind(contentWindow, 'resize', resizeWindow);
            dom.unbind(contentWindow, 'scroll', scroll);
            // Clean memory for IE
            contentWindow = null;
        });
    };
    // TINY-9226: When set, the `ui_mode: split` option will create two different sinks (one for popups and one for sinks)
    // and the popup sink will be placed adjacent to the editor. This will make it having the same scrolling ancestry.
    const attachUiMotherships = (editor, uiRoot, uiRefs) => {
        if (isSplitUiMode(editor)) {
            attachSystemAfter(uiRefs.mainUi.mothership.element, uiRefs.popupUi.mothership);
        }
        // In UiRefs, dialogUi and popupUi refer to the same thing if ui_mode: combined
        attachSystem(uiRoot, uiRefs.dialogUi.mothership);
    };
    const render$1 = (editor, uiRefs, rawUiConfig, backstage, args) => {
        const { mainUi, uiMotherships } = uiRefs;
        const lastToolbarWidth = Cell(0);
        const outerContainer = mainUi.outerContainer;
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        iframe(editor);
        const eTargetNode = SugarElement.fromDom(args.targetNode);
        const uiRoot = getContentContainer(getRootNode(eTargetNode));
        attachSystemAfter(eTargetNode, mainUi.mothership);
        attachUiMotherships(editor, uiRoot, uiRefs);
        editor.on('PostRender', () => {
            OuterContainer.setSidebar(outerContainer, rawUiConfig.sidebar, getSidebarShow(editor));
        });
        // TINY-10343: Using `SkinLoaded` instead of `PostRender` because if the skin loading takes too long you run in to rendering problems since things are measured before the CSS is being applied
        editor.on('SkinLoaded', () => {
            // Set the sidebar before the toolbar and menubar
            // - each sidebar has an associated toggle toolbar button that needs to check the
            //   sidebar that is set to determine its active state on setup
            setToolbar(editor, uiRefs, rawUiConfig, backstage);
            lastToolbarWidth.set(editor.getWin().innerWidth);
            OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));
            OuterContainer.setViews(outerContainer, rawUiConfig.views);
            setupEvents$1(editor, uiRefs);
        });
        const socket = OuterContainer.getSocket(outerContainer).getOrDie('Could not find expected socket element');
        if (isiOS12) {
            setAll(socket.element, {
                'overflow': 'scroll',
                '-webkit-overflow-scrolling': 'touch' // required for ios < 13 content scrolling
            });
            const limit = first$1(() => {
                editor.dispatch('ScrollContent');
            }, 20);
            const unbinder = bind$1(socket.element, 'scroll', limit.throttle);
            editor.on('remove', unbinder.unbind);
        }
        setupEventsForUi(editor, uiRefs);
        editor.addCommand('ToggleSidebar', (_ui, value) => {
            OuterContainer.toggleSidebar(outerContainer, value);
            fireToggleSidebar(editor);
        });
        editor.addQueryValueHandler('ToggleSidebar', () => { var _a; return (_a = OuterContainer.whichSidebar(outerContainer)) !== null && _a !== void 0 ? _a : ''; });
        editor.addCommand('ToggleView', (_ui, value) => {
            if (OuterContainer.toggleView(outerContainer, value)) {
                const target = outerContainer.element;
                mainUi.mothership.broadcastOn([dismissPopups()], { target });
                each$1(uiMotherships, (m) => {
                    m.broadcastOn([dismissPopups()], { target });
                });
                // Switching back to main view should focus the editor and update any UIs
                if (isNull(OuterContainer.whichView(outerContainer))) {
                    editor.focus();
                    editor.nodeChanged();
                    OuterContainer.refreshToolbar(outerContainer);
                }
                fireToggleView(editor);
            }
        });
        editor.addQueryValueHandler('ToggleView', () => { var _a; return (_a = OuterContainer.whichView(outerContainer)) !== null && _a !== void 0 ? _a : ''; });
        const toolbarMode = getToolbarMode(editor);
        const refreshDrawer = () => {
            OuterContainer.refreshToolbar(uiRefs.mainUi.outerContainer);
        };
        if (toolbarMode === ToolbarMode$1.sliding || toolbarMode === ToolbarMode$1.floating) {
            editor.on('ResizeWindow ResizeEditor ResizeContent', () => {
                // Check if the width has changed, if so then refresh the toolbar drawer. We don't care if height changes.
                const width = editor.getWin().innerWidth;
                if (width !== lastToolbarWidth.get()) {
                    refreshDrawer();
                    lastToolbarWidth.set(width);
                }
            });
        }
        const api = {
            setEnabled: (state) => {
                const eventType = state ? 'setEnabled' : 'setDisabled';
                broadcastEvents(uiRefs, eventType);
            },
            isEnabled: () => !Disabling.isDisabled(outerContainer)
        };
        return {
            iframeContainer: socket.element.dom,
            editorContainer: outerContainer.element.dom,
            api
        };
    };

    var Iframe = /*#__PURE__*/Object.freeze({
        __proto__: null,
        render: render$1
    });

    const parseToInt = (val) => {
        // if size is a number or '_px', will return the number
        const re = /^[0-9\.]+(|px)$/i;
        if (re.test('' + val)) {
            return Optional.some(parseInt('' + val, 10));
        }
        return Optional.none();
    };
    const numToPx = (val) => isNumber(val) ? val + 'px' : val;
    const calcCappedSize = (size, minSize, maxSize) => {
        const minOverride = minSize.filter((min) => size < min);
        const maxOverride = maxSize.filter((max) => size > max);
        return minOverride.or(maxOverride).getOr(size);
    };
    const convertValueToPx = (element, value) => {
        if (typeof value === 'number') {
            return Optional.from(value);
        }
        const splitValue = /^([0-9.]+)(pt|em|px)$/.exec(value.trim());
        if (splitValue) {
            const type = splitValue[2];
            const parsed = Number.parseFloat(splitValue[1]);
            if (Number.isNaN(parsed) || parsed < 0) {
                return Optional.none();
            }
            else if (type === 'em') {
                return Optional.from(parsed * Number.parseFloat(window.getComputedStyle(element.dom).fontSize));
            }
            else if (type === 'pt') {
                return Optional.from(parsed * (72 / 96));
            }
            else if (type === 'px') {
                return Optional.from(parsed);
            }
        }
        return Optional.none();
    };

    const getHeight = (editor) => {
        const baseHeight = convertValueToPx(SugarElement.fromDom(editor.targetElm), getHeightOption(editor));
        const minHeight = getMinHeightOption(editor);
        const maxHeight = getMaxHeightOption(editor);
        return baseHeight.map((height) => calcCappedSize(height, minHeight, maxHeight));
    };
    const getHeightWithFallback = (editor) => {
        return getHeight(editor).getOr(getHeightOption(editor)); // If we can't parse, set the height while ignoring min/max values.
    };
    const getWidth = (editor) => {
        const baseWidth = getWidthOption(editor);
        const minWidth = getMinWidthOption(editor);
        const maxWidth = getMaxWidthOption(editor);
        return parseToInt(baseWidth).map((width) => calcCappedSize(width, minWidth, maxWidth));
    };
    const getWidthWithFallback = (editor) => {
        const width = getWidth(editor);
        return width.getOr(getWidthOption(editor));
    };

    const { ToolbarLocation, ToolbarMode } = Options;
    const maximumDistanceToEdge = 40;
    const InlineHeader = (editor, targetElm, uiRefs, backstage, floatContainer) => {
        const { mainUi, uiMotherships } = uiRefs;
        const DOM = global$9.DOM;
        const useFixedToolbarContainer = useFixedContainer(editor);
        const isSticky = isStickyToolbar(editor);
        const editorMaxWidthOpt = getMaxWidthOption(editor).or(getWidth(editor));
        const headerBackstage = backstage.shared.header;
        const isPositionedAtTop = headerBackstage.isPositionedAtTop;
        const minimumToolbarWidth = 150; // Value is arbitrary.
        const toolbarMode = getToolbarMode(editor);
        const isSplitToolbar = toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating;
        const visible = Cell(false);
        const isVisible = () => visible.get() && !editor.removed;
        // Calculate the toolbar offset when using a split toolbar drawer
        const calcToolbarOffset = (toolbar) => isSplitToolbar ?
            toolbar.fold(constant$1(0), (tbar) => 
            // If we have an overflow toolbar, we need to offset the positioning by the height of the overflow toolbar
            tbar.components().length > 1 ? get$d(tbar.components()[1].element) : 0) : 0;
        const calcMode = (container) => {
            switch (getToolbarLocation(editor)) {
                case ToolbarLocation.auto:
                    const toolbar = OuterContainer.getToolbar(mainUi.outerContainer);
                    const offset = calcToolbarOffset(toolbar);
                    const toolbarHeight = get$d(container.element) - offset;
                    const targetBounds = box$1(targetElm);
                    // Determine if the toolbar has room to render at the top/bottom of the document
                    const roomAtTop = targetBounds.y > toolbarHeight;
                    if (roomAtTop) {
                        return 'top';
                    }
                    else {
                        const doc = documentElement(targetElm);
                        const docHeight = Math.max(doc.dom.scrollHeight, get$d(doc));
                        const roomAtBottom = targetBounds.bottom < docHeight - toolbarHeight;
                        // If there isn't ever room to add the toolbar above the target element, then place the toolbar at the bottom.
                        // Likewise if there's no room at the bottom, then we should show at the top. If there's no room at the bottom
                        // or top, then prefer the bottom except when it'll prevent accessing the content at the bottom.
                        // Make sure to exclude scroll position, as we want to still show at the top if the user can scroll up to undock
                        if (roomAtBottom) {
                            return 'bottom';
                        }
                        else {
                            const winBounds = win();
                            const isRoomAtBottomViewport = winBounds.bottom < targetBounds.bottom - toolbarHeight;
                            return isRoomAtBottomViewport ? 'bottom' : 'top';
                        }
                    }
                case ToolbarLocation.bottom:
                    return 'bottom';
                case ToolbarLocation.top:
                default:
                    return 'top';
            }
        };
        const setupMode = (mode) => {
            // Update the docking mode
            floatContainer.on((container) => {
                Docking.setModes(container, [mode]);
                headerBackstage.setDockingMode(mode);
                // Update the vertical menu direction
                const verticalDir = isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop;
                set$9(container.element, Attribute, verticalDir);
            });
        };
        const updateChromeWidth = () => {
            floatContainer.on((container) => {
                // Update the max width of the inline toolbar
                const maxWidth = editorMaxWidthOpt.getOrThunk(() => {
                    // Adding 10px of margin so that the toolbar won't try to wrap
                    return getBounds$1().width - viewport$1(targetElm).left - 10;
                });
                set$7(container.element, 'max-width', maxWidth + 'px');
            });
        };
        const updateChromePosition = (isOuterContainerWidthRestored, prevScroll) => {
            floatContainer.on((container) => {
                const toolbar = OuterContainer.getToolbar(mainUi.outerContainer);
                const offset = calcToolbarOffset(toolbar);
                // The float container/editor may not have been rendered yet, which will cause it to have a non integer based positions
                // so we need to round this to account for that.
                const targetBounds = box$1(targetElm);
                const offsetParent = getOffsetParent$1(editor, mainUi.outerContainer.element);
                const getLeft = () => offsetParent.fold(() => targetBounds.x, (offsetParent) => {
                    // Because for ui_mode: split, the main mothership (which includes the toolbar) is moved and added as a sibling
                    // If there's any relative position div set as the parent and the offsetParent is no longer the body,
                    // the absolute top/left positions would no longer be correct
                    // When there's a relative div and the position is the same as the toolbar container
                    // then it would produce a negative top as it needs to be positioned on top of the offsetParent
                    const offsetBox = box$1(offsetParent);
                    const isOffsetParentBody = eq(offsetParent, body());
                    return isOffsetParentBody
                        ? targetBounds.x
                        : targetBounds.x - offsetBox.x;
                });
                const getTop = () => offsetParent.fold(() => isPositionedAtTop()
                    ? Math.max(targetBounds.y - get$d(container.element) + offset, 0)
                    : targetBounds.bottom, (offsetParent) => {
                    var _a;
                    // Because for ui_mode: split, the main mothership (which includes the toolbar) is moved and added as a sibling
                    // If there's any relative position div set as the parent and the offsetParent is no longer the body,
                    // the absolute top/left positions would no longer be correct
                    // When there's a relative div and the position is the same as the toolbar container
                    // then it would produce a negative top as it needs to be positioned on top of the offsetParent
                    const offsetBox = box$1(offsetParent);
                    const scrollDelta = (_a = offsetParent.dom.scrollTop) !== null && _a !== void 0 ? _a : 0;
                    const isOffsetParentBody = eq(offsetParent, body());
                    const topValue = isOffsetParentBody
                        ? Math.max(targetBounds.y - get$d(container.element) + offset, 0)
                        : targetBounds.y - offsetBox.y + scrollDelta - get$d(container.element) + offset;
                    return isPositionedAtTop()
                        ? topValue
                        : targetBounds.bottom;
                });
                const left = getLeft();
                const widthProperties = someIf(isOuterContainerWidthRestored, 
                // This width can be used for calculating the "width" when resolving issues with flex-wrapping being triggered at the window width, despite scroll space being available to the right.
                Math.ceil(mainUi.outerContainer.element.dom.getBoundingClientRect().width))
                    // this check is needed because if the toolbar is rendered outside of the `outerContainer` because the toolbar have `position: "fixed"`
                    // the calculate width isn't correct
                    .filter((w) => w > minimumToolbarWidth).map((toolbarWidth) => {
                    const scroll = prevScroll.getOr(get$b());
                    /*
                  As the editor container can wrap its elements (due to flex-wrap), the width of the container impacts also its height. Adding a minimum width works around two problems:
        
                  a) The docking behaviour (e.g. lazyContext) does not handle the situation of a very thin component near the edge of the screen very well, and actually has no concept of horizontal scroll - it only checks y values.
        
                  b) A very small toolbar is essentially unusable. On scrolling of X, we keep updating the width of the toolbar so that it can grow to fit the available space.
        
                  Note: this is entirely determined on the number of items in the menu and the toolbar, because when they wrap, that's what causes the height. Also, having multiple toolbars can also make it higher.
                  */
                    const availableWidth = window.innerWidth - (left - scroll.left);
                    const width = Math.max(Math.min(toolbarWidth, availableWidth), minimumToolbarWidth);
                    if (availableWidth < toolbarWidth) {
                        set$7(mainUi.outerContainer.element, 'width', width + 'px');
                    }
                    return {
                        width: width + 'px'
                    };
                }).getOr({ width: 'max-content' });
                const baseProperties = {
                    position: 'absolute',
                    left: Math.round(left) + 'px',
                    top: getTop() + 'px'
                };
                setAll(mainUi.outerContainer.element, {
                    ...baseProperties,
                    ...widthProperties
                });
            });
        };
        // This would return Optional.none, for ui_mode: combined, which will fallback to the default code block
        // For ui_mode: split, the offsetParent would be the body if there were no relative div set as parent
        const getOffsetParent$1 = (editor, element) => isSplitUiMode(editor) ? getOffsetParent(element) : Optional.none();
        const repositionPopups$1 = () => {
            each$1(uiMotherships, (m) => {
                m.broadcastOn([repositionPopups()], {});
            });
        };
        const restoreOuterContainerWidth = () => {
            /*
            Editors can be placed so far to the right that their left position is beyond the window width. This causes problems with flex-wrap. To solve this, set a width style on the container.
            Natural width of the container needs to be calculated first.
            */
            if (!useFixedToolbarContainer) {
                const toolbarCurrentRightsidePosition = absolute$3(mainUi.outerContainer.element).left + getOuter(mainUi.outerContainer.element);
                /*
                Check the width if we are within X number of pixels to the edge ( or above ). Also check if we have the width-value set.
                This helps handling the issue where it goes from having a width set ( because it's too wide ) to going so far from the edge it no longer triggers the problem. Common when the width is changed by test.
                */
                if (toolbarCurrentRightsidePosition >= window.innerWidth - maximumDistanceToEdge || getRaw(mainUi.outerContainer.element, 'width').isSome()) {
                    set$7(mainUi.outerContainer.element, 'position', 'absolute');
                    set$7(mainUi.outerContainer.element, 'left', '0px');
                    remove$6(mainUi.outerContainer.element, 'width');
                    return true;
                }
            }
            return false;
        };
        const update = (stickyAction) => {
            // Skip updating the ui if it's hidden
            if (!isVisible()) {
                return;
            }
            // Handles positioning, docking and SplitToolbar (more drawer) behaviour. Modes:
            // 1. Basic inline: does positioning and docking
            // 2. Inline + more drawer: does positioning, docking and SplitToolbar
            // 3. Inline + fixed_toolbar_container: does nothing
            // 4. Inline + fixed_toolbar_container + more drawer: does SplitToolbar
            // Update the max width, as the body width may have changed
            if (!useFixedToolbarContainer) {
                updateChromeWidth();
            }
            const prevScroll = get$b();
            const isOuterContainerWidthRestored = useFixedToolbarContainer ? false : restoreOuterContainerWidth();
            /*
              Refresh split toolbar. Before calling refresh, we need to make sure that we have the full width (through restoreOuterContainerWidth above), otherwise too much will be put in the overflow drawer.
              A split toolbar requires a calculation to see what ends up in the "more drawer". When we don't have a split toolbar, then there is no reason to refresh the toolbar when the size changes.
            */
            if (isSplitToolbar) {
                OuterContainer.refreshToolbar(mainUi.outerContainer);
            }
            // Positioning
            if (!useFixedToolbarContainer) {
                // Getting the current scroll as the previous step may have reset the scroll,
                // We also want calculation based on the previous scroll, then restoring the scroll when everything is set.
                const currentScroll = get$b();
                const optScroll = someIf(prevScroll.left !== currentScroll.left, prevScroll);
                // This will position the container in the right spot.
                updateChromePosition(isOuterContainerWidthRestored, optScroll);
                // Restore scroll left position only if they are different, keeping the current scroll top, that shouldn't be changed
                optScroll.each((scroll) => {
                    to(scroll.left, currentScroll.top);
                });
            }
            // Docking
            if (isSticky) {
                floatContainer.on(stickyAction);
            }
            // Floating toolbar
            repositionPopups$1();
        };
        const doUpdateMode = () => {
            // Skip updating the mode if the toolbar is hidden, is
            // using a fixed container or has sticky toolbars disabled
            if (useFixedToolbarContainer || !isSticky || !isVisible()) {
                return false;
            }
            return floatContainer.get().exists((fc) => {
                const currentMode = headerBackstage.getDockingMode();
                const newMode = calcMode(fc);
                // Note: the docking mode will only be able to change when the `toolbar_location`
                // is set to "auto".
                if (newMode !== currentMode) {
                    setupMode(newMode);
                    return true;
                }
                else {
                    return false;
                }
            });
        };
        const show = () => {
            visible.set(true);
            set$7(mainUi.outerContainer.element, 'display', 'flex');
            DOM.addClass(editor.getBody(), 'mce-edit-focus');
            each$1(uiMotherships, (m) => {
                // We remove the display style when showing, because when hiding, we set it to "none"
                remove$6(m.element, 'display');
            });
            doUpdateMode();
            if (isSplitUiMode(editor)) {
                // When the toolbar is shown, then hidden and when the page is then scrolled,
                // the toolbar is set to docked, which shouldn't be as it should be static position
                // calling reset here, to reset the state.
                // Another case would be when the toolbar is shown initially (with location_bottom)
                // we don't want to dock the toolbar, calling Docking.refresh
                update((elem) => Docking.isDocked(elem) ? Docking.reset(elem) : Docking.refresh(elem));
            }
            else {
                // Even if we aren't updating the docking mode, we still want to reposition
                // the Ui. NOTE: We are using Docking.refresh here, rather than Docking.reset. This
                // means it should keep whatever its "previous" coordinates were, and will just
                // behave like the window was scrolled again, and Docking needs to work out if it
                // is going to dock / undock
                update(Docking.refresh);
            }
        };
        const hide = () => {
            visible.set(false);
            set$7(mainUi.outerContainer.element, 'display', 'none');
            DOM.removeClass(editor.getBody(), 'mce-edit-focus');
            each$1(uiMotherships, (m) => {
                set$7(m.element, 'display', 'none');
            });
        };
        const updateMode = () => {
            const changedMode = doUpdateMode();
            // If the docking mode has changed due to the update, we want to reset
            // docking. This will clear any prior stored positions
            if (changedMode) {
                update(Docking.reset);
            }
        };
        return {
            isVisible,
            isPositionedAtTop,
            show,
            hide,
            update,
            updateMode,
            repositionPopups: repositionPopups$1
        };
    };

    const getTargetPosAndBounds = (targetElm, isToolbarTop) => {
        const bounds = box$1(targetElm);
        return {
            pos: isToolbarTop ? bounds.y : bounds.bottom,
            bounds
        };
    };
    const setupEvents = (editor, targetElm, ui, toolbarPersist) => {
        const prevPosAndBounds = Cell(getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()));
        const resizeContent = (e) => {
            const { pos, bounds } = getTargetPosAndBounds(targetElm, ui.isPositionedAtTop());
            const { pos: prevPos, bounds: prevBounds } = prevPosAndBounds.get();
            const hasResized = bounds.height !== prevBounds.height || bounds.width !== prevBounds.width;
            prevPosAndBounds.set({ pos, bounds });
            if (hasResized) {
                fireResizeContent(editor, e);
            }
            if (ui.isVisible()) {
                if (prevPos !== pos) {
                    // The proposed toolbar location has moved, so we need to reposition the Ui. This might
                    // include things like refreshing any Docking / stickiness for the toolbars
                    ui.update(Docking.reset);
                }
                else if (hasResized) {
                    // The proposed toolbar location hasn't moved, but the dimensions of the editor have changed.
                    // We use "updateMode" here instead of "update". The primary reason is that "updateMode"
                    // only repositions the Ui if it has detected that the docking mode needs to change, which
                    // will only happen with `toolbar_location` is set to `auto`.
                    ui.updateMode();
                    // NOTE: This repositionPopups call is going to be a duplicate if "updateMode" identifies
                    // that the mode has changed. We probably need to make it a bit more granular .. so
                    // that we can just query if the mode has changed. Otherwise, we're going to end up with
                    // situations like this where we are doing a potentially expensive operation
                    // (repositionPopups) more than once.
                    ui.repositionPopups();
                }
            }
        };
        if (!toolbarPersist) {
            editor.on('activate', ui.show);
            editor.on('deactivate', ui.hide);
        }
        // For both the initial load (SkinLoaded) and any resizes (ResizeWindow), we want to
        // update the positions of the Ui elements (and reset Docking / stickiness)
        editor.on('SkinLoaded ResizeWindow', () => ui.update(Docking.reset));
        editor.on('NodeChange keydown', (e) => {
            requestAnimationFrame(() => resizeContent(e));
        });
        // When the page has been scrolled, we need to update any docking positions. We also
        // want to reposition all the Ui elements if required.
        let lastScrollX = 0;
        const updateUi = last(() => ui.update(Docking.refresh), 33);
        editor.on('ScrollWindow', () => {
            const newScrollX = get$b().left;
            if (newScrollX !== lastScrollX) {
                lastScrollX = newScrollX;
                updateUi.throttle();
            }
            ui.updateMode();
        });
        if (isSplitUiMode(editor)) {
            editor.on('ElementScroll', (_args) => {
                // When the scroller containing the editor scrolls, update the Ui positions
                ui.update(Docking.refresh);
            });
        }
        // Bind to async load events and trigger a content resize event if the size has changed
        // This is handling resizing based on anything loading inside the content (e.g. img tags)
        const elementLoad = unbindable();
        elementLoad.set(capture(SugarElement.fromDom(editor.getBody()), 'load', (e) => resizeContent(e.raw)));
        editor.on('remove', () => {
            elementLoad.clear();
        });
    };
    const render = (editor, uiRefs, rawUiConfig, backstage, args) => {
        const { mainUi } = uiRefs;
        // This is used to store the reference to the header part of OuterContainer, which is
        // *not* created by this module. This reference is used to make sure that we only bind
        // events for an inline container *once* ... because our show function is just the
        // InlineHeader's show function if this reference is already set. We pass it through to
        // InlineHeader because InlineHeader will depend on it.
        const floatContainer = value$2();
        const targetElm = SugarElement.fromDom(args.targetNode);
        const ui = InlineHeader(editor, targetElm, uiRefs, backstage, floatContainer);
        const toolbarPersist = isToolbarPersist(editor);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        inline(editor);
        const render = () => {
            // Because we set the floatContainer immediately afterwards, this is just telling us
            // if we have already called this code (e.g. show, hide, show) - then don't do anything
            // more than show. It's a pretty messy way of ensuring that all the code that follows
            // this `if` block is only executed once (setting up events etc.). So the first call
            // to `render` will execute it, but the second call won't. This `render` function is
            // used for most of the "show" handlers here, so the function can be invoked either
            // for the first time, or or just because something is being show again, after being
            // toggled to hidden earlier.
            if (floatContainer.isSet()) {
                ui.show();
                return;
            }
            // Set up the header part of OuterContainer. Once configured, the `InlineHeader` code
            // will use it when setting up and updating the Ui. This module uses it mainly just to
            // allow us to call `render` multiple times, but only have it execute the setup code once.
            floatContainer.set(OuterContainer.getHeader(mainUi.outerContainer).getOrDie());
            // `uiContainer` handles *where* the motherhips get added by default. Currently, uiContainer
            // will mostly be the <body> of the document (unless it's a ShadowRoot). When using ui_mode: split,
            // the main mothership (which includes the toolbar) and popup sinks will be added as siblings of
            // the target element, so that they have the same scrolling context / environment
            const uiContainer = getUiContainer(editor);
            // Position the motherships based on the editor Ui options.
            if (isSplitUiMode(editor)) {
                attachSystemAfter(targetElm, mainUi.mothership);
                // Only in ui_mode: split, do we have a separate popup sink
                attachSystemAfter(targetElm, uiRefs.popupUi.mothership);
            }
            else {
                attachSystem(uiContainer, mainUi.mothership);
            }
            // NOTE: In UiRefs, dialogUi and popupUi refer to the same thing if ui_mode: combined
            attachSystem(uiContainer, uiRefs.dialogUi.mothership);
            const setup = () => {
                // Unlike menubar below which uses OuterContainer directly, this level of abstraction is
                // required because of the different types of toolbars available (e.g. multiple vs single)
                setToolbar(editor, uiRefs, rawUiConfig, backstage);
                OuterContainer.setMenubar(mainUi.outerContainer, identifyMenus(editor, rawUiConfig));
                // Initialise the toolbar - set initial positioning then show
                ui.show();
                setupEvents(editor, targetElm, ui, toolbarPersist);
                editor.nodeChanged();
            };
            if (toolbarPersist) {
                // TINY-10482: for `toolbar_persist: true` we need to wait for the skin to be loaded before showing the toolbar/menubar.
                // Without this, there's the occasional chance that the toolbar/menubar could be set/shown before the skin has finished
                // loading, which causes CSS issues.
                editor.once('SkinLoaded', setup);
            }
            else {
                setup();
            }
        };
        editor.on('show', render);
        editor.on('hide', ui.hide);
        if (!toolbarPersist) {
            editor.on('focus', render);
            editor.on('blur', ui.hide);
        }
        editor.on('init', () => {
            if (editor.hasFocus() || toolbarPersist) {
                render();
            }
        });
        setupEventsForUi(editor, uiRefs);
        const api = {
            show: render,
            hide: ui.hide,
            setEnabled: (state) => {
                const eventType = state ? 'setEnabled' : 'setDisabled';
                broadcastEvents(uiRefs, eventType);
            },
            isEnabled: () => !Disabling.isDisabled(mainUi.outerContainer)
        };
        return {
            editorContainer: mainUi.outerContainer.element.dom,
            api
        };
    };

    var Inline = /*#__PURE__*/Object.freeze({
        __proto__: null,
        render: render
    });

    const LazyUiReferences = () => {
        const dialogUi = value$2();
        const popupUi = value$2();
        const mainUi = value$2();
        const lazyGetInOuterOrDie = (label, f) => () => mainUi.get().bind((oc) => f(oc.outerContainer)).getOrDie(`Could not find ${label} element in OuterContainer`);
        // TINY-9226: If the motherships are the same, return just the dialog Ui of them (ui_mode: combined mode)
        const getUiMotherships = () => {
            const optDialogMothership = dialogUi.get().map((ui) => ui.mothership);
            const optPopupMothership = popupUi.get().map((ui) => ui.mothership);
            return optDialogMothership.fold(() => optPopupMothership.toArray(), (dm) => optPopupMothership.fold(() => [dm], (pm) => eq(dm.element, pm.element) ? [dm] : [dm, pm]));
        };
        return {
            dialogUi,
            popupUi,
            mainUi,
            getUiMotherships,
            lazyGetInOuterOrDie
        };
    };

    // TODO: Find a better way of doing this. We probably don't want to just listen to
    // editor events. Having an API available like WindowManager would be the best option
    const showContextToolbarEvent = 'contexttoolbar-show';
    const hideContextToolbarEvent = 'contexttoolbar-hide';

    const getFormApi = (input, valueState, focusfallbackElement) => {
        return ({
            setInputEnabled: (state) => {
                if (!state && focusfallbackElement) {
                    focus$4(focusfallbackElement);
                }
                Disabling.set(input, !state);
            },
            isInputEnabled: () => !Disabling.isDisabled(input),
            hide: () => {
                emit(input, sandboxClose());
            },
            back: () => {
                emit(input, backSlideEvent);
            },
            getValue: () => {
                return valueState.get().getOrThunk(() => Representing.getValue(input));
            },
            setValue: (value) => {
                if (input.getSystem().isConnected()) {
                    Representing.setValue(input, value);
                }
                else {
                    valueState.set(value);
                }
            }
        });
    };
    const getFormParentApi = (comp, valueState, focusfallbackElement) => {
        const parent$1 = parent(comp.element);
        const parentCompOpt = parent$1.bind((parent) => comp.getSystem().getByDom(parent).toOptional());
        return getFormApi(parentCompOpt.getOr(comp), valueState, focusfallbackElement);
    };

    const runOnExecute = (memInput, original, valueState) => run$1(internalToolbarButtonExecute, (comp, se) => {
        const input = memInput.get(comp);
        const formApi = getFormApi(input, valueState, comp.element);
        original.onAction(formApi, se.event.buttonApi);
    });
    const renderContextButton = (memInput, button, providers, valueState) => {
        const { primary, ...rest } = button.original;
        const bridged = getOrDie(createToolbarButton({
            ...rest,
            type: 'button',
            onAction: noop
        }));
        return renderToolbarButtonWith(bridged, providers, [
            runOnExecute(memInput, button, valueState)
        ]);
    };
    const renderContextToggleButton = (memInput, button, providers, valueState) => {
        const { primary, ...rest } = button.original;
        const bridged = getOrDie(createToggleButton({
            ...rest,
            type: 'togglebutton',
            onAction: noop
        }));
        return renderToolbarToggleButtonWith(bridged, providers, [
            runOnExecute(memInput, button, valueState)
        ]);
    };
    const isToggleButton = (button) => button.type === 'contextformtogglebutton';
    const generateOne = (memInput, button, providersBackstage, valueState) => {
        if (isToggleButton(button)) {
            return renderContextToggleButton(memInput, button, providersBackstage, valueState);
        }
        else {
            return renderContextButton(memInput, button, providersBackstage, valueState);
        }
    };
    const generate = (memInput, buttons, providersBackstage, valueState) => {
        const mementos = map$2(buttons, (button) => record(generateOne(memInput, button, providersBackstage, valueState)));
        const asSpecs = () => map$2(mementos, (mem) => mem.asSpec());
        const findPrimary = (compInSystem) => findMap(buttons, (button, i) => {
            if (button.primary) {
                return Optional.from(mementos[i]).bind((mem) => mem.getOpt(compInSystem)).filter(not(Disabling.isDisabled));
            }
            else {
                return Optional.none();
            }
        });
        return {
            asSpecs,
            findPrimary
        };
    };

    const renderContextFormSizeInput = (ctx, providersBackstage, onEnter, valueState) => {
        const { width, height } = ctx.initValue();
        let converter = noSizeConversion;
        const enabled = true;
        const ratioEvent = generate$6('ratio-event');
        const getApi = (comp) => getFormApi(comp, valueState);
        const makeIcon = (iconName) => render$4(iconName, { tag: 'span', classes: ['tox-icon', 'tox-lock-icon__' + iconName] }, providersBackstage.icons);
        const disabled = () => !enabled;
        const label = ctx.label.getOr('Constrain proportions');
        const translatedLabel = providersBackstage.translate(label);
        const pLock = FormCoupledInputs.parts.lock({
            dom: {
                tag: 'button',
                classes: ['tox-lock', 'tox-lock-context-form-size-input', 'tox-button', 'tox-button--naked', 'tox-button--icon'],
                attributes: {
                    'aria-label': translatedLabel,
                    'data-mce-name': label
                }
            },
            components: [
                makeIcon('lock'),
                makeIcon('unlock')
            ],
            buttonBehaviours: derive$1([
                Disabling.config({ disabled }),
                Tabstopping.config({}),
                Tooltipping.config(providersBackstage.tooltips.getConfig({
                    tooltipText: translatedLabel
                }))
            ])
        });
        const formGroup = (components) => ({
            dom: {
                tag: 'div',
                classes: ['tox-context-form__group']
            },
            components
        });
        const goToParent = (comp) => {
            const focussableWrapperOpt = ancestor$1(comp.element, 'div.tox-focusable-wrapper');
            return focussableWrapperOpt.fold(Optional.none, (focussableWrapper) => {
                focus$4(focussableWrapper);
                return Optional.some(true);
            });
        };
        const getFieldPart = (isField1) => FormField.parts.field({
            factory: Input,
            inputClasses: ['tox-textfield', 'tox-toolbar-textfield', 'tox-textfield-size'],
            data: isField1 ? width : height,
            inputBehaviours: derive$1([
                Disabling.config({ disabled }),
                Tabstopping.config({}),
                config('size-input-toolbar-events', [
                    run$1(focusin(), (component, _simulatedEvent) => {
                        emitWith(component, ratioEvent, { isField1 });
                    })
                ]),
                Keying.config({ mode: 'special', onEnter, onEscape: goToParent })
            ]),
            selectOnFocus: false
        });
        const getLabel = (label) => ({
            dom: {
                tag: 'label',
                classes: ['tox-label']
            },
            components: [
                text$2(providersBackstage.translate(label))
            ]
        });
        const focusableWrapper = (field) => ({
            dom: {
                tag: 'div',
                classes: ['tox-focusable-wrapper', 'tox-toolbar-nav-item'],
            },
            components: [field],
            behaviours: derive$1([
                Tabstopping.config({}),
                Focusing.config({}),
                Keying.config({
                    mode: 'special',
                    onEnter: (comp) => {
                        const focussableInputOpt = descendant(comp.element, 'input');
                        return focussableInputOpt.fold(Optional.none, (focussableInput) => {
                            focus$4(focussableInput);
                            return Optional.some(true);
                        });
                    }
                })
            ])
        });
        const widthField = focusableWrapper(FormCoupledInputs.parts.field1(formGroup([FormField.parts.label(getLabel('Width:')), getFieldPart(true)])));
        const heightField = focusableWrapper(FormCoupledInputs.parts.field2(formGroup([FormField.parts.label(getLabel('Height:')), getFieldPart(false)])));
        const editorOffCell = Cell(noop);
        const controlLifecycleHandlers = [
            onControlAttached({
                onBeforeSetup: (comp) => descendant(comp.element, 'input').each(focus$4),
                onSetup: ctx.onSetup,
                getApi
            }, editorOffCell),
            onContextFormControlDetached({ getApi }, editorOffCell, valueState),
        ];
        return FormCoupledInputs.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-context-form__group']
            },
            components: [
                // NOTE: Form coupled inputs to the FormField.sketch themselves.
                widthField,
                formGroup([
                    pLock
                ]),
                heightField
            ],
            field1Name: 'width',
            field2Name: 'height',
            locked: true,
            markers: {
                lockClass: 'tox-locked'
            },
            onLockedChange: (current, other, _lock) => {
                parseSize(Representing.getValue(current)).each((size) => {
                    converter(size).each((newSize) => {
                        Representing.setValue(other, formatSize(newSize));
                    });
                });
            },
            onInput: (current) => emit(current, formInputEvent),
            coupledFieldBehaviours: derive$1([
                Focusing.config({}),
                Keying.config({
                    mode: 'flow',
                    focusInside: FocusInsideModes.OnEnterOrSpaceMode,
                    cycles: false,
                    selector: 'button, .tox-focusable-wrapper',
                }),
                Disabling.config({
                    disabled,
                    onDisabled: (comp) => {
                        FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.disable);
                        FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.disable);
                        FormCoupledInputs.getLock(comp).each(Disabling.disable);
                    },
                    onEnabled: (comp) => {
                        FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.enable);
                        FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.enable);
                        FormCoupledInputs.getLock(comp).each(Disabling.enable);
                    }
                }),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext('mode:design')),
                config('size-input-toolbar-events2', [
                    run$1(ratioEvent, (component, simulatedEvent) => {
                        const isField1 = simulatedEvent.event.isField1;
                        const optCurrent = isField1 ? FormCoupledInputs.getField1(component) : FormCoupledInputs.getField2(component);
                        const optOther = isField1 ? FormCoupledInputs.getField2(component) : FormCoupledInputs.getField1(component);
                        const value1 = optCurrent.map(Representing.getValue).getOr('');
                        const value2 = optOther.map(Representing.getValue).getOr('');
                        converter = makeRatioConverter(value1, value2);
                    }),
                    run$1(formInputEvent, (input) => ctx.onInput(getApi(input))),
                    ...controlLifecycleHandlers,
                ])
            ])
        });
    };

    const createContextFormFieldFromParts = (pLabel, pField, providers) => FormField.sketch({
        dom: {
            tag: 'div',
            classes: ['tox-context-form__group']
        },
        components: [...pLabel.toArray(), pField],
        fieldBehaviours: derive$1([
            Disabling.config({
                disabled: () => providers.checkUiComponentContext('mode:design').shouldDisable,
                onDisabled: (comp) => {
                    focusParent(comp);
                    FormField.getField(comp).each(Disabling.disable);
                },
                onEnabled: (comp) => {
                    FormField.getField(comp).each(Disabling.enable);
                }
            }),
        ])
    });

    const renderContextFormSliderInput = (ctx, providers, onEnter, valueState) => {
        const editorOffCell = Cell(noop);
        const getApi = (comp) => getFormParentApi(comp, valueState);
        const pLabel = ctx.label.map((label) => FormField.parts.label({
            dom: { tag: 'label', classes: ['tox-label'] },
            components: [text$2(providers.translate(label))]
        }));
        const pField = FormField.parts.field({
            factory: Input,
            type: 'range',
            inputClasses: ['tox-toolbar-slider__input', 'tox-toolbar-nav-item'],
            inputAttributes: {
                min: String(ctx.min()),
                max: String(ctx.max())
            },
            data: ctx.initValue().toString(),
            fromInputValue: (value) => toFloat(value).getOr(ctx.min()),
            toInputValue: (value) => String(value),
            inputBehaviours: derive$1([
                Disabling.config({
                    disabled: () => providers.checkUiComponentContext('mode:design').shouldDisable
                }),
                toggleOnReceive(() => providers.checkUiComponentContext('mode:design')),
                Keying.config({
                    mode: 'special',
                    onEnter,
                    // These two lines need to be tested. They are about left and right bypassing
                    // any keyboard handling, and allowing left and right to be processed by the input
                    // Maybe this should go in an alloy sketch for Input?
                    onLeft: (comp, se) => {
                        se.cut();
                        return Optional.none();
                    },
                    onRight: (comp, se) => {
                        se.cut();
                        return Optional.none();
                    }
                }),
                config('slider-events', [
                    onControlAttached({
                        onSetup: ctx.onSetup,
                        getApi,
                        onBeforeSetup: Keying.focusIn
                    }, editorOffCell),
                    onContextFormControlDetached({ getApi }, editorOffCell, valueState),
                    run$1(input(), (comp) => {
                        ctx.onInput(getApi(comp));
                    })
                ])
            ])
        });
        return createContextFormFieldFromParts(pLabel, pField, providers);
    };

    const renderContextFormTextInput = (ctx, providers, onEnter, valueState) => {
        const editorOffCell = Cell(noop);
        const getFormApi = (comp) => getFormParentApi(comp, valueState);
        const pLabel = ctx.label.map((label) => FormField.parts.label({
            dom: { tag: 'label', classes: ['tox-label'] },
            components: [text$2(providers.translate(label))]
        }));
        const placeholder = ctx.placeholder.map((p) => ({ placeholder: providers.translate(p) })).getOr({});
        const inputAttributes = {
            ...placeholder,
        };
        const pField = FormField.parts.field({
            factory: Input,
            inputClasses: ['tox-toolbar-textfield', 'tox-toolbar-nav-item'],
            inputAttributes,
            data: ctx.initValue(),
            selectOnFocus: true,
            inputBehaviours: derive$1([
                Disabling.config({
                    disabled: () => providers.checkUiComponentContext('mode:design').shouldDisable
                }),
                toggleOnReceive(() => providers.checkUiComponentContext('mode:design')),
                Keying.config({
                    mode: 'special',
                    onEnter,
                    // These two lines need to be tested. They are about left and right bypassing
                    // any keyboard handling, and allowing left and right to be processed by the input
                    // Maybe this should go in an alloy sketch for Input?
                    onLeft: (comp, se) => {
                        se.cut();
                        return Optional.none();
                    },
                    onRight: (comp, se) => {
                        se.cut();
                        return Optional.none();
                    }
                }),
                config('input-events', [
                    onControlAttached({
                        onSetup: ctx.onSetup,
                        getApi: (comp) => {
                            const closestFocussableOpt = ancestor$1(comp.element, '.tox-toolbar').bind((toolbar) => descendant(toolbar, 'button:enabled'));
                            return closestFocussableOpt.fold(() => getFormParentApi(comp, valueState), (closestFocussable) => getFormParentApi(comp, valueState, closestFocussable));
                        },
                        onBeforeSetup: Keying.focusIn
                    }, editorOffCell),
                    onContextFormControlDetached({ getApi: getFormApi }, editorOffCell, valueState),
                    run$1(input(), (comp) => {
                        ctx.onInput(getFormApi(comp));
                    })
                ])
            ])
        });
        return createContextFormFieldFromParts(pLabel, pField, providers);
    };

    const buildInitGroup = (f, ctx, providers) => {
        const valueState = value$2();
        const onEnter = (input) => {
            return startCommands.findPrimary(input).orThunk(() => endCommands.findPrimary(input)).map((primary) => {
                emitExecute(primary);
                return true;
            });
        };
        const memInput = record(f(providers, onEnter, valueState));
        const commandParts = partition$3(ctx.commands, (command) => command.align === 'start');
        const startCommands = generate(memInput, commandParts.pass, providers, valueState);
        const endCommands = generate(memInput, commandParts.fail, providers, valueState);
        return filter$2([
            {
                title: Optional.none(),
                label: Optional.none(),
                items: startCommands.asSpecs()
            },
            {
                title: Optional.none(),
                label: Optional.none(),
                items: [memInput.asSpec()]
            },
            {
                title: Optional.none(),
                label: Optional.none(),
                items: endCommands.asSpecs()
            }
        ], (group) => group.items.length > 0);
    };
    const buildInitGroups = (ctx, providers) => {
        switch (ctx.type) {
            case 'contextform': return buildInitGroup(curry(renderContextFormTextInput, ctx), ctx, providers);
            case 'contextsliderform': return buildInitGroup(curry(renderContextFormSliderInput, ctx), ctx, providers);
            case 'contextsizeinputform': return buildInitGroup(curry(renderContextFormSizeInput, ctx), ctx, providers);
        }
    };
    const renderContextForm = (toolbarType, ctx, providers) => renderToolbar({
        type: toolbarType,
        uid: generate$6('context-toolbar'),
        initGroups: buildInitGroups(ctx, providers),
        onEscape: Optional.none,
        cyclicKeying: true,
        providers
    });
    const ContextForm = {
        renderContextForm,
        buildInitGroups
    };

    // The "threshold" here is the amount of overlap. To make the overlap check
    // be more permissive (return true for 'almost' an overlap), use a negative
    // threshold value
    const isVerticalOverlap = (a, b, threshold) => b.bottom - a.y >= threshold && a.bottom - b.y >= threshold;
    const getRangeRect = (rng) => {
        const rect = rng.getBoundingClientRect();
        // Some ranges (eg <td><br></td>) will return a 0x0 rect, so we'll need to calculate it from the leaf instead
        if (rect.height <= 0 && rect.width <= 0) {
            const leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset).element;
            const elm = isText(leaf$1) ? parent(leaf$1) : Optional.some(leaf$1);
            return elm.filter(isElement$1)
                .map((e) => e.dom.getBoundingClientRect())
                // We have nothing valid, so just fallback to the original rect
                .getOr(rect);
        }
        else {
            return rect;
        }
    };
    const getSelectionBounds = (editor) => {
        const rng = editor.selection.getRng();
        const rect = getRangeRect(rng);
        if (editor.inline) {
            const scroll = get$b();
            return bounds(scroll.left + rect.left, scroll.top + rect.top, rect.width, rect.height);
        }
        else {
            // Translate to the top level document, as rect is relative to the iframe viewport
            const bodyPos = absolute$2(SugarElement.fromDom(editor.getBody()));
            return bounds(bodyPos.x + rect.left, bodyPos.y + rect.top, rect.width, rect.height);
        }
    };
    const getAnchorElementBounds = (editor, lastElement) => lastElement
        .filter((elem) => inBody(elem) && isHTMLElement(elem))
        .map(absolute$2)
        .getOrThunk(() => getSelectionBounds(editor));
    const getHorizontalBounds = (contentAreaBox, viewportBounds, margin) => {
        const x = Math.max(contentAreaBox.x + margin, viewportBounds.x);
        const right = Math.min(contentAreaBox.right - margin, viewportBounds.right);
        return { x, width: right - x };
    };
    const getVerticalBounds = (editor, contentAreaBox, viewportBounds, isToolbarLocationTop, toolbarType, margin) => {
        const container = SugarElement.fromDom(editor.getContainer());
        const header = descendant(container, '.tox-editor-header').getOr(container);
        const headerBox = box$1(header);
        const isToolbarBelowContentArea = headerBox.y >= contentAreaBox.bottom;
        const isToolbarAbove = isToolbarLocationTop && !isToolbarBelowContentArea;
        // Scenario toolbar top & inline: Bottom of the header -> Bottom of the viewport
        if (editor.inline && isToolbarAbove) {
            return {
                y: Math.max(headerBox.bottom + margin, viewportBounds.y),
                bottom: viewportBounds.bottom
            };
        }
        // Scenario toolbar top & inline: Top of the viewport -> Top of the header
        if (editor.inline && !isToolbarAbove) {
            return {
                y: viewportBounds.y,
                bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)
            };
        }
        // Allow line based context toolbar to overlap the statusbar
        const containerBounds = toolbarType === 'line' ? box$1(container) : contentAreaBox;
        // Scenario toolbar bottom & Iframe: Bottom of the header -> Bottom of the editor container
        if (isToolbarAbove) {
            return {
                y: Math.max(headerBox.bottom + margin, viewportBounds.y),
                bottom: Math.min(containerBounds.bottom - margin, viewportBounds.bottom)
            };
        }
        // Scenario toolbar bottom & Iframe: Top of the editor container -> Top of the header
        return {
            y: Math.max(containerBounds.y + margin, viewportBounds.y),
            bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)
        };
    };
    const getContextToolbarBounds = (editor, sharedBackstage, toolbarType, margin = 0) => {
        const viewportBounds = getBounds$1(window);
        const contentAreaBox = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));
        const toolbarOrMenubarEnabled = isMenubarEnabled(editor) || isToolbarEnabled(editor) || isMultipleToolbars(editor);
        const { x, width } = getHorizontalBounds(contentAreaBox, viewportBounds, margin);
        // Create bounds that lets the context toolbar overflow outside the content area, but remains in the viewport
        if (editor.inline && !toolbarOrMenubarEnabled) {
            return bounds(x, viewportBounds.y, width, viewportBounds.height);
        }
        else {
            const isToolbarTop = sharedBackstage.header.isPositionedAtTop();
            const { y, bottom } = getVerticalBounds(editor, contentAreaBox, viewportBounds, isToolbarTop, toolbarType, margin);
            return bounds(x, y, width, bottom - y);
        }
    };

    const bubbleSize$1 = 12;
    const bubbleAlignments$1 = {
        valignCentre: [],
        alignCentre: [],
        alignLeft: ['tox-pop--align-left'],
        alignRight: ['tox-pop--align-right'],
        right: ['tox-pop--right'],
        left: ['tox-pop--left'],
        bottom: ['tox-pop--bottom'],
        top: ['tox-pop--top'],
        inset: ['tox-pop--inset']
    };
    const anchorOverrides = {
        maxHeightFunction: expandable$1(),
        maxWidthFunction: expandable()
    };
    const isEntireElementSelected = (editor, elem) => {
        const rng = editor.selection.getRng();
        const leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset);
        return rng.startContainer === rng.endContainer && rng.startOffset === rng.endOffset - 1 && eq(leaf$1.element, elem);
    };
    const preservePosition = (elem, position, f) => {
        const currentPosition = getRaw(elem, 'position');
        set$7(elem, 'position', position);
        const result = f(elem);
        currentPosition.each((pos) => set$7(elem, 'position', pos));
        return result;
    };
    // Don't use an inset layout when using a selection/line based anchors as it'll cover the content and can't be moved out the way
    const shouldUseInsetLayouts = (position) => position === 'node';
    /**
     * This function is designed to attempt to intelligently detect where the contextbar should be anchored when using an inside
     * layout. It will attempt to preserve the previous outside placement when anchoring to the same element. However, when the
     * placement is re-triggered (e.g. not triggered by a reposition) and the current editor selection overlaps with the contextbar,
     * then the anchoring should flip from the previous position to avoid conflicting with the selection.
     */
    const determineInsetLayout = (editor, contextbar, elem, data, bounds) => {
        const selectionBounds = getSelectionBounds(editor);
        const isSameAnchorElement = data.lastElement().exists((prev) => eq(elem, prev));
        if (isEntireElementSelected(editor, elem)) {
            // The entire anchor element is selected so it'll always overlap with the selection, in which case just
            // preserve or show at the top for a new anchor element.
            return isSameAnchorElement ? preserve$1 : north$1;
        }
        else if (isSameAnchorElement) {
            // Preserve the position, get the bounds and then see if we have an overlap.
            // If overlapping and this wasn't triggered by a reposition then flip the placement
            return preservePosition(contextbar, data.getMode(), () => {
                // TINY-8890: The negative 20px threshold here was arrived at by considering the use
                // case of a table with default heights for the rows. The threshold had to be
                // large enough so that the context toolbar would not prevent the user selecting
                // in the row containing the context toolbar.
                const isOverlapping = isVerticalOverlap(selectionBounds, box$1(contextbar), -20);
                return isOverlapping && !data.isReposition() ? flip : preserve$1;
            });
        }
        else {
            // Attempt to find the best layout to use that won't cause an overlap for the new anchor element
            // Note: In fixed positioning mode we need to translate by adding the scroll pos to get the absolute position
            const yBounds = data.getMode() === 'fixed' ? bounds.y + get$b().top : bounds.y;
            const contextbarHeight = get$d(contextbar) + bubbleSize$1;
            return yBounds + contextbarHeight <= selectionBounds.y ? north$1 : south$1;
        }
    };
    const getAnchorSpec$2 = (editor, mobile, data, position) => {
        // IMPORTANT: We lazily determine the layout here so that we only do the calculations if absolutely necessary
        const smartInsetLayout = (elem) => (anchor, element, bubbles, placee, bounds) => {
            const layout = determineInsetLayout(editor, placee, elem, data, bounds);
            // Adjust the anchor box to use the passed y bound coords so that we simulate a "docking" type of behaviour
            const newAnchor = {
                ...anchor,
                y: bounds.y,
                height: bounds.height
            };
            return {
                ...layout(newAnchor, element, bubbles, placee, bounds),
                // Ensure this is always the preferred option if no outside layouts fit
                alwaysFit: true
            };
        };
        const getInsetLayouts = (elem) => shouldUseInsetLayouts(position) ? [smartInsetLayout(elem)] : [];
        // On desktop we prioritise north-then-south because it's cleaner, but on mobile we prioritise south to try to avoid overlapping with native context toolbars
        const desktopAnchorSpecLayouts = {
            onLtr: (elem) => [north$2, south$2, northeast$2, southeast$2, northwest$2, southwest$2].concat(getInsetLayouts(elem)),
            onRtl: (elem) => [north$2, south$2, northwest$2, southwest$2, northeast$2, southeast$2].concat(getInsetLayouts(elem))
        };
        const mobileAnchorSpecLayouts = {
            onLtr: (elem) => [south$2, southeast$2, southwest$2, northeast$2, northwest$2, north$2].concat(getInsetLayouts(elem)),
            onRtl: (elem) => [south$2, southwest$2, southeast$2, northwest$2, northeast$2, north$2].concat(getInsetLayouts(elem))
        };
        return mobile ? mobileAnchorSpecLayouts : desktopAnchorSpecLayouts;
    };
    const getAnchorLayout = (editor, position, isTouch, data) => {
        if (position === 'line') {
            return {
                bubble: nu$6(bubbleSize$1, 0, bubbleAlignments$1),
                layouts: {
                    onLtr: () => [east$2],
                    onRtl: () => [west$2]
                },
                overrides: anchorOverrides
            };
        }
        else {
            return {
                // Ensure that inset layouts use a 1px bubble since we're hiding the bubble arrow
                bubble: nu$6(0, bubbleSize$1, bubbleAlignments$1, 1 / bubbleSize$1),
                layouts: getAnchorSpec$2(editor, isTouch, data, position),
                overrides: anchorOverrides
            };
        }
    };

    const matchTargetWith = (elem, candidates) => {
        const ctxs = filter$2(candidates, (toolbarApi) => toolbarApi.predicate(elem.dom));
        // TODO: somehow type this properly (Arr.partition can't)
        // e.g. here pass is Toolbar.ContextToolbar and fail is Toolbar.ContextForm
        const { pass, fail } = partition$3(ctxs, (t) => t.type === 'contexttoolbar');
        return {
            contextToolbars: pass,
            contextForms: fail
        };
    };
    const filterByPositionForStartNode = (toolbars) => {
        if (toolbars.length <= 1) {
            return toolbars;
        }
        else {
            const doesPositionExist = (value) => exists(toolbars, (t) => t.position === value);
            const filterToolbarsByPosition = (value) => filter$2(toolbars, (t) => t.position === value);
            const hasSelectionToolbars = doesPositionExist('selection');
            const hasNodeToolbars = doesPositionExist('node');
            if (hasSelectionToolbars || hasNodeToolbars) {
                if (hasNodeToolbars && hasSelectionToolbars) {
                    // if there's a mix, change the 'selection' toolbars to 'node' so there's no positioning confusion
                    const nodeToolbars = filterToolbarsByPosition('node');
                    const selectionToolbars = map$2(filterToolbarsByPosition('selection'), (t) => ({ ...t, position: 'node' }));
                    return nodeToolbars.concat(selectionToolbars);
                }
                else {
                    return hasSelectionToolbars ? filterToolbarsByPosition('selection') : filterToolbarsByPosition('node');
                }
            }
            else {
                return filterToolbarsByPosition('line');
            }
        }
    };
    const filterByPositionForAncestorNode = (toolbars) => {
        if (toolbars.length <= 1) {
            return toolbars;
        }
        else {
            const findPosition = (value) => find$5(toolbars, (t) => t.position === value);
            // prioritise position by 'selection' -> 'node' -> 'line'
            const basePosition = findPosition('selection')
                .orThunk(() => findPosition('node'))
                .orThunk(() => findPosition('line'))
                .map((t) => t.position);
            return basePosition.fold(() => [], (pos) => filter$2(toolbars, (t) => t.position === pos));
        }
    };
    const matchStartNode = (elem, nodeCandidates, editorCandidates) => {
        // requirements:
        // 1. prioritise context forms over context menus
        // 2. prioritise node scoped over editor scoped context forms
        // 3. only show max 1 context form
        // 4. concatenate all available context toolbars if no context form
        const nodeMatches = matchTargetWith(elem, nodeCandidates);
        if (nodeMatches.contextForms.length > 0) {
            return Optional.some({ elem, toolbars: [nodeMatches.contextForms[0]] });
        }
        else {
            const editorMatches = matchTargetWith(elem, editorCandidates);
            if (editorMatches.contextForms.length > 0) {
                return Optional.some({ elem, toolbars: [editorMatches.contextForms[0]] });
            }
            else if (nodeMatches.contextToolbars.length > 0 || editorMatches.contextToolbars.length > 0) {
                const toolbars = filterByPositionForStartNode(nodeMatches.contextToolbars.concat(editorMatches.contextToolbars));
                return Optional.some({ elem, toolbars });
            }
            else {
                return Optional.none();
            }
        }
    };
    const matchAncestor = (isRoot, startNode, scopes) => {
        // Don't continue to traverse if the start node is the root node
        if (isRoot(startNode)) {
            return Optional.none();
        }
        else {
            return ancestor(startNode, (ancestorElem) => {
                if (isElement$1(ancestorElem)) {
                    const { contextToolbars, contextForms } = matchTargetWith(ancestorElem, scopes.inNodeScope);
                    const toolbars = contextForms.length > 0 ? contextForms : filterByPositionForAncestorNode(contextToolbars);
                    return toolbars.length > 0 ? Optional.some({ elem: ancestorElem, toolbars }) : Optional.none();
                }
                else {
                    return Optional.none();
                }
            }, isRoot);
        }
    };
    const lookup$1 = (scopes, editor) => {
        const rootElem = SugarElement.fromDom(editor.getBody());
        const isRoot = (elem) => eq(elem, rootElem);
        const isOutsideRoot = (startNode) => !isRoot(startNode) && !contains(rootElem, startNode);
        const startNode = SugarElement.fromDom(editor.selection.getNode());
        // Ensure the lookup doesn't start on a parent or sibling element of the root node
        if (isOutsideRoot(startNode)) {
            return Optional.none();
        }
        return matchStartNode(startNode, scopes.inNodeScope, scopes.inEditorScope).orThunk(() => matchAncestor(isRoot, startNode, scopes));
    };

    const categorise = (contextToolbars, navigate) => {
        // TODO: Use foldl/foldr and avoid as much mutation.
        const forms = {};
        const inNodeScope = [];
        const inEditorScope = [];
        const formNavigators = {};
        const lookupTable = {};
        const registerForm = (key, toolbarSpec) => {
            const contextForm = getOrDie(createContextForm(toolbarSpec));
            forms[key] = contextForm;
            contextForm.launch.map((launch) => {
                // Use the original here (pre-boulder), because using as a the spec for toolbar buttons
                formNavigators['form:' + key + ''] = {
                    ...toolbarSpec.launch,
                    type: (launch.type === 'contextformtogglebutton' ? 'togglebutton' : 'button'),
                    onAction: () => {
                        navigate(contextForm);
                    }
                };
            });
            if (contextForm.scope === 'editor') {
                inEditorScope.push(contextForm);
            }
            else {
                inNodeScope.push(contextForm);
            }
            lookupTable[key] = contextForm;
        };
        const registerToolbar = (key, toolbarSpec) => {
            createContextToolbar(toolbarSpec).each((contextToolbar) => {
                if (contextToolbar.launch.isSome()) {
                    formNavigators['toolbar:' + key + ''] = {
                        ...toolbarSpec.launch,
                        type: 'button',
                        onAction: () => {
                            navigate(contextToolbar);
                        }
                    };
                }
                if (toolbarSpec.scope === 'editor') {
                    inEditorScope.push(contextToolbar);
                }
                else {
                    inNodeScope.push(contextToolbar);
                }
                lookupTable[key] = contextToolbar;
            });
        };
        const keys$1 = keys(contextToolbars);
        each$1(keys$1, (key) => {
            const toolbarApi = contextToolbars[key];
            if (toolbarApi.type === 'contextform' || toolbarApi.type === 'contextsliderform' || toolbarApi.type === 'contextsizeinputform') {
                registerForm(key, toolbarApi);
            }
            else if (toolbarApi.type === 'contexttoolbar') {
                registerToolbar(key, toolbarApi);
            }
        });
        return {
            forms,
            inNodeScope,
            inEditorScope,
            lookupTable,
            formNavigators
        };
    };

    const transitionClass = 'tox-pop--transition';
    const isToolbarActionKey = (keyCode) => keyCode === global$1.ENTER || keyCode === global$1.SPACEBAR;
    const register$a = (editor, registryContextToolbars, sink, extras) => {
        const backstage = extras.backstage;
        const sharedBackstage = backstage.shared;
        const isTouch = detect$1().deviceType.isTouch;
        const lastElement = value$2();
        const lastTrigger = value$2();
        const lastContextPosition = value$2();
        const contextToolbarResult = renderContextToolbar({
            sink,
            onEscape: () => {
                editor.focus();
                fireContextToolbarClose(editor);
                return Optional.some(true);
            },
            onHide: () => {
                fireContextToolbarClose(editor);
            },
            onBack: () => {
                fireContextFormSlideBack(editor);
            },
            focusElement: (el) => {
                if (editor.getBody().contains(el.dom)) {
                    editor.focus();
                }
                else {
                    focus$4(el);
                }
            }
        });
        const contextbar = build$1(contextToolbarResult.sketch);
        const getBounds = () => {
            const position = lastContextPosition.get().getOr('node');
            // Use a 1px margin for the bounds to keep the context toolbar from butting directly against
            // the header, etc... when switching to inset layouts
            const margin = shouldUseInsetLayouts(position) ? 1 : 0;
            return getContextToolbarBounds(editor, sharedBackstage, position, margin);
        };
        const canLaunchToolbar = () => {
            // If a mobile context menu is open, don't launch else they'll probably overlap. For android, specifically.
            return !editor.removed && !(isTouch() && backstage.isContextMenuOpen());
        };
        const isSameLaunchElement = (elem) => is$1(lift2(elem, lastElement.get(), eq), true);
        const shouldContextToolbarHide = () => {
            if (!canLaunchToolbar()) {
                return true;
            }
            else {
                const contextToolbarBounds = getBounds();
                // Get the anchor bounds. For node anchors we should always try to use the last element bounds
                const anchorBounds = is$1(lastContextPosition.get(), 'node') ?
                    getAnchorElementBounds(editor, lastElement.get()) :
                    getSelectionBounds(editor);
                // If the anchor bounds aren't overlapping with the context toolbar bounds, then the context toolbar
                // should hide. We want the threshold to require some overlap here (+.01), so that as soon as the
                // anchor is off-screen, the context toolbar disappers.
                return contextToolbarBounds.height <= 0 || !isVerticalOverlap(anchorBounds, contextToolbarBounds, 0.01);
            }
        };
        const close = () => {
            lastElement.clear();
            lastTrigger.clear();
            lastContextPosition.clear();
            InlineView.hide(contextbar);
        };
        const hideOrRepositionIfNecessary = () => {
            if (InlineView.isOpen(contextbar)) {
                const contextBarEle = contextbar.element;
                remove$6(contextBarEle, 'display');
                if (shouldContextToolbarHide()) {
                    set$7(contextBarEle, 'display', 'none');
                }
                else {
                    lastTrigger.set(0 /* TriggerCause.Reposition */);
                    InlineView.reposition(contextbar);
                }
            }
        };
        const wrapInPopDialog = (toolbarSpec) => ({
            dom: {
                tag: 'div',
                classes: ['tox-pop__dialog']
            },
            components: [toolbarSpec],
            behaviours: derive$1([
                Keying.config({
                    mode: 'acyclic'
                }),
                config('pop-dialog-wrap-events', [
                    runOnAttached((comp) => {
                        editor.shortcuts.add('ctrl+F9', 'focus statusbar', () => Keying.focusIn(comp));
                    }),
                    runOnDetached((_comp) => {
                        editor.shortcuts.remove('ctrl+F9');
                    })
                ])
            ])
        });
        const navigate = (toolbarApi) => {
            // ASSUMPTION: This should only ever show one context toolbar since it's used for context forms hence [toolbarApi]
            const alloySpec = buildToolbar([toolbarApi]);
            emitWith(contextbar, forwardSlideEvent, {
                forwardContents: wrapInPopDialog(alloySpec)
            });
        };
        const getScopes = cached(() => categorise(registryContextToolbars, navigate));
        const buildContextToolbarGroups = (allButtons, ctx) => {
            return identifyButtons(editor, { buttons: allButtons, toolbar: ctx.items, allowToolbarGroups: false }, extras.backstage, Optional.some(['form:', 'toolbar:']));
        };
        const buildContextFormGroups = (ctx, providers) => ContextForm.buildInitGroups(ctx, providers);
        const buildToolbar = (toolbars) => {
            const { buttons } = editor.ui.registry.getAll();
            const scopes = getScopes();
            const allButtons = { ...buttons, ...scopes.formNavigators };
            // For context toolbars we don't want to use floating or sliding, so just restrict this
            // to scrolling or wrapping (default)
            const toolbarType = getToolbarMode(editor) === ToolbarMode$1.scrolling ? ToolbarMode$1.scrolling : ToolbarMode$1.default;
            const initGroups = flatten(map$2(toolbars, (ctx) => ctx.type === 'contexttoolbar' ? buildContextToolbarGroups(allButtons, contextToolbarToSpec(ctx)) : buildContextFormGroups(ctx, sharedBackstage.providers)));
            return renderToolbar({
                type: toolbarType,
                uid: generate$6('context-toolbar'),
                initGroups,
                onEscape: Optional.none,
                cyclicKeying: true,
                providers: sharedBackstage.providers
            });
        };
        const getAnchor = (position, element) => {
            const anchorage = position === 'node' ? sharedBackstage.anchors.node(element) : sharedBackstage.anchors.cursor();
            const anchorLayout = getAnchorLayout(editor, position, isTouch(), {
                lastElement: lastElement.get,
                isReposition: () => is$1(lastTrigger.get(), 0 /* TriggerCause.Reposition */),
                getMode: () => Positioning.getMode(sink)
            });
            return deepMerge(anchorage, anchorLayout);
        };
        const launchContext = (toolbarApi, elem) => {
            launchContextToolbar.cancel();
            // Don't launch if the editor has something else open that would conflict
            if (!canLaunchToolbar()) {
                return;
            }
            const toolbarSpec = buildToolbar(toolbarApi);
            // TINY-4495 ASSUMPTION: Can only do toolbarApi[0].position because ContextToolbarLookup.filterToolbarsByPosition
            // ensures all toolbars returned by ContextToolbarLookup have the same position.
            // And everything else that gets toolbars from elsewhere only returns maximum 1 toolbar
            const position = toolbarApi[0].position;
            const anchor = getAnchor(position, elem);
            lastContextPosition.set(position);
            lastTrigger.set(1 /* TriggerCause.NewAnchor */);
            const contextBarEle = contextbar.element;
            remove$6(contextBarEle, 'display');
            // Reset placement and transitions when moving to different elements
            if (!isSameLaunchElement(elem)) {
                remove$3(contextBarEle, transitionClass);
                Positioning.reset(sink, contextbar);
            }
            // Place the element
            InlineView.showWithinBounds(contextbar, wrapInPopDialog(toolbarSpec), {
                anchor,
                transition: {
                    classes: [transitionClass],
                    mode: 'placement'
                }
            }, () => Optional.some(getBounds()));
            // IMPORTANT: This must be stored after the initial render, otherwise the lookup of the last element in the
            // anchor placement will be incorrect as it'll reuse the new element as the anchor point.
            elem.fold(lastElement.clear, lastElement.set);
            // It's possible we may have launched offscreen, if so then hide
            if (shouldContextToolbarHide()) {
                set$7(contextBarEle, 'display', 'none');
            }
        };
        const instantReposition = () => {
            // Sometimes when we reposition the toolbar it might be in a transitioning state and
            // if we try to reposition while that happens the computed position/width will be incorrect.
            set$7(contextbar.element, 'transition', 'none');
            hideOrRepositionIfNecessary();
            remove$6(contextbar.element, 'transition');
        };
        let isDragging = false;
        const launchContextToolbar = last(() => {
            // Don't launch if the editor doesn't have focus or has been destroyed
            if (!editor.hasFocus() || editor.removed || isDragging) {
                return;
            }
            // If currently transitioning then throttle again so we don't interrupt the transition
            if (has(contextbar.element, transitionClass)) {
                launchContextToolbar.throttle();
            }
            else {
                const scopes = getScopes();
                lookup$1(scopes, editor).fold(close, (info) => {
                    launchContext(info.toolbars, Optional.some(info.elem));
                });
            }
        }, 17); // 17ms is used as that's about 1 frame at 60fps
        editor.on('init', () => {
            editor.on('remove', close);
            editor.on('ScrollContent ScrollWindow ObjectResized ResizeEditor longpress', hideOrRepositionIfNecessary);
            // FIX: Make it go away when the action makes it go away. E.g. deleting a column deletes the table.
            editor.on('click focus SetContent', launchContextToolbar.throttle);
            editor.on('keyup', (e) => {
                // If you use keyboard to press a button in a subtoolbar then the keyup will happen inside the editor and that should not re-render the toolbar
                if (!isToolbarActionKey(e.keyCode) || !contextToolbarResult.inSubtoolbar()) {
                    launchContextToolbar.throttle();
                }
            });
            editor.on(hideContextToolbarEvent, close);
            editor.on(showContextToolbarEvent, (e) => {
                const scopes = getScopes();
                // TODO: Have this stored in a better structure
                get$h(scopes.lookupTable, e.toolbarKey).each((ctx) => {
                    // ASSUMPTION: this is only used to open one specific toolbar at a time, hence [ctx]
                    launchContext([ctx], someIf(e.target !== editor, e.target));
                    focusIn(contextbar);
                });
            });
            editor.on('focusout', (_e) => {
                global$a.setEditorTimeout(editor, () => {
                    if (search(sink.element).isNone() && search(contextbar.element).isNone() && !editor.hasFocus()) {
                        close();
                    }
                }, 0);
            });
            editor.on('SwitchMode', () => {
                if (editor.mode.isReadOnly()) {
                    close();
                }
            });
            editor.on('DisabledStateChange', (e) => {
                if (e.state) {
                    close();
                }
            });
            // TINY-10640: Firefox was flaking in tests and was not properly dismissing the toolbar could not reproduce it manually but adding this seems to resolve it.
            editor.on('ExecCommand', ({ command }) => {
                if (command.toLowerCase() === 'toggleview') {
                    close();
                }
            });
            editor.on('AfterProgressState', (event) => {
                if (event.state) {
                    close();
                }
                else if (editor.hasFocus()) {
                    launchContextToolbar.throttle();
                }
            });
            editor.on('dragstart', () => {
                isDragging = true;
            });
            editor.on('dragend drop', () => {
                isDragging = false;
            });
            editor.on('NodeChange', (_e) => {
                if (!contextToolbarResult.inSubtoolbar()) {
                    search(contextbar.element).fold(launchContextToolbar.throttle, noop);
                }
                else {
                    instantReposition();
                }
            });
        });
    };

    const register$9 = (editor) => {
        const alignToolbarButtons = [
            { name: 'alignleft', text: 'Align left', cmd: 'JustifyLeft', icon: 'align-left' },
            { name: 'aligncenter', text: 'Align center', cmd: 'JustifyCenter', icon: 'align-center' },
            { name: 'alignright', text: 'Align right', cmd: 'JustifyRight', icon: 'align-right' },
            { name: 'alignjustify', text: 'Justify', cmd: 'JustifyFull', icon: 'align-justify' }
        ];
        each$1(alignToolbarButtons, (item) => {
            editor.ui.registry.addToggleButton(item.name, {
                tooltip: item.text,
                icon: item.icon,
                onAction: onActionExecCommand(editor, item.cmd),
                onSetup: onSetupStateToggle(editor, item.name)
            });
        });
        editor.ui.registry.addButton('alignnone', {
            tooltip: 'No alignment',
            icon: 'align-none',
            onSetup: onSetupEditableToggle(editor),
            onAction: onActionExecCommand(editor, 'JustifyNone')
        });
    };

    const registerController = (editor, spec) => {
        const getMenuItems = () => {
            const options = spec.getOptions(editor);
            const initial = spec.getCurrent(editor).map(spec.hash);
            const current = value$2();
            return map$2(options, (value) => ({
                type: 'togglemenuitem',
                text: spec.display(value),
                onSetup: (api) => {
                    const setActive = (active) => {
                        if (active) {
                            current.on((oldApi) => oldApi.setActive(false));
                            current.set(api);
                        }
                        api.setActive(active);
                    };
                    setActive(is$1(initial, spec.hash(value)));
                    const unbindWatcher = spec.watcher(editor, value, setActive);
                    return () => {
                        current.clear();
                        unbindWatcher();
                    };
                },
                onAction: () => spec.setCurrent(editor, value)
            }));
        };
        editor.ui.registry.addMenuButton(spec.name, {
            tooltip: spec.text,
            icon: spec.icon,
            fetch: (callback) => callback(getMenuItems()),
            onSetup: spec.onToolbarSetup
        });
        editor.ui.registry.addNestedMenuItem(spec.name, {
            type: 'nestedmenuitem',
            text: spec.text,
            getSubmenuItems: getMenuItems,
            onSetup: spec.onMenuSetup
        });
    };
    const lineHeightSpec = (editor) => ({
        name: 'lineheight',
        text: 'Line height',
        icon: 'line-height',
        getOptions: getLineHeightFormats,
        hash: (input) => normalise(input, ['fixed', 'relative', 'empty']).getOr(input),
        display: identity,
        watcher: (editor, value, callback) => editor.formatter.formatChanged('lineheight', callback, false, { value }).unbind,
        getCurrent: (editor) => Optional.from(editor.queryCommandValue('LineHeight')),
        setCurrent: (editor, value) => editor.execCommand('LineHeight', false, value),
        onToolbarSetup: onSetupEditableToggle(editor),
        onMenuSetup: onSetupEditableToggle(editor)
    });
    const languageSpec = (editor) => {
        const settingsOpt = Optional.from(getContentLanguages(editor));
        return settingsOpt.map((settings) => ({
            name: 'language',
            text: 'Language',
            icon: 'language',
            getOptions: constant$1(settings),
            hash: (input) => isUndefined(input.customCode) ? input.code : `${input.code}/${input.customCode}`,
            display: (input) => input.title,
            watcher: (editor, value, callback) => { var _a; return editor.formatter.formatChanged('lang', callback, false, { value: value.code, customValue: (_a = value.customCode) !== null && _a !== void 0 ? _a : null }).unbind; },
            getCurrent: (editor) => {
                const node = SugarElement.fromDom(editor.selection.getNode());
                return closest(node, (n) => Optional.some(n)
                    .filter(isElement$1)
                    .bind((ele) => {
                    const codeOpt = getOpt(ele, 'lang');
                    return codeOpt.map((code) => {
                        const customCode = getOpt(ele, 'data-mce-lang').getOrUndefined();
                        return { code, customCode, title: '' };
                    });
                }));
            },
            setCurrent: (editor, lang) => editor.execCommand('Lang', false, lang),
            onToolbarSetup: (api) => {
                const unbinder = unbindable();
                api.setActive(editor.formatter.match('lang', {}, undefined, true));
                unbinder.set(editor.formatter.formatChanged('lang', api.setActive, true));
                return composeUnbinders(unbinder.clear, onSetupEditableToggle(editor)(api));
            },
            onMenuSetup: onSetupEditableToggle(editor)
        }));
    };
    const register$8 = (editor) => {
        registerController(editor, lineHeightSpec(editor));
        languageSpec(editor).each((spec) => registerController(editor, spec));
    };

    const register$7 = (editor, backstage) => {
        createAlignMenu(editor, backstage);
        createFontFamilyMenu(editor, backstage);
        createStylesMenu(editor, backstage);
        createBlocksMenu(editor, backstage);
        createFontSizeMenu(editor, backstage);
    };

    const register$6 = (editor) => {
        editor.ui.registry.addContext('editable', () => {
            return editor.selection.isEditable();
        });
        editor.ui.registry.addContext('mode', (mode) => {
            return editor.mode.get() === mode;
        });
        editor.ui.registry.addContext('any', always);
        editor.ui.registry.addContext('formatting', (format) => {
            return editor.formatter.canApply(format);
        });
        editor.ui.registry.addContext('insert', (child) => {
            return editor.schema.isValidChild(editor.selection.getNode().tagName, child);
        });
    };

    const onSetupOutdentState = (editor) => onSetupEvent(editor, 'NodeChange', (api) => {
        api.setEnabled(editor.queryCommandState('outdent') && editor.selection.isEditable());
    });
    const registerButtons$2 = (editor) => {
        editor.ui.registry.addButton('outdent', {
            tooltip: 'Decrease indent',
            icon: 'outdent',
            onSetup: onSetupOutdentState(editor),
            onAction: onActionExecCommand(editor, 'outdent')
        });
        editor.ui.registry.addButton('indent', {
            tooltip: 'Increase indent',
            icon: 'indent',
            onSetup: onSetupEditableToggle(editor, () => editor.queryCommandState('indent')),
            onAction: onActionExecCommand(editor, 'indent')
        });
    };
    const register$5 = (editor) => {
        registerButtons$2(editor);
    };

    const makeSetupHandler = (editor, pasteAsText) => (api) => {
        api.setActive(pasteAsText.get());
        const pastePlainTextToggleHandler = (e) => {
            pasteAsText.set(e.state);
            api.setActive(e.state);
        };
        editor.on('PastePlainTextToggle', pastePlainTextToggleHandler);
        return composeUnbinders(() => editor.off('PastePlainTextToggle', pastePlainTextToggleHandler), onSetupEditableToggle(editor)(api));
    };
    const register$4 = (editor) => {
        const pasteAsText = Cell(getPasteAsText(editor));
        const onAction = () => editor.execCommand('mceTogglePlainTextPaste');
        editor.ui.registry.addToggleButton('pastetext', {
            active: false,
            icon: 'paste-text',
            tooltip: 'Paste as text',
            onAction,
            onSetup: makeSetupHandler(editor, pasteAsText)
        });
        editor.ui.registry.addToggleMenuItem('pastetext', {
            text: 'Paste as text',
            icon: 'paste-text',
            onAction,
            onSetup: makeSetupHandler(editor, pasteAsText)
        });
    };

    const onActionToggleFormat = (editor, fmt) => () => {
        editor.execCommand('mceToggleFormat', false, fmt);
    };
    const registerFormatButtons = (editor) => {
        global$2.each([
            { name: 'bold', text: 'Bold', icon: 'bold', shortcut: 'Meta+B' },
            { name: 'italic', text: 'Italic', icon: 'italic', shortcut: 'Meta+I' },
            { name: 'underline', text: 'Underline', icon: 'underline', shortcut: 'Meta+U' },
            { name: 'strikethrough', text: 'Strikethrough', icon: 'strike-through' },
            { name: 'subscript', text: 'Subscript', icon: 'subscript' },
            { name: 'superscript', text: 'Superscript', icon: 'superscript' }
        ], (btn, _idx) => {
            editor.ui.registry.addToggleButton(btn.name, {
                tooltip: btn.text,
                icon: btn.icon,
                onSetup: onSetupStateToggle(editor, btn.name),
                onAction: onActionToggleFormat(editor, btn.name),
                shortcut: btn.shortcut
            });
        });
        for (let i = 1; i <= 6; i++) {
            const name = 'h' + i;
            const shortcut = `Access+${i}`;
            editor.ui.registry.addToggleButton(name, {
                text: name.toUpperCase(),
                tooltip: 'Heading ' + i,
                onSetup: onSetupStateToggle(editor, name),
                onAction: onActionToggleFormat(editor, name),
                shortcut
            });
        }
    };
    const registerCommandButtons = (editor) => {
        global$2.each([
            { name: 'copy', text: 'Copy', action: 'Copy', icon: 'copy', context: 'any' },
            { name: 'help', text: 'Help', action: 'mceHelp', icon: 'help', shortcut: 'Alt+0', context: 'any' },
            { name: 'selectall', text: 'Select all', action: 'SelectAll', icon: 'select-all', shortcut: 'Meta+A', context: 'any' },
            { name: 'newdocument', text: 'New document', action: 'mceNewDocument', icon: 'new-document' },
            { name: 'print', text: 'Print', action: 'mcePrint', icon: 'print', shortcut: 'Meta+P', context: 'any' },
        ], (btn) => {
            editor.ui.registry.addButton(btn.name, {
                tooltip: btn.text,
                icon: btn.icon,
                onAction: onActionExecCommand(editor, btn.action),
                shortcut: btn.shortcut,
                context: btn.context
            });
        });
        global$2.each([
            { name: 'cut', text: 'Cut', action: 'Cut', icon: 'cut' },
            { name: 'paste', text: 'Paste', action: 'Paste', icon: 'paste' },
            // visualaid was here but also exists in VisualAid.ts?
            { name: 'removeformat', text: 'Clear formatting', action: 'RemoveFormat', icon: 'remove-formatting' },
            { name: 'remove', text: 'Remove', action: 'Delete', icon: 'remove' },
            { name: 'hr', text: 'Horizontal line', action: 'InsertHorizontalRule', icon: 'horizontal-rule' }
        ], (btn) => {
            editor.ui.registry.addButton(btn.name, {
                tooltip: btn.text,
                icon: btn.icon,
                onSetup: onSetupEditableToggle(editor),
                onAction: onActionExecCommand(editor, btn.action)
            });
        });
    };
    const registerCommandToggleButtons = (editor) => {
        global$2.each([
            { name: 'blockquote', text: 'Blockquote', action: 'mceBlockQuote', icon: 'quote' }
        ], (btn) => {
            editor.ui.registry.addToggleButton(btn.name, {
                tooltip: btn.text,
                icon: btn.icon,
                onAction: onActionExecCommand(editor, btn.action),
                onSetup: onSetupStateToggle(editor, btn.name)
            });
        });
    };
    const registerButtons$1 = (editor) => {
        registerFormatButtons(editor);
        registerCommandButtons(editor);
        registerCommandToggleButtons(editor);
    };
    const registerMenuItems$2 = (editor) => {
        global$2.each([
            { name: 'newdocument', text: 'New document', action: 'mceNewDocument', icon: 'new-document' },
            { name: 'copy', text: 'Copy', action: 'Copy', icon: 'copy', shortcut: 'Meta+C', context: 'any' },
            { name: 'selectall', text: 'Select all', action: 'SelectAll', icon: 'select-all', shortcut: 'Meta+A', context: 'any' },
            { name: 'print', text: 'Print...', action: 'mcePrint', icon: 'print', shortcut: 'Meta+P', context: 'any' }
        ], (menuitem) => {
            editor.ui.registry.addMenuItem(menuitem.name, {
                text: menuitem.text,
                icon: menuitem.icon,
                shortcut: menuitem.shortcut,
                onAction: onActionExecCommand(editor, menuitem.action),
                context: menuitem.context
            });
        });
        global$2.each([
            { name: 'bold', text: 'Bold', action: 'Bold', icon: 'bold', shortcut: 'Meta+B' },
            { name: 'italic', text: 'Italic', action: 'Italic', icon: 'italic', shortcut: 'Meta+I' },
            { name: 'underline', text: 'Underline', action: 'Underline', icon: 'underline', shortcut: 'Meta+U' },
            { name: 'strikethrough', text: 'Strikethrough', action: 'Strikethrough', icon: 'strike-through' },
            { name: 'subscript', text: 'Subscript', action: 'Subscript', icon: 'subscript' },
            { name: 'superscript', text: 'Superscript', action: 'Superscript', icon: 'superscript' },
            { name: 'removeformat', text: 'Clear formatting', action: 'RemoveFormat', icon: 'remove-formatting' },
            { name: 'cut', text: 'Cut', action: 'Cut', icon: 'cut', shortcut: 'Meta+X' },
            { name: 'paste', text: 'Paste', action: 'Paste', icon: 'paste', shortcut: 'Meta+V' },
            { name: 'hr', text: 'Horizontal line', action: 'InsertHorizontalRule', icon: 'horizontal-rule' }
        ], (menuitem) => {
            editor.ui.registry.addMenuItem(menuitem.name, {
                text: menuitem.text,
                icon: menuitem.icon,
                shortcut: menuitem.shortcut,
                onSetup: onSetupEditableToggle(editor),
                onAction: onActionExecCommand(editor, menuitem.action)
            });
        });
        editor.ui.registry.addMenuItem('codeformat', {
            text: 'Code',
            icon: 'sourcecode',
            onSetup: onSetupEditableToggle(editor),
            onAction: onActionToggleFormat(editor, 'code')
        });
    };
    const register$3 = (editor) => {
        registerButtons$1(editor);
        registerMenuItems$2(editor);
    };

    const onSetupUndoRedoState = (editor, type) => onSetupEvent(editor, 'Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', (api) => {
        api.setEnabled(!editor.mode.isReadOnly() && editor.undoManager[type]());
    });
    const registerMenuItems$1 = (editor) => {
        editor.ui.registry.addMenuItem('undo', {
            text: 'Undo',
            icon: 'undo',
            shortcut: 'Meta+Z',
            onSetup: onSetupUndoRedoState(editor, 'hasUndo'),
            onAction: onActionExecCommand(editor, 'undo')
        });
        editor.ui.registry.addMenuItem('redo', {
            text: 'Redo',
            icon: 'redo',
            shortcut: 'Meta+Y',
            onSetup: onSetupUndoRedoState(editor, 'hasRedo'),
            onAction: onActionExecCommand(editor, 'redo')
        });
    };
    // Note: The undo/redo buttons are disabled by default here, as they'll be rendered
    // on init generally and it won't have any undo levels at that stage.
    const registerButtons = (editor) => {
        editor.ui.registry.addButton('undo', {
            tooltip: 'Undo',
            icon: 'undo',
            enabled: false,
            onSetup: onSetupUndoRedoState(editor, 'hasUndo'),
            onAction: onActionExecCommand(editor, 'undo'),
            shortcut: 'Meta+Z'
        });
        editor.ui.registry.addButton('redo', {
            tooltip: 'Redo',
            icon: 'redo',
            enabled: false,
            onSetup: onSetupUndoRedoState(editor, 'hasRedo'),
            onAction: onActionExecCommand(editor, 'redo'),
            shortcut: 'Meta+Y'
        });
    };
    const register$2 = (editor) => {
        registerMenuItems$1(editor);
        registerButtons(editor);
    };

    const onSetupVisualAidState = (editor) => onSetupEvent(editor, 'VisualAid', (api) => {
        api.setActive(editor.hasVisual);
    });
    const registerMenuItems = (editor) => {
        editor.ui.registry.addToggleMenuItem('visualaid', {
            text: 'Visual aids',
            onSetup: onSetupVisualAidState(editor),
            onAction: onActionExecCommand(editor, 'mceToggleVisualAid'),
            context: 'any'
        });
    };
    const registerToolbarButton = (editor) => {
        editor.ui.registry.addButton('visualaid', {
            tooltip: 'Visual aids',
            text: 'Visual aids',
            onAction: onActionExecCommand(editor, 'mceToggleVisualAid'),
            context: 'any'
        });
    };
    const register$1 = (editor) => {
        registerToolbarButton(editor);
        registerMenuItems(editor);
    };

    const setup$6 = (editor, backstage) => {
        register$9(editor);
        register$3(editor);
        register$7(editor, backstage);
        register$2(editor);
        register$d(editor);
        register$1(editor);
        register$5(editor);
        register$8(editor);
        register$4(editor);
        register$6(editor);
    };

    const patchPipeConfig = (config) => isString(config) ? config.split(/[ ,]/) : config;
    const option = (name) => (editor) => editor.options.get(name);
    const register = (editor) => {
        const registerOption = editor.options.register;
        registerOption('contextmenu_avoid_overlap', {
            processor: 'string',
            default: ''
        });
        registerOption('contextmenu_never_use_native', {
            processor: 'boolean',
            default: false
        });
        registerOption('contextmenu', {
            processor: (value) => {
                if (value === false) {
                    return { value: [], valid: true };
                }
                else if (isString(value) || isArrayOf(value, isString)) {
                    return { value: patchPipeConfig(value), valid: true };
                }
                else {
                    return { valid: false, message: 'Must be false or a string.' };
                }
            },
            default: 'link linkchecker image editimage table spellchecker configurepermanentpen'
        });
    };
    const shouldNeverUseNative = option('contextmenu_never_use_native');
    const getAvoidOverlapSelector = option('contextmenu_avoid_overlap');
    const isContextMenuDisabled = (editor) => getContextMenu(editor).length === 0;
    const getContextMenu = (editor) => {
        const contextMenus = editor.ui.registry.getAll().contextMenus;
        const contextMenu = editor.options.get('contextmenu');
        if (editor.options.isSet('contextmenu')) {
            return contextMenu;
        }
        else {
            // Filter default context menu items when they are not in the registry (e.g. when the plugin is not loaded)
            return filter$2(contextMenu, (item) => has$2(contextMenus, item));
        }
    };

    const nu = (x, y) => ({
        type: 'makeshift',
        x,
        y
    });
    const transpose = (pos, dx, dy) => {
        return nu(pos.x + dx, pos.y + dy);
    };
    const isTouchEvent$1 = (e) => e.type === 'longpress' || e.type.indexOf('touch') === 0;
    const fromPageXY = (e) => {
        if (isTouchEvent$1(e)) {
            const touch = e.touches[0];
            return nu(touch.pageX, touch.pageY);
        }
        else {
            return nu(e.pageX, e.pageY);
        }
    };
    const fromClientXY = (e) => {
        if (isTouchEvent$1(e)) {
            const touch = e.touches[0];
            return nu(touch.clientX, touch.clientY);
        }
        else {
            return nu(e.clientX, e.clientY);
        }
    };
    const transposeContentAreaContainer = (element, pos) => {
        const containerPos = global$9.DOM.getPos(element);
        return transpose(pos, containerPos.x, containerPos.y);
    };
    const getPointAnchor = (editor, e) => {
        // If the contextmenu event is fired via the editor.dispatch() API or some other means, fall back to selection anchor
        if (e.type === 'contextmenu' || e.type === 'longpress') {
            if (editor.inline) {
                return fromPageXY(e);
            }
            else {
                return transposeContentAreaContainer(editor.getContentAreaContainer(), fromClientXY(e));
            }
        }
        else {
            return getSelectionAnchor(editor);
        }
    };
    const getSelectionAnchor = (editor) => {
        return {
            type: 'selection',
            root: SugarElement.fromDom(editor.selection.getNode())
        };
    };
    const getNodeAnchor = (editor) => ({
        type: 'node',
        node: Optional.some(SugarElement.fromDom(editor.selection.getNode())),
        root: SugarElement.fromDom(editor.getBody())
    });
    const getAnchorSpec$1 = (editor, e, anchorType) => {
        switch (anchorType) {
            case 'node':
                return getNodeAnchor(editor);
            case 'point':
                return getPointAnchor(editor, e);
            case 'selection':
                return getSelectionAnchor(editor);
        }
    };

    const initAndShow$1 = (editor, e, buildMenu, backstage, contextmenu, anchorType) => {
        const items = buildMenu();
        const anchorSpec = getAnchorSpec$1(editor, e, anchorType);
        build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
            isHorizontalMenu: false,
            search: Optional.none()
        }).map((menuData) => {
            e.preventDefault();
            // show the context menu, with items set to close on click
            InlineView.showMenuAt(contextmenu, { anchor: anchorSpec }, {
                menu: {
                    markers: markers('normal')
                },
                data: menuData
            });
        });
    };

    const layouts = {
        onLtr: () => [south$2, southeast$2, southwest$2, northeast$2, northwest$2, north$2,
            north$1, south$1, northeast$1, southeast$1, northwest$1, southwest$1],
        onRtl: () => [south$2, southwest$2, southeast$2, northwest$2, northeast$2, north$2,
            north$1, south$1, northwest$1, southwest$1, northeast$1, southeast$1]
    };
    const bubbleSize = 12;
    const bubbleAlignments = {
        valignCentre: [],
        alignCentre: [],
        alignLeft: ['tox-pop--align-left'],
        alignRight: ['tox-pop--align-right'],
        right: ['tox-pop--right'],
        left: ['tox-pop--left'],
        bottom: ['tox-pop--bottom'],
        top: ['tox-pop--top']
    };
    const isTouchWithinSelection = (editor, e) => {
        const selection = editor.selection;
        if (selection.isCollapsed() || e.touches.length < 1) {
            return false;
        }
        else {
            const touch = e.touches[0];
            const rng = selection.getRng();
            const rngRectOpt = getFirstRect(editor.getWin(), SimSelection.domRange(rng));
            return rngRectOpt.exists((rngRect) => rngRect.left <= touch.clientX &&
                rngRect.right >= touch.clientX &&
                rngRect.top <= touch.clientY &&
                rngRect.bottom >= touch.clientY);
        }
    };
    const setupiOSOverrides = (editor) => {
        // iOS will change the selection due to longpress also being a range selection gesture. As such we
        // need to reset the selection back to the original selection after the touchend event has fired
        const originalSelection = editor.selection.getRng();
        const selectionReset = () => {
            global$a.setEditorTimeout(editor, () => {
                editor.selection.setRng(originalSelection);
            }, 10);
            unbindEventListeners();
        };
        editor.once('touchend', selectionReset);
        // iPadOS will trigger a mousedown after the longpress which will close open context menus
        // so we want to prevent that from running
        const preventMousedown = (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
        };
        editor.on('mousedown', preventMousedown, true);
        // If a longpresscancel is fired, then a touchmove has occurred so we shouldn't do any overrides
        const clearSelectionReset = () => unbindEventListeners();
        editor.once('longpresscancel', clearSelectionReset);
        const unbindEventListeners = () => {
            editor.off('touchend', selectionReset);
            editor.off('longpresscancel', clearSelectionReset);
            editor.off('mousedown', preventMousedown);
        };
    };
    const getAnchorSpec = (editor, e, anchorType) => {
        const anchorSpec = getAnchorSpec$1(editor, e, anchorType);
        const bubbleYOffset = anchorType === 'point' ? bubbleSize : 0;
        return {
            bubble: nu$6(0, bubbleYOffset, bubbleAlignments),
            layouts,
            overrides: {
                maxWidthFunction: expandable(),
                maxHeightFunction: expandable$1()
            },
            ...anchorSpec
        };
    };
    const show = (editor, e, items, backstage, contextmenu, anchorType, highlightImmediately) => {
        const anchorSpec = getAnchorSpec(editor, e, anchorType);
        build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
            // MobileContextMenus are the *only* horizontal menus currently (2022-08-16)
            isHorizontalMenu: true,
            search: Optional.none()
        }).map((menuData) => {
            e.preventDefault();
            // If we are highlighting immediately, then we want to highlight the menu
            // and the item. Otherwise, we don't want to highlight anything.
            const highlightOnOpen = highlightImmediately
                ? HighlightOnOpen.HighlightMenuAndItem
                : HighlightOnOpen.HighlightNone;
            // Show the context menu, with items set to close on click
            InlineView.showMenuWithinBounds(contextmenu, { anchor: anchorSpec }, {
                menu: {
                    markers: markers('normal'),
                    highlightOnOpen
                },
                data: menuData,
                type: 'horizontal'
            }, () => Optional.some(getContextToolbarBounds(editor, backstage.shared, anchorType === 'node' ? 'node' : 'selection')));
            // Ensure the context toolbar is hidden
            editor.dispatch(hideContextToolbarEvent);
        });
    };
    const initAndShow = (editor, e, buildMenu, backstage, contextmenu, anchorType) => {
        const detection = detect$1();
        const isiOS = detection.os.isiOS();
        const isMacOS = detection.os.isMacOS();
        const isAndroid = detection.os.isAndroid();
        const isTouch = detection.deviceType.isTouch();
        const shouldHighlightImmediately = () => !(isAndroid || isiOS || (isMacOS && isTouch));
        const open = () => {
            const items = buildMenu();
            show(editor, e, items, backstage, contextmenu, anchorType, shouldHighlightImmediately());
        };
        // On iOS/iPadOS if we've long pressed on a ranged selection then we've already selected the content
        // and just need to open the menu. Otherwise we need to wait for a selection change to occur as long
        // press triggers a ranged selection on iOS.
        if ((isMacOS || isiOS) && anchorType !== 'node') {
            const openiOS = () => {
                setupiOSOverrides(editor);
                open();
            };
            if (isTouchWithinSelection(editor, e)) {
                openiOS();
            }
            else {
                editor.once('selectionchange', openiOS);
                editor.once('touchend', () => editor.off('selectionchange', openiOS));
            }
        }
        else {
            open();
        }
    };

    const isSeparator = (item) => isString(item) ? item === '|' : item.type === 'separator';
    const separator = {
        type: 'separator'
    };
    const makeContextItem = (item) => {
        const commonMenuItem = (item) => ({
            text: item.text,
            icon: item.icon,
            enabled: item.enabled,
            shortcut: item.shortcut,
        });
        if (isString(item)) {
            return item;
        }
        else {
            switch (item.type) {
                case 'separator':
                    return separator;
                case 'submenu':
                    return {
                        type: 'nestedmenuitem',
                        ...commonMenuItem(item),
                        getSubmenuItems: () => {
                            const items = item.getSubmenuItems();
                            if (isString(items)) {
                                return items;
                            }
                            else {
                                return map$2(items, makeContextItem);
                            }
                        }
                    };
                default:
                    // case 'item', or anything else really
                    const commonItem = item;
                    return {
                        type: 'menuitem',
                        ...commonMenuItem(commonItem),
                        // disconnect the function from the menu item API bridge defines
                        onAction: noarg(commonItem.onAction)
                    };
            }
        }
    };
    const addContextMenuGroup = (xs, groupItems) => {
        // Skip if there are no items
        if (groupItems.length === 0) {
            return xs;
        }
        // Only add a separator at the beginning if the last item isn't a separator
        const lastMenuItem = last$1(xs).filter((item) => !isSeparator(item));
        const before = lastMenuItem.fold(() => [], (_) => [separator]);
        return xs.concat(before).concat(groupItems).concat([separator]);
    };
    const generateContextMenu = (contextMenus, menuConfig, selectedElement) => {
        const sections = foldl(menuConfig, (acc, name) => {
            // Either read and convert the list of items out of the plugin, or assume it's a standard menu item reference
            return get$h(contextMenus, name.toLowerCase()).map((menu) => {
                const items = menu.update(selectedElement);
                if (isString(items) && isNotEmpty(trim$1(items))) {
                    return addContextMenuGroup(acc, items.split(' '));
                }
                else if (isArray(items) && items.length > 0) {
                    // TODO: Should we add a StructureSchema check here?
                    const allItems = map$2(items, makeContextItem);
                    return addContextMenuGroup(acc, allItems);
                }
                else {
                    return acc;
                }
            }).getOrThunk(() => acc.concat([name]));
        }, []);
        // Strip off any trailing separator
        if (sections.length > 0 && isSeparator(sections[sections.length - 1])) {
            sections.pop();
        }
        return sections;
    };
    const isNativeOverrideKeyEvent = (editor, e) => e.ctrlKey && !shouldNeverUseNative(editor);
    const isTouchEvent = (e) => e.type === 'longpress' || has$2(e, 'touches');
    const isTriggeredByKeyboard = (editor, e) => 
    // Different browsers trigger the context menu from keyboards differently, so need to check various different things here.
    // If a longpress touch event, always treat it as a pointer event
    // Chrome: button = 0, pointerType = undefined & target = the selection range node
    // Firefox: button = 0, pointerType = undefined & target = body
    // Safari: N/A (Mac's don't expose a contextmenu keyboard shortcut)
    !isTouchEvent(e) && (e.button !== 2 || e.target === editor.getBody() && e.pointerType === '');
    const getSelectedElement = (editor, e) => isTriggeredByKeyboard(editor, e) ? editor.selection.getStart(true) : e.target;
    const getAnchorType = (editor, e) => {
        const selector = getAvoidOverlapSelector(editor);
        const anchorType = isTriggeredByKeyboard(editor, e) ? 'selection' : 'point';
        if (isNotEmpty(selector)) {
            const target = getSelectedElement(editor, e);
            const selectorExists = closest$1(SugarElement.fromDom(target), selector);
            return selectorExists ? 'node' : anchorType;
        }
        else {
            return anchorType;
        }
    };
    const setup$5 = (editor, lazySink, backstage) => {
        const detection = detect$1();
        const isTouch = detection.deviceType.isTouch;
        const contextmenu = build$1(InlineView.sketch({
            dom: {
                tag: 'div'
            },
            lazySink,
            onEscape: () => editor.focus(),
            onShow: () => backstage.setContextMenuState(true),
            onHide: () => backstage.setContextMenuState(false),
            fireDismissalEventInstead: {},
            inlineBehaviours: derive$1([
                config('dismissContextMenu', [
                    run$1(dismissRequested(), (comp, _se) => {
                        Sandboxing.close(comp);
                        editor.focus();
                    })
                ])
            ])
        }));
        const hideContextMenu = () => InlineView.hide(contextmenu);
        const showContextMenu = (e) => {
            // Prevent the default if we should never use native
            if (shouldNeverUseNative(editor)) {
                e.preventDefault();
            }
            if (isNativeOverrideKeyEvent(editor, e) || isContextMenuDisabled(editor)) {
                return;
            }
            const anchorType = getAnchorType(editor, e);
            const buildMenu = () => {
                // Use the event target element for touch events, otherwise fallback to the current selection
                const selectedElement = getSelectedElement(editor, e);
                const registry = editor.ui.registry.getAll();
                const menuConfig = getContextMenu(editor);
                return generateContextMenu(registry.contextMenus, menuConfig, selectedElement);
            };
            const initAndShow$2 = isTouch() ? initAndShow : initAndShow$1;
            initAndShow$2(editor, e, buildMenu, backstage, contextmenu, anchorType);
        };
        editor.on('init', () => {
            // Hide the context menu when scrolling or resizing
            // Except ResizeWindow on mobile which fires when the keyboard appears/disappears
            const hideEvents = 'ResizeEditor ScrollContent ScrollWindow longpresscancel' + (isTouch() ? '' : ' ResizeWindow');
            editor.on(hideEvents, hideContextMenu);
            editor.on('longpress contextmenu', showContextMenu);
        });
    };

    const snapWidth = 40;
    const snapOffset = snapWidth / 2;
    // const insertDebugDiv = (left, top, width, height, color, clazz) => {
    //   const debugArea = SugarElement.fromHtml(`<div class="${clazz}"></div>`);
    //   Css.setAll(debugArea, {
    //     'left': left.toString() + 'px',
    //     'top': top.toString() + 'px',
    //     'background-color': color,
    //     'position': 'absolute',
    //     'width': width.toString() + 'px',
    //     'height': height.toString() + 'px',
    //     'opacity': '0.2'
    //   });
    //   Insert.append(SugarBody.body(), debugArea);
    // };
    const calcSnap = (selectorOpt, td, x, y, width, height) => selectorOpt.fold(() => Dragging.snap({
        sensor: absolute$1(x - snapOffset, y - snapOffset),
        range: SugarPosition(width, height),
        output: absolute$1(Optional.some(x), Optional.some(y)),
        extra: {
            td
        }
    }), (selectorHandle) => {
        const sensorLeft = x - snapOffset;
        const sensorTop = y - snapOffset;
        const sensorWidth = snapWidth; // box.width();
        const sensorHeight = snapWidth; // box.height();
        const rect = selectorHandle.element.dom.getBoundingClientRect();
        // insertDebugDiv(sensorLeft, sensorTop, sensorWidth, sensorHeight, 'green', 'top-left-snap-debug');
        return Dragging.snap({
            sensor: absolute$1(sensorLeft, sensorTop),
            range: SugarPosition(sensorWidth, sensorHeight),
            output: absolute$1(Optional.some(x - (rect.width / 2)), Optional.some(y - (rect.height / 2))),
            extra: {
                td
            }
        });
    });
    const getSnapsConfig = (getSnapPoints, cell, onChange) => {
        // Can't use Optional.is() here since we need to do a dom compare, not an equality compare
        const isSameCell = (cellOpt, td) => cellOpt.exists((currentTd) => eq(currentTd, td));
        return {
            getSnapPoints,
            leftAttr: 'data-drag-left',
            topAttr: 'data-drag-top',
            onSensor: (component, extra) => {
                const td = extra.td;
                if (!isSameCell(cell.get(), td)) {
                    cell.set(td);
                    onChange(td);
                }
            },
            mustSnap: true
        };
    };
    const createSelector = (snaps) => record(Button.sketch({
        dom: {
            tag: 'div',
            classes: ['tox-selector']
        },
        buttonBehaviours: derive$1([
            Dragging.config({
                mode: 'mouseOrTouch',
                blockerClass: 'blocker',
                snaps
            }),
            Unselecting.config({})
        ]),
        eventOrder: {
            // Because this is a button, allow dragging. It will stop clicking.
            mousedown: ['dragging', 'alloy.base.behaviour'],
            touchstart: ['dragging', 'alloy.base.behaviour']
        }
    }));
    const setup$4 = (editor, sink) => {
        const tlTds = Cell([]);
        const brTds = Cell([]);
        const isVisible = Cell(false);
        const startCell = value$2();
        const finishCell = value$2();
        const getTopLeftSnap = (td) => {
            const box = absolute$2(td);
            return calcSnap(memTopLeft.getOpt(sink), td, box.x, box.y, box.width, box.height);
        };
        const getTopLeftSnaps = () => 
        // const body = SugarBody.body();
        // const debugs = SelectorFilter.descendants(body, '.top-left-snap-debug');
        // Arr.each(debugs, (debugArea) => {
        //   Remove.remove(debugArea);
        // });
        map$2(tlTds.get(), (td) => getTopLeftSnap(td));
        const getBottomRightSnap = (td) => {
            const box = absolute$2(td);
            return calcSnap(memBottomRight.getOpt(sink), td, box.right, box.bottom, box.width, box.height);
        };
        const getBottomRightSnaps = () => 
        // const body = SugarBody.body();
        // const debugs = SelectorFilter.descendants(body, '.bottom-right-snap-debug');
        // Arr.each(debugs, (debugArea) => {
        //   Remove.remove(debugArea);
        // });
        map$2(brTds.get(), (td) => getBottomRightSnap(td));
        const topLeftSnaps = getSnapsConfig(getTopLeftSnaps, startCell, (start) => {
            finishCell.get().each((finish) => {
                editor.dispatch('TableSelectorChange', { start, finish });
            });
        });
        const bottomRightSnaps = getSnapsConfig(getBottomRightSnaps, finishCell, (finish) => {
            startCell.get().each((start) => {
                editor.dispatch('TableSelectorChange', { start, finish });
            });
        });
        const memTopLeft = createSelector(topLeftSnaps);
        const memBottomRight = createSelector(bottomRightSnaps);
        const topLeft = build$1(memTopLeft.asSpec());
        const bottomRight = build$1(memBottomRight.asSpec());
        const showOrHideHandle = (selector, cell, isAbove, isBelow) => {
            const cellRect = cell.dom.getBoundingClientRect();
            remove$6(selector.element, 'display');
            const viewportHeight = defaultView(SugarElement.fromDom(editor.getBody())).dom.innerHeight;
            const aboveViewport = isAbove(cellRect);
            const belowViewport = isBelow(cellRect, viewportHeight);
            if (aboveViewport || belowViewport) {
                set$7(selector.element, 'display', 'none');
            }
        };
        const snapTo = (selector, cell, getSnapConfig, pos) => {
            const snap = getSnapConfig(cell);
            Dragging.snapTo(selector, snap);
            const isAbove = (rect) => rect[pos] < 0;
            const isBelow = (rect, viewportHeight) => rect[pos] > viewportHeight;
            showOrHideHandle(selector, cell, isAbove, isBelow);
        };
        const snapTopLeft = (cell) => snapTo(topLeft, cell, getTopLeftSnap, 'top');
        const snapLastTopLeft = () => startCell.get().each(snapTopLeft);
        const snapBottomRight = (cell) => snapTo(bottomRight, cell, getBottomRightSnap, 'bottom');
        const snapLastBottomRight = () => finishCell.get().each(snapBottomRight);
        // TODO: Make this work for desktop maybe?
        if (detect$1().deviceType.isTouch()) {
            const domToSugar = (arr) => map$2(arr, SugarElement.fromDom);
            editor.on('TableSelectionChange', (e) => {
                if (!isVisible.get()) {
                    attach(sink, topLeft);
                    attach(sink, bottomRight);
                    isVisible.set(true);
                }
                const start = SugarElement.fromDom(e.start);
                const finish = SugarElement.fromDom(e.finish);
                startCell.set(start);
                finishCell.set(finish);
                Optional.from(e.otherCells).each((otherCells) => {
                    tlTds.set(domToSugar(otherCells.upOrLeftCells));
                    brTds.set(domToSugar(otherCells.downOrRightCells));
                    snapTopLeft(start);
                    snapBottomRight(finish);
                });
            });
            editor.on('ResizeEditor ResizeWindow ScrollContent', () => {
                snapLastTopLeft();
                snapLastBottomRight();
            });
            editor.on('TableSelectionClear', () => {
                if (isVisible.get()) {
                    detach(topLeft);
                    detach(bottomRight);
                    isVisible.set(false);
                }
                startCell.clear();
                finishCell.clear();
            });
        }
    };

    var Logo = "<svg height=\"16\" viewBox=\"0 0 80 16\" width=\"80\" xmlns=\"http://www.w3.org/2000/svg\"><g opacity=\".8\"><path d=\"m80 3.537v-2.202h-7.976v11.585h7.976v-2.25h-5.474v-2.621h4.812v-2.069h-4.812v-2.443zm-10.647 6.929c-.493.217-1.13.337-1.864.337s-1.276-.156-1.805-.47a3.732 3.732 0 0 1 -1.3-1.298c-.324-.554-.48-1.191-.48-1.877s.156-1.335.48-1.877a3.635 3.635 0 0 1 1.3-1.299 3.466 3.466 0 0 1 1.805-.481c.65 0 .914.06 1.263.18.36.12.698.277.986.47.289.192.578.384.842.6l.12.085v-2.586l-.023-.024c-.385-.35-.855-.614-1.384-.818-.53-.205-1.155-.313-1.877-.313-.721 0-1.6.144-2.333.445a5.773 5.773 0 0 0 -1.937 1.251 5.929 5.929 0 0 0 -1.324 1.9c-.324.735-.48 1.565-.48 2.455s.156 1.72.48 2.454c.325.734.758 1.383 1.324 1.913.553.53 1.215.938 1.937 1.25a6.286 6.286 0 0 0 2.333.434c.819 0 1.384-.108 1.961-.313.59-.216 1.083-.505 1.468-.866l.024-.024v-2.49l-.12.096c-.41.337-.878.626-1.396.866zm-14.869-4.15-4.8-5.04-.024-.025h-.902v11.67h2.502v-6.847l2.827 3.08.385.409.397-.41 2.791-3.067v6.845h2.502v-11.679h-.902l-4.788 5.052z\"/><path clip-rule=\"evenodd\" d=\"m15.543 5.137c0-3.032-2.466-5.113-4.957-5.137-.36 0-.745.024-1.094.096-.157.024-3.85.758-3.85.758-3.032.602-4.62 2.466-4.704 4.788-.024.89-.024 4.27-.024 4.27.036 3.165 2.406 5.138 5.017 5.126.337 0 1.119-.109 1.287-.145.144-.024.385-.084.746-.144.661-.12 1.684-.325 3.067-.602 2.37-.409 4.103-2.009 4.44-4.33.156-1.023.084-4.692.084-4.692zm-3.213 3.308-2.346.457v2.31l-5.859 1.143v-5.75l2.346-.458v3.441l3.513-.686v-3.44l-3.513.685v-2.297l5.859-1.143v5.75zm20.09-3.296-.083-1.023h-2.13v8.794h2.346v-4.884c0-1.107.95-1.985 2.057-1.997 1.095 0 1.901.89 1.901 1.997v4.884h2.346v-5.245c-.012-2.105-1.588-3.777-3.67-3.765a3.764 3.764 0 0 0 -2.778 1.25l.012-.011zm-6.014-4.102 2.346-.458v2.298l-2.346.457z\" fill-rule=\"evenodd\"/><path d=\"m28.752 4.126h-2.346v8.794h2.346z\"/><path clip-rule=\"evenodd\" d=\"m43.777 15.483 4.043-11.357h-2.418l-1.54 4.355-.445 1.324-.36-1.324-1.54-4.355h-2.418l3.151 8.794-1.083 3.08zm-21.028-5.51c0 .722.541 1.034.878 1.034s.638-.048.95-.144l.518 1.708c-.217.145-.879.518-2.13.518a2.565 2.565 0 0 1 -2.562-2.587c-.024-1.082-.024-2.49 0-4.21h-1.54v-2.142h1.54v-1.912l2.346-.458v2.37h2.201v2.142h-2.2v3.693-.012z\" fill-rule=\"evenodd\"/></g></svg>\n";

    const isHidden = (elm) => elm.nodeName === 'BR' || !!elm.getAttribute('data-mce-bogus') || elm.getAttribute('data-mce-type') === 'bookmark';
    const renderElementPath = (editor, settings, providersBackstage) => {
        var _a;
        const delimiter = (_a = settings.delimiter) !== null && _a !== void 0 ? _a : '\u203A';
        const renderElement = (name, element, index) => Button.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-statusbar__path-item'],
                attributes: {
                    'data-index': index,
                }
            },
            components: [
                text$2(name)
            ],
            action: (_btn) => {
                editor.focus();
                editor.selection.select(element);
                editor.nodeChanged();
            },
            buttonBehaviours: derive$1([
                Tooltipping.config({
                    ...providersBackstage.tooltips.getConfig({
                        tooltipText: providersBackstage.translate(['Select the {0} element', element.nodeName.toLowerCase()]),
                        onShow: (comp, tooltip) => {
                            describedBy(comp.element, tooltip.element);
                        },
                        onHide: (comp) => {
                            remove$1(comp.element);
                        }
                    }),
                }),
                DisablingConfigs.button(providersBackstage.isDisabled),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext('any'))
            ])
        });
        const renderDivider = () => ({
            dom: {
                tag: 'div',
                classes: ['tox-statusbar__path-divider'],
                attributes: {
                    'aria-hidden': true
                }
            },
            components: [
                text$2(` ${delimiter} `)
            ]
        });
        const renderPathData = (data) => foldl(data, (acc, path, index) => {
            const element = renderElement(path.name, path.element, index);
            if (index === 0) {
                return acc.concat([element]);
            }
            else {
                return acc.concat([renderDivider(), element]);
            }
        }, []);
        const updatePath = (parents) => {
            const newPath = [];
            let i = parents.length;
            while (i-- > 0) {
                const parent = parents[i];
                if (parent.nodeType === 1 && !isHidden(parent)) {
                    const args = fireResolveName(editor, parent);
                    if (!args.isDefaultPrevented()) {
                        newPath.push({ name: args.name, element: parent });
                    }
                    if (args.isPropagationStopped()) {
                        break;
                    }
                }
            }
            return newPath;
        };
        return {
            dom: {
                tag: 'div',
                classes: ['tox-statusbar__path'],
                attributes: {
                    role: 'navigation'
                }
            },
            behaviours: derive$1([
                Keying.config({
                    mode: 'flow',
                    selector: 'div[role=button]'
                }),
                Disabling.config({
                    disabled: providersBackstage.isDisabled
                }),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext('any')),
                Tabstopping.config({}),
                Replacing.config({}),
                config('elementPathEvents', [
                    runOnAttached((comp, _e) => {
                        // NOTE: If statusbar ever gets re-rendered, we will need to free this.
                        editor.shortcuts.add('alt+F11', 'focus statusbar elementpath', () => Keying.focusIn(comp));
                        editor.on('NodeChange', (e) => {
                            const newPath = updatePath(e.parents);
                            const newChildren = newPath.length > 0 ? renderPathData(newPath) : [];
                            Replacing.set(comp, newChildren);
                        });
                    })
                ])
            ]),
            components: []
        };
    };

    var ResizeTypes;
    (function (ResizeTypes) {
        ResizeTypes[ResizeTypes["None"] = 0] = "None";
        ResizeTypes[ResizeTypes["Both"] = 1] = "Both";
        ResizeTypes[ResizeTypes["Vertical"] = 2] = "Vertical";
    })(ResizeTypes || (ResizeTypes = {}));
    const getOriginalDimensions = (editor) => {
        const container = SugarElement.fromDom(editor.getContainer());
        const originalHeight = get$d(container);
        const originalWidth = get$c(container);
        return {
            height: originalHeight,
            width: originalWidth,
        };
    };
    const getDimensions = (editor, deltas, resizeType, originalDimentions) => {
        const dimensions = {
            height: calcCappedSize(originalDimentions.height + deltas.top, getMinHeightOption(editor), getMaxHeightOption(editor)),
            width: resizeType === ResizeTypes.Both
                ? calcCappedSize(originalDimentions.width + deltas.left, getMinWidthOption(editor), getMaxWidthOption(editor))
                : originalDimentions.width,
        };
        return dimensions;
    };
    const resize = (editor, deltas, resizeType) => {
        const container = SugarElement.fromDom(editor.getContainer());
        const originalDimentions = getOriginalDimensions(editor);
        const dimensions = getDimensions(editor, deltas, resizeType, originalDimentions);
        each(dimensions, (val, dim) => {
            if (isNumber(val)) {
                set$7(container, dim, numToPx(val));
            }
        });
        fireResizeEditor(editor);
        return dimensions;
    };

    const getResizeType = (editor) => {
        const resize = getResize(editor);
        if (resize === false) {
            return ResizeTypes.None;
        }
        else if (resize === 'both') {
            return ResizeTypes.Both;
        }
        else {
            return ResizeTypes.Vertical;
        }
    };
    const getAriaValuetext = (dimensions, resizeType) => {
        return resizeType === ResizeTypes.Both
            ? global$6.translate([`Editor's height: {0} pixels, Editor's width: {1} pixels`, dimensions.height, dimensions.width])
            : global$6.translate([`Editor's height: {0} pixels`, dimensions.height]);
    };
    const setAriaValuetext = (comp, dimensions, resizeType) => {
        set$9(comp.element, 'aria-valuetext', getAriaValuetext(dimensions, resizeType));
    };
    const keyboardHandler = (editor, comp, resizeType, x, y) => {
        const scale = 20;
        const delta = SugarPosition(x * scale, y * scale);
        const newDimentions = resize(editor, delta, resizeType);
        setAriaValuetext(comp, newDimentions, resizeType);
        return Optional.some(true);
    };
    const renderResizeHandler = (editor, providersBackstage) => {
        const resizeType = getResizeType(editor);
        if (resizeType === ResizeTypes.None) {
            return Optional.none();
        }
        const resizeLabel = resizeType === ResizeTypes.Both
            ? global$6.translate('Press the arrow keys to resize the editor.')
            : global$6.translate('Press the Up and Down arrow keys to resize the editor.');
        const cursorClass = resizeType === ResizeTypes.Both
            ? 'tox-statusbar__resize-cursor-both'
            : 'tox-statusbar__resize-cursor-default';
        return Optional.some(render$4('resize-handle', {
            tag: 'div',
            classes: ['tox-statusbar__resize-handle', cursorClass],
            attributes: {
                'aria-label': providersBackstage.translate(resizeLabel),
                'data-mce-name': 'resize-handle',
                'role': 'separator'
            },
            behaviours: [
                Dragging.config({
                    mode: 'mouse',
                    repositionTarget: false,
                    onDrag: (comp, _target, delta) => {
                        const newDimentions = resize(editor, delta, resizeType);
                        setAriaValuetext(comp, newDimentions, resizeType);
                    },
                    blockerClass: 'tox-blocker'
                }),
                Keying.config({
                    mode: 'special',
                    onLeft: (comp) => keyboardHandler(editor, comp, resizeType, -1, 0),
                    onRight: (comp) => keyboardHandler(editor, comp, resizeType, 1, 0),
                    onUp: (comp) => keyboardHandler(editor, comp, resizeType, 0, -1),
                    onDown: (comp) => keyboardHandler(editor, comp, resizeType, 0, 1),
                }),
                Tabstopping.config({}),
                Focusing.config({}),
                Tooltipping.config(providersBackstage.tooltips.getConfig({
                    tooltipText: providersBackstage.translate('Resize')
                })),
                config('set-aria-valuetext', [
                    runOnAttached((comp) => {
                        const setInitialValuetext = () => {
                            setAriaValuetext(comp, getOriginalDimensions(editor), resizeType);
                        };
                        if (editor._skinLoaded) {
                            setInitialValuetext();
                        }
                        else {
                            editor.once('SkinLoaded', setInitialValuetext);
                        }
                    })
                ])
            ],
            eventOrder: {
                [attachedToDom()]: ['add-focusable', 'set-aria-valuetext']
            }
        }, providersBackstage.icons));
    };

    const renderWordCount = (editor, providersBackstage) => {
        const replaceCountText = (comp, count, mode) => Replacing.set(comp, [text$2(providersBackstage.translate(['{0} ' + mode, count[mode]]))]);
        return Button.sketch({
            dom: {
                // The tag for word count was changed to 'button' as Jaws does not read out spans.
                // Word count is just a toggle and changes modes between words and characters.
                tag: 'button',
                classes: ['tox-statusbar__wordcount']
            },
            components: [],
            buttonBehaviours: derive$1([
                DisablingConfigs.button(providersBackstage.isDisabled),
                toggleOnReceive(() => providersBackstage.checkUiComponentContext('any')),
                Tabstopping.config({}),
                Replacing.config({}),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: {
                            mode: "words" /* WordCountMode.Words */,
                            count: { words: 0, characters: 0 }
                        }
                    }
                }),
                config('wordcount-events', [
                    runOnExecute$1((comp) => {
                        const currentVal = Representing.getValue(comp);
                        const newMode = currentVal.mode === "words" /* WordCountMode.Words */ ? "characters" /* WordCountMode.Characters */ : "words" /* WordCountMode.Words */;
                        Representing.setValue(comp, { mode: newMode, count: currentVal.count });
                        replaceCountText(comp, currentVal.count, newMode);
                    }),
                    runOnAttached((comp) => {
                        editor.on('wordCountUpdate', (e) => {
                            const { mode } = Representing.getValue(comp);
                            Representing.setValue(comp, { mode, count: e.wordCount });
                            replaceCountText(comp, e.wordCount, mode);
                        });
                    })
                ])
            ]),
            eventOrder: {
                [execute$5()]: ['disabling', 'alloy.base.behaviour', 'wordcount-events']
            }
        });
    };

    const renderStatusbar = (editor, providersBackstage) => {
        const renderBranding = () => {
            return {
                dom: {
                    tag: 'span',
                    classes: ['tox-statusbar__branding'],
                },
                components: [
                    {
                        dom: {
                            tag: 'a',
                            attributes: {
                                'href': 'https://www.tiny.cloud/powered-by-tiny?utm_campaign=poweredby&utm_source=tiny&utm_medium=referral&utm_content=v7',
                                'rel': 'noopener',
                                'target': '_blank',
                                'aria-label': editor.translate(['Build with {0}', 'TinyMCE'])
                            },
                            innerHtml: editor.translate(['Build with {0}', Logo.trim()])
                        },
                        behaviours: derive$1([
                            Focusing.config({})
                        ])
                    }
                ]
            };
        };
        const renderHelpAccessibility = () => {
            const shortcutText = convertText('Alt+0');
            const text = `Press {0} for help`;
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-statusbar__help-text'],
                },
                components: [
                    text$2(global$6.translate([text, shortcutText]))
                ]
            };
        };
        const renderRightContainer = () => {
            const components = [];
            if (editor.hasPlugin('wordcount')) {
                components.push(renderWordCount(editor, providersBackstage));
            }
            if (useBranding(editor)) {
                components.push(renderBranding());
            }
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-statusbar__right-container']
                },
                components
            };
        };
        const getTextComponents = () => {
            const components = [];
            const shouldRenderHelp = useHelpAccessibility(editor);
            const shouldRenderElementPath = useElementPath(editor);
            const shouldRenderRightContainer = useBranding(editor) || editor.hasPlugin('wordcount');
            const getTextComponentClasses = () => {
                const flexStart = 'tox-statusbar__text-container--flex-start';
                const flexEnd = 'tox-statusbar__text-container--flex-end';
                const spaceAround = 'tox-statusbar__text-container--space-around';
                if (shouldRenderHelp) {
                    const container3Columns = 'tox-statusbar__text-container-3-cols';
                    if (!shouldRenderRightContainer && !shouldRenderElementPath) {
                        return [container3Columns, spaceAround];
                    }
                    if (shouldRenderRightContainer && !shouldRenderElementPath) {
                        return [container3Columns, flexEnd];
                    }
                    return [container3Columns, flexStart];
                }
                return [shouldRenderRightContainer && !shouldRenderElementPath ? flexEnd : flexStart];
            };
            if (shouldRenderElementPath) {
                components.push(renderElementPath(editor, {}, providersBackstage));
            }
            if (shouldRenderHelp) {
                components.push(renderHelpAccessibility());
            }
            if (shouldRenderRightContainer) {
                components.push(renderRightContainer());
            }
            if (components.length > 0) {
                return [{
                        dom: {
                            tag: 'div',
                            classes: ['tox-statusbar__text-container', ...getTextComponentClasses()]
                        },
                        components
                    }];
            }
            return [];
        };
        const getComponents = () => {
            const components = getTextComponents();
            const resizeHandler = renderResizeHandler(editor, providersBackstage);
            return components.concat(resizeHandler.toArray());
        };
        return {
            dom: {
                tag: 'div',
                classes: ['tox-statusbar']
            },
            components: getComponents()
        };
    };

    const getLazyMothership = (label, singleton) => singleton.get().getOrDie(`UI for ${label} has not been rendered`);
    const setup$3 = (editor, setupForTheme) => {
        const isInline = editor.inline;
        const mode = isInline ? Inline : Iframe;
        // We use a different component for creating the sticky toolbar behaviour. The
        // most important difference is it needs "Docking" configured and all of the
        // ripple effects that creates.
        const header = isStickyToolbar(editor) ? StickyHeader : StaticHeader;
        const lazyUiRefs = LazyUiReferences();
        // Importantly, this is outside the setup function.
        const lazyMothership = value$2();
        const lazyDialogMothership = value$2();
        const lazyPopupMothership = value$2();
        const platform = detect$1();
        const isTouch = platform.deviceType.isTouch();
        const touchPlatformClass = 'tox-platform-touch';
        const deviceClasses = isTouch ? [touchPlatformClass] : [];
        const isToolbarBottom = isToolbarLocationBottom(editor);
        const toolbarMode = getToolbarMode(editor);
        const memAnchorBar = record({
            dom: {
                tag: 'div',
                classes: ['tox-anchorbar']
            }
        });
        const memBottomAnchorBar = record({
            dom: {
                tag: 'div',
                classes: ['tox-bottom-anchorbar']
            }
        });
        const lazyHeader = () => lazyUiRefs.mainUi.get()
            .map((ui) => ui.outerContainer)
            .bind(OuterContainer.getHeader);
        const lazyDialogSinkResult = () => Result.fromOption(lazyUiRefs.dialogUi.get().map((ui) => ui.sink), 'UI has not been rendered');
        const lazyPopupSinkResult = () => Result.fromOption(lazyUiRefs.popupUi.get().map((ui) => ui.sink), '(popup) UI has not been rendered');
        const lazyAnchorBar = lazyUiRefs.lazyGetInOuterOrDie('anchor bar', memAnchorBar.getOpt);
        const lazyBottomAnchorBar = lazyUiRefs.lazyGetInOuterOrDie('bottom anchor bar', memBottomAnchorBar.getOpt);
        const lazyToolbar = lazyUiRefs.lazyGetInOuterOrDie('toolbar', OuterContainer.getToolbar);
        const lazyThrobber = lazyUiRefs.lazyGetInOuterOrDie('throbber', OuterContainer.getThrobber);
        // Here, we build the backstage. The backstage is going to use different sinks for dialog
        // vs popup.
        const backstages = init({
            popup: lazyPopupSinkResult,
            dialog: lazyDialogSinkResult
        }, editor, lazyAnchorBar, lazyBottomAnchorBar);
        const makeHeaderPart = () => {
            const verticalDirAttributes = {
                attributes: {
                    [Attribute]: isToolbarBottom ?
                        AttributeValue.BottomToTop :
                        AttributeValue.TopToBottom
                }
            };
            const partMenubar = OuterContainer.parts.menubar({
                dom: {
                    tag: 'div',
                    classes: ['tox-menubar']
                },
                // TINY-9223: The menu bar should scroll with the editor.
                backstage: backstages.popup,
                onEscape: () => {
                    editor.focus();
                }
            });
            const partToolbar = OuterContainer.parts.toolbar({
                dom: {
                    tag: 'div',
                    classes: ['tox-toolbar']
                },
                getSink: backstages.popup.shared.getSink,
                providers: backstages.popup.shared.providers,
                onEscape: () => {
                    editor.focus();
                },
                onToolbarToggled: (state) => {
                    fireToggleToolbarDrawer(editor, state);
                },
                type: toolbarMode,
                lazyToolbar,
                lazyHeader: () => lazyHeader().getOrDie('Could not find header element'),
                ...verticalDirAttributes
            });
            const partMultipleToolbar = OuterContainer.parts['multiple-toolbar']({
                dom: {
                    tag: 'div',
                    classes: ['tox-toolbar-overlord']
                },
                providers: backstages.popup.shared.providers,
                onEscape: () => {
                    editor.focus();
                },
                type: toolbarMode
            });
            // False should stop the menubar and toolbar rendering altogether
            const hasMultipleToolbar = isMultipleToolbars(editor);
            const hasToolbar = isToolbarEnabled(editor);
            const hasMenubar = isMenubarEnabled(editor);
            const shouldHavePromotionLink = promotionEnabled(editor);
            const partPromotion = makePromotion(shouldHavePromotionLink);
            const hasAnyContents = hasMultipleToolbar || hasToolbar || hasMenubar;
            const getPartToolbar = () => {
                if (hasMultipleToolbar) {
                    return [partMultipleToolbar];
                }
                else if (hasToolbar) {
                    return [partToolbar];
                }
                else {
                    return [];
                }
            };
            const menubarCollection = [partPromotion, partMenubar];
            return OuterContainer.parts.header({
                dom: {
                    tag: 'div',
                    classes: ['tox-editor-header']
                        .concat(hasAnyContents ? [] : ['tox-editor-header--empty']),
                    ...verticalDirAttributes
                },
                components: flatten([
                    hasMenubar ? menubarCollection : [],
                    getPartToolbar(),
                    // fixed_toolbar_container anchors to the editable area, else add an anchor bar
                    useFixedContainer(editor) ? [] : [memAnchorBar.asSpec()]
                ]),
                sticky: isStickyToolbar(editor),
                editor,
                // TINY-9223: If using a sticky toolbar, which sink should it really go in?
                sharedBackstage: backstages.popup.shared
            });
        };
        const makePromotion = (promotionLink) => {
            return OuterContainer.parts.promotion({
                dom: {
                    tag: 'div',
                    classes: ['tox-promotion'],
                },
                promotionLink
            });
        };
        const makeSidebarDefinition = () => {
            const partSocket = OuterContainer.parts.socket({
                dom: {
                    tag: 'div',
                    classes: ['tox-edit-area']
                }
            });
            const partSidebar = OuterContainer.parts.sidebar({
                dom: {
                    tag: 'div',
                    classes: ['tox-sidebar']
                }
            });
            return {
                dom: {
                    tag: 'div',
                    classes: ['tox-sidebar-wrap']
                },
                components: [
                    partSocket,
                    partSidebar
                ]
            };
        };
        const renderDialogUi = () => {
            const uiContainer = getUiContainer(editor);
            // TINY-3321: When the body is using a grid layout, we need to ensure the sink width is manually set
            const isGridUiContainer = eq(body(), uiContainer) && get$e(uiContainer, 'display') === 'grid';
            const sinkSpec = {
                dom: {
                    tag: 'div',
                    classes: ['tox', 'tox-silver-sink', 'tox-tinymce-aux'].concat(deviceClasses),
                    attributes: {
                        ...global$6.isRtl() ? { dir: 'rtl' } : {}
                    }
                },
                behaviours: derive$1([
                    Positioning.config({
                        useFixed: () => header.isDocked(lazyHeader)
                    })
                ])
            };
            const reactiveWidthSpec = {
                dom: {
                    styles: { width: document.body.clientWidth + 'px' }
                },
                events: derive$2([
                    run$1(windowResize(), (comp) => {
                        set$7(comp.element, 'width', document.body.clientWidth + 'px');
                    })
                ])
            };
            const sink = build$1(deepMerge(sinkSpec, isGridUiContainer ? reactiveWidthSpec : {}));
            const uiMothership = takeover(sink);
            lazyDialogMothership.set(uiMothership);
            return { sink, mothership: uiMothership };
        };
        const renderPopupUi = () => {
            // TINY-9226: Because the popupUi is going to be placed adjacent to the editor, we aren't currently
            // implementing the behaviour to reset widths based on window sizing. It is a workaround that
            // is mainly targeted at Ui containers in the root. However, we may need to revisit this
            // if the ui_mode: split setting is commonly used when the editor is at the root level, and the
            // page has size-unfriendly CSS for sinks (like CSS grid)
            const sinkSpec = {
                dom: {
                    tag: 'div',
                    classes: ['tox', 'tox-silver-sink', 'tox-silver-popup-sink', 'tox-tinymce-aux'].concat(deviceClasses),
                    attributes: {
                        ...global$6.isRtl() ? { dir: 'rtl' } : {}
                    }
                },
                behaviours: derive$1([
                    Positioning.config({
                        useFixed: () => header.isDocked(lazyHeader),
                        // TINY-9226: We want to limit the popup sink's bounds based on its scrolling environment. We don't
                        // want it to try to position things outside of its scrolling viewport, because they will
                        // just appear offscreen (hidden by the current scroll values)
                        getBounds: () => setupForTheme.getPopupSinkBounds()
                    })
                ])
            };
            const sink = build$1(sinkSpec);
            const uiMothership = takeover(sink);
            lazyPopupMothership.set(uiMothership);
            return { sink, mothership: uiMothership };
        };
        const renderMainUi = () => {
            const partHeader = makeHeaderPart();
            const sidebarContainer = makeSidebarDefinition();
            const partThrobber = OuterContainer.parts.throbber({
                dom: {
                    tag: 'div',
                    classes: ['tox-throbber']
                },
                backstage: backstages.popup
            });
            const partViewWrapper = OuterContainer.parts.viewWrapper({
                backstage: backstages.popup
            });
            const statusbar = useStatusBar(editor) && !isInline ? Optional.some(renderStatusbar(editor, backstages.popup.shared.providers)) : Optional.none();
            // We need the statusbar to be separate to everything else so resizing works properly
            const editorComponents = flatten([
                isToolbarBottom ? [] : [partHeader],
                // Inline mode does not have a socket/sidebar
                isInline ? [] : [sidebarContainer],
                isToolbarBottom ? [partHeader] : []
            ]);
            const editorContainer = OuterContainer.parts.editorContainer({
                components: flatten([
                    editorComponents,
                    isInline ? [] : [memBottomAnchorBar.asSpec()]
                ])
            });
            // Hide the outer container if using inline mode and there's no menubar or toolbar
            const isHidden = isDistractionFree(editor);
            const attributes = {
                role: 'application',
                ...global$6.isRtl() ? { dir: 'rtl' } : {},
                ...isHidden ? { 'aria-hidden': 'true' } : {}
            };
            const outerContainer = build$1(OuterContainer.sketch({
                dom: {
                    tag: 'div',
                    classes: ['tox', 'tox-tinymce']
                        .concat(isInline ? ['tox-tinymce-inline'] : [])
                        .concat(isToolbarBottom ? ['tox-tinymce--toolbar-bottom'] : [])
                        .concat(deviceClasses),
                    styles: {
                        // This is overridden by the skin, it helps avoid FOUC
                        visibility: 'hidden',
                        // Hide the container if needed, but don't use "display: none" so that it still has a position
                        ...isHidden ? { opacity: '0', border: '0' } : {}
                    },
                    attributes
                },
                components: [
                    editorContainer,
                    // Inline mode does not have a status bar
                    ...isInline ? [] : [partViewWrapper, ...statusbar.toArray()],
                    partThrobber,
                ],
                behaviours: derive$1([
                    toggleOnReceive(() => backstages.popup.shared.providers.checkUiComponentContext('any')),
                    Disabling.config({
                        disableClass: 'tox-tinymce--disabled'
                    }),
                    Keying.config({
                        mode: 'cyclic',
                        selector: '.tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle'
                    })
                ])
            }));
            const mothership = takeover(outerContainer);
            lazyMothership.set(mothership);
            return { mothership, outerContainer };
        };
        const setEditorSize = (outerContainer) => {
            // Set height and width if they were given, though height only applies to iframe mode
            const parsedHeight = numToPx(getHeightWithFallback(editor));
            const parsedWidth = numToPx(getWidthWithFallback(editor));
            if (!editor.inline) {
                // Update the width
                if (isValidValue$1('div', 'width', parsedWidth)) {
                    set$7(outerContainer.element, 'width', parsedWidth);
                }
                // Update the height
                if (isValidValue$1('div', 'height', parsedHeight)) {
                    set$7(outerContainer.element, 'height', parsedHeight);
                }
                else {
                    set$7(outerContainer.element, 'height', '400px');
                }
            }
            return parsedHeight;
        };
        const setupShortcutsAndCommands = (outerContainer) => {
            editor.addShortcut('alt+F9', 'focus menubar', () => {
                OuterContainer.focusMenubar(outerContainer);
            });
            editor.addShortcut('alt+F10', 'focus toolbar', () => {
                OuterContainer.focusToolbar(outerContainer);
            });
            editor.addCommand('ToggleToolbarDrawer', (_ui, options, args) => {
                if (options === null || options === void 0 ? void 0 : options.skipFocus) {
                    logFeatureDeprecationWarning('skipFocus');
                    OuterContainer.toggleToolbarDrawerWithoutFocusing(outerContainer);
                }
                else if (args === null || args === void 0 ? void 0 : args.skip_focus) {
                    OuterContainer.toggleToolbarDrawerWithoutFocusing(outerContainer);
                }
                else {
                    OuterContainer.toggleToolbarDrawer(outerContainer);
                }
            });
            editor.addQueryStateHandler('ToggleToolbarDrawer', () => OuterContainer.isToolbarDrawerToggled(outerContainer));
            editor.on('blur', () => {
                if (getToolbarMode(editor) === ToolbarMode$1.floating && OuterContainer.isToolbarDrawerToggled(outerContainer)) {
                    OuterContainer.toggleToolbarDrawerWithoutFocusing(outerContainer);
                }
            });
        };
        const renderUIWithRefs = (uiRefs) => {
            const { mainUi, popupUi, uiMotherships } = uiRefs;
            map$1(getToolbarGroups(editor), (toolbarGroupButtonConfig, name) => {
                editor.ui.registry.addGroupToolbarButton(name, toolbarGroupButtonConfig);
            });
            // Apply Bridge types
            const { buttons, menuItems, contextToolbars, sidebars, views } = editor.ui.registry.getAll();
            const toolbarOpt = getMultipleToolbarsOption(editor);
            const rawUiConfig = {
                menuItems,
                menus: getMenus(editor),
                menubar: getMenubar(editor),
                toolbar: toolbarOpt.getOrThunk(() => getToolbar(editor)),
                allowToolbarGroups: toolbarMode === ToolbarMode$1.floating,
                buttons,
                sidebar: sidebars,
                views
            };
            setupShortcutsAndCommands(mainUi.outerContainer);
            setup$b(editor, mainUi.mothership, uiMotherships);
            // This backstage needs to kept in sync with the one passed to the Header part.
            header.setup(editor, backstages.popup.shared, lazyHeader);
            // This backstage is probably needed for just the bespoke dropdowns
            setup$6(editor, backstages.popup);
            setup$5(editor, backstages.popup.shared.getSink, backstages.popup);
            setup$8(editor);
            setup$7(editor, lazyThrobber, backstages.popup.shared);
            register$a(editor, contextToolbars, popupUi.sink, { backstage: backstages.popup });
            setup$4(editor, popupUi.sink);
            const elm = editor.getElement();
            const height = setEditorSize(mainUi.outerContainer);
            const args = { targetNode: elm, height };
            // The only components that use backstages.dialog currently are the Modal dialogs.
            return mode.render(editor, uiRefs, rawUiConfig, backstages.popup, args);
        };
        const reuseDialogUiForPopuUi = (dialogUi) => {
            lazyPopupMothership.set(dialogUi.mothership);
            return dialogUi;
        };
        const renderUI = () => {
            const mainUi = renderMainUi();
            const dialogUi = renderDialogUi();
            // If dialogUi and popupUi are the same, LazyUiReferences should handle deduplicating then
            // get calling getUiMotherships
            const popupUi = isSplitUiMode(editor) ? renderPopupUi() : reuseDialogUiForPopuUi(dialogUi);
            lazyUiRefs.dialogUi.set(dialogUi);
            lazyUiRefs.popupUi.set(popupUi);
            lazyUiRefs.mainUi.set(mainUi);
            // From this point on, we shouldn't use LazyReferences any more.
            const uiRefs = {
                popupUi,
                dialogUi,
                mainUi,
                uiMotherships: lazyUiRefs.getUiMotherships()
            };
            return renderUIWithRefs(uiRefs);
        };
        // We don't have uiRefs here, so we have to rely on cells that are set by renderUI unfortunately.
        return {
            popups: {
                backstage: backstages.popup,
                getMothership: () => getLazyMothership('popups', lazyPopupMothership)
            },
            dialogs: {
                backstage: backstages.dialog,
                getMothership: () => getLazyMothership('dialogs', lazyDialogMothership)
            },
            renderUI
        };
    };

    const toValidValues = (values) => {
        const errors = [];
        const result = {};
        each(values, (value, name) => {
            value.fold(() => {
                errors.push(name);
            }, (v) => {
                result[name] = v;
            });
        });
        return errors.length > 0 ? Result.error(errors) :
            Result.value(result);
    };

    const renderBodyPanel = (spec, dialogData, backstage, getCompByName) => {
        const memForm = record(Form.sketch((parts) => ({
            dom: {
                tag: 'div',
                classes: ['tox-form'].concat(spec.classes)
            },
            // All of the items passed through the form need to be put through the interpreter
            // with their form part preserved.
            components: map$2(spec.items, (item) => interpretInForm(parts, item, dialogData, backstage, getCompByName))
        })));
        return {
            dom: {
                tag: 'div',
                classes: ['tox-dialog__body']
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-dialog__body-content']
                    },
                    components: [
                        memForm.asSpec()
                    ]
                }
            ],
            behaviours: derive$1([
                Keying.config({
                    mode: 'acyclic',
                    useTabstopAt: not(isPseudoStop)
                }),
                ComposingConfigs.memento(memForm),
                memento(memForm, {
                    postprocess: (formValue) => toValidValues(formValue).fold((err) => {
                        // eslint-disable-next-line no-console
                        console.error(err);
                        return {};
                    }, identity)
                }),
                config('dialog-body-panel', [
                    // TINY-10101: This is to cater for the case where clicks are made into the dialog instead using keyboard navigation, as FocusShifted would not be triggered in that case.
                    run$1(focusin(), (comp, se) => {
                        comp.getSystem().broadcastOn([dialogFocusShiftedChannel], {
                            newFocus: Optional.some(se.event.target)
                        });
                    }),
                ])
            ])
        };
    };

    const measureHeights = (allTabs, tabview, tabviewComp) => map$2(allTabs, (_tab, i) => {
        Replacing.set(tabviewComp, allTabs[i].view());
        const rect = tabview.dom.getBoundingClientRect();
        Replacing.set(tabviewComp, []);
        return rect.height;
    });
    const getMaxHeight = (heights) => head(sort(heights, (a, b) => {
        if (a > b) {
            return -1;
        }
        else if (a < b) {
            return +1;
        }
        else {
            return 0;
        }
    }));
    const getMaxTabviewHeight = (dialog, tabview, tablist) => {
        const documentElement$1 = documentElement(dialog).dom;
        const rootElm = ancestor$1(dialog, '.tox-dialog-wrap').getOr(dialog);
        const isFixed = get$e(rootElm, 'position') === 'fixed';
        // Get the document or window/viewport height
        let maxHeight;
        if (isFixed) {
            maxHeight = Math.max(documentElement$1.clientHeight, window.innerHeight);
        }
        else {
            maxHeight = Math.max(documentElement$1.offsetHeight, documentElement$1.scrollHeight);
        }
        // Determine the current height taken up by the tabview panel
        const tabviewHeight = get$d(tabview);
        const isTabListBeside = tabview.dom.offsetLeft >= tablist.dom.offsetLeft + get$c(tablist);
        const currentTabHeight = isTabListBeside ? Math.max(get$d(tablist), tabviewHeight) : tabviewHeight;
        // Get the dialog height, making sure to account for any margins on the dialog
        const dialogTopMargin = parseInt(get$e(dialog, 'margin-top'), 10) || 0;
        const dialogBottomMargin = parseInt(get$e(dialog, 'margin-bottom'), 10) || 0;
        const dialogHeight = get$d(dialog) + dialogTopMargin + dialogBottomMargin;
        const chromeHeight = dialogHeight - currentTabHeight;
        return maxHeight - chromeHeight;
    };
    const showTab = (allTabs, comp) => {
        head(allTabs).each((tab) => TabSection.showTab(comp, tab.value));
    };
    const setTabviewHeight = (tabview, height) => {
        // Set both height and flex-basis as some browsers don't support flex-basis.
        set$7(tabview, 'height', height + 'px');
        set$7(tabview, 'flex-basis', height + 'px');
    };
    const updateTabviewHeight = (dialogBody, tabview, maxTabHeight) => {
        ancestor$1(dialogBody, '[role="dialog"]').each((dialog) => {
            descendant(dialog, '[role="tablist"]').each((tablist) => {
                maxTabHeight.get().map((height) => {
                    // Set the tab view height to 0, so we can calculate the max tabview height, without worrying about overflows
                    set$7(tabview, 'height', '0');
                    set$7(tabview, 'flex-basis', '0');
                    return Math.min(height, getMaxTabviewHeight(dialog, tabview, tablist));
                }).each((height) => {
                    setTabviewHeight(tabview, height);
                });
            });
        });
    };
    const getTabview = (dialog) => descendant(dialog, '[role="tabpanel"]');
    const smartMode = (allTabs) => {
        const maxTabHeight = value$2();
        const extraEvents = [
            runOnAttached((comp) => {
                const dialog = comp.element;
                getTabview(dialog).each((tabview) => {
                    set$7(tabview, 'visibility', 'hidden');
                    // Determine the maximum heights of each tab
                    comp.getSystem().getByDom(tabview).toOptional().each((tabviewComp) => {
                        const heights = measureHeights(allTabs, tabview, tabviewComp);
                        // Calculate the maximum tab height and store it
                        const maxTabHeightOpt = getMaxHeight(heights);
                        maxTabHeightOpt.fold(maxTabHeight.clear, maxTabHeight.set);
                    });
                    // Set an initial height, based on the current size
                    updateTabviewHeight(dialog, tabview, maxTabHeight);
                    // Show the tabs
                    remove$6(tabview, 'visibility');
                    showTab(allTabs, comp);
                    // Use a delay here and recalculate the height, as we need all the components attached
                    // to be able to properly calculate the max height
                    requestAnimationFrame(() => {
                        updateTabviewHeight(dialog, tabview, maxTabHeight);
                    });
                });
            }),
            run$1(windowResize(), (comp) => {
                const dialog = comp.element;
                getTabview(dialog).each((tabview) => {
                    updateTabviewHeight(dialog, tabview, maxTabHeight);
                });
            }),
            run$1(formResizeEvent, (comp, _se) => {
                const dialog = comp.element;
                getTabview(dialog).each((tabview) => {
                    const oldFocus = active$1(getRootNode(tabview));
                    set$7(tabview, 'visibility', 'hidden');
                    const oldHeight = getRaw(tabview, 'height').map((h) => parseInt(h, 10));
                    remove$6(tabview, 'height');
                    remove$6(tabview, 'flex-basis');
                    const newHeight = tabview.dom.getBoundingClientRect().height;
                    const hasGrown = oldHeight.forall((h) => newHeight > h);
                    if (hasGrown) {
                        maxTabHeight.set(newHeight);
                        updateTabviewHeight(dialog, tabview, maxTabHeight);
                    }
                    else {
                        oldHeight.each((h) => {
                            setTabviewHeight(tabview, h);
                        });
                    }
                    remove$6(tabview, 'visibility');
                    oldFocus.each(focus$4);
                });
            })
        ];
        const selectFirst = false;
        return {
            extraEvents,
            selectFirst
        };
    };

    const SendDataToSectionChannel = 'send-data-to-section';
    const SendDataToViewChannel = 'send-data-to-view';
    const renderTabPanel = (spec, dialogData, backstage, getCompByName) => {
        const storedValue = Cell({});
        const updateDataWithForm = (form) => {
            const formData = Representing.getValue(form);
            const validData = toValidValues(formData).getOr({});
            const currentData = storedValue.get();
            const newData = deepMerge(currentData, validData);
            storedValue.set(newData);
        };
        const setDataOnForm = (form) => {
            const tabData = storedValue.get();
            Representing.setValue(form, tabData);
        };
        const oldTab = Cell(null);
        const allTabs = map$2(spec.tabs, (tab) => {
            return {
                value: tab.name,
                dom: {
                    tag: 'div',
                    classes: ['tox-dialog__body-nav-item']
                },
                components: [
                    text$2(backstage.shared.providers.translate(tab.title))
                ],
                view: () => {
                    return [
                        // Dupe with SilverDialog
                        Form.sketch((parts) => ({
                            dom: {
                                tag: 'div',
                                classes: ['tox-form']
                            },
                            components: map$2(tab.items, (item) => interpretInForm(parts, item, dialogData, backstage, getCompByName)),
                            formBehaviours: derive$1([
                                Keying.config({
                                    mode: 'acyclic',
                                    useTabstopAt: not(isPseudoStop)
                                }),
                                config('TabView.form.events', [
                                    runOnAttached(setDataOnForm),
                                    runOnDetached(updateDataWithForm)
                                ]),
                                Receiving.config({
                                    channels: wrapAll([
                                        {
                                            key: SendDataToSectionChannel,
                                            value: {
                                                onReceive: updateDataWithForm
                                            }
                                        },
                                        {
                                            key: SendDataToViewChannel,
                                            value: {
                                                onReceive: setDataOnForm
                                            }
                                        }
                                    ])
                                })
                            ])
                        }))
                    ];
                }
            };
        });
        // Assign fixed height or variable height to the tabs
        const tabMode = smartMode(allTabs);
        return TabSection.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-dialog__body']
            },
            onChangeTab: (section, button, _viewItems) => {
                const name = Representing.getValue(button);
                emitWith(section, formTabChangeEvent, {
                    name,
                    oldName: oldTab.get()
                });
                oldTab.set(name);
            },
            tabs: allTabs,
            components: [
                TabSection.parts.tabbar({
                    dom: {
                        tag: 'div',
                        classes: ['tox-dialog__body-nav']
                    },
                    components: [
                        Tabbar.parts.tabs({})
                    ],
                    markers: {
                        tabClass: 'tox-tab',
                        selectedClass: 'tox-dialog__body-nav-item--active'
                    },
                    tabbarBehaviours: derive$1([
                        Tabstopping.config({})
                    ])
                }),
                TabSection.parts.tabview({
                    dom: {
                        tag: 'div',
                        classes: ['tox-dialog__body-content']
                    }
                })
            ],
            selectFirst: tabMode.selectFirst,
            tabSectionBehaviours: derive$1([
                config('tabpanel', tabMode.extraEvents),
                Keying.config({
                    mode: 'acyclic'
                }),
                // INVESTIGATE: Is this necessary? Probably used by getCompByName.
                Composing.config({
                    // TODO: Think about this
                    find: (comp) => head(TabSection.getViewItems(comp))
                }),
                withComp(Optional.none(), (tsection) => {
                    // NOTE: Assumes synchronous updating of store.
                    tsection.getSystem().broadcastOn([SendDataToSectionChannel], {});
                    return storedValue.get();
                }, (tsection, value) => {
                    storedValue.set(value);
                    tsection.getSystem().broadcastOn([SendDataToViewChannel], {});
                })
            ])
        });
    };

    // ariaAttrs is being passed through to silver inline dialog
    // from the WindowManager as a property of 'params'
    const renderBody = (spec, dialogId, contentId, backstage, ariaAttrs, getCompByName) => {
        const renderComponents = (incoming) => {
            const body = incoming.body;
            switch (body.type) {
                case 'tabpanel': {
                    return [
                        renderTabPanel(body, incoming.initialData, backstage, getCompByName)
                    ];
                }
                default: {
                    return [
                        renderBodyPanel(body, incoming.initialData, backstage, getCompByName)
                    ];
                }
            }
        };
        const updateState = (_comp, incoming) => Optional.some({
            isTabPanel: () => incoming.body.type === 'tabpanel'
        });
        const ariaAttributes = {
            'aria-live': 'polite'
        };
        return {
            dom: {
                tag: 'div',
                classes: ['tox-dialog__content-js'],
                attributes: {
                    ...contentId.map((x) => ({ id: x })).getOr({}),
                    ...ariaAttrs ? ariaAttributes : {}
                }
            },
            components: [],
            behaviours: derive$1([
                ComposingConfigs.childAt(0),
                Reflecting.config({
                    channel: `${bodyChannel}-${dialogId}`,
                    updateState,
                    renderComponents,
                    initialData: spec
                })
            ])
        };
    };
    const renderInlineBody = (spec, dialogId, contentId, backstage, ariaAttrs, getCompByName) => renderBody(spec, dialogId, Optional.some(contentId), backstage, ariaAttrs, getCompByName);
    const renderModalBody = (spec, dialogId, backstage, getCompByName) => {
        const bodySpec = renderBody(spec, dialogId, Optional.none(), backstage, false, getCompByName);
        return ModalDialog.parts.body(bodySpec);
    };
    const renderIframeBody = (spec) => {
        const bodySpec = {
            dom: {
                tag: 'div',
                classes: ['tox-dialog__content-js']
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: ['tox-dialog__body-iframe']
                    },
                    components: [
                        craft(Optional.none(), {
                            dom: {
                                tag: 'iframe',
                                attributes: {
                                    src: spec.url
                                }
                            },
                            behaviours: derive$1([
                                Tabstopping.config({}),
                                Focusing.config({})
                            ])
                        })
                    ]
                }
            ],
            behaviours: derive$1([
                Keying.config({
                    mode: 'acyclic',
                    useTabstopAt: not(isPseudoStop)
                })
            ])
        };
        return ModalDialog.parts.body(bodySpec);
    };

    const isTouch = global$7.deviceType.isTouch();
    const hiddenHeader = (title, close) => ({
        dom: {
            tag: 'div',
            styles: { display: 'none' },
            classes: ['tox-dialog__header']
        },
        components: [
            title,
            close
        ]
    });
    const pClose = (onClose, providersBackstage) => ModalDialog.parts.close(
    // Need to find a way to make it clear in the docs whether parts can be sketches
    Button.sketch({
        dom: {
            tag: 'button',
            classes: ['tox-button', 'tox-button--icon', 'tox-button--naked'],
            attributes: {
                'type': 'button',
                'aria-label': providersBackstage.translate('Close')
            }
        },
        action: onClose,
        buttonBehaviours: derive$1([
            Tabstopping.config({})
        ])
    }));
    const pUntitled = () => ModalDialog.parts.title({
        dom: {
            tag: 'div',
            classes: ['tox-dialog__title'],
            innerHtml: '',
            styles: {
                display: 'none'
            }
        }
    });
    const pBodyMessage = (message, providersBackstage) => ModalDialog.parts.body({
        dom: {
            tag: 'div',
            classes: ['tox-dialog__body']
        },
        components: [
            {
                dom: {
                    tag: 'div',
                    classes: ['tox-dialog__body-content']
                },
                components: [
                    {
                        dom: fromHtml(`<p>${sanitizeHtmlString(providersBackstage.translate(message))}</p>`)
                    }
                ]
            }
        ]
    });
    const pFooter = (buttons) => ModalDialog.parts.footer({
        dom: {
            tag: 'div',
            classes: ['tox-dialog__footer']
        },
        components: buttons
    });
    const pFooterGroup = (startButtons, endButtons) => [
        Container.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-dialog__footer-start']
            },
            components: startButtons
        }),
        Container.sketch({
            dom: {
                tag: 'div',
                classes: ['tox-dialog__footer-end']
            },
            components: endButtons
        })
    ];
    const renderDialog$1 = (spec) => {
        const dialogClass = 'tox-dialog';
        const blockerClass = dialogClass + '-wrap';
        const blockerBackdropClass = blockerClass + '__backdrop';
        const scrollLockClass = dialogClass + '__disable-scroll';
        return ModalDialog.sketch({
            lazySink: spec.lazySink,
            onEscape: (comp) => {
                spec.onEscape(comp);
                // TODO: Make a strong type for Handled KeyEvent
                return Optional.some(true);
            },
            useTabstopAt: (elem) => !isPseudoStop(elem),
            firstTabstop: spec.firstTabstop,
            dom: {
                tag: 'div',
                classes: [dialogClass].concat(spec.extraClasses),
                styles: {
                    position: 'relative',
                    ...spec.extraStyles
                }
            },
            components: [
                spec.header,
                spec.body,
                ...spec.footer.toArray()
            ],
            parts: {
                blocker: {
                    dom: fromHtml(`<div class="${blockerClass}"></div>`),
                    components: [
                        {
                            dom: {
                                tag: 'div',
                                classes: (isTouch ? [blockerBackdropClass, blockerBackdropClass + '--opaque'] : [blockerBackdropClass])
                            }
                        }
                    ]
                }
            },
            dragBlockClass: blockerClass,
            modalBehaviours: derive$1([
                Focusing.config({}),
                config('dialog-events', spec.dialogEvents.concat([
                    // Note: `runOnSource` here will only listen to the event at the outer component level.
                    // Using just `run` instead will cause an infinite loop as `focusIn` would fire a `focusin` which would then get responded to and so forth.
                    runOnSource(focusin(), (comp, _se) => {
                        Blocking.isBlocked(comp) ? noop() : Keying.focusIn(comp);
                    }),
                    run$1(focusShifted(), (comp, se) => {
                        comp.getSystem().broadcastOn([dialogFocusShiftedChannel], {
                            newFocus: se.event.newFocus
                        });
                    })
                ])),
                config('scroll-lock', [
                    runOnAttached(() => {
                        add$2(body(), scrollLockClass);
                    }),
                    runOnDetached(() => {
                        remove$3(body(), scrollLockClass);
                    })
                ]),
                ...spec.extraBehaviours
            ]),
            eventOrder: {
                [execute$5()]: ['dialog-events'],
                [attachedToDom()]: ['scroll-lock', 'dialog-events', 'alloy.base.behaviour'],
                [detachedFromDom()]: ['alloy.base.behaviour', 'dialog-events', 'scroll-lock'],
                ...spec.eventOrder
            }
        });
    };

    const renderClose = (providersBackstage) => Button.sketch({
        dom: {
            tag: 'button',
            classes: ['tox-button', 'tox-button--icon', 'tox-button--naked'],
            attributes: {
                'type': 'button',
                'aria-label': providersBackstage.translate('Close'),
                'data-mce-name': 'close'
            }
        },
        buttonBehaviours: derive$1([
            Tabstopping.config({}),
            Tooltipping.config(providersBackstage.tooltips.getConfig({
                tooltipText: providersBackstage.translate('Close')
            }))
        ]),
        components: [
            render$4('close', { tag: 'span', classes: ['tox-icon'] }, providersBackstage.icons)
        ],
        action: (comp) => {
            emit(comp, formCancelEvent);
        },
    });
    const renderTitle = (spec, dialogId, titleId, providersBackstage) => {
        const renderComponents = (data) => [text$2(providersBackstage.translate(data.title))];
        return {
            dom: {
                tag: 'h1',
                classes: ['tox-dialog__title'],
                attributes: {
                    ...titleId.map((x) => ({ id: x })).getOr({})
                }
            },
            components: [],
            behaviours: derive$1([
                Reflecting.config({
                    channel: `${titleChannel}-${dialogId}`,
                    initialData: spec,
                    renderComponents
                })
            ])
        };
    };
    const renderDragHandle = () => ({
        dom: fromHtml('<div class="tox-dialog__draghandle"></div>')
    });
    const renderInlineHeader = (spec, dialogId, titleId, providersBackstage) => Container.sketch({
        dom: fromHtml('<div class="tox-dialog__header"></div>'),
        components: [
            renderTitle(spec, dialogId, Optional.some(titleId), providersBackstage),
            renderDragHandle(),
            renderClose(providersBackstage)
        ],
        containerBehaviours: derive$1([
            Dragging.config({
                mode: 'mouse',
                blockerClass: 'blocker',
                getTarget: (handle) => {
                    return closest$3(handle, '[role="dialog"]').getOrDie();
                },
                snaps: {
                    getSnapPoints: () => [],
                    leftAttr: 'data-drag-left',
                    topAttr: 'data-drag-top'
                },
                onDrag: (comp, target) => {
                    comp.getSystem().broadcastOn([repositionPopups()], { target });
                }
            })
        ])
    });
    const renderModalHeader = (spec, dialogId, providersBackstage) => {
        const pTitle = ModalDialog.parts.title(renderTitle(spec, dialogId, Optional.none(), providersBackstage));
        const pHandle = ModalDialog.parts.draghandle(renderDragHandle());
        const pClose = ModalDialog.parts.close(renderClose(providersBackstage));
        const components = [pTitle].concat(spec.draggable ? [pHandle] : []).concat([pClose]);
        return Container.sketch({
            dom: fromHtml('<div class="tox-dialog__header"></div>'),
            components
        });
    };

    const getHeader = (title, dialogId, backstage) => renderModalHeader({
        title: backstage.shared.providers.translate(title),
        draggable: backstage.dialog.isDraggableModal()
    }, dialogId, backstage.shared.providers);
    const getBusySpec = (message, bs, providers, headerHeight) => ({
        dom: {
            tag: 'div',
            classes: ['tox-dialog__busy-spinner'],
            attributes: {
                'aria-label': providers.translate(message)
            },
            styles: {
                left: '0px',
                right: '0px',
                bottom: '0px',
                top: `${headerHeight.getOr(0)}px`,
                position: 'absolute'
            }
        },
        behaviours: bs,
        components: [{
                dom: fromHtml('<div class="tox-spinner"><div></div><div></div><div></div></div>')
            }]
    });
    const getEventExtras = (lazyDialog, providers, extra) => ({
        onClose: () => extra.closeWindow(),
        onBlock: (blockEvent) => {
            const headerHeight = descendant(lazyDialog().element, '.tox-dialog__header').map((header) => get$d(header));
            ModalDialog.setBusy(lazyDialog(), (_comp, bs) => getBusySpec(blockEvent.message, bs, providers, headerHeight));
        },
        onUnblock: () => {
            ModalDialog.setIdle(lazyDialog());
        }
    });
    const fullscreenClass = 'tox-dialog--fullscreen';
    const largeDialogClass = 'tox-dialog--width-lg';
    const mediumDialogClass = 'tox-dialog--width-md';
    const getDialogSizeClass = (size) => {
        switch (size) {
            case 'large':
                return Optional.some(largeDialogClass);
            case 'medium':
                return Optional.some(mediumDialogClass);
            default:
                return Optional.none();
        }
    };
    const updateDialogSizeClass = (size, component) => {
        const dialogBody = SugarElement.fromDom(component.element.dom);
        if (!has(dialogBody, fullscreenClass)) {
            remove$2(dialogBody, [largeDialogClass, mediumDialogClass]);
            getDialogSizeClass(size).each((dialogSizeClass) => add$2(dialogBody, dialogSizeClass));
        }
    };
    const toggleFullscreen = (comp, currentSize) => {
        const dialogBody = SugarElement.fromDom(comp.element.dom);
        const classes = get$7(dialogBody);
        const currentSizeClass = find$5(classes, (c) => c === largeDialogClass || c === mediumDialogClass).or(getDialogSizeClass(currentSize));
        toggle$3(dialogBody, [fullscreenClass, ...currentSizeClass.toArray()]);
    };
    const renderModalDialog = (spec, dialogEvents, backstage) => build$1(renderDialog$1({
        ...spec,
        firstTabstop: 1,
        lazySink: backstage.shared.getSink,
        extraBehaviours: [
            memory({}),
            ...spec.extraBehaviours
        ],
        onEscape: (comp) => {
            emit(comp, formCancelEvent);
        },
        dialogEvents,
        eventOrder: {
            [receive()]: [Reflecting.name(), Receiving.name()],
            [attachedToDom()]: ['scroll-lock', Reflecting.name(), 'messages', 'dialog-events', 'alloy.base.behaviour'],
            [detachedFromDom()]: ['alloy.base.behaviour', 'dialog-events', 'messages', Reflecting.name(), 'scroll-lock']
        }
    }));
    const mapMenuButtons = (buttons, menuItemStates = {}) => {
        const mapItems = (button) => {
            const items = map$2(button.items, (item) => {
                const cell = get$h(menuItemStates, item.name).getOr(Cell(false));
                return {
                    ...item,
                    storage: cell
                };
            });
            return {
                ...button,
                items
            };
        };
        return map$2(buttons, (button) => {
            return button.type === 'menu' ? mapItems(button) : button;
        });
    };
    const extractCellsToObject = (buttons) => foldl(buttons, (acc, button) => {
        if (button.type === 'menu') {
            const menuButton = button;
            return foldl(menuButton.items, (innerAcc, item) => {
                innerAcc[item.name] = item.storage;
                return innerAcc;
            }, acc);
        }
        return acc;
    }, {});

    const initCommonEvents = (fireApiEvent, extras) => [
        // When focus moves onto a tab-placeholder, skip to the next thing in the tab sequence
        runWithTarget(focusin(), onFocus),
        // TODO: Test if disabled first.
        fireApiEvent(formCloseEvent, (_api, spec, _event, self) => {
            // TINY-9148: Safari scrolls down to the sink if the dialog is selected before removing,
            // so we should blur the currently active element beforehand.
            if (hasFocus(self.element)) {
                active$1(getRootNode(self.element)).each(blur$1);
            }
            extras.onClose();
            spec.onClose();
        }),
        // TODO: Test if disabled first.
        fireApiEvent(formCancelEvent, (api, spec, _event, self) => {
            spec.onCancel(api);
            emit(self, formCloseEvent);
        }),
        run$1(formUnblockEvent, (_c, _se) => extras.onUnblock()),
        run$1(formBlockEvent, (_c, se) => extras.onBlock(se.event))
    ];
    const initUrlDialog = (getInstanceApi, extras) => {
        const fireApiEvent = (eventName, f) => run$1(eventName, (c, se) => {
            withSpec(c, (spec, _c) => {
                f(getInstanceApi(), spec, se.event, c);
            });
        });
        const withSpec = (c, f) => {
            Reflecting.getState(c).get().each((currentDialog) => {
                f(currentDialog, c);
            });
        };
        return [
            ...initCommonEvents(fireApiEvent, extras),
            fireApiEvent(formActionEvent, (api, spec, event) => {
                spec.onAction(api, { name: event.name });
            })
        ];
    };
    const initDialog = (getInstanceApi, extras, getSink) => {
        const fireApiEvent = (eventName, f) => run$1(eventName, (c, se) => {
            withSpec(c, (spec, _c) => {
                f(getInstanceApi(), spec, se.event, c);
            });
        });
        const withSpec = (c, f) => {
            Reflecting.getState(c).get().each((currentDialogInit) => {
                f(currentDialogInit.internalDialog, c);
            });
        };
        return [
            ...initCommonEvents(fireApiEvent, extras),
            fireApiEvent(formSubmitEvent, (api, spec) => spec.onSubmit(api)),
            fireApiEvent(formChangeEvent, (api, spec, event) => {
                spec.onChange(api, { name: event.name });
            }),
            fireApiEvent(formActionEvent, (api, spec, event, component) => {
                // TODO: add a test for focusIn (TINY-10125)
                const focusIn = () => component.getSystem().isConnected() ? Keying.focusIn(component) : undefined;
                const isDisabled = (focused) => has$1(focused, 'disabled') || getOpt(focused, 'aria-disabled').exists((val) => val === 'true');
                const rootNode = getRootNode(component.element);
                const current = active$1(rootNode);
                spec.onAction(api, { name: event.name, value: event.value });
                active$1(rootNode).fold(focusIn, (focused) => {
                    // We need to check if the focused element is disabled because apparently firefox likes to leave focus on disabled elements.
                    if (isDisabled(focused)) {
                        focusIn();
                        // And we need the below check for IE, which likes to leave focus on the parent of disabled elements
                    }
                    else if (current.exists((cur) => contains(focused, cur) && isDisabled(cur))) {
                        focusIn();
                        // Lastly if something outside the sink has focus then return the focus back to the dialog
                    }
                    else {
                        getSink().toOptional()
                            .filter((sink) => !contains(sink.element, focused))
                            .each(focusIn);
                    }
                });
            }),
            fireApiEvent(formTabChangeEvent, (api, spec, event) => {
                spec.onTabChange(api, { newTabName: event.name, oldTabName: event.oldName });
            }),
            // When the dialog is being closed, store the current state of the form
            runOnDetached((component) => {
                const api = getInstanceApi();
                Representing.setValue(component, api.getData());
            })
        ];
    };

    const makeButton = (button, backstage) => renderFooterButton(button, button.type, backstage);
    const lookup = (compInSystem, footerButtons, buttonName) => find$5(footerButtons, (button) => button.name === buttonName)
        .bind((memButton) => memButton.memento.getOpt(compInSystem));
    const renderComponents = (_data, state) => {
        // default group is 'end'
        const footerButtons = state.map((s) => s.footerButtons).getOr([]);
        const buttonGroups = partition$3(footerButtons, (button) => button.align === 'start');
        const makeGroup = (edge, buttons) => Container.sketch({
            dom: {
                tag: 'div',
                classes: [`tox-dialog__footer-${edge}`]
            },
            components: map$2(buttons, (button) => button.memento.asSpec())
        });
        const startButtons = makeGroup('start', buttonGroups.pass);
        const endButtons = makeGroup('end', buttonGroups.fail);
        return [startButtons, endButtons];
    };
    const renderFooter = (initSpec, dialogId, backstage) => {
        const updateState = (comp, data) => {
            const footerButtons = map$2(data.buttons, (button) => {
                const memButton = record(makeButton(button, backstage));
                return {
                    name: button.name,
                    align: button.align,
                    memento: memButton
                };
            });
            const lookupByName = (buttonName) => lookup(comp, footerButtons, buttonName);
            return Optional.some({
                lookupByName,
                footerButtons
            });
        };
        return {
            dom: fromHtml('<div class="tox-dialog__footer"></div>'),
            components: [],
            behaviours: derive$1([
                Reflecting.config({
                    channel: `${footerChannel}-${dialogId}`,
                    initialData: initSpec,
                    updateState,
                    renderComponents
                })
            ])
        };
    };
    const renderInlineFooter = (initSpec, dialogId, backstage) => renderFooter(initSpec, dialogId, backstage);
    const renderModalFooter = (initSpec, dialogId, backstage) => ModalDialog.parts.footer(renderFooter(initSpec, dialogId, backstage));

    const getCompByName = (access, name) => {
        // TODO: Add API to alloy to find the inner most component of a Composing chain.
        const root = access.getRoot();
        // This is just to avoid throwing errors if the dialog closes before this. We should take it out
        // while developing (probably), and put it back in for the real thing.
        if (root.getSystem().isConnected()) {
            const form = Composing.getCurrent(access.getFormWrapper()).getOr(access.getFormWrapper());
            return Form.getField(form, name).orThunk(() => {
                const footer = access.getFooter();
                const footerState = footer.bind((f) => Reflecting.getState(f).get());
                return footerState.bind((f) => f.lookupByName(name));
            });
        }
        else {
            return Optional.none();
        }
    };
    const validateData$1 = (access, data) => {
        const root = access.getRoot();
        return Reflecting.getState(root).get().map((dialogState) => getOrDie(asRaw('data', dialogState.dataValidator, data))).getOr(data);
    };
    const getDialogApi = (access, doRedial, menuItemStates) => {
        const withRoot = (f) => {
            const root = access.getRoot();
            if (root.getSystem().isConnected()) {
                f(root);
            }
        };
        const getData = () => {
            const root = access.getRoot();
            const valueComp = root.getSystem().isConnected() ? access.getFormWrapper() : root;
            const representedValues = Representing.getValue(valueComp);
            const menuItemCurrentState = map$1(menuItemStates, (cell) => cell.get());
            return {
                ...representedValues,
                ...menuItemCurrentState
            };
        };
        const setData = (newData) => {
            // Currently, the decision is to ignore setData calls that fire after the dialog is closed
            withRoot((_) => {
                const prevData = instanceApi.getData();
                const mergedData = deepMerge(prevData, newData);
                const newInternalData = validateData$1(access, mergedData);
                const form = access.getFormWrapper();
                Representing.setValue(form, newInternalData);
                each(menuItemStates, (v, k) => {
                    if (has$2(mergedData, k)) {
                        v.set(mergedData[k]);
                    }
                });
            });
        };
        const setEnabled = (name, state) => {
            getCompByName(access, name).each(state ? Disabling.enable : Disabling.disable);
        };
        const focus = (name) => {
            getCompByName(access, name).each(Focusing.focus);
        };
        const block = (message) => {
            if (!isString(message)) {
                throw new Error('The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument');
            }
            withRoot((root) => {
                emitWith(root, formBlockEvent, { message });
            });
        };
        const unblock = () => {
            withRoot((root) => {
                emit(root, formUnblockEvent);
            });
        };
        const showTab = (name) => {
            withRoot((_) => {
                const body = access.getBody();
                const bodyState = Reflecting.getState(body);
                if (bodyState.get().exists((b) => b.isTabPanel())) {
                    Composing.getCurrent(body).each((tabSection) => {
                        TabSection.showTab(tabSection, name);
                    });
                }
            });
        };
        const redial = (d) => {
            withRoot((root) => {
                const id = access.getId();
                const dialogInit = doRedial(d);
                const storedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons, menuItemStates);
                // TINY-9223: We only need to broadcast to the mothership containing the dialog
                root.getSystem().broadcastOn([`${dialogChannel}-${id}`], dialogInit);
                // NOTE: Reflecting does not have any smart handling of nested reflecting components,
                // and the order of receiving a broadcast is non-deterministic. Here we use separate
                // channels for each section (title, body, footer), and make those broadcasts *after*
                // we've already sent the overall dialog broadcast. The overall dialog broadcast
                // doesn't actually change the components ... its Reflecting config just stores state,
                // but these Reflecting configs (title, body, footer) do change the components based on
                // the received broadcasts.
                root.getSystem().broadcastOn([`${titleChannel}-${id}`], dialogInit.internalDialog);
                root.getSystem().broadcastOn([`${bodyChannel}-${id}`], dialogInit.internalDialog);
                root.getSystem().broadcastOn([`${footerChannel}-${id}`], {
                    ...dialogInit.internalDialog,
                    buttons: storedMenuButtons
                });
                instanceApi.setData(dialogInit.initialData);
            });
        };
        const close = () => {
            withRoot((root) => {
                emit(root, formCloseEvent);
            });
        };
        const instanceApi = {
            getData,
            setData,
            setEnabled,
            focus,
            block,
            unblock,
            showTab,
            redial,
            close,
            toggleFullscreen: access.toggleFullscreen
        };
        return instanceApi;
    };

    const renderDialog = (dialogInit, extra, backstage) => {
        const dialogId = generate$6('dialog');
        const internalDialog = dialogInit.internalDialog;
        const header = getHeader(internalDialog.title, dialogId, backstage);
        const dialogSize = Cell(internalDialog.size);
        const getCompByName$1 = (name) => getCompByName(modalAccess, name);
        const dialogSizeClasses = getDialogSizeClass(dialogSize.get()).toArray();
        const updateState = (comp, incoming) => {
            dialogSize.set(incoming.internalDialog.size);
            updateDialogSizeClass(incoming.internalDialog.size, comp);
            return Optional.some(incoming);
        };
        const body = renderModalBody({
            body: internalDialog.body,
            initialData: internalDialog.initialData
        }, dialogId, backstage, getCompByName$1);
        const storedMenuButtons = mapMenuButtons(internalDialog.buttons);
        const objOfCells = extractCellsToObject(storedMenuButtons);
        const footer = someIf(storedMenuButtons.length !== 0, renderModalFooter({ buttons: storedMenuButtons }, dialogId, backstage));
        const dialogEvents = initDialog(() => instanceApi, getEventExtras(() => dialog, backstage.shared.providers, extra), backstage.shared.getSink);
        const spec = {
            id: dialogId,
            header,
            body,
            footer,
            extraClasses: dialogSizeClasses,
            extraBehaviours: [
                Reflecting.config({
                    channel: `${dialogChannel}-${dialogId}`,
                    updateState,
                    initialData: dialogInit
                }),
            ],
            extraStyles: {}
        };
        const dialog = renderModalDialog(spec, dialogEvents, backstage);
        const modalAccess = (() => {
            const getForm = () => {
                const outerForm = ModalDialog.getBody(dialog);
                return Composing.getCurrent(outerForm).getOr(outerForm);
            };
            const toggleFullscreen$1 = () => {
                toggleFullscreen(dialog, dialogSize.get());
            };
            return {
                getId: constant$1(dialogId),
                getRoot: constant$1(dialog),
                getBody: () => ModalDialog.getBody(dialog),
                getFooter: () => ModalDialog.getFooter(dialog),
                getFormWrapper: getForm,
                toggleFullscreen: toggleFullscreen$1
            };
        })();
        // TODO: Get the validator from the dialog state.
        const instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);
        return {
            dialog,
            instanceApi
        };
    };

    // DUPE with SilverDialog. Cleaning up.
    const renderInlineDialog = (dialogInit, extra, backstage, ariaAttrs = false, refreshDocking) => {
        const dialogId = generate$6('dialog');
        const dialogLabelId = generate$6('dialog-label');
        const dialogContentId = generate$6('dialog-content');
        const internalDialog = dialogInit.internalDialog;
        const getCompByName$1 = (name) => getCompByName(modalAccess, name);
        const dialogSize = Cell(internalDialog.size);
        const dialogSizeClass = getDialogSizeClass(dialogSize.get()).toArray();
        // Reflecting behaviour broadcasts on dialog channel only on redial.
        const updateState = (comp, incoming) => {
            // Update dialog size and position upon redial.
            dialogSize.set(incoming.internalDialog.size);
            updateDialogSizeClass(incoming.internalDialog.size, comp);
            refreshDocking();
            return Optional.some(incoming);
        };
        const memHeader = record(renderInlineHeader({
            title: internalDialog.title,
            draggable: true
        }, dialogId, dialogLabelId, backstage.shared.providers));
        const memBody = record(renderInlineBody({
            body: internalDialog.body,
            initialData: internalDialog.initialData,
        }, dialogId, dialogContentId, backstage, ariaAttrs, getCompByName$1));
        const storagedMenuButtons = mapMenuButtons(internalDialog.buttons);
        const objOfCells = extractCellsToObject(storagedMenuButtons);
        const optMemFooter = someIf(storagedMenuButtons.length !== 0, record(renderInlineFooter({
            buttons: storagedMenuButtons
        }, dialogId, backstage)));
        const dialogEvents = initDialog(() => instanceApi, {
            onBlock: (event) => {
                Blocking.block(dialog, (_comp, bs) => {
                    const headerHeight = memHeader.getOpt(dialog).map((dialog) => get$d(dialog.element));
                    return getBusySpec(event.message, bs, backstage.shared.providers, headerHeight);
                });
            },
            onUnblock: () => {
                Blocking.unblock(dialog);
            },
            onClose: () => extra.closeWindow()
        }, backstage.shared.getSink);
        const inlineClass = 'tox-dialog-inline';
        const os = detect$1().os;
        // TODO: Disable while validating?
        const dialog = build$1({
            dom: {
                tag: 'div',
                classes: ['tox-dialog', inlineClass, ...dialogSizeClass],
                attributes: {
                    role: 'dialog',
                    // TINY-10808 - Workaround to address the dialog header not being announced on VoiceOver with aria-labelledby, ideally we should use the aria-labelledby
                    ...os.isMacOS() ? { 'aria-label': internalDialog.title } : { 'aria-labelledby': dialogLabelId }
                }
            },
            eventOrder: {
                [receive()]: [Reflecting.name(), Receiving.name()],
                [execute$5()]: ['execute-on-form'],
                [attachedToDom()]: ['reflecting', 'execute-on-form']
            },
            // Dupe with SilverDialog.
            behaviours: derive$1([
                Keying.config({
                    mode: 'cyclic',
                    onEscape: (c) => {
                        emit(c, formCloseEvent);
                        return Optional.some(true);
                    },
                    useTabstopAt: (elem) => !isPseudoStop(elem) && (name$3(elem) !== 'button' || get$g(elem, 'disabled') !== 'disabled'),
                    firstTabstop: 1
                }),
                Reflecting.config({
                    channel: `${dialogChannel}-${dialogId}`,
                    updateState,
                    initialData: dialogInit
                }),
                Focusing.config({}),
                config('execute-on-form', dialogEvents.concat([
                    // Note: `runOnSource` here will only listen to the event at the outer component level.
                    // Using just `run` instead will cause an infinite loop as `focusIn` would fire a `focusin` which would then get responded to and so forth.
                    runOnSource(focusin(), (comp, _se) => {
                        Keying.focusIn(comp);
                    }),
                    run$1(focusShifted(), (comp, se) => {
                        comp.getSystem().broadcastOn([dialogFocusShiftedChannel], {
                            newFocus: se.event.newFocus
                        });
                    })
                ])),
                Blocking.config({ getRoot: () => Optional.some(dialog) }),
                Replacing.config({}),
                memory({})
            ]),
            components: [
                memHeader.asSpec(),
                memBody.asSpec(),
                ...optMemFooter.map((memFooter) => memFooter.asSpec()).toArray()
            ]
        });
        const toggleFullscreen$1 = () => {
            toggleFullscreen(dialog, dialogSize.get());
        };
        // TODO: Clean up the dupe between this (InlineDialog) and SilverDialog
        const modalAccess = {
            getId: constant$1(dialogId),
            getRoot: constant$1(dialog),
            getFooter: () => optMemFooter.map((memFooter) => memFooter.get(dialog)),
            getBody: () => memBody.get(dialog),
            getFormWrapper: () => {
                const body = memBody.get(dialog);
                return Composing.getCurrent(body).getOr(body);
            },
            toggleFullscreen: toggleFullscreen$1
        };
        const instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);
        return {
            dialog,
            instanceApi
        };
    };

    var global = tinymce.util.Tools.resolve('tinymce.util.URI');

    const getUrlDialogApi = (root) => {
        const withRoot = (f) => {
            if (root.getSystem().isConnected()) {
                f(root);
            }
        };
        const block = (message) => {
            if (!isString(message)) {
                throw new Error('The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument');
            }
            withRoot((root) => {
                emitWith(root, formBlockEvent, { message });
            });
        };
        const unblock = () => {
            withRoot((root) => {
                emit(root, formUnblockEvent);
            });
        };
        const close = () => {
            withRoot((root) => {
                emit(root, formCloseEvent);
            });
        };
        const sendMessage = (data) => {
            withRoot((root) => {
                root.getSystem().broadcastOn([bodySendMessageChannel], data);
            });
        };
        return {
            block,
            unblock,
            close,
            sendMessage
        };
    };

    // A list of supported message actions
    const SUPPORTED_MESSAGE_ACTIONS = ['insertContent', 'setContent', 'execCommand', 'close', 'block', 'unblock'];
    const isSupportedMessage = (data) => isObject(data) && SUPPORTED_MESSAGE_ACTIONS.indexOf(data.mceAction) !== -1;
    const isCustomMessage = (data) => !isSupportedMessage(data) && isObject(data) && has$2(data, 'mceAction');
    const handleMessage = (editor, api, data) => {
        switch (data.mceAction) {
            case 'insertContent':
                editor.insertContent(data.content);
                break;
            case 'setContent':
                editor.setContent(data.content);
                break;
            case 'execCommand':
                const ui = isBoolean(data.ui) ? data.ui : false;
                editor.execCommand(data.cmd, ui, data.value);
                break;
            case 'close':
                api.close();
                break;
            case 'block':
                api.block(data.message);
                break;
            case 'unblock':
                api.unblock();
                break;
        }
    };
    const renderUrlDialog = (internalDialog, extra, editor, backstage) => {
        const dialogId = generate$6('dialog');
        const header = getHeader(internalDialog.title, dialogId, backstage);
        const body = renderIframeBody(internalDialog);
        const footer = internalDialog.buttons.bind((buttons) => {
            // Don't render a footer if no buttons are specified
            if (buttons.length === 0) {
                return Optional.none();
            }
            else {
                return Optional.some(renderModalFooter({ buttons }, dialogId, backstage));
            }
        });
        const dialogEvents = initUrlDialog(() => instanceApi, getEventExtras(() => dialog, backstage.shared.providers, extra));
        // Add the styles for the modal width/height
        const styles = {
            ...internalDialog.height.fold(() => ({}), (height) => ({ 'height': height + 'px', 'max-height': height + 'px' })),
            ...internalDialog.width.fold(() => ({}), (width) => ({ 'width': width + 'px', 'max-width': width + 'px' }))
        };
        // Default back to using a large sized dialog, if no dimensions are specified
        const classes = internalDialog.width.isNone() && internalDialog.height.isNone() ? ['tox-dialog--width-lg'] : [];
        // Determine the iframe urls domain, so we can target that specifically when sending messages
        const iframeUri = new global(internalDialog.url, { base_uri: new global(window.location.href) });
        const iframeDomain = `${iframeUri.protocol}://${iframeUri.host}${iframeUri.port ? ':' + iframeUri.port : ''}`;
        const messageHandlerUnbinder = unbindable();
        const updateState = (_comp, incoming) => Optional.some(incoming);
        // Setup the behaviours for dealing with messages between the iframe and current window
        const extraBehaviours = [
            // Because this doesn't define `renderComponents`, all this does is update the state.
            // We use the state for the initialData. The other parts (body etc.) render the
            // components based on what reflecting receives.
            Reflecting.config({
                channel: `${dialogChannel}-${dialogId}`,
                updateState,
                initialData: internalDialog
            }),
            config('messages', [
                // When the dialog is opened, bind a window message listener for the spec url
                runOnAttached(() => {
                    const unbind = bind$1(SugarElement.fromDom(window), 'message', (e) => {
                        // Validate that the request came from the correct domain
                        if (iframeUri.isSameOrigin(new global(e.raw.origin))) {
                            const data = e.raw.data;
                            // Handle the message if it has the 'mceAction' key, otherwise just ignore it
                            if (isSupportedMessage(data)) {
                                handleMessage(editor, instanceApi, data);
                            }
                            else if (isCustomMessage(data)) {
                                internalDialog.onMessage(instanceApi, data);
                            }
                        }
                    });
                    messageHandlerUnbinder.set(unbind);
                }),
                // When the dialog is closed, unbind the window message listener
                runOnDetached(messageHandlerUnbinder.clear)
            ]),
            Receiving.config({
                channels: {
                    [bodySendMessageChannel]: {
                        onReceive: (comp, data) => {
                            // Send the message to the iframe via postMessage
                            descendant(comp.element, 'iframe').each((iframeEle) => {
                                const iframeWin = iframeEle.dom.contentWindow;
                                if (isNonNullable(iframeWin)) {
                                    iframeWin.postMessage(data, iframeDomain);
                                }
                            });
                        }
                    }
                }
            })
        ];
        const spec = {
            id: dialogId,
            header,
            body,
            footer,
            extraClasses: classes,
            extraBehaviours,
            extraStyles: styles
        };
        const dialog = renderModalDialog(spec, dialogEvents, backstage);
        const instanceApi = getUrlDialogApi(dialog);
        return {
            dialog,
            instanceApi
        };
    };

    const setup$2 = (backstage) => {
        const sharedBackstage = backstage.shared;
        const open = (message, callback) => {
            const closeDialog = () => {
                ModalDialog.hide(alertDialog);
                callback();
            };
            const memFooterClose = record(renderFooterButton({
                context: 'any',
                name: 'close-alert',
                text: 'OK',
                primary: true,
                buttonType: Optional.some('primary'),
                align: 'end',
                enabled: true,
                icon: Optional.none()
            }, 'cancel', backstage));
            const titleSpec = pUntitled();
            const closeSpec = pClose(closeDialog, sharedBackstage.providers);
            const alertDialog = build$1(renderDialog$1({
                lazySink: () => sharedBackstage.getSink(),
                header: hiddenHeader(titleSpec, closeSpec),
                body: pBodyMessage(message, sharedBackstage.providers),
                footer: Optional.some(pFooter(pFooterGroup([], [
                    memFooterClose.asSpec()
                ]))),
                onEscape: closeDialog,
                extraClasses: ['tox-alert-dialog'],
                extraBehaviours: [],
                extraStyles: {},
                dialogEvents: [
                    run$1(formCancelEvent, closeDialog)
                ],
                eventOrder: {}
            }));
            ModalDialog.show(alertDialog);
            const footerCloseButton = memFooterClose.get(alertDialog);
            Focusing.focus(footerCloseButton);
        };
        return {
            open
        };
    };

    const setup$1 = (backstage) => {
        const sharedBackstage = backstage.shared;
        // FIX: Extreme dupe with Alert dialog
        const open = (message, callback) => {
            const closeDialog = (state) => {
                ModalDialog.hide(confirmDialog);
                callback(state);
            };
            const memFooterYes = record(renderFooterButton({
                context: 'any',
                name: 'yes',
                text: 'Yes',
                primary: true,
                buttonType: Optional.some('primary'),
                align: 'end',
                enabled: true,
                icon: Optional.none()
            }, 'submit', backstage));
            const footerNo = renderFooterButton({
                context: 'any',
                name: 'no',
                text: 'No',
                primary: false,
                buttonType: Optional.some('secondary'),
                align: 'end',
                enabled: true,
                icon: Optional.none()
            }, 'cancel', backstage);
            const titleSpec = pUntitled();
            const closeSpec = pClose(() => closeDialog(false), sharedBackstage.providers);
            const confirmDialog = build$1(renderDialog$1({
                lazySink: () => sharedBackstage.getSink(),
                header: hiddenHeader(titleSpec, closeSpec),
                body: pBodyMessage(message, sharedBackstage.providers),
                footer: Optional.some(pFooter(pFooterGroup([], [
                    footerNo,
                    memFooterYes.asSpec()
                ]))),
                onEscape: () => closeDialog(false),
                extraClasses: ['tox-confirm-dialog'],
                extraBehaviours: [],
                extraStyles: {},
                dialogEvents: [
                    run$1(formCancelEvent, () => closeDialog(false)),
                    run$1(formSubmitEvent, () => closeDialog(true))
                ],
                eventOrder: {}
            }));
            ModalDialog.show(confirmDialog);
            const footerYesButton = memFooterYes.get(confirmDialog);
            Focusing.focus(footerYesButton);
        };
        return {
            open
        };
    };

    const validateData = (data, validator) => getOrDie(asRaw('data', validator, data));
    const isAlertOrConfirmDialog = (target) => closest$1(target, '.tox-alert-dialog') || closest$1(target, '.tox-confirm-dialog');
    const inlineAdditionalBehaviours = (editor, isStickyToolbar, isToolbarLocationTop, onHide) => {
        // When using sticky toolbars it already handles the docking behaviours so applying docking would
        // do nothing except add additional processing when scrolling, so we don't want to include it here
        // (Except when the toolbar is located at the bottom since the anchor will be at the top)
        if (isStickyToolbar && isToolbarLocationTop) {
            return [];
        }
        else {
            return [
                Docking.config({
                    contextual: {
                        lazyContext: () => Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer()))),
                        fadeInClass: 'tox-dialog-dock-fadein',
                        fadeOutClass: 'tox-dialog-dock-fadeout',
                        transitionClass: 'tox-dialog-dock-transition',
                        onHide
                    },
                    modes: ['top'],
                    lazyViewport: (comp) => {
                        // If we don't have a special scrolling environment, then just use the default
                        // viewport of (window)
                        const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);
                        return optScrollingContext
                            .map((sc) => {
                            const combinedBounds = getBoundsFrom(sc);
                            return {
                                bounds: combinedBounds,
                                optScrollEnv: Optional.some({
                                    currentScrollTop: sc.element.dom.scrollTop,
                                    scrollElmTop: absolute$3(sc.element).top
                                })
                            };
                        }).getOrThunk(() => ({
                            bounds: win(),
                            optScrollEnv: Optional.none()
                        }));
                    }
                })
            ];
        }
    };
    const setup = (extras) => {
        const editor = extras.editor;
        const isStickyToolbar$1 = isStickyToolbar(editor);
        // Alert and Confirm dialogs are Modal Dialogs
        const alertDialog = setup$2(extras.backstages.dialog);
        const confirmDialog = setup$1(extras.backstages.dialog);
        const open = (config, params, closeWindow) => {
            if (!isUndefined(params)) {
                if (params.inline === 'toolbar') {
                    return openInlineDialog(config, extras.backstages.popup.shared.anchors.inlineDialog(), closeWindow, params);
                }
                else if (params.inline === 'bottom') {
                    return openBottomInlineDialog(config, extras.backstages.popup.shared.anchors.inlineBottomDialog(), closeWindow, params);
                }
                else if (params.inline === 'cursor') {
                    return openInlineDialog(config, extras.backstages.popup.shared.anchors.cursor(), closeWindow, params);
                }
            }
            return openModalDialog(config, closeWindow);
        };
        const openUrl = (config, closeWindow) => openModalUrlDialog(config, closeWindow);
        const openModalUrlDialog = (config, closeWindow) => {
            const factory = (contents) => {
                const dialog = renderUrlDialog(contents, {
                    closeWindow: () => {
                        ModalDialog.hide(dialog.dialog);
                        closeWindow(dialog.instanceApi);
                    }
                }, editor, extras.backstages.dialog);
                ModalDialog.show(dialog.dialog);
                return dialog.instanceApi;
            };
            return DialogManager.openUrl(factory, config);
        };
        const openModalDialog = (config, closeWindow) => {
            const factory = (contents, internalInitialData, dataValidator) => {
                // We used to validate data here, but it's done by the instanceApi.setData call below.
                const initialData = internalInitialData;
                const dialogInit = {
                    dataValidator,
                    initialData,
                    internalDialog: contents
                };
                const dialog = renderDialog(dialogInit, {
                    redial: DialogManager.redial,
                    closeWindow: () => {
                        ModalDialog.hide(dialog.dialog);
                        closeWindow(dialog.instanceApi);
                    }
                }, extras.backstages.dialog);
                ModalDialog.show(dialog.dialog);
                dialog.instanceApi.setData(initialData);
                return dialog.instanceApi;
            };
            return DialogManager.open(factory, config);
        };
        const openInlineDialog = (config$1, anchor, closeWindow, windowParams) => {
            const factory = (contents, internalInitialData, dataValidator) => {
                const initialData = validateData(internalInitialData, dataValidator);
                const inlineDialog = value$2();
                const isToolbarLocationTop = extras.backstages.popup.shared.header.isPositionedAtTop();
                const dialogInit = {
                    dataValidator,
                    initialData,
                    internalDialog: contents
                };
                const refreshDocking = () => inlineDialog.on((dialog) => {
                    InlineView.reposition(dialog);
                    if (!isStickyToolbar$1 || !isToolbarLocationTop) {
                        Docking.refresh(dialog);
                    }
                });
                const dialogUi = renderInlineDialog(dialogInit, {
                    redial: DialogManager.redial,
                    closeWindow: () => {
                        inlineDialog.on(InlineView.hide);
                        editor.off('ResizeEditor', refreshDocking);
                        editor.off('ScrollWindow', repositionPopups$1);
                        inlineDialog.clear();
                        closeWindow(dialogUi.instanceApi);
                    }
                }, extras.backstages.popup, windowParams.ariaAttrs, refreshDocking);
                const repositionPopups$1 = () => dialogUi.dialog.getSystem().broadcastOn([repositionPopups()], { target: dialogUi.dialog.element });
                const dismissPopups$1 = () => dialogUi.dialog.getSystem().broadcastOn([dismissPopups()], { target: dialogUi.dialog.element });
                const inlineDialogComp = build$1(InlineView.sketch({
                    lazySink: extras.backstages.popup.shared.getSink,
                    dom: {
                        tag: 'div',
                        classes: []
                    },
                    // Fires the default dismiss event.
                    fireDismissalEventInstead: (windowParams.persistent ? { event: 'doNotDismissYet' } : {}),
                    // TINY-9412: The docking behaviour for inline dialogs is inconsistent
                    // for toolbar_location: bottom. We need to clarify exactly what the behaviour
                    // should be. The intent here might have been that they shouldn't automatically
                    // reposition at all because they aren't visually connected to the toolbar
                    // (i.e. inline "toolbar" dialogs still display at the top, even when the
                    // toolbar_location is bottom), but it's unclear.
                    ...isToolbarLocationTop ? {} : { fireRepositionEventInstead: {} },
                    inlineBehaviours: derive$1([
                        config('window-manager-inline-events', [
                            run$1(dismissRequested(), (_comp, _se) => {
                                emit(dialogUi.dialog, formCancelEvent);
                            })
                        ]),
                        ...inlineAdditionalBehaviours(editor, isStickyToolbar$1, isToolbarLocationTop, dismissPopups$1)
                    ]),
                    // Treat alert or confirm dialogs as part of the inline dialog
                    isExtraPart: (_comp, target) => isAlertOrConfirmDialog(target)
                }));
                inlineDialog.set(inlineDialogComp);
                const getInlineDialogBounds = () => {
                    // At the moment the inline dialog is just put anywhere in the body, and docking is what is used to make
                    // sure that it stays onscreen
                    const elem = editor.inline ? body() : SugarElement.fromDom(editor.getContainer());
                    const bounds = box$1(elem);
                    return Optional.some(bounds);
                };
                // Position the inline dialog
                InlineView.showWithinBounds(inlineDialogComp, premade(dialogUi.dialog), { anchor }, getInlineDialogBounds);
                // Refresh the docking position if not using a sticky toolbar
                if (!isStickyToolbar$1 || !isToolbarLocationTop) {
                    Docking.refresh(inlineDialogComp);
                    // Bind to the editor resize event and update docking as needed. We don't need to worry about
                    // 'ResizeWindow` as that's handled by docking already.
                    editor.on('ResizeEditor', refreshDocking);
                }
                editor.on('ScrollWindow', repositionPopups$1);
                // Set the initial data in the dialog and focus the first focusable item
                dialogUi.instanceApi.setData(initialData);
                Keying.focusIn(dialogUi.dialog);
                return dialogUi.instanceApi;
            };
            return DialogManager.open(factory, config$1);
        };
        const openBottomInlineDialog = (config$1, anchor, closeWindow, windowParams) => {
            const factory = (contents, internalInitialData, dataValidator) => {
                const initialData = validateData(internalInitialData, dataValidator);
                const inlineDialog = value$2();
                const isToolbarLocationTop = extras.backstages.popup.shared.header.isPositionedAtTop();
                const dialogInit = {
                    dataValidator,
                    initialData,
                    internalDialog: contents
                };
                const refreshDocking = () => inlineDialog.on((dialog) => {
                    InlineView.reposition(dialog);
                    Docking.refresh(dialog);
                });
                const dialogUi = renderInlineDialog(dialogInit, {
                    redial: DialogManager.redial,
                    closeWindow: () => {
                        inlineDialog.on(InlineView.hide);
                        editor.off('ResizeEditor ScrollWindow ElementScroll', refreshDocking);
                        inlineDialog.clear();
                        closeWindow(dialogUi.instanceApi);
                    }
                }, extras.backstages.popup, windowParams.ariaAttrs, refreshDocking);
                const inlineDialogComp = build$1(InlineView.sketch({
                    lazySink: extras.backstages.popup.shared.getSink,
                    dom: {
                        tag: 'div',
                        classes: []
                    },
                    // Fires the default dismiss event.
                    fireDismissalEventInstead: (windowParams.persistent ? { event: 'doNotDismissYet' } : {}),
                    ...isToolbarLocationTop ? {} : { fireRepositionEventInstead: {} },
                    inlineBehaviours: derive$1([
                        config('window-manager-inline-events', [
                            run$1(dismissRequested(), (_comp, _se) => {
                                emit(dialogUi.dialog, formCancelEvent);
                            })
                        ]),
                        Docking.config({
                            contextual: {
                                lazyContext: () => Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer()))),
                                fadeInClass: 'tox-dialog-dock-fadein',
                                fadeOutClass: 'tox-dialog-dock-fadeout',
                                transitionClass: 'tox-dialog-dock-transition'
                            },
                            modes: ['top', 'bottom'],
                            lazyViewport: (comp) => {
                                const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);
                                return optScrollingContext.map((sc) => {
                                    const combinedBounds = getBoundsFrom(sc);
                                    return {
                                        bounds: combinedBounds,
                                        optScrollEnv: Optional.some({
                                            currentScrollTop: sc.element.dom.scrollTop,
                                            scrollElmTop: absolute$3(sc.element).top
                                        })
                                    };
                                }).getOrThunk(() => ({
                                    bounds: win(),
                                    optScrollEnv: Optional.none()
                                }));
                            }
                        })
                    ]),
                    // Treat alert or confirm dialogs as part of the inline dialog
                    isExtraPart: (_comp, target) => isAlertOrConfirmDialog(target)
                }));
                inlineDialog.set(inlineDialogComp);
                const getInlineDialogBounds = () => {
                    return extras.backstages.popup.shared.getSink().toOptional().bind((s) => {
                        const optScrollingContext = detectWhenSplitUiMode(editor, s.element);
                        // Margin between element and the bottom of the screen or the editor content area container
                        const margin = 15;
                        const bounds$1 = optScrollingContext.map((sc) => getBoundsFrom(sc)).getOr(win());
                        const contentAreaContainer = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));
                        const constrainedBounds = constrain(contentAreaContainer, bounds$1);
                        return Optional.some(bounds(constrainedBounds.x, constrainedBounds.y, constrainedBounds.width, constrainedBounds.height - margin));
                    });
                };
                // Position the inline dialog
                InlineView.showWithinBounds(inlineDialogComp, premade(dialogUi.dialog), { anchor }, getInlineDialogBounds);
                Docking.refresh(inlineDialogComp);
                editor.on('ResizeEditor ScrollWindow ElementScroll ResizeWindow', refreshDocking);
                // Set the initial data in the dialog and focus the first focusable item
                dialogUi.instanceApi.setData(initialData);
                Keying.focusIn(dialogUi.dialog);
                return dialogUi.instanceApi;
            };
            return DialogManager.open(factory, config$1);
        };
        const confirm = (message, callback) => {
            confirmDialog.open(message, callback);
        };
        const alert = (message, callback) => {
            alertDialog.open(message, callback);
        };
        const close = (instanceApi) => {
            instanceApi.close();
        };
        return {
            open,
            openUrl,
            alert,
            close,
            confirm
        };
    };

    const registerOptions = (editor) => {
        register$f(editor);
        register$e(editor);
        register(editor);
    };
    var Theme = () => {
        global$b.add('silver', (editor) => {
            registerOptions(editor);
            // When using the ui_mode: split, the popup sink is placed as a sibling to the
            // editor, which means that it might be subject to any scrolling environments
            // that the editor has. Therefore, we want to make the popup sink have an overall
            // bounds that is dependent on its scrolling environment. We don't know that ahead
            // of time, so we use a mutable variable whose value will change if there is a scrolling context.
            let popupSinkBounds = () => win();
            const { dialogs, popups, renderUI: renderModeUI } = setup$3(editor, {
                // consult the mutable variable to find out the bounds for the popup sink. When renderUI is
                // called, this mutable variable might be reassigned
                getPopupSinkBounds: () => popupSinkBounds()
            });
            // We wrap the `renderModeUI` function being returned by Render so that we can update
            // the getPopupSinkBounds mutable variable if required.
            // DON'T define this function as `async`; otherwise, it will slow down the rendering process and cause flickering if the editor is repeatedly removed and re-initialized.
            const renderUI = () => {
                const renderResult = renderModeUI();
                const optScrollingContext = detectWhenSplitUiMode(editor, popups.getMothership().element);
                optScrollingContext.each((sc) => {
                    popupSinkBounds = () => {
                        // At this stage, it looks like we need to calculate the bounds each time, just in
                        // case the scrolling context details have changed since the last time. The bounds considers
                        // the Boxes.box sizes, which might change over time.
                        return getBoundsFrom(sc);
                    };
                });
                return renderResult;
            };
            Autocompleter.register(editor, popups.backstage.shared);
            const windowMgr = setup({
                editor,
                backstages: {
                    popup: popups.backstage,
                    dialog: dialogs.backstage
                }
            });
            const notificationRegion = value$2();
            // The NotificationManager uses the popup mothership (and sink)
            const getNotificationManagerImpl = () => NotificationManagerImpl(editor, { backstage: popups.backstage }, popups.getMothership(), notificationRegion);
            const getPromotionElement = () => {
                return descendant(SugarElement.fromDom(editor.getContainer()), '.tox-promotion').map((promotion) => promotion.dom).getOrNull();
            };
            return {
                renderUI,
                getWindowManagerImpl: constant$1(windowMgr),
                getNotificationManagerImpl,
                getPromotionElement
            };
        });
    };

    Theme();
    /** *****
     * DO NOT EXPORT ANYTHING
     *
     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE
     *******/

})();

tinymce.IconManager.add('default', {
  icons: {
    'accessibility-check': '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z" fill-rule="nonzero"/></svg>',
    'accordion-toggle': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3 7.3a1 1 0 0 1 1.4 0L16 9.6l2.3-2.3a1 1 0 1 1 1.4 1.4L16 12.4l-3.7-3.7a1 1 0 0 1 0-1.4ZM4.3 11.7a1 1 0 0 1 0-1.4L6.6 8 4.3 5.7a1 1 0 0 1 1.4-1.4L9.4 8l-3.7 3.7a1 1 0 0 1-1.4 0Z"/></svg>',
    'accordion': '<svg width="24" height="24"><rect x="12" y="7" width="10" height="2" rx="1"/><rect x="12" y="11" width="10" height="2" rx="1"/><rect x="12" y="15" width="6" height="2" rx="1"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2.3 7.3a1 1 0 0 1 1.4 0L6 9.6l2.3-2.3a1 1 0 0 1 1.4 1.4L6 12.4 2.3 8.7a1 1 0 0 1 0-1.4Z"/></svg>',
    'action-next': '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z"/></svg>',
    'action-prev': '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z"/></svg>',
    'addtag': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z"/></svg>',
    'ai-prompt': '<svg width="24" height="24"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 6.7a1 1 0 0 0-1.4 0l-9.9 10a1 1 0 0 0 0 1.3l2.1 2.1c.4.4 1 .4 1.4 0l10-9.9c.3-.3.3-1 0-1.4l-2.2-2Zm1.4 2.8-2-2-3 2.7 2.2 2.2 2.8-2.9Z"/><path d="m18.5 7.3-.7-1.5-1.5-.8 1.5-.7.7-1.5.7 1.5 1.5.7-1.5.8-.7 1.5ZM18.5 16.5l-.7-1.6-1.5-.7 1.5-.7.7-1.6.7 1.6 1.5.7-1.5.7-.7 1.6ZM9.7 7.3 9 5.8 7.5 5 9 4.3l.7-1.5.7 1.5L12 5l-1.5.8-.7 1.5Z"/></g><defs><clipPath id="a"><path d="M0 0h24v24H0z"/></clipPath></defs></svg>',
    'ai': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M5 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3H5Zm6.8 11.5.5 1.2a68.3 68.3 0 0 0 .7 1.1l.4.1c.3 0 .5 0 .7-.3.2-.1.3-.3.3-.6l-.3-1-2.6-6.2a20.4 20.4 0 0 0-.5-1.3l-.5-.4-.7-.2c-.2 0-.5 0-.6.2-.2 0-.4.2-.5.4l-.3.6-.3.7L5.7 15l-.2.6-.1.4c0 .3 0 .5.3.7l.6.2c.3 0 .5 0 .7-.2l.4-1 .5-1.2h3.9ZM9.8 9l1.5 4h-3l1.5-4Zm5.6-.9v7.6c0 .4 0 .7.2 1l.7.2c.3 0 .6 0 .8-.3l.2-.9V8.1c0-.4 0-.7-.2-.9a1 1 0 0 0-.8-.3c-.2 0-.5.1-.7.3l-.2 1Z"/></svg>',
    'align-center': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    'align-justify': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    'align-left': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    'align-none': '<svg width="24" height="24"><path d="M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z" fill-rule="evenodd"/></svg>',
    'align-right': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    'arrow-left': '<svg width="24" height="24"><path d="m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z" fill-rule="evenodd"/></svg>',
    'arrow-right': '<svg width="24" height="24"><path d="m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z" fill-rule="evenodd"/></svg>',
    'bold': '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z" fill-rule="evenodd"/></svg>',
    'bookmark': '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z" fill-rule="nonzero"/></svg>',
    'border-style': '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
    'border-width': '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
    'brightness': '<svg width="24" height="24"><path d="M12.7 18.3a1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v1a1 1 0 0 0 .3.7 1 1 0 0 0 .7.3 1 1 0 0 0 .7-.3 1 1 0 0 0 .3-.7v-1a1 1 0 0 0-.3-.7ZM11.3 5.7a1 1 0 0 0 .7.3 1 1 0 0 0 .7-.3A1 1 0 0 0 13 5V4a1 1 0 0 0-.3-.7A1 1 0 0 0 12 3a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v1a1 1 0 0 0 .3.7Zm9.4 5.6a1 1 0 0 0-.7-.3h-1a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7 1 1 0 0 0 .3.7 1 1 0 0 0 .7.3h1a1 1 0 0 0 .7-.3 1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.7Zm-15 1.4A1 1 0 0 0 6 12a1 1 0 0 0-.3-.7A1 1 0 0 0 5 11H4a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7 1 1 0 0 0 .3.7 1 1 0 0 0 .7.3h1a1 1 0 0 0 .7-.3Zm13 4.6-.7-.8a1 1 0 0 0-.8-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7 1 1 0 0 0 .3.8l.7.7a1 1 0 0 0 .7.3 1 1 0 0 0 .8-.3 1 1 0 0 0 .3-.8 1 1 0 0 0-.3-.7ZM5.3 6.7l.7.8a1 1 0 0 0 .8.3 1 1 0 0 0 .7-.3 1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.8l-.7-.7A1 1 0 0 0 6 5a1 1 0 0 0-.8.3 1 1 0 0 0-.3.8 1 1 0 0 0 .3.6Zm12 1a1 1 0 0 0 .7-.2l.7-.7A1 1 0 0 0 19 6a1 1 0 0 0-.3-.8 1 1 0 0 0-.8-.3 1 1 0 0 0-.7.3l-.7.7a1 1 0 0 0-.3.8 1 1 0 0 0 .3.7 1 1 0 0 0 .7.2ZM6.7 16.4a1 1 0 0 0-.8.2l-.7.7a1 1 0 0 0-.3.7 1 1 0 0 0 .3.8 1 1 0 0 0 .8.3 1 1 0 0 0 .7-.3l.7-.7a1 1 0 0 0 .3-.8 1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3Z"/><path fill-rule="evenodd" d="M13.6 8.3A4 4 0 0 0 12 8a4 4 0 0 0-1.6.3A4 4 0 0 0 9 9.5a4 4 0 0 0-.6 1A4 4 0 0 0 8 12c0 .6.1 1 .3 1.6a4 4 0 0 0 2.1 2 4 4 0 0 0 1.6.4 4 4 0 0 0 1.6-.3 4 4 0 0 0 2-2.1A4 4 0 0 0 16 12a4 4 0 0 0-.3-1.6 4 4 0 0 0-2.1-2ZM14 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"/></svg>',
    'browse': '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z" fill-rule="nonzero"/></svg>',
    'cancel': '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z" fill-rule="nonzero"/></svg>',
    'cell-background-color': '<svg width="24" height="24"><path d="m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z"/></svg>',
    'cell-border-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="m13 11-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z"/></g></svg>',
    'change-case': '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
    'character-count': '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z" fill-rule="evenodd"/></svg>',
    'checklist-rtl': '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
    'checklist': '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z" fill-rule="evenodd"/></svg>',
    'checkmark-filled': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 2a10 10 0 1 1 0 20 10 10 0 0 1 0-20Zm4.8 5a1 1 0 0 0-1.4.3l-5.4 8-2-2.1a1 1 0 1 0-1.5 1.4l3 3a1 1 0 0 0 1.5-.2l6-9a1 1 0 0 0-.2-1.4Z"/></svg>',
    'checkmark': '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z" fill-rule="nonzero"/></svg>',
    'chevron-down': '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z" fill-rule="nonzero"/></svg>',
    'chevron-left': '<svg width="10" height="10"><path d="M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z" fill-rule="nonzero"/></svg>',
    'chevron-right': '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z" fill-rule="nonzero"/></svg>',
    'chevron-up': '<svg width="10" height="10"><path d="M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z" fill-rule="nonzero"/></svg>',
    'close-filled': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 2a10 10 0 1 1 0 20 10 10 0 0 1 0-20Zm4.7 5.3a1 1 0 0 0-1.3 0L12 10.6 8.6 7.3a1 1 0 0 0-1.3 1.3l3.3 3.4-3.3 3.4a1 1 0 0 0 1.3 1.3l3.4-3.3 3.4 3.3a1 1 0 0 0 1.3-1.3L13.4 12l3.3-3.4a1 1 0 0 0 0-1.3Z"/></svg>',
    'close': '<svg width="24" height="24"><path d="M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z" fill-rule="evenodd"/></svg>',
    'code-sample': '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z" fill-rule="evenodd"/></svg>',
    'color-levels': '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z" fill-rule="evenodd"/></svg>',
    'color-picker': '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z" fill-rule="nonzero"/></svg>',
    'color-swatch-remove-color': '<svg width="24" height="24" class="color-swatch-remove-color"><path stroke="#000" stroke-width="2" d="M21 3 3 21" fill-rule="evenodd"/></svg>',
    'color-swatch': '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
    'comment-add': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z"/></g></svg>',
    'comment': '<svg width="24" height="24"><path fill-rule="nonzero" d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/></svg>',
    'contrast': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 0 1 19.4 9c.4 1 .6 2 .6 3.1s-.2 2.1-.6 3.1a8 8 0 0 1-1.7 2.6 8 8 0 0 1-2.6 1.7 7.8 7.8 0 0 1-3.1.6 7.8 7.8 0 0 1-3.1-.6 8 8 0 0 1-2.6-1.7A8 8 0 0 1 4.6 15 7.8 7.8 0 0 1 4 12c0-1.1.2-2.1.6-3.1a8 8 0 0 1 1.7-2.6A8 8 0 0 1 9 4.6 7.8 7.8 0 0 1 12 4Zm-6 8a6 6 0 0 0 1.8 4.2 6 6 0 0 0 1.9 1.3 5.8 5.8 0 0 0 2.3.5V6c-.8 0-1.6.2-2.3.5a6 6 0 0 0-2 1.3 6 6 0 0 0-1.2 1.9A5.8 5.8 0 0 0 6 12Z"/></svg>',
    'copy': '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z" fill-rule="nonzero"/></svg>',
    'crop': '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z" fill-rule="evenodd"/></svg>',
    'cut-column': '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z"/></svg>',
    'cut-row': '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z"/></svg>',
    'cut': '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z" fill-rule="evenodd"/></svg>',
    'document-properties': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    'drag': '<svg width="24" height="24"><path d="M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z" fill-rule="evenodd"/></svg>',
    'duplicate-column': '<svg width="24" height="24"><path d="M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z"/></svg>',
    'duplicate-row': '<svg width="24" height="24"><path d="M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z"/></svg>',
    'duplicate': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z"/></g></svg>',
    'edit-block': '<svg width="24" height="24"><path fill-rule="nonzero" d="m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z"/></svg>',
    'edit-image': '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z" fill-rule="nonzero"/></svg>',
    'embed-page': '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z" fill-rule="nonzero"/></svg>',
    'embed': '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z" fill-rule="nonzero"/></svg>',
    'emoji': '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z" fill-rule="nonzero"/></svg>',
    'export': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z"/><path d="M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z"/></g></svg>',
    'feedback': '<svg width="24" height="24"><path fill-rule="evenodd" d="M16 6c1 0 2 1 2 2v5c0 1-1 2-2 2h-3l-4 3v-3H8c-1 0-2-1-2-2V8c0-1 1-2 2-2h8Zm-7 5v1h4v-1H9Zm0-2v1h6V9H9Z"/></svg>',
    'fill': '<svg width="24" height="26"><path d="m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z" fill-rule="nonzero"/></svg>',
    'flip-horizontally': '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z" fill-rule="nonzero"/></svg>',
    'flip-vertically': '<svg width="24" height="24"><path d="M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z" fill-rule="nonzero"/></svg>',
    'footnote': '<svg width="24" height="24"><path d="M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19 4v6h-1V5h-1.5V4h2.6Z"/><path d="M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z"/></svg>',
    'format-code': '<svg width="24" height="24"><path d="m10 22 2-7H6l9-13h2l-2 8h7L12 22h-2ZM6 2h7l-1.4 2H6V2Zm4.2 4H4v2h4.8l1.4-2Zm-2.7 4H2v2h4l1.5-2Z"/></svg>',
    'format-painter': '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z" fill-rule="nonzero"/></svg>',
    'format': '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z"/></svg>',
    'fullscreen': '<svg width="24" height="24"><path d="m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z" fill-rule="nonzero"/></svg>',
    'gallery': '<svg width="24" height="24"><path fill-rule="nonzero" d="m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z"/></svg>',
    'gamma': '<svg height="24" width="24"><path d="M11.5 16.3a.7.7 0 1 0 1.4 0V14l2.7-6a.7.7 0 1 0-1.2-.6l-2.2 5-2.3-4.9C9.6 7 8.7 7 8 7.2v1.1c.8-.2.9 0 1.2 1l2.3 4.7z"/><path d="M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm1 2h14v14H5z" fill-rule="evenodd"/></svg>',
    'help': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
    'highlight-bg-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
    'home': '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
    'horizontal-rule': '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
    'image-options': '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    'image': '<svg width="24" height="24"><path d="m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill-rule="nonzero"/></svg>',
    'indent': '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    'info': '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z" fill-rule="evenodd"/></svg>',
    'insert-character': '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z" fill-rule="evenodd"/></svg>',
    'insert-time': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z"/></g></svg>',
    'invert': '<svg height="24" width="24"><path d="M5 4 3.6 5.4l3.9 4C6.6 10.7 6 12.3 6 14a6 6 0 0 0 10.3 4.2l1.9 1.8 1.4-1.4z" fill-rule="evenodd"/><path d="M13.4 8.4c.9 1 1.6 2.1 2 3.2l2.6 2.6V14c0-5-6-10-6-10s-1 .8-2.1 2l1.4 1.5.7-.7 1.4 1.6z"/></svg>',
    'italic': '<svg width="24" height="24"><path d="m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z" fill-rule="evenodd"/></svg>',
    'language': '<svg width="24" height="24"><path d="M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z"/></svg>',
    'line-height': '<svg width="24" height="24"><path d="M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z"/></svg>',
    'line': '<svg width="24" height="24"><path d="m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z" fill-rule="evenodd"/></svg>',
    'link': '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z" fill-rule="nonzero"/></svg>',
    'list-bull-circle': '<svg height="48" width="48"><path d="M8 14a3 3 0 1 0 6 0 3 3 0 0 0-6 0zm5 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM8 24a3 3 0 1 0 6 0 3 3 0 0 0-6 0zm5 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM8 34a3 3 0 1 0 6 0 3 3 0 0 0-6 0zm5 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0z" fill-rule="evenodd"/><path d="M18 12h22v4H18zm0 10h22v4H18zm0 10h22v4H18z" opacity=".2"/></svg>',
    'list-bull-default': '<svg height="48" width="48"><path d="M14 14a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/><path d="M12 24a3 3 0 1 0 6 0 3 3 0 0 0-6 0zm5 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0z" fill-rule="evenodd"/><path d="M16 31h6v6h-6z"/><path d="M16 31h6v6h-6z"/><path d="M18 12h22v4H18zm4 10h18v4H22zm4 10h14v4H26z" opacity=".2"/></svg>',
    'list-bull-disc': '<svg height="48" width="48"><path d="M14 14a3 3 0 1 1-6 0 3 3 0 0 1 6 0zm0 10a3 3 0 1 1-6 0 3 3 0 0 1 6 0zm0 10a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/><path d="M18 12h22v4H18zm0 10h22v4H18zm0 10h22v4H18z" opacity=".2"/></svg>',
    'list-bull-square': '<svg height="48" width="48"><path d="M8 21h6v6H8zm0 10h6v6H8zm0-20h6v6H8z"/><path d="M18 12h22v4H18zm0 10h22v4H18zm0 10h22v4H18z" opacity=".2"/></svg>',
    'list-num-default-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
    'list-num-default': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z"/></g></svg>',
    'list-num-lower-alpha-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    'list-num-lower-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    'list-num-lower-greek-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    'list-num-lower-greek': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    'list-num-lower-roman-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
    'list-num-lower-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
    'list-num-upper-alpha-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    'list-num-upper-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    'list-num-upper-roman-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
    'list-num-upper-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
    'lock': '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z" fill-rule="evenodd"/></svg>',
    'ltr': '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    'math-equation': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 4.8c.1-.5.5-.8 1-.8h10a1 1 0 1 1 0 2h-9.2L8.3 19.2a1 1 0 0 1-1.7.4l-3.4-4.2a1 1 0 0 1 1.6-1.2l2 2.5L9 4.8Zm9.7 5.5c.4.4.4 1 0 1.4L17 13.5l1.8 1.8a1 1 0 1 1-1.4 1.4L15.5 15l-1.8 1.8a1 1 0 0 1-1.4-1.4l1.8-1.8-1.8-1.8a1 1 0 0 1 1.4-1.4l1.8 1.8 1.8-1.8a1 1 0 0 1 1.4 0Z"/></svg>',
    'mentions': '<svg height="24" width="24"><path d="M12 21a8.8 8.8 0 0 1-3.5-.7 9 9 0 0 1-2.9-2 9 9 0 0 1-1.9-2.8A8.8 8.8 0 0 1 3 12c0-1.3.2-2.4.7-3.5a9 9 0 0 1 4.8-4.8A8.8 8.8 0 0 1 12 3c1.3 0 2.4.2 3.5.7a9.1 9.1 0 0 1 4.8 4.8A8.7 8.7 0 0 1 21 12v1.4a3 3 0 0 1-.9 2.2 3 3 0 0 1-2.2.9c-.5 0-1-.1-1.5-.4a3.8 3.8 0 0 1-1.1-1 4.8 4.8 0 0 1-1.5 1 4.3 4.3 0 0 1-1.8.4c-1.2 0-2.3-.4-3.2-1.3-.9-.9-1.3-2-1.3-3.2s.4-2.3 1.3-3.2c.9-.9 2-1.3 3.2-1.3s2.3.4 3.2 1.3c.9.9 1.3 2 1.3 3.2v1.4c0 .4.1.7.4 1 .3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1V12c0-2-.7-3.8-2.1-5.2S14 4.7 12 4.7s-3.8.7-5.2 2.1S4.7 10 4.7 12s.7 3.8 2.1 5.2 3.2 2.1 5.2 2.1h4.5V21zm0-6.2c.8 0 1.4-.3 2-.8a2.7 2.7 0 0 0 .8-2c0-.8-.3-1.4-.8-2a2.7 2.7 0 0 0-2-.8c-.8 0-1.4.3-2 .8a2.7 2.7 0 0 0-.8 2c0 .8.3 1.4.8 2a2.7 2.7 0 0 0 2 .8z"/></svg>',
    'minus': '<svg width="24" height="24"><path d="M19 11a1 1 0 0 1 .1 2H5a1 1 0 0 1-.1-2H19Z"/></svg>',
    'more-drawer': '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    'new-document': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    'new-tab': '<svg width="24" height="24"><path d="m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z" fill-rule="evenodd"/></svg>',
    'non-breaking': '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    'notice': '<svg width="24" height="24"><path d="M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z" fill-rule="evenodd" clip-rule="evenodd"/></svg>',
    'ordered-list-rtl': '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    'ordered-list': '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    'orientation': '<svg width="24" height="24"><path d="M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z" fill-rule="nonzero"/></svg>',
    'outdent': '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    'export-pdf': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V17h-2V9h-4V5H7v3H5V5c0-1.1.9-2 2-2Z"/><path d="M2.6 15.2v-1.9h1c.6 0 1-.2 1.4-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2a2 2 0 0 0-1.3-.4H1v5.2h1.6Zm.4-3h-.4v-1.1h.5l.6.1.2.5c0 .1 0 .3-.2.4l-.7.1Zm5.7 3 1-.1c.3 0 .5-.2.7-.4l.5-.8c.2-.3.2-.7.2-1.3v-1l-.5-.8c-.2-.3-.4-.5-.7-.6L8.7 10H6.3v5.2h2.4Zm-.4-1.1H8v-3h.4c.5 0 .8.2 1 .4l.2 1.1-.1 1-.3.3-.8.2Zm5.3 1.2V13h2v-1h-2v-1H16V10h-4v5.2h1.6Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M15 17a1 1 0 1 0-2 0v3.1l-1.4-1a1 1 0 1 0-1.2 1.7l3.6 2.4 3.6-2.4a1 1 0 0 0-1.2-1.6l-1.4 1V17Z"/></svg>',
    'export-word': '<svg width="24" height="24"><path d="M9.5 7A1.5 1.5 0 0 1 11 8.4v7.1A1.5 1.5 0 0 1 9.6 17H2.5A1.5 1.5 0 0 1 1 15.6V8.5A1.5 1.5 0 0 1 2.4 7h7.1Zm-1 2.8-1 2.6-1-2.5v-.1a.6.6 0 0 0-1 0l-.1.1-.9 2.5-1-2.5v-.1a.6.6 0 0 0-1 .4v.1l1.5 4v.1a.6.6 0 0 0 1 0v-.1l1-2.5.9 2.5v.1a.6.6 0 0 0 1 0H8l1.6-4v-.2a.6.6 0 0 0-1.1-.4Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V17h-2V9h-4V5H5c0-1.1.9-2 2-2ZM15 17a1 1 0 1 0-2 0v3.1l-1.4-1a1 1 0 1 0-1.2 1.7l3.6 2.4 3.6-2.4a1 1 0 0 0-1.2-1.6l-1.4 1V17Z"/></svg>',
    'import-word': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V15h-2V9h-4V5H5c0-1.1.9-2 2-2Z"/><path d="M9.5 7A1.5 1.5 0 0 1 11 8.4v7.1A1.5 1.5 0 0 1 9.6 17H2.5A1.5 1.5 0 0 1 1 15.6V8.5A1.5 1.5 0 0 1 2.4 7h7.1Zm-1 2.8-1 2.6-1-2.5v-.1a.6.6 0 0 0-1 0l-.1.1-.9 2.5-1-2.5v-.1a.6.6 0 0 0-1 .4v.1l1.5 4v.1a.6.6 0 0 0 1 0v-.1l1-2.5.9 2.5v.1a.6.6 0 0 0 1 0H8l1.6-4v-.2a.6.6 0 0 0-1.1-.4Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M11.4 18.2a1 1 0 0 0 1.2 1.6l1.4-1V22a1 1 0 1 0 2 0v-3.1l1.4 1a1 1 0 0 0 1.2-1.7L15 15.8l-3.6 2.4Z"/></svg>',
    'page-break': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z"/></g></svg>',
    'paragraph': '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z"/></svg>',
    'paste-column-after': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    'paste-column-before': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    'paste-row-after': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    'paste-row-before': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    'paste-text': '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z" fill-rule="nonzero"/></svg>',
    'paste': '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z" fill-rule="nonzero"/></svg>',
    'permanent-pen': '<svg width="24" height="24"><path d="M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z" fill-rule="nonzero"/></svg>',
    'plus': '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z"/></svg>',
    'preferences': '<svg width="24" height="24"><path d="m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" fill-rule="evenodd"/></svg>',
    'preview': '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z" fill-rule="nonzero"/></svg>',
    'print': '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z" fill-rule="nonzero"/></svg>',
    'quote': '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z" fill-rule="nonzero"/></svg>',
    'redo': '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z" fill-rule="nonzero"/></svg>',
    'reload': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z"/></g></svg>',
    'remove-formatting': '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z" fill-rule="evenodd"/></svg>',
    'remove': '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z" fill-rule="nonzero"/></svg>',
    'resize-handle': '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z"/></g></svg>',
    'resize': '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z" fill-rule="evenodd"/></svg>',
    'restore-draft': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
    'revision-history': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
    'rotate-left': '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></svg>',
    'rotate-right': '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z" fill-rule="nonzero"/></svg>',
    'rtl': '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    'save': '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z" fill-rule="nonzero"/></svg>',
    'search': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" fill-rule="nonzero"/></svg>',
    'select-all': '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z" fill-rule="nonzero"/></svg>',
    'selected': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z"/></svg>',
    'send': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="m13.3 22 7-18.3-18.3 7L9 15l4.3 7ZM18 6.8l-.7-.7L9.4 14l.7.7L18 6.8Z"/></svg>',
    'settings': '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z" fill-rule="evenodd"/></svg>',
    'sharpen': '<svg width="24" height="24"><path fill-rule="evenodd" d="m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z"/></svg>',
    'sourcecode': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z"/></g></svg>',
    'spell-check': '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z" fill-rule="evenodd"/></svg>',
    'strike-through': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z" fill-rule="nonzero"/></g></svg>',
    'subscript': '<svg width="24" height="24"><path d="m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z" fill-rule="nonzero"/></svg>',
    'suggestededits-badge': '<svg height="24" width="24"><path d="M11 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9.7a6 6 0 0 1-2 .3v9H7V5h4a6 6 0 0 1 0-2z"/><path d="M15 13v-2h-4v2zm-3 2H9v2h3zm-1-8H9v2h2zm4 10v-2h-2v2z"/><path d="M21 4a4 4 0 1 1-8 0 4 4 0 0 1 8 0z" class="tox-icon--badge"/></svg>',
    'suggestededits': '<svg width="24" height="24"><path d="M7 3h7.4L19 7.6V19a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2Zm0 16h10V9h-3V5H7v14Z" clip-rule="evenodd"/><path d="M9 7h2v2H9V7Zm2 4h4v2h-4v-2Zm-2 4h3v2H9v-2Z"/><path d="M9 7h2v2H9V7Zm4 8h2v2h-2v-2Z"/></svg>',
    'superscript': '<svg width="24" height="24"><path d="M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z" fill-rule="nonzero"/></svg>',
    'table-caption': '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></g></svg>',
    'table-cell-classes': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z" opacity=".2"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z" opacity=".2"/></g></svg>',
    'table-cell-properties': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z"/></svg>',
    'table-cell-select-all': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z" opacity=".2"/></g></svg>',
    'table-cell-select-inner': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z"/></g></svg>',
    'table-classes': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/></g></svg>',
    'table-delete-column': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z"/></svg>',
    'table-delete-row': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z"/></svg>',
    'table-delete-table': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z"/><path d="m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
    'table-insert-column-after': '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z"/></svg>',
    'table-insert-column-before': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z"/></svg>',
    'table-insert-row-above': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z"/></svg>',
    'table-insert-row-after': '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z"/></svg>',
    'table-left-header': '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z"/></svg>',
    'table-merge-cells': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z"/></svg>',
    'table-row-numbering-rtl': '<svg width="24" height="24"><path d="M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z"/></svg>',
    'table-row-numbering': '<svg width="24" height="24"><path d="M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z"/></svg>',
    'table-row-properties': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z"/></svg>',
    'table-split-cells': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z"/></svg>',
    'table-top-header': '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></svg>',
    'table': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z"/></svg>',
    'template-add': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 12v4H5a2 2 0 0 0-2 2v3h9.3a6 6 0 0 1-.3-2H5v-1h7a6 6 0 0 1 .8-2H11v-5l-.8-.6a3 3 0 1 1 3.6 0l-.8.6v4.7a6 6 0 0 1 2-1.9V12a5 5 0 1 0-6 0Z"/><path d="M18 15c.5 0 1 .4 1 .9V18h2a1 1 0 0 1 .1 2H19v2a1 1 0 0 1-2 .1V20h-2a1 1 0 0 1-.1-2H17v-2c0-.6.4-1 1-1Z"/></svg>',
    'template': '<svg width="24" height="24"><path d="M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z" fill-rule="nonzero"/></svg>',
    'temporary-placeholder': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
    'text-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z"/></g></svg>',
    'text-size-decrease': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM14 12a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z"/></svg>',
    'text-size-increase': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM17 9a1 1 0 0 0-1 1v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2c0-.6-.4-1-1-1Z"/></svg>',
    'toc': '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    'translate': '<svg width="24" height="24"><path d="m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z" fill-rule="evenodd"/></svg>',
    'typography': '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z"/><path d="m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z"/></svg>',
    'underline': '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    'undo': '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z" fill-rule="nonzero"/></svg>',
    'unlink': '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z" fill-rule="nonzero"/></svg>',
    'unlock': '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z" fill-rule="evenodd"/></svg>',
    'unordered-list': '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z" fill-rule="evenodd"/></svg>',
    'unselected': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z"/></svg>',
    'upload': '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z" fill-rule="nonzero"/></svg>',
    'add-file': '<svg height="24" width="24"><path d="M2 7h2V4h3V2H4a2 2 0 0 0-2 2zm20 0h-2V4h-3V2h3a2 2 0 0 1 2 2zm0 2h-2v6h2zm0 8h-2v3h-3v2h3a2 2 0 0 0 2-2zM2 9h2v6H2zm0 8h2v3h3v2H4a2 2 0 0 1-2-2zm7 5v-2h6v2zm6-20v2H9V2zM6 17h12l-4-5-3 3.8-2-2.6z"/><path d="M2 7h2V4h3V2H4a2 2 0 0 0-2 2zm20 0h-2V4h-3V2h3a2 2 0 0 1 2 2zm0 2h-2v6h2zm0 8h-2v3h-3v2h3a2 2 0 0 0 2-2zM2 9h2v6H2zm0 8h2v3h3v2H4a2 2 0 0 1-2-2zm7 5v-2h6v2zm6-20v2H9V2zM6 17h12l-4-5-3 3.8-2-2.6z"/><path d="M6 17h12l-4-5-3 3.8-2-2.6z"/><path d="M6 17h12l-4-5-3 3.8-2-2.6z"/><path d="M6 17h12l-4-5-3 3.8-2-2.6z"/><path d="M6 17h12l-4-5-3 3.8-2-2.6z"/></svg>',
    'adjustments': '<svg width="24" height="24"><path d="M16 11a3 3 0 1 1 2.8-4H21v2h-2.2a3 3 0 0 1-2.8 2Zm0-2a1 1 0 1 1 0-2 1 1 0 0 1 0 2ZM3 9h8V7H3v2Zm5 10a3 3 0 1 0-2.8-4H3v2h2.2A3 3 0 0 0 8 19Zm0-2a1 1 0 1 0 0-2 1 1 0 0 0 0 2Zm13 0h-8v-2h8v2Z"/></svg>',
    'alt-text': '<svg width="24" height="24"><path d="M3 20a2 2 0 0 1-1.4-.6A2 2 0 0 1 1 18V6c0-.6.2-1 .6-1.4A2 2 0 0 1 3 4h18c.6 0 1 .2 1.4.6.4.4.6.9.6 1.4v12c0 .6-.2 1-.6 1.4a2 2 0 0 1-1.4.6H3Zm0-2h18V6H3v12Zm1.5-3H6v-1.5h1.5V15H9v-5a1 1 0 0 0-.3-.7A1 1 0 0 0 8 9H5.5a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v5ZM6 12v-1.5h1.5V12H6Z"/><path d="M11 15V9h1.3v4.5h2V15H11Zm5.8-4.5V15h1.4v-4.5h1.3V9h-4v1.5h1.3Z"/></svg>',
    'auto-image-enhancement': '<svg width="24" height="24"><path d="M7.7 10.6a5.8 5.8 0 0 0 5.7 5.7A5.8 5.8 0 0 0 7.7 22 5.8 5.8 0 0 0 2 16.3a5.8 5.8 0 0 0 5.7-5.7ZM15.5 2c.3 3 3.3 6 6.5 6.4-3.2.5-6.2 3.4-6.5 6.5-.3-3.4-3-6-6.4-6.5 3.3-.5 6.1-3 6.4-6.4Z"/></svg>',
    'blur': '<svg width="24" height="24"><path d="M19.3 9.3a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3a1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.7A1 1 0 0 0 20 9a1 1 0 0 0-.7.3Zm-16 0a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3A1 1 0 0 0 5 10a1 1 0 0 0-.3-.7A1 1 0 0 0 4 9a1 1 0 0 0-.7.3Zm16 6a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3a1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3Zm-16 0a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3A1 1 0 0 0 5 16a1 1 0 0 0-.3-.7A1 1 0 0 0 4 15a1 1 0 0 0-.7.3Zm5-11A1 1 0 0 0 8 5a1 1 0 0 0 1 1c.3 0 .5-.1.7-.3A1 1 0 0 0 10 5a1 1 0 0 0-.3-.7A1 1 0 0 0 9 4a1 1 0 0 0-.7.3Zm6 0a1 1 0 0 0-.3.7 1 1 0 0 0 1 1c.3 0 .5-.1.7-.3A1 1 0 0 0 16 5a1 1 0 0 0-.3-.7A1 1 0 0 0 15 4a1 1 0 0 0-.7.3Zm-6 16a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3a1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.7A1 1 0 0 0 9 20a1 1 0 0 0-.7.3Zm6 0a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3a1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3ZM7.6 8.6A2 2 0 0 0 7 10c0 .6.2 1 .6 1.4.4.4.8.6 1.4.6s1-.2 1.4-.6c.4-.4.6-.8.6-1.4s-.2-1-.6-1.4A2 2 0 0 0 9 8a2 2 0 0 0-1.4.6Zm0 6A2 2 0 0 0 7 16c0 .6.2 1 .6 1.4.4.4.8.6 1.4.6s1-.2 1.4-.6c.4-.4.6-.8.6-1.4s-.2-1-.6-1.4A2 2 0 0 0 9 14a2 2 0 0 0-1.4.6Zm6-6A2 2 0 0 0 13 10c0 .6.2 1 .6 1.4.4.4.8.6 1.4.6s1-.2 1.4-.6c.4-.4.6-.8.6-1.4s-.2-1-.6-1.4A2 2 0 0 0 15 8a2 2 0 0 0-1.4.6Zm0 6A2 2 0 0 0 13 16c0 .6.2 1 .6 1.4.4.4.8.6 1.4.6s1-.2 1.4-.6c.4-.4.6-.8.6-1.4s-.2-1-.6-1.4A2 2 0 0 0 15 14a2 2 0 0 0-1.4.6Z"/></svg>',
    'box': '<svg width="24" height="24"><path d="M3.8 7a1 1 0 0 0-.7.6l-.1 3V13.8a3.5 3.5 0 0 0 4 2.7c.8-.2 1.4-.5 2-1l.3-.3.3.2c.7.7 1.4 1 2.4 1.1 1.2 0 2.4-.6 3-1.6.9-1.2.8-2.8 0-4a3.7 3.7 0 0 0-2-1.2c-.4-.1-1.2-.1-1.6 0a3.4 3.4 0 0 0-1.7 1l-.3.2-.2-.1c-.4-.5-1.2-1-2-1.1-.6-.2-1.5 0-2 .2H5V9c0-1.3 0-1.3-.3-1.6a1 1 0 0 0-1-.3Zm12 2.6c-.3.2-.5.4-.6.8v.6l.9 1 .7 1v.1l-.8 1-.7 1a1 1 0 0 0 0 .7 1 1 0 0 0 1.3.6c.2 0 .3-.2 1-1l.5-.7.6.8.7.8c.4.3 1 .3 1.3 0l.2-.3a1 1 0 0 0 0-.8l-.8-1.2-.7-1a26 26 0 0 0 1.5-2 .8.8 0 0 0 .1-.4c0-.4-.1-.7-.5-.9H20c-.4 0-.5 0-1.2.8l-.7.8-.6-.7-.7-.9a1 1 0 0 0-1 0Zm-9 2 .4.1c.3.1.6.5.7.8l.1.6v.6c-.6 1-2 1.2-2.7.3-.3-.3-.3-.5-.3-1v-.5c.3-.5.7-.8 1.1-1a1.5 1.5 0 0 1 .7 0Zm5.7 0c.4 0 .8.4 1 .8l.2.6-.1.7c-.5.9-1.6 1.1-2.4.6a1.4 1.4 0 0 1-.6-1.1 1.4 1.4 0 0 1 .5-1.2 1.5 1.5 0 0 1 1.4-.4Z"/></svg>',
    'camera': '<svg height="24" width="24"><g clip-rule="evenodd" fill-rule="evenodd"><path d="M10 5.4a1 1 0 0 1 .8-.4h4.4a1 1 0 0 1 .8.4l1.2 1.8h2.3A2.5 2.5 0 0 1 22 9.6v8a2.5 2.5 0 0 1-2.5 2.5h-13A2.5 2.5 0 0 1 4 17.6v-8a2.5 2.5 0 0 1 2.5-2.4h2.3zM11.4 7l-1.2 1.7a1 1 0 0 1-.8.5h-3a.5.5 0 0 0-.4.4v8a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.4h-2.9a1 1 0 0 1-.8-.5L14.6 7z"/><path d="M13 11.4a2 2 0 1 0 0 3.8 2 2 0 0 0 0-3.8zm-4 1.9a4 4 0 1 1 8 0 4 4 0 0 1-8 0z"/></g></svg>',
    'caption': '<svg height="24" width="24"><path d="M6 16h8v-2H6zm10 0h2v-2h-2zM4 20a2 2 0 0 1-1.5-.6A2 2 0 0 1 2 18V6c0-.6.2-1 .6-1.4A2 2 0 0 1 4 4h16c.6 0 1 .2 1.4.6.4.4.6.9.6 1.4v12c0 .6-.2 1-.6 1.4a2 2 0 0 1-1.4.6zm0-2h16V6H4z"/></svg>',
    'dropbox': '<svg height="24" width="24"><path clip-rule="evenodd" d="m6.4 9.3-3-2a1 1 0 0 1 0-1.6l4-2.5a1 1 0 0 1 1 0L12 5.5l3.6-2.3a1 1 0 0 1 1 0l4 2.5a1 1 0 0 1 0 1.7l-3 1.9 3 1.9a1 1 0 0 1 0 1.6l-2.9 1.9V16c0 .3-.1.6-.4.8l-4.5 3a1 1 0 0 1-1.2 0l-4.4-3a1 1 0 0 1-.5-.9v-1l-3.2-2.2a1 1 0 0 1 0-1.6zm3 0L12 7.5l2.6 1.8L12 11zM8.9 15v.4l3.3 2.3 3.4-2.3v-.2L12 13l-3.1 2zm-1-10-2 1.4 2 1.3 2-1.3zm8.2 0-2 1.4 2 1.3 2-1.3zm-2 6.9 2-1.3 2 1.3-2 1.3-2-1.3zm-8.3 0 2-1.3L10 12l-2 1.3-2-1.3z" fill-rule="evenodd"/></svg>',
    'evernote': '<svg width="24" height="24"><path fill-rule="evenodd" d="m9.5 3-.3.1-2.6 2.6C3.8 8.5 4 8.2 4 8.7c0 1.3.3 3 .6 4.3.5 2 1.1 3.2 2 3.7l1.2.3c1 .2 1.5.2 2.2.2 1.3 0 1.7 0 2.2-.4.3-.2.3-.4.4-1a38.4 38.4 0 0 1 .3-.4l.3.1 1.8.1h1.6v-1.8H14l-.1-.2a6.8 6.8 0 0 1-.5-1c-.2-.4-.3-.6-.5-.7a.8.8 0 0 0-.5-.1.9.9 0 0 0-.8.5l-.4 1.6-.3 1.5H9.4l-2-.3a1 1 0 0 1-.1-.2A10.1 10.1 0 0 1 6 9.7v-.2h4l.5-.5V5H12c.4.2.7.7.8 1.1a1 1 0 0 0 .2.6c.2.2.3.2 1 .3 1.2 0 2 .2 2.5.6.4.2.8.7 1 1.2.3 1.2.5 4 .3 6.4 0 1.8-.4 3.4-.8 4h-.7a8 8 0 0 1-.8 0c-.2 0-.3-.3-.2-.5a.5.5 0 0 1 .4-.3h.9v-1.8H16c-.7 0-.9 0-1.2.2-.9.4-1.4 1.2-1.4 2.1l.1.4.1.2a1 1 0 0 1 .1.2c.3.7.8 1.2 1.4 1.3l1.2.1h1.2a2 2 0 0 0 1-.8 9 9 0 0 0 1.1-4.3c.2-3 0-6.3-.4-7.7A4.3 4.3 0 0 0 16 5.3a7 7 0 0 0-1.3-.2 7.2 7.2 0 0 1-.4 0 5.5 5.5 0 0 1 0-.3c-.2-.5-.6-1-1.2-1.4a3 3 0 0 0-.5-.2c-.4-.2-.5-.2-1.8-.2a26.5 26.5 0 0 0-1.3 0Zm-.8 4v.7H7.2l.7-.8.8-.7v.7Zm7 3.5c-.4 0-.7.5-.9 1v.7h.3c.7 0 1.1.2 1.5.6l.3.2.3-.6V11a1 1 0 0 0-.6-.4 2 2 0 0 0-.8 0Z" clip-rule="evenodd"/></svg>',
    'exposure': '<svg width="24" height="24"><path d="M5 21a2 2 0 0 1-1.4-.6A2 2 0 0 1 3 19V5c0-.6.2-1 .6-1.4A2 2 0 0 1 5 3h14c.6 0 1 .2 1.4.6.4.4.6.8.6 1.4v14c0 .6-.2 1-.6 1.4a2 2 0 0 1-1.4.6H5Zm0-2h14V5L5 19Zm9.5-1v-2h-2v-1.5h2v-2H16v2h2V16h-2v2h-1.5ZM6 8.5h5V7H6v1.5Z"/></svg>',
    'fb': '<svg width="24" height="24"><path fill-rule="evenodd" d="M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-11 6.7V14H8.1v-2.5h2v-1C10 8.2 11.5 7 12.8 7H16v2.5h-2.4c-.8 0-1 .7-1 1.3v.7h3.2l-1 2.5h-2v5a7 7 0 1 0-2.8-.2Z" clip-rule="evenodd"/></svg>',
    'flickr': '<svg width="24" height="24"><path d="M8.2 15.3c1.7 0 3.1-1.4 3.1-3.1A3.2 3.2 0 0 0 8.1 9 3.2 3.2 0 0 0 5 12.2c0 1.7 1.4 3 3.2 3Zm7.6 0c1.7 0 3.2-1.4 3.2-3.1a3.2 3.2 0 0 0-6.3 0c0 1.7 1.4 3 3.1 3Z"/></svg>',
    'folder': '<svg width="24" height="24"><path fill-rule="evenodd" d="M5.6 6a.6.6 0 0 0-.6.6v11.2a.6.6 0 0 0 .6.6h12.8a.6.6 0 0 0 .6-.6V9a.6.6 0 0 0-.6-.6h-7.2a1 1 0 0 1-.8-.4L9 6H5.6ZM3.8 4.8A2.6 2.6 0 0 1 5.6 4h4a1 1 0 0 1 .8.4l1.3 2h6.7A2.6 2.6 0 0 1 21 9v8.8a2.6 2.6 0 0 1-2.6 2.6H5.6A2.6 2.6 0 0 1 3 17.8V6.6c0-.7.3-1.4.8-1.8Z" clip-rule="evenodd"/></svg>',
    'google-drive': '<svg height="24" width="24"><path clip-rule="evenodd" d="M8.7 4.5a1 1 0 0 1 .9-.5h4.8a1 1 0 0 1 .9.5l5.6 9.7a1 1 0 0 1 0 1l-2.4 4.2a1 1 0 0 1-.9.5H6.4a1 1 0 0 1-.9-.5l-2.4-4.2a1 1 0 0 1 0-1zM10.2 6l-4.5 7.7h2.5L12.7 6h-2.5zm4.2 1 4.4 7.7-1.2 2.2-4.4-7.7zM12 11.2l-1.5 2.5h3zm2.6 4.5H5.7L7 17.9h8.9l-1.3-2.2z" fill-rule="evenodd"/></svg>',
    'google-photos': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12.4 3c-.8 0-1.4.7-1.4 1.4v3.2a5 5 0 0 0-8 4c0 .8.6 1.4 1.4 1.4h3.2a5 5 0 0 0-1 3 5 5 0 0 0 5 5c.8 0 1.4-.6 1.4-1.4v-3.2a5 5 0 0 0 8-4c0-.8-.7-1.4-1.4-1.4h-3.2a5 5 0 0 0-4-8Zm.6 8V5a3 3 0 0 1 2.4 3 3 3 0 0 1-2.4 3Zm-2 0H5a3 3 0 0 1 3-2.4 3 3 0 0 1 3 2.4Zm2 2a3 3 0 0 0 3 2.4 3 3 0 0 0 3-2.4h-6Zm-4.4 3a3 3 0 0 1 2.4-3v6a3 3 0 0 1-2.4-3Z" clip-rule="evenodd"/></svg>',
    'grayscale': '<svg height="24" width="24"><path d="M3 5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2zm12.4 0H19v3.6zm-2.8 0h-2.2l8.6 8.6v-2.2zm-5 0H5l14 14v-2.6z" fill-rule="evenodd"/></svg>',
    'huddle': '<svg height="24" width="24"><path d="M10.3 5.6V8h.8v-2l3.5 2 4.3-2.5L14.6 3l-4.3 2.6zM14.6 8v5.2l4.3-2.6V5.6L14.6 8zM6 13.3v2.5h.9v-2l3.4 2 4.3-2.5-4.3-2.6zm4.3 2.6V21l4.3-2.6v-5.1l-4.3 2.6z"/></svg>',
    'image-decorative': '<svg width="24" height="24"><path d="M12 10c.3 0 .5-.1.7-.3A1 1 0 0 0 13 9a1 1 0 0 0-.3-.7A1 1 0 0 0 12 8a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7 1 1 0 0 0 1 1Zm0 6a3 3 0 0 1-1.8-.5A3 3 0 0 1 9.1 14a2 2 0 0 0-.2 0 3 3 0 0 1-2.5-1 3 3 0 0 1-.9-2.2A3 3 0 0 1 6.2 9a3.4 3.4 0 0 1-.5-1 3 3 0 0 1-.2-1 3 3 0 0 1 1-2.2A3 3 0 0 1 8.8 4H9a3 3 0 0 1 1.1-1.4A3 3 0 0 1 12 2a3 3 0 0 1 1.8.5c.5.4.9.9 1.1 1.5h.2a3 3 0 0 1 2.5.8 3 3 0 0 1 .9 2.3c0 .3 0 .7-.2 1a2.8 2.8 0 0 1-.5.9l.5 1 .2 1a3 3 0 0 1-1 2.2 3 3 0 0 1-2.4.9 1.8 1.8 0 0 0-.2 0 3 3 0 0 1-1.1 1.4 3 3 0 0 1-1.8.5Zm0 7a8.7 8.7 0 0 1 .7-3.5 9.2 9.2 0 0 1 2-2.8 9.2 9.2 0 0 1 2.8-2A8.6 8.6 0 0 1 21 14a8.6 8.6 0 0 1-.7 3.5 9.2 9.2 0 0 1-2 2.8 9.2 9.2 0 0 1-2.8 2 8.6 8.6 0 0 1-3.5.7Zm2.5-2.5a6.8 6.8 0 0 0 2.4-1.5 6.8 6.8 0 0 0 1.7-2.6c-1 .4-1.8 1-2.6 1.7a6.8 6.8 0 0 0-1.5 2.4ZM12 23a8.6 8.6 0 0 0-.7-3.5 9.2 9.2 0 0 0-2-2.9 9.2 9.2 0 0 0-2.8-1.9A8.6 8.6 0 0 0 3 14a8.7 8.7 0 0 0 .7 3.5 9.2 9.2 0 0 0 2 2.9 9.2 9.2 0 0 0 2.8 1.9 8.6 8.6 0 0 0 3.5.7Zm-2.5-2.5A6.8 6.8 0 0 1 7.2 19a6.8 6.8 0 0 1-1.6-2.6c.9.4 1.7 1 2.5 1.7a6.8 6.8 0 0 1 1.6 2.4Zm5.9-8.4c.3 0 .5-.1.8-.4.2-.2.3-.5.3-.8 0-.2 0-.4-.2-.6a1.3 1.3 0 0 0-.5-.4l-.8-.4a3 3 0 0 1-.2.5 3.8 3.8 0 0 1-.2.5 2.5 2.5 0 0 1-.3.4 4 4 0 0 1-.4.4l.8.6a.8.8 0 0 0 .3.1h.4ZM15 8.5l.8-.4.5-.4.2-.6a1.1 1.1 0 0 0-.3-.8 1 1 0 0 0-.8-.4 1.1 1.1 0 0 0-.7.2l-.8.6.4.4.3.4a3.9 3.9 0 0 1 .4 1Zm-4-2.3a2.7 2.7 0 0 1 1-.2 2.7 2.7 0 0 1 1 .2l.2-1.1c0-.3-.1-.6-.4-.8A1.2 1.2 0 0 0 12 4c-.3 0-.6.1-.8.3-.3.2-.4.5-.3.8v1.1Zm1 7.8c.3 0 .6-.1.8-.3.3-.2.4-.5.3-.8v-1.1a2.7 2.7 0 0 1-1.1.2 2.7 2.7 0 0 1-1-.2l-.2 1.1c0 .3.1.6.4.8.2.2.5.3.8.3ZM9 8.5a3 3 0 0 1 .4-1l.3-.4.4-.4-.8-.6A.9.9 0 0 0 9 6a1.2 1.2 0 0 0-.3 0c-.4 0-.6 0-.9.3a1.1 1.1 0 0 0-.3.8c0 .2 0 .4.2.6l.5.4.9.4Zm-.3 3.6H9l.3-.2.8-.6a5.5 5.5 0 0 1-.4-.4 2.1 2.1 0 0 1-.3-.4 3.8 3.8 0 0 1-.2-.5 3 3 0 0 1-.1-.5l-1 .4-.4.4a1.1 1.1 0 0 0-.2.6c0 .3.2.6.4.8.2.2.4.4.7.4Z"/></svg>',
    'image-enhancements': '<svg height="24" width="24"><path d="M5.3 21a2 2 0 0 1-1.5-.6 2 2 0 0 1-.6-1.4V5c0-.6.2-1 .6-1.4A2 2 0 0 1 5.2 3H13v2H5.2v14h14v-8h2v8c0 .6-.1 1-.5 1.4a2 2 0 0 1-1.4.6z"/><path d="M11 9a4 4 0 0 0 4 4 4 4 0 0 0-4 4 4 4 0 0 0-4-4 4 4 0 0 0 4-4zm5.5-6c.2 2.1 2.2 4.1 4.5 4.5-2.3.4-4.3 2.4-4.5 4.5A5.2 5.2 0 0 0 12 7.5 5.2 5.2 0 0 0 16.5 3z"/></svg>',
    'instagram': '<svg height="24" width="24"><path clip-rule="evenodd" d="M10.1 9a4 4 0 1 1 4.4 6.6A4 4 0 0 1 10.1 9zm2.2 1.3a2 2 0 1 0 0 4 2 2 0 0 0 0-4z" fill-rule="evenodd"/><path d="M16 9.3a1.3 1.3 0 1 0 0-2.6 1.3 1.3 0 0 0 0 2.6z"/><path clip-rule="evenodd" d="M3 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3zm3-1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1z" fill-rule="evenodd"/></svg>',
    'onedrive': '<svg height="24" width="24"><path d="M4 13.7h1zm16 .7h-1zm-11.7-4A4.4 4.4 0 0 1 12.1 8V6a6.4 6.4 0 0 0-5.6 3.4l1.8 1zM12.1 8c2 0 3.6 1.4 4 2.8l2-.5A6.3 6.3 0 0 0 12 6v2zm8.1 6.8-9.8-5.5-1 1.8 9.8 5.5 1-1.8zm-9.8-5.5A5 5 0 0 0 3 13.7h2A3 3 0 0 1 9.5 11l1-1.8zM3 13.7a5 5 0 0 0 1 2.8l1.5-1.1a3 3 0 0 1-.5-1.7zm15.8 1.6a2.3 2.3 0 0 1-2 1.4v2a4.3 4.3 0 0 0 3.9-2.6zm-2 1.4H8v2h8.7zm-8.8 0a3 3 0 0 1-2.5-1.3L4 16.5a5 5 0 0 0 4 2.2v-2zm12.7-.6c.2-.6.3-1.1.3-1.7h-2c0 .3 0 .6-.2.9zm.3-1.7c0-3-3.1-5.1-6-4l.8 1.9a2.3 2.3 0 0 1 3.2 2h2zm-6-4L4.4 15l.8 1.9 10.7-4.6-.7-1.8z"/></svg>',
    'photo-filter': '<svg height="24" width="24"><path d="M4.4 21c-.3 0-.6-.2-.9-.5-.3-.3-.4-.6-.5-.9L19.6 3c.3 0 .6.3.9.5l.5.9zM3 14.7v-2.8L11.9 3h2.8zM3 7V5c0-.6.2-1 .6-1.4A2 2 0 0 1 5 3h2zm14 14 4-4v2c0 .6-.2 1-.6 1.4a2 2 0 0 1-1.4.6zm-7.7 0L21 9.3v2.8L12 21z"/></svg>',
    'revert-changes': '<svg height="24" width="24"><path d="m8.9 18.8.4 3.2H13v-2h-2v-2.6a4.6 4.6 0 0 1-1.6-.6 5.9 5.9 0 0 1-1.3-1l-2.5 1-1-1.7 2.2-1.6a4 4 0 0 1-.2-.7 5.9 5.9 0 0 1 0-.8v-.8l.2-.8-2.2-1.6 1-1.7 2.5 1a6 6 0 0 1 1.2-.9l1.4-.6.4-2.6h2l.3 2.6A5.6 5.6 0 0 1 16 8.2l2.5-1 1 1.6-2.2 1.7.2.7v.8a5 5 0 0 1 0 1h2a2.6 2.6 0 0 0 0-.5V11.3l2.6-2-2.8-4.7-3 1.3a8.2 8.2 0 0 0-.5-.4 3.8 3.8 0 0 0-.6-.3L14.8 2H9.3l-.4 3.2a5 5 0 0 0-1.2.7l-3-1.3L2 9.4l2.6 2V12.6l-2.6 2 2.7 4.7 3-1.3a8 8 0 0 0 1.2.7z"/><path d="m14.5 20.3 2.1-2-2.1-2.2 1.4-1.4 2.1 2.1 2.1-2 1.4 1.3-2 2.1 2 2.1-1.4 1.4-2.1-2-2.1 2zM12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></svg>',
    'saturation': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 20.5a6 6 0 1 1-5.9-10.2 6 6 0 1 1 11.8 0A6 6 0 1 1 12 20.5Zm-1.1-7.7a6 6 0 0 0-.2.3 4.3 4.3 0 0 1-2-1.3c.9.1 1.6.5 2.2 1Zm2.4.3a6 6 0 0 0-.2-.3 4.3 4.3 0 0 1 2.2-1 4.3 4.3 0 0 1-2 1.3ZM12.2 15a6.3 6.3 0 0 1-.4 0 4.3 4.3 0 0 0 .2 2.5 4.3 4.3 0 0 0 .2-2.5Zm.9 4.2a6 6 0 0 0 .8-4.5 6 6 0 0 0 3.4-2.8 4.3 4.3 0 0 1-1.3 8.4 4.3 4.3 0 0 1-2.9-1.1Zm-2.2 0a4.3 4.3 0 1 1-4.2-7.3 6 6 0 0 0 3.4 2.8 6 6 0 0 0 .8 4.5Zm-3-9.2a4.3 4.3 0 1 1 8.3 0 6 6 0 0 0-4.2 1.5A6 6 0 0 0 7.8 10Z"/></svg>',
    'transform-image': '<svg height="24" width="24"><path d="M3 21v-6h2V9H3V3h6v2h6V3h6v6h-2v6h2v6h-6v-2H9v2zm6-4h6v-2h2V9h-2V7H9v2H7v6h2zM5 7h2V5H5zm12 0h2V5h-2zm0 12h2v-2h-2zM5 19h2v-2H5z"/></svg>',
    'vibrance': '<svg height="24" width="24"><path d="M12 20 22 4H2zm2.6-8 1.3-2H8l1.3 2h5.2zm-1.2 2h-2.8l1.4 2.2zm5-8L17 8H7L5.6 6h12.8z" fill-rule="evenodd"/></svg>',
    'vk': '<svg width="24" height="24"><path fill-rule="evenodd" d="M14.8 17.4a2 2 0 0 1-1.3.7 8 8 0 0 1-7.7-3.6c-1.4-2-2.2-4.4-2.6-5.7L3 8.6A2 2 0 0 1 5 6h2.5c.4 0 .8.1 1.2.4A2 2 0 0 1 9.8 6h3.5a2 2 0 0 1 1.4.6 2 2 0 0 1 1.5-.6h2.4a2 2 0 0 1 2 2.5c-.5 1.5-1.2 2.6-1.8 3.6a12.5 12.5 0 0 1 2 3.2A2 2 0 0 1 19 18h-2.6a2 2 0 0 1-1.3-.5 6.9 6.9 0 0 1-.3-.2Zm.5-2.5-1.2-1a3 3 0 0 0-.8-.2v2.4h-1.7a5.6 5.6 0 0 1-.3 0c-3-.7-4.7-3.7-5.6-6.1A38.1 38.1 0 0 1 5 8.1V8h2.5a80.5 80.5 0 0 1 1.2 2.5c.6 1.2 1.2 2 2 2.1V9l-.9-1h3.5v4.1a5 5 0 0 0 .4-.3c.7-.7 1.2-1.4 1.6-2.2l.2-.3.7-1.3h2.4a8.5 8.5 0 0 1-.8 2l-1.3 2-.3.3a10.5 10.5 0 0 1 2.8 3.8h-2.6l-.8-.9a20.6 20.6 0 0 0-.3-.3Z" clip-rule="evenodd"/></svg>',
    'warmth': '<svg height="24" width="24"><path d="M12 21.1c-1.4 0-2.6-.5-3.6-1.5s-1.5-2.1-1.5-3.5c0-.8.2-1.6.6-2.2A5 5 0 0 1 8.9 12v-6c0-.8.3-1.5 1-2.1a2.9 2.9 0 0 1 2-.9c.9 0 1.6.3 2.2.9.5.6.8 1.3.8 2.1v6a5 5 0 0 1 1.5 1.8A4.9 4.9 0 0 1 17 16c0 1.4-.5 2.6-1.4 3.5s-2.2 1.5-3.6 1.5zm-3-5h6c0-.5-.2-1-.4-1.4a3 3 0 0 0-.9-1l-.8-.6v-7a1 1 0 0 0-.3-.7A1 1 0 0 0 12 5a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v7l-.8.6a2.9 2.9 0 0 0-.9 1 3 3 0 0 0-.3 1.4z"/></svg>',
    'user': '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z" fill-rule="nonzero"/></svg>',
    'vertical-align': '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z"/></g></svg>',
    'visualblocks': '<svg width="24" height="24"><path d="M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z" fill-rule="evenodd"/></svg>',
    'visualchars': '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z" fill-rule="evenodd"/></svg>',
    'warning': '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z" fill-rule="evenodd"/></svg>',
    'zoom-in': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
    'zoom-out': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
  }
});